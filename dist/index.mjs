import * as lx from "vue";
import { defineComponent as ae, ref as X, onMounted as Zt, onBeforeUnmount as Zc, h as mt, getCurrentInstance as Oo, watchEffect as ps, nextTick as Af, unref as C, markRaw as pA, customRef as d3, provide as cr, reactive as Gw, render as cx, effectScope as gA, watch as Bt, shallowRef as mv, onUnmounted as Mo, isRef as Ss, isReactive as ux, isVNode as f3, createApp as dx, openBlock as J, createBlock as Ze, withCtx as Ue, createElementVNode as se, renderSlot as Lt, createTextVNode as vv, toDisplayString as Ut, normalizeClass as It, resolveDynamicComponent as ii, normalizeStyle as Rr, createElementBlock as be, inject as Ln, computed as rt, Fragment as Vt, createVNode as W, Text as h3, createCommentVNode as He, withDirectives as Yr, vModelText as vc, renderList as $n, cloneVNode as p3, Teleport as g3, withKeys as mA, pushScopeId as vA, popScopeId as bA, vShow as ql, resolveComponent as m3 } from "vue";
import yA from "katex";
function Cn(t) {
  this.content = t;
}
Cn.prototype = {
  constructor: Cn,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t)
        return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, i = r.find(t), s = r.content.slice();
    return i == -1 ? s.push(n || t, e) : (s[i + 1] = e, n && (s[i] = n)), new Cn(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1)
      return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Cn(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new Cn([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new Cn(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(t);
    return i.splice(s == -1 ? i.length : s, 0, e, n), new Cn(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = Cn.from(t), t.size ? new Cn(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = Cn.from(t), t.size ? new Cn(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = Cn.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Cn.from = function(t) {
  if (t instanceof Cn)
    return t;
  var e = [];
  if (t)
    for (var n in t)
      e.push(n, t[n]);
  return new Cn(e);
};
function wA(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), s = e.child(r);
    if (i == s) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return n;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        n++;
      return n;
    }
    if (i.content.size || s.content.size) {
      let o = wA(i.content, s.content, n + 1);
      if (o != null)
        return o;
    }
    n += i.nodeSize;
  }
}
function _A(t, e, n, r) {
  for (let i = t.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: n, b: r };
    let o = t.child(--i), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      n -= l, r -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: n, b: r };
    if (o.isText && o.text != a.text) {
      let c = 0, u = Math.min(o.text.length, a.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, r--;
      return { a: n, b: r };
    }
    if (o.content.size || a.content.size) {
      let c = _A(o.content, a.content, n - 1, r - 1);
      if (c)
        return c;
    }
    n -= l, r -= l;
  }
}
let je = class Vn {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, s) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o], c = a + l.nodeSize;
      if (c > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), r, i + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new Vn(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let s = 0, o = 0; o < n; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))), r.push(a), i += a.nodeSize), o = l;
      }
    return new Vn(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? Vn.empty : e == 0 && n == this.content.length ? this : new Vn(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), s = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new Vn(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Vn([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Vn(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return wA(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return _A(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return ah(0, e);
    if (e == this.size)
      return ah(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let s = this.child(r), o = i + s.nodeSize;
      if (o >= e)
        return o == e || n > 0 ? ah(r + 1, o) : ah(r, i);
      i = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Vn.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Vn(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Vn.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s);
    }
    return new Vn(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Vn.empty;
    if (e instanceof Vn)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Vn([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
je.empty = new je([], 0);
const A0 = { index: 0, offset: 0 };
function ah(t, e) {
  return A0.index = t, A0.offset = e, A0;
}
function ng(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!ng(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !ng(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let Xt = class sy {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        n || (n = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(s);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && ng(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    return r.create(n.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return sy.none;
    if (e instanceof sy)
      return [e];
    let n = e.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
Xt.none = [];
let rg = class extends Error {
}, Fe = class Ml {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = SA(this.content, e + this.openStart, n);
    return r && new Ml(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new Ml(EA(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Ml.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Ml(je.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new Ml(e, r, i);
  }
};
Fe.empty = new Fe(je.empty, 0, 0);
function EA(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r), { index: o, offset: a } = t.findIndex(n);
  if (i == e || s.isText) {
    if (a != n && !t.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, s.copy(EA(s.content, e - i - 1, n - i - 1)));
}
function SA(t, e, n, r) {
  let { index: i, offset: s } = t.findIndex(e), o = t.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = SA(o.content, e - s - 1, n);
  return a && t.replaceChild(i, o.copy(a));
}
function v3(t, e, n) {
  if (n.openStart > t.depth)
    throw new rg("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new rg("Inconsistent open depths");
  return xA(t, e, n, 0);
}
function xA(t, e, n, r) {
  let i = t.index(r), s = t.node(r);
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let o = xA(t, e, n, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let o = t.parent, a = o.content;
      return Ea(o, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = b3(n, t);
      return Ea(s, CA(t, o, a, e, r));
    }
  else
    return Ea(s, ig(t, e, r));
}
function kA(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new rg("Cannot join " + e.type.name + " onto " + t.type.name);
}
function oy(t, e, n) {
  let r = t.node(n);
  return kA(r, e.node(n)), r;
}
function _a(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function qu(t, e, n, r) {
  let i = (e || t).node(n), s = 0, o = e ? e.index(n) : i.childCount;
  t && (s = t.index(n), t.depth > n ? s++ : t.textOffset && (_a(t.nodeAfter, r), s++));
  for (let a = s; a < o; a++)
    _a(i.child(a), r);
  e && e.depth == n && e.textOffset && _a(e.nodeBefore, r);
}
function Ea(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function CA(t, e, n, r, i) {
  let s = t.depth > i && oy(t, e, i + 1), o = r.depth > i && oy(n, r, i + 1), a = [];
  return qu(null, t, i, a), s && o && e.index(i) == n.index(i) ? (kA(s, o), _a(Ea(s, CA(t, e, n, r, i + 1)), a)) : (s && _a(Ea(s, ig(t, e, i + 1)), a), qu(e, n, i, a), o && _a(Ea(o, ig(n, r, i + 1)), a)), qu(r, null, i, a), new je(a);
}
function ig(t, e, n) {
  let r = [];
  if (qu(null, t, n, r), t.depth > n) {
    let i = oy(t, e, n + 1);
    _a(Ea(i, ig(t, e, n + 1)), r);
  }
  return qu(e, null, n, r), new je(r);
}
function b3(t, e) {
  let n = e.depth - t.openStart, i = e.node(n).copy(t.content);
  for (let s = n - 1; s >= 0; s--)
    i = e.node(s).copy(je.from(i));
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  };
}
let fx = class ay {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(n);
    return r ? e.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return Xt.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), i = e.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new w3(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, s = n;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s), c = s - l;
      if (r.push(o, a, i + l), !c || (o = o.child(a), o.isText))
        break;
      s = c - 1, i += l + 1;
    }
    return new ay(n, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    for (let i = 0; i < N0.length; i++) {
      let s = N0[i];
      if (s.pos == n && s.doc == e)
        return s;
    }
    let r = N0[R0] = ay.resolve(e, n);
    return R0 = (R0 + 1) % y3, r;
  }
}, N0 = [], R0 = 0, y3 = 12, w3 = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
const _3 = /* @__PURE__ */ Object.create(null);
let TA = class ly {
  /**
  @internal
  */
  constructor(e, n, r, i = Xt.none) {
    this.type = e, this.attrs = n, this.marks = i, this.content = r || je.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && ng(this.attrs, n || e.defaultAttrs || _3) && Xt.sameSet(this.marks, r || Xt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new ly(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new ly(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return Fe.empty;
    let i = this.resolve(e), s = this.resolve(n), o = r ? 0 : i.sharedDepth(n), a = i.start(o), c = i.node(o).content.cut(i.pos - a, s.pos - a);
    return new Fe(c, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return v3(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == e || n.isText)
        return n;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return fx.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return fx.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let i = !1;
    return n > e && this.nodesBetween(e, n, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), E3(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = je.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), a = o && o.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = i; l < s; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, n);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let e = Xt.none;
    for (let n = 0; n < this.marks.length; n++)
      e = this.marks[n].addToSet(e);
    if (!Xt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r = null;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let i = je.fromJSON(e, n.content);
    return e.nodeType(n.type).create(n.attrs, i, r);
  }
};
TA.prototype.text = void 0;
function E3(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
function S3(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function x3(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = e && e[r];
    if (i === void 0) {
      let s = t[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function k3(t) {
  let e = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let n in t)
      e[n] = new C3(t[n]);
  return e;
}
let C3 = class {
  constructor(e) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"), this.default = e.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}, T3 = class OA {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = k3(i.attrs), this.excluded = null;
    let s = S3(this.attrs);
    this.instance = s ? new Xt(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Xt(this, x3(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new OA(s, i++, n, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
};
function O3(t) {
  return t.tag != null;
}
function M3(t) {
  return t.style != null;
}
let A3 = class cy {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [], n.forEach((r) => {
      O3(r) ? this.tags.push(r) : M3(r) && this.styles.push(r);
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let i = e.nodes[r.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new px(this, n, !1);
    return r.addAll(e, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new px(this, n, !0);
    return r.addAll(e, n.from, n.to), Fe.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (D3(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (o.getAttrs) {
          let l = o.getAttrs(n);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < n.length; o++) {
        let a = n[o];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      n.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = gx(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = gx(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new cy(e, cy.schemaRules(e)));
  }
};
const MA = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, N3 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, AA = { ol: !0, ul: !0 }, sg = 1, og = 2, Ku = 4;
function hx(t, e, n) {
  return e != null ? (e ? sg : 0) | (e === "full" ? og : 0) : t && t.whitespace == "pre" ? sg | og : n & ~Ku;
}
let lh = class {
  constructor(e, n, r, i, s, o, a) {
    this.type = e, this.attrs = n, this.marks = r, this.pendingMarks = i, this.solid = s, this.options = a, this.content = [], this.activeMarks = Xt.none, this.stashMarks = [], this.match = o || (a & Ku ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(je.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & sg)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let n = je.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(je.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  popFromStashMark(e) {
    for (let n = this.stashMarks.length - 1; n >= 0; n--)
      if (e.eq(this.stashMarks[n]))
        return this.stashMarks.splice(n, 1)[0];
  }
  applyPending(e) {
    for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
      let i = r[n];
      (this.type ? this.type.allowsMarkType(i.type) : P3(i.type, e)) && !i.isInSet(this.activeMarks) && (this.activeMarks = i.addToSet(this.activeMarks), this.pendingMarks = i.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !MA.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}, px = class {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0;
    let i = n.topNode, s, o = hx(null, n.preserveWhitespace, 0) | (r ? Ku : 0);
    i ? s = new lh(i.type, i.attrs, Xt.none, Xt.none, !0, n.topMatch || i.type.contentMatch, o) : r ? s = new lh(null, null, Xt.none, Xt.none, !0, null, o) : s = new lh(e.schema.topNodeType, null, Xt.none, Xt.none, !0, null, o), this.nodes = [s], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e) {
    e.nodeType == 3 ? this.addTextNode(e) : e.nodeType == 1 && this.addElement(e);
  }
  withStyleRules(e, n) {
    let r = e.getAttribute("style");
    if (!r)
      return n();
    let i = this.readStyles(I3(r));
    if (!i)
      return;
    let [s, o] = i, a = this.top;
    for (let l = 0; l < o.length; l++)
      this.removePendingMark(o[l], a);
    for (let l = 0; l < s.length; l++)
      this.addPendingMark(s[l]);
    n();
    for (let l = 0; l < s.length; l++)
      this.removePendingMark(s[l], a);
    for (let l = 0; l < o.length; l++)
      this.addPendingMark(o[l]);
  }
  addTextNode(e) {
    let n = e.nodeValue, r = this.top;
    if (r.options & og || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
      if (r.options & sg)
        r.options & og ? n = n.replace(/\r\n?/g, `
`) : n = n.replace(/\r?\n|\r/g, " ");
      else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
        let i = r.content[r.content.length - 1], s = e.previousSibling;
        (!i || s && s.nodeName == "BR" || i.isText && /[ \t\r\n\u000c]$/.test(i.text)) && (n = n.slice(1));
      }
      n && this.insertNode(this.parser.schema.text(n)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n) {
    let r = e.nodeName.toLowerCase(), i;
    AA.hasOwnProperty(r) && this.parser.normalizeLists && R3(e);
    let s = this.options.ruleFromNode && this.options.ruleFromNode(e) || (i = this.parser.matchTag(e, this, n));
    if (s ? s.ignore : N3.hasOwnProperty(r))
      this.findInside(e), this.ignoreFallback(e);
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent ? this.open = Math.max(0, this.open - 1) : s && s.skip.nodeType && (e = s.skip);
      let o, a = this.top, l = this.needsBlock;
      if (MA.hasOwnProperty(r))
        a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), o = !0, a.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e);
        return;
      }
      s && s.skip ? this.addAll(e) : this.withStyleRules(e, () => this.addAll(e)), o && this.sync(a), this.needsBlock = l;
    } else
      this.withStyleRules(e, () => {
        this.addElementByRule(e, s, s.consuming === !1 ? i : void 0);
      });
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`));
  }
  // Called for ignored nodes
  ignoreFallback(e) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(e) {
    let n = Xt.none, r = Xt.none;
    for (let i = 0; i < e.length; i += 2)
      for (let s = void 0; ; ) {
        let o = this.parser.matchStyle(e[i], e[i + 1], this, s);
        if (!o)
          break;
        if (o.ignore)
          return null;
        if (o.clearMark ? this.top.pendingMarks.concat(this.top.activeMarks).forEach((a) => {
          o.clearMark(a) && (r = a.addToSet(r));
        }) : n = this.parser.schema.marks[o.mark].create(o.attrs).addToSet(n), o.consuming === !1)
          s = o;
        else
          break;
      }
    return [n, r];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r) {
    let i, s, o;
    n.node ? (s = this.parser.schema.nodes[n.node], s.isLeaf ? this.insertNode(s.create(n.attrs)) || this.leafFallback(e) : i = this.enter(s, n.attrs || null, n.preserveWhitespace)) : (o = this.parser.schema.marks[n.mark].create(n.attrs), this.addPendingMark(o));
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, r);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l);
    }
    i && this.sync(a) && this.open--, o && this.removePendingMark(o, a);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r) {
    let i = n || 0;
    for (let s = n ? e.childNodes[n] : e.firstChild, o = r == null ? null : e.childNodes[r]; s != o; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e) {
    let n, r;
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i], o = s.findWrapping(e);
      if (o && (!n || n.length > o.length) && (n = o, r = s, !o.length) || s.solid)
        break;
    }
    if (!n)
      return !1;
    this.sync(r);
    for (let i = 0; i < n.length; i++)
      this.enterInner(n[i], null, !1);
    return !0;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let n = this.textblockFromContext();
      n && this.enterInner(n);
    }
    if (this.findPlace(e)) {
      this.closeExtra();
      let n = this.top;
      n.applyPending(e.type), n.match && (n.match = n.match.matchType(e.type));
      let r = n.activeMarks;
      for (let i = 0; i < e.marks.length; i++)
        (!n.type || n.type.allowsMarkType(e.marks[i].type)) && (r = e.marks[i].addToSet(r));
      return n.content.push(e.mark(r)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r) {
    let i = this.findPlace(e.create(n));
    return i && this.enterInner(e, n, !0, r), i;
  }
  // Open a node of the given type
  enterInner(e, n = null, r = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.applyPending(e), s.match = s.match && s.match.matchType(e);
    let o = hx(e, i, s.options);
    s.options & Ku && s.content.length == 0 && (o |= Ku), this.nodes.push(new lh(e, n, s.activeMarks, s.pendingMarks, r, null, o)), this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--)
      if (this.nodes[n] == e)
        return this.open = n, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (o(a - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null;
          if (!u || u.name != c && u.groups.indexOf(c) == -1)
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
  addPendingMark(e) {
    let n = L3(e, this.top.pendingMarks);
    n && this.top.stashMarks.push(n), this.top.pendingMarks = e.addToSet(this.top.pendingMarks);
  }
  removePendingMark(e, n) {
    for (let r = this.open; r >= 0; r--) {
      let i = this.nodes[r];
      if (i.pendingMarks.lastIndexOf(e) > -1)
        i.pendingMarks = e.removeFromSet(i.pendingMarks);
      else {
        i.activeMarks = e.removeFromSet(i.activeMarks);
        let o = i.popFromStashMark(e);
        o && i.type && i.type.allowsMarkType(o.type) && (i.activeMarks = o.addToSet(i.activeMarks));
      }
      if (i == n)
        break;
    }
  }
};
function R3(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && AA.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function D3(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function I3(t) {
  let e = /\s*([\w-]+)\s*:\s*([^;]+)/g, n, r = [];
  for (; n = e.exec(t); )
    r.push(n[1], n[2].trim());
  return r;
}
function gx(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function P3(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(t))
      continue;
    let s = [], o = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
function L3(t, e) {
  for (let n = 0; n < e.length; n++)
    if (t.eq(e[n]))
      return e[n];
}
let jw = class yu {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = D0(n).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < o.marks.length; ) {
          let c = o.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(s[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          i = s.pop()[1];
        for (; l < o.marks.length; ) {
          let c = o.marks[l++], u = this.serializeMark(c, o.isInline, n);
          u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = yu.renderSpec(D0(n), this.nodes[e.type.name](e));
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, n);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name];
    return i && yu.renderSpec(D0(r), i(e, n));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(e, n, r = null) {
    if (typeof n == "string")
      return { dom: e.createTextNode(n) };
    if (n.nodeType != null)
      return { dom: n };
    if (n.dom && n.dom.nodeType != null)
      return n;
    let i = n[0], s = i.indexOf(" ");
    s > 0 && (r = i.slice(0, s), i = i.slice(s + 1));
    let o, a = r ? e.createElementNS(r, i) : e.createElement(i), l = n[1], c = 1;
    if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
      c = 2;
      for (let u in l)
        if (l[u] != null) {
          let d = u.indexOf(" ");
          d > 0 ? a.setAttributeNS(u.slice(0, d), u.slice(d + 1), l[u]) : a.setAttribute(u, l[u]);
        }
    }
    for (let u = c; u < n.length; u++) {
      let d = n[u];
      if (d === 0) {
        if (u < n.length - 1 || u > c)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: a, contentDOM: a };
      } else {
        let { dom: f, contentDOM: h } = yu.renderSpec(e, d, r);
        if (a.appendChild(f), h) {
          if (o)
            throw new RangeError("Multiple content holes");
          o = h;
        }
      }
    }
    return { dom: a, contentDOM: o };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new yu(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = mx(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return mx(e.marks);
  }
};
function mx(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function D0(t) {
  return t.document || window.document;
}
const NA = 65535, RA = Math.pow(2, 16);
function $3(t, e) {
  return t + e * RA;
}
function vx(t) {
  return t & NA;
}
function B3(t) {
  return (t - (t & NA)) / RA;
}
const DA = 1, IA = 2, fp = 4, PA = 8;
let uy = class {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & PA) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DA | fp)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (IA | fp)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & fp) > 0;
  }
}, Ba = class Al {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Al.empty)
      return Al.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = vx(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + B3(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = this.ranges[a + o], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : n : n, h = l + i + (f < 0 ? 0 : u);
        if (r)
          return h;
        let p = e == (n < 0 ? l : d) ? null : $3(a / 3, e - l), g = e == l ? IA : e == d ? DA : fp;
        return (n < 0 ? e != l : e != d) && (g |= PA), new uy(h, g, p);
      }
      i += u - c;
    }
    return r ? e + i : new uy(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = vx(n), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = l + c;
      if (e <= u && a == i * 3)
        return !0;
      r += this.ranges[a + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), c = this.ranges[i + n], u = this.ranges[i + r];
      e(a, a + c, l, l + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Al(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Al.empty : new Al(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
};
Ba.empty = new Ba([]);
let F3 = class hp {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, r = 0, i = e.length) {
    this.maps = e, this.mirror = n, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new hp(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new hp(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new hp();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s], a = o.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, e = a.pos;
    }
    return r ? e : new uy(e, i, null);
  }
};
const I0 = /* @__PURE__ */ Object.create(null);
let zn = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Ba.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = I0[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in I0)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return I0[e] = n, n.prototype.jsonID = e, n;
  }
}, Yn = class wu {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new wu(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new wu(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return wu.ok(e.replace(n, r, i));
    } catch (s) {
      if (s instanceof rg)
        return wu.fail(s.message);
      throw s;
    }
  }
};
function qw(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let s = t.child(i);
    s.content.size && (s = s.copy(qw(s.content, e, s))), s.isInline && (s = e(s, n, i)), r.push(s);
  }
  return je.fromArray(r);
}
let Kw = class _u extends zn {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new Fe(qw(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), n.openStart, n.openEnd);
    return Yn.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new Nf(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new _u(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof _u && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new _u(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _u(n.from, n.to, e.markFromJSON(n.mark));
  }
};
zn.jsonID("addMark", Kw);
let Nf = class Eu extends zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new Fe(qw(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return Yn.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Kw(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new Eu(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Eu && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Eu(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Eu(n.from, n.to, e.markFromJSON(n.mark));
  }
};
zn.jsonID("removeMark", Nf);
let Yw = class Su extends zn {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Yn.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Yn.fromReplace(e, this.pos, this.pos + 1, new Fe(je.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new Su(this.pos, n.marks[i]);
        return new Su(this.pos, this.mark);
      }
    }
    return new Xw(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Su(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Su(n.pos, e.markFromJSON(n.mark));
  }
};
zn.jsonID("addNodeMark", Yw);
let Xw = class dy extends zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Yn.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Yn.fromReplace(e, this.pos, this.pos + 1, new Fe(je.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new Yw(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new dy(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new dy(n.pos, e.markFromJSON(n.mark));
  }
};
zn.jsonID("removeNodeMark", Xw);
let Us = class Zo extends zn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && fy(e, this.from, this.to) ? Yn.fail("Structure replace would overwrite content") : Yn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Ba([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Zo(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new Zo(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof Zo) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? Fe.empty : new Fe(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Zo(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? Fe.empty : new Fe(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Zo(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Zo(n.from, n.to, Fe.fromJSON(e, n.slice), !!n.structure);
  }
};
zn.jsonID("replace", Us);
let ul = class pp extends zn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, s, o, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (fy(e, this.from, this.gapFrom) || fy(e, this.gapTo, this.to)))
      return Yn.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Yn.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? Yn.fromReplace(e, this.from, this.to, r) : Yn.fail("Content does not fit in gap");
  }
  getMap() {
    return new Ba([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new pp(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || s > r.pos ? null : new pp(n.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new pp(n.from, n.to, n.gapFrom, n.gapTo, Fe.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
};
zn.jsonID("replaceAround", ul);
function fy(t, e, n) {
  let r = t.resolve(e), i = n - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function z3(t, e, n, r) {
  let i = [], s = [], o, a;
  t.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), h = Math.min(c + l.nodeSize, n), p = r.addToSet(d);
      for (let g = 0; g < d.length; g++)
        d[g].isInSet(p) || (o && o.to == f && o.mark.eq(d[g]) ? o.to = h : i.push(o = new Nf(f, h, d[g])));
      a && a.to == f ? a.to = h : s.push(a = new Kw(f, h, r));
    }
  }), i.forEach((l) => t.step(l)), s.forEach((l) => t.step(l));
}
function H3(t, e, n, r) {
  let i = [], s = 0;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (!o.isInline)
      return;
    s++;
    let l = null;
    if (r instanceof T3) {
      let c = o.marks, u;
      for (; u = r.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else
      r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks;
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, n);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], f;
        for (let h = 0; h < i.length; h++) {
          let p = i[h];
          p.step == s - 1 && d.eq(i[h].style) && (f = p);
        }
        f ? (f.to = c, f.step = s) : i.push({ style: d, from: Math.max(a, e), to: c, step: s });
      }
    }
  }), i.forEach((o) => t.step(new Nf(o.from, o.to, o.style)));
}
function LA(t, e, n, r = n.contentMatch, i = !0) {
  let s = t.doc.nodeAt(e), o = [], a = e + 1;
  for (let l = 0; l < s.childCount; l++) {
    let c = s.child(l), u = a + c.nodeSize, d = r.matchType(c.type);
    if (!d)
      o.push(new Us(a, u, Fe.empty));
    else {
      r = d;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new Nf(a, u, c.marks[f]));
      if (i && c.isText && n.whitespace != "pre") {
        let f, h = /\r?\n|\r/g, p;
        for (; f = h.exec(c.text); )
          p || (p = new Fe(je.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), o.push(new Us(a + f.index, a + f.index + f[0].length, p));
      }
    }
    a = u;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(je.empty, !0);
    t.replace(a, a, new Fe(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    t.step(o[l]);
}
function U3(t, e, n) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), a = i.after(s + 1), l = o, c = a, u = je.empty, d = 0;
  for (let p = s, g = !1; p > n; p--)
    g || r.index(p) > 0 ? (g = !0, u = je.from(r.node(p).copy(u)), d++) : l--;
  let f = je.empty, h = 0;
  for (let p = s, g = !1; p > n; p--)
    g || i.after(p + 1) < i.end(p) ? (g = !0, f = je.from(i.node(p).copy(f)), h++) : c++;
  t.step(new ul(l, c, o, a, new Fe(u.append(f), d, h), u.size - d, !0));
}
function V3(t, e, n) {
  let r = je.empty;
  for (let o = n.length - 1; o >= 0; o--) {
    if (r.size) {
      let a = n[o].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = je.from(n[o].type.create(n[o].attrs, r));
  }
  let i = e.start, s = e.end;
  t.step(new ul(i, s, i, s, new Fe(r, 0, 0), n.length, !0));
}
function W3(t, e, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = t.steps.length;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (o.isTextblock && !o.hasMarkup(r, i) && q3(t.doc, t.mapping.slice(s).map(a), r)) {
      let l = null;
      if (r.schema.linebreakReplacement) {
        let f = r.whitespace == "pre", h = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        f && !h ? l = !1 : !f && h && (l = !0);
      }
      l === !1 && j3(t, o, a, s), LA(t, t.mapping.slice(s).map(a, 1), r, void 0, l === null);
      let c = t.mapping.slice(s), u = c.map(a, 1), d = c.map(a + o.nodeSize, 1);
      return t.step(new ul(u, d, u + 1, d - 1, new Fe(je.from(r.create(i, null, o.marks)), 0, 0), 1, !0)), l === !0 && G3(t, o, a, s), !1;
    }
  });
}
function G3(t, e, n, r) {
  e.forEach((i, s) => {
    if (i.isText) {
      let o, a = /\r?\n|\r/g;
      for (; o = a.exec(i.text); ) {
        let l = t.mapping.slice(r).map(n + 1 + s + o.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function j3(t, e, n, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = t.mapping.slice(r).map(n + 1 + s);
      t.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function q3(t, e, n) {
  let r = t.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function K3(t, e, n, r, i) {
  let s = t.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  n || (n = s.type);
  let o = n.create(r, null, i || s.marks);
  if (s.isLeaf)
    return t.replaceWith(e, e + s.nodeSize, o);
  if (!n.validContent(s.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new ul(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new Fe(je.from(o), 0, 0), 1, !0));
}
function Y3(t, e, n = 1, r) {
  let i = t.doc.resolve(e), s = je.empty, o = je.empty;
  for (let a = i.depth, l = i.depth - n, c = n - 1; a > l; a--, c--) {
    s = je.from(i.node(a).copy(s));
    let u = r && r[c];
    o = je.from(u ? u.type.create(u.attrs, o) : i.node(a).copy(o));
  }
  t.step(new Us(e, e, new Fe(s.append(o), n, n), !0));
}
function X3(t, e, n) {
  let r = new Us(e - n, e + n, Fe.empty, !0);
  t.step(r);
}
function J3(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function Z3(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let i = n.content;
  for (let s = 0; s < n.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, l = r.index(o) + (a > 0 ? 1 : 0), c = r.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(l, l, i);
      else {
        let d = c.contentMatchAt(l).findWrapping(i.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function Q3(t, e, n = e, r = Fe.empty) {
  if (e == n && !r.size)
    return null;
  let i = t.resolve(e), s = t.resolve(n);
  return $A(i, s, r) ? new Us(e, n, r) : new ez(i, s, r).fit();
}
function $A(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
let ez = class {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = je.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = je.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, a = i.depth;
    for (; o && a && s.childCount == 1; )
      s = s.firstChild.content, o--, a--;
    let l = new Fe(s, o, a);
    return e > -1 ? new ul(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new Us(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = n.firstChild;
      if (n.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      n = s.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = P0(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, d = null;
          if (n == 1 && (o ? c.matchType(o.type) || (d = c.fillBefore(je.from(o), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, inject: d };
          if (n == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = P0(e, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new Fe(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = P0(e, n);
    if (i.childCount <= 1 && n > 0) {
      let s = e.size - n <= n + i.size;
      this.unplaced = new Fe(xu(e, n - 1, 1), n - 1, s ? n - 1 : r);
    } else
      this.unplaced = new Fe(xu(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: s }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (s)
      for (let g = 0; g < s.length; g++)
        this.openFrontierNode(s[g]);
    let o = this.unplaced, a = r ? r.content : o.content, l = o.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[n];
    if (i) {
      for (let g = 0; g < i.childCount; g++)
        u.push(i.child(g));
      d = d.matchFragment(i);
    }
    let h = a.size + e - (o.content.size - o.openEnd);
    for (; c < a.childCount; ) {
      let g = a.child(c), m = d.matchType(g.type);
      if (!m)
        break;
      c++, (c > 1 || l == 0 || g.content.size) && (d = m, u.push(BA(g.mark(f.allowedMarks(g.marks)), c == 1 ? l : 0, c == a.childCount ? h : -1)));
    }
    let p = c == a.childCount;
    p || (h = -1), this.placed = ku(this.placed, n, je.from(u)), this.frontier[n].match = d, p && h < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, m = a; g < h; g++) {
      let v = m.lastChild;
      this.frontier.push({ type: v.type, match: v.contentMatchAt(v.childCount) }), m = v.content;
    }
    this.unplaced = p ? e == 0 ? Fe.empty : new Fe(xu(o.content, e - 1, 1), e - 1, h < 0 ? o.openEnd : e - 1) : new Fe(xu(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !L0(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e:
      for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
        let { match: r, type: i } = this.frontier[n], s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), o = L0(e, n, i, r, s);
        if (o) {
          for (let a = n - 1; a >= 0; a--) {
            let { match: l, type: c } = this.frontier[a], u = L0(e, a, c, l, !0);
            if (!u || u.childCount)
              continue e;
          }
          return { depth: n, fit: o, move: s ? e.doc.resolve(e.after(n + 1)) : e };
        }
      }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = ku(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = ku(this.placed, this.depth, je.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(je.empty, !0);
    n.childCount && (this.placed = ku(this.placed, this.frontier.length, n));
  }
};
function xu(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(xu(t.firstChild.content, e - 1, n)));
}
function ku(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(ku(t.lastChild.content, e - 1, n)));
}
function P0(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function BA(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, BA(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(je.empty, !0)))), t.copy(r);
}
function L0(t, e, n, r, i) {
  let s = t.node(e), o = i ? t.indexAfter(e) : t.index(e);
  if (o == s.childCount && !n.compatibleContent(s.type))
    return null;
  let a = r.fillBefore(s.content, !0, o);
  return a && !tz(n, s.content, o) ? a : null;
}
function tz(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function nz(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function rz(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let i = t.doc.resolve(e), s = t.doc.resolve(n);
  if ($A(i, s, r))
    return t.step(new Us(e, n, r));
  let o = zA(i, t.doc.resolve(n));
  o[o.length - 1] == 0 && o.pop();
  let a = -(i.depth + 1);
  o.unshift(a);
  for (let f = i.depth, h = i.pos - 1; f > 0; f--, h--) {
    let p = i.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? a = f : i.before(f) == h && o.splice(1, 0, -f);
  }
  let l = o.indexOf(a), c = [], u = r.openStart;
  for (let f = r.content, h = 0; ; h++) {
    let p = f.firstChild;
    if (c.push(p), h == r.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let h = c[f], p = nz(h.type);
    if (p && !h.sameMarkup(i.node(Math.abs(a) - 1)))
      u = f;
    else if (p || !h.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let h = (f + u + 1) % (r.openStart + 1), p = c[h];
    if (p)
      for (let g = 0; g < o.length; g++) {
        let m = o[(g + l) % o.length], v = !0;
        m < 0 && (v = !1, m = -m);
        let y = i.node(m - 1), E = i.index(m - 1);
        if (y.canReplaceWith(E, E, p.type, p.marks))
          return t.replace(i.before(m), v ? s.after(m) : n, new Fe(FA(r.content, 0, r.openStart, h), h, r.openEnd));
      }
  }
  let d = t.steps.length;
  for (let f = o.length - 1; f >= 0 && (t.replace(e, n, r), !(t.steps.length > d)); f--) {
    let h = o[f];
    h < 0 || (e = i.before(h), n = s.after(h));
  }
}
function FA(t, e, n, r, i) {
  if (e < n) {
    let s = t.firstChild;
    t = t.replaceChild(0, s.copy(FA(s.content, e + 1, n, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(t).append(t);
    t = o.append(s.matchFragment(o).fillBefore(je.empty, !0));
  }
  return t;
}
function iz(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = J3(t.doc, e, r.type);
    i != null && (e = n = i);
  }
  t.replaceRange(e, n, new Fe(je.from(r), 0, 0));
}
function sz(t, e, n) {
  let r = t.doc.resolve(e), i = t.doc.resolve(n), s = zA(r, i);
  for (let o = 0; o < s.length; o++) {
    let a = s[o], l = o == s.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), i.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return t.delete(r.before(a), i.after(a));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o)
      return t.delete(r.before(o), n);
  t.delete(e, n);
}
function zA(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = t.start(i);
    if (s < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && n.push(i);
  }
  return n;
}
let HA = class gp extends zn {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Yn.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in n.attrs)
      r[s] = n.attrs[s];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return Yn.fromReplace(e, this.pos, this.pos + 1, new Fe(je.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Ba.empty;
  }
  invert(e) {
    return new gp(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new gp(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new gp(n.pos, n.attr, n.value);
  }
};
zn.jsonID("attr", HA);
let UA = class hy extends zn {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      n[i] = e.attrs[i];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return Yn.ok(r);
  }
  getMap() {
    return Ba.empty;
  }
  invert(e) {
    return new hy(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new hy(n.attr, n.value);
  }
};
zn.jsonID("docAttr", UA);
let bc = class extends Error {
};
bc = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
bc.prototype = Object.create(Error.prototype);
bc.prototype.constructor = bc;
bc.prototype.name = "TransformError";
let oz = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new F3();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new bc(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = Fe.empty) {
    let i = Q3(this.doc, e, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new Fe(je.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, Fe.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return rz(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return iz(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return sz(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return U3(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return X3(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return V3(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, i = null) {
    return W3(this, e, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, i) {
    return K3(this, e, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new HA(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new UA(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new Yw(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof Xt)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(r.marks), !n)
        return this;
    }
    return this.step(new Xw(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, r) {
    return Y3(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return z3(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return H3(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return LA(this, e, n, r), this;
  }
};
const $0 = /* @__PURE__ */ Object.create(null);
class $e {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new Jw(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = Fe.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: c } = o[a], u = e.mapping.slice(s);
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? Fe.empty : n), a == 0 && wx(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: a } = i[s], l = e.mapping.slice(r), c = l.map(o.pos), u = l.map(a.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), wx(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let i = e.parent.inlineContent ? new Te(e) : Nl(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = n < 0 ? Nl(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, r) : Nl(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new ur(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Nl(e, e, 0, 0, 1) || new ur(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Nl(e, e, e.content.size, e.childCount, -1) || new ur(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = $0[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in $0)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return $0[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Te.between(this.$anchor, this.$head).getBookmark();
  }
}
$e.prototype.visible = !0;
class Jw {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let bx = !1;
function yx(t) {
  !bx && !t.parent.inlineContent && (bx = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class Te extends $e {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    yx(e), yx(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return $e.near(r);
    let i = e.resolve(n.map(this.anchor));
    return new Te(i.parent.inlineContent ? i : r, r);
  }
  replace(e, n = Fe.empty) {
    if (super.replace(e, n), n == Fe.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Te && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new bv(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Te(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let i = e.resolve(n);
    return new this(i, r == n ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let i = e.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let s = $e.findFrom(n, r, !0) || $e.findFrom(n, -r, !0);
      if (s)
        n = s.$head;
      else
        return $e.near(n, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = n : (e = ($e.findFrom(e, -r, !0) || $e.findFrom(e, r, !0)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new Te(e, n);
  }
}
$e.jsonID("text", Te);
class bv {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new bv(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Te.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ve extends $e {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), s = e.resolve(i);
    return r ? $e.near(s) : new ve(s);
  }
  content() {
    return new Fe(je.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ve && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Zw(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ve(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new ve(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ve.prototype.visible = !1;
$e.jsonID("node", ve);
class Zw {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new bv(r, r) : new Zw(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && ve.isSelectable(r) ? new ve(n) : $e.near(n);
  }
}
class ur extends $e {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = Fe.empty) {
    if (n == Fe.empty) {
      e.delete(0, e.doc.content.size);
      let r = $e.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new ur(e);
  }
  map(e) {
    return new ur(e);
  }
  eq(e) {
    return e instanceof ur;
  }
  getBookmark() {
    return az;
  }
}
$e.jsonID("all", ur);
const az = {
  map() {
    return this;
  },
  resolve(t) {
    return new ur(t);
  }
};
function Nl(t, e, n, r, i, s = !1) {
  if (e.inlineContent)
    return Te.create(t, n);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let a = e.child(o);
    if (a.isAtom) {
      if (!s && ve.isSelectable(a))
        return ve.create(t, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let l = Nl(t, a, n + i, i < 0 ? a.childCount : 0, i, s);
      if (l)
        return l;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function wx(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let i = t.steps[r];
  if (!(i instanceof Us || i instanceof ul))
    return;
  let s = t.mapping.maps[r], o;
  s.forEach((a, l, c, u) => {
    o == null && (o = u);
  }), t.setSelection($e.near(t.doc.resolve(o), n));
}
const _x = 1, ch = 2, Ex = 4;
let lz = class extends oz {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | _x) & ~ch, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & _x) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= ch, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Xt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & ch) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~ch, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Xt.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !e)
        return this.deleteRange(n, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(n);
        s = r == n ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(e, s)), this.selection.empty || this.setSelection($e.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Ex, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Ex) > 0;
  }
};
function Sx(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Cu {
  constructor(e, n, r) {
    this.name = e, this.init = Sx(n.init, r), this.apply = Sx(n.apply, r);
  }
}
const cz = [
  new Cu("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new Cu("selection", {
    init(t, e) {
      return t.selection || $e.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new Cu("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new Cu("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class B0 {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = cz.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Cu(r.key, r.spec.state, r));
    });
  }
}
class Kl {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o];
        if (a.spec.appendTransaction) {
          let l = i ? i[o].n : 0, c = i ? i[o].state : this, u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r);
          if (u && r.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                i.push(d < o ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(u), r = r.applyInner(u), s = !0;
          }
          i && (i[o] = { state: r, n: n.length });
        }
      }
      if (!s)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Kl(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      n[s.name] = s.apply(e, this[s.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new lz(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new B0(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Kl(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new B0(this.schema, e.plugins), r = n.fields, i = new Kl(n);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (n[r] = s.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new B0(e.schema, e.plugins), s = new Kl(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = TA.fromJSON(e.schema, n.doc);
      else if (o.name == "selection")
        s.selection = $e.fromJSON(s.doc, n.selection);
      else if (o.name == "storedMarks")
        n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let l = r[a], c = l.spec.state;
            if (l.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              s[o.name] = c.fromJSON.call(l, e, n[a], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function VA(t, e, n) {
  for (let r in t) {
    let i = t[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = VA(i, e, {})), n[r] = i;
  }
  return n;
}
class ut {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && VA(e.props, this, this.props), this.key = e.key ? e.key.key : WA("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const F0 = /* @__PURE__ */ Object.create(null);
function WA(t) {
  return t in F0 ? t + "$" + ++F0[t] : (F0[t] = 0, t + "$");
}
class ft {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = WA(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
function GA(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), s = e.child(r);
    if (i == s) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return n;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        n++;
      return n;
    }
    if (i.content.size || s.content.size) {
      let o = GA(i.content, s.content, n + 1);
      if (o != null)
        return o;
    }
    n += i.nodeSize;
  }
}
function jA(t, e, n, r) {
  for (let i = t.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: n, b: r };
    let o = t.child(--i), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      n -= l, r -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: n, b: r };
    if (o.isText && o.text != a.text) {
      let c = 0, u = Math.min(o.text.length, a.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, r--;
      return { a: n, b: r };
    }
    if (o.content.size || a.content.size) {
      let c = jA(o.content, a.content, n - 1, r - 1);
      if (c)
        return c;
    }
    n -= l, r -= l;
  }
}
let pe = class Wn {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, s) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o], c = a + l.nodeSize;
      if (c > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), r, i + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new Wn(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let s = 0, o = 0; o < n; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))), r.push(a), i += a.nodeSize), o = l;
      }
    return new Wn(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? Wn.empty : e == 0 && n == this.content.length ? this : new Wn(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), s = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new Wn(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Wn([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Wn(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return GA(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return jA(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return uh(0, e);
    if (e == this.size)
      return uh(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let s = this.child(r), o = i + s.nodeSize;
      if (o >= e)
        return o == e || n > 0 ? uh(r + 1, o) : uh(r, i);
      i = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Wn.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Wn(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Wn.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s);
    }
    return new Wn(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Wn.empty;
    if (e instanceof Wn)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Wn([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
pe.empty = new pe([], 0);
const z0 = { index: 0, offset: 0 };
function uh(t, e) {
  return z0.index = t, z0.offset = e, z0;
}
function ag(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!ag(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !ag(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let Ft = class py {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        n || (n = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(s);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && ag(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return py.none;
    if (e instanceof py)
      return [e];
    let n = e.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
Ft.none = [];
let lg = class extends Error {
}, De = class Rl {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = KA(this.content, e + this.openStart, n);
    return r && new Rl(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new Rl(qA(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Rl.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Rl(pe.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new Rl(e, r, i);
  }
};
De.empty = new De(pe.empty, 0, 0);
function qA(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r), { index: o, offset: a } = t.findIndex(n);
  if (i == e || s.isText) {
    if (a != n && !t.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, s.copy(qA(s.content, e - i - 1, n - i - 1)));
}
function KA(t, e, n, r) {
  let { index: i, offset: s } = t.findIndex(e), o = t.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = KA(o.content, e - s - 1, n);
  return a && t.replaceChild(i, o.copy(a));
}
function uz(t, e, n) {
  if (n.openStart > t.depth)
    throw new lg("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new lg("Inconsistent open depths");
  return YA(t, e, n, 0);
}
function YA(t, e, n, r) {
  let i = t.index(r), s = t.node(r);
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let o = YA(t, e, n, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let o = t.parent, a = o.content;
      return xa(o, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = dz(n, t);
      return xa(s, JA(t, o, a, e, r));
    }
  else
    return xa(s, cg(t, e, r));
}
function XA(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new lg("Cannot join " + e.type.name + " onto " + t.type.name);
}
function gy(t, e, n) {
  let r = t.node(n);
  return XA(r, e.node(n)), r;
}
function Sa(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function Yu(t, e, n, r) {
  let i = (e || t).node(n), s = 0, o = e ? e.index(n) : i.childCount;
  t && (s = t.index(n), t.depth > n ? s++ : t.textOffset && (Sa(t.nodeAfter, r), s++));
  for (let a = s; a < o; a++)
    Sa(i.child(a), r);
  e && e.depth == n && e.textOffset && Sa(e.nodeBefore, r);
}
function xa(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function JA(t, e, n, r, i) {
  let s = t.depth > i && gy(t, e, i + 1), o = r.depth > i && gy(n, r, i + 1), a = [];
  return Yu(null, t, i, a), s && o && e.index(i) == n.index(i) ? (XA(s, o), Sa(xa(s, JA(t, e, n, r, i + 1)), a)) : (s && Sa(xa(s, cg(t, e, i + 1)), a), Yu(e, n, i, a), o && Sa(xa(o, cg(n, r, i + 1)), a)), Yu(r, null, i, a), new pe(a);
}
function cg(t, e, n) {
  let r = [];
  if (Yu(null, t, n, r), t.depth > n) {
    let i = gy(t, e, n + 1);
    Sa(xa(i, cg(t, e, n + 1)), r);
  }
  return Yu(e, null, n, r), new pe(r);
}
function dz(t, e) {
  let n = e.depth - t.openStart, i = e.node(n).copy(t.content);
  for (let s = n - 1; s >= 0; s--)
    i = e.node(s).copy(pe.from(i));
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  };
}
class Td {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(n);
    return r ? e.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return Ft.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), i = e.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new ug(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, s = n;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s), c = s - l;
      if (r.push(o, a, i + l), !c || (o = o.child(a), o.isText))
        break;
      s = c - 1, i += l + 1;
    }
    return new Td(n, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = xx.get(e);
    if (r)
      for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s];
        if (o.pos == n)
          return o;
      }
    else
      xx.set(e, r = new fz());
    let i = r.elts[r.i] = Td.resolve(e, n);
    return r.i = (r.i + 1) % hz, i;
  }
}
class fz {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const hz = 12, xx = /* @__PURE__ */ new WeakMap();
class ug {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const pz = /* @__PURE__ */ Object.create(null);
let rc = class my {
  /**
  @internal
  */
  constructor(e, n, r, i = Ft.none) {
    this.type = e, this.attrs = n, this.marks = i, this.content = r || pe.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && ag(this.attrs, n || e.defaultAttrs || pz) && Ft.sameSet(this.marks, r || Ft.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new my(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new my(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return De.empty;
    let i = this.resolve(e), s = this.resolve(n), o = r ? 0 : i.sharedDepth(n), a = i.start(o), c = i.node(o).content.cut(i.pos - a, s.pos - a);
    return new De(c, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return uz(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == e || n.isText)
        return n;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Td.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Td.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let i = !1;
    return n > e && this.nodesBetween(e, n, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), ZA(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = pe.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), a = o && o.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = i; l < s; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, n);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Ft.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!Ft.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let i = pe.fromJSON(e, n.content), s = e.nodeType(n.type).create(n.attrs, i, r);
    return s.type.checkAttrs(s.attrs), s;
  }
};
rc.prototype.text = void 0;
class dg extends rc {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    if (super(e, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : ZA(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new dg(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new dg(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function ZA(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class Fa {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new gz(e, n);
    if (r.next == null)
      return Fa.empty;
    let i = QA(r);
    r.next && r.err("Unexpected trailing text");
    let s = Ez(_z(i));
    return Sz(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let i = this;
    for (let s = n; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let i = [this];
    function s(o, a) {
      let l = o.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return pe.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: d } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(d) == -1) {
          i.push(d);
          let f = s(d, a.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let a = i; a.type; a = a.via)
          o.push(a.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
Fa.empty = new Fa(!0);
class gz {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function QA(t) {
  let e = [];
  do
    e.push(mz(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function mz(t) {
  let e = [];
  do
    e.push(vz(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function vz(t) {
  let e = wz(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = bz(t, e);
    else
      break;
  return e;
}
function kx(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function bz(t, e) {
  let n = kx(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = kx(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function yz(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let i = [];
  for (let s in n) {
    let o = n[s];
    o.isInGroup(e) && i.push(o);
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function wz(t) {
  if (t.eat("(")) {
    let e = QA(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = yz(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function _z(t) {
  let e = [[]];
  return i(s(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(o, a, l) {
    let c = { term: l, to: a };
    return e[o].push(c), c;
  }
  function i(o, a) {
    o.forEach((l) => l.to = a);
  }
  function s(o, a) {
    if (o.type == "choice")
      return o.exprs.reduce((l, c) => l.concat(s(c, a)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let c = s(o.exprs[l], a);
        if (l == o.exprs.length - 1)
          return c;
        i(c, a = n());
      }
    else if (o.type == "star") {
      let l = n();
      return r(a, l), i(s(o.expr, l), l), [r(l)];
    } else if (o.type == "plus") {
      let l = n();
      return i(s(o.expr, a), l), i(s(o.expr, l), l), [r(l)];
    } else {
      if (o.type == "opt")
        return [r(a)].concat(s(o.expr, a));
      if (o.type == "range") {
        let l = a;
        for (let c = 0; c < o.min; c++) {
          let u = n();
          i(s(o.expr, l), u), l = u;
        }
        if (o.max == -1)
          i(s(o.expr, l), l);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = n();
            r(l, u), i(s(o.expr, l), u), l = u;
          }
        return [r(l)];
      } else {
        if (o.type == "name")
          return [r(a, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function eN(t, e) {
  return e - t;
}
function Cx(t, e) {
  let n = [];
  return r(e), n.sort(eN);
  function r(i) {
    let s = t[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    n.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o];
      !a && n.indexOf(l) == -1 && r(l);
    }
  }
}
function Ez(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(Cx(t, 0));
  function n(r) {
    let i = [];
    r.forEach((o) => {
      t[o].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let u = 0; u < i.length; u++)
          i[u][0] == a && (c = i[u][1]);
        Cx(t, l).forEach((u) => {
          c || i.push([a, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[r.join(",")] = new Fa(r.indexOf(t.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let a = i[o][1].sort(eN);
      s.next.push({ type: i[o][0], next: e[a.join(",")] || n(a) });
    }
    return s;
  }
}
function Sz(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let i = r[n], s = !i.validEnd, o = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: c } = i.next[a];
      o.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), r.indexOf(c) == -1 && r.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function tN(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function nN(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = e && e[r];
    if (i === void 0) {
      let s = t[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function rN(t, e, n, r) {
  for (let i in e)
    if (!(i in t))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in t) {
    let s = t[i];
    s.validate && s.validate(e[i]);
  }
}
function iN(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      n[r] = new kz(t, r, e[r]);
  return n;
}
let Tx = class sN {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = iN(e, r.attrs), this.defaultAttrs = tN(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Fa.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : nN(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new rc(this, this.computeAttrs(e), pe.from(n), Ft.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = pe.from(n), this.checkContent(n), new rc(this, this.computeAttrs(e), n, Ft.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = pe.from(n), n.size) {
      let o = this.contentMatch.fillBefore(n);
      if (!o)
        return null;
      n = o.append(n);
    }
    let i = this.contentMatch.matchFragment(n), s = i && i.fillBefore(pe.empty, !0);
    return s ? new rc(this, e, n.append(s), Ft.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    rN(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : Ft.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new sN(s, n, o));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function xz(t, e, n) {
  let r = n.split("|");
  return (i) => {
    let s = i === null ? "null" : typeof i;
    if (r.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${s}`);
  };
}
class kz {
  constructor(e, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? xz(e, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class yv {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = iN(e, i.attrs), this.excluded = null;
    let s = tN(this.attrs);
    this.instance = s ? new Ft(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Ft(this, nN(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new yv(s, i++, n, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    rN(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class oN {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in e)
      n[i] = e[i];
    n.nodes = Cn.from(e.nodes), n.marks = Cn.from(e.marks || {}), this.nodes = Tx.compile(this.spec.nodes, this), this.marks = yv.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", a = s.spec.marks;
      if (s.contentMatch = r[o] || (r[o] = Fa.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = a == "_" ? null : a ? Ox(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : Ox(this, o.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Tx) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else
      throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new dg(r, r.defaultAttrs, e, Ft.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return rc.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Ft.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function Ox(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = t.marks[i], o = s;
    if (s)
      n.push(s);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function Cz(t) {
  return t.tag != null;
}
function Tz(t) {
  return t.style != null;
}
let Xu = class vy {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (Cz(i))
        this.tags.push(i);
      else if (Tz(i)) {
        let s = /[^=]*/.exec(i.style)[0];
        r.indexOf(s) < 0 && r.push(s), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let s = e.nodes[i.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new Ax(this, n, !1);
    return r.addAll(e, Ft.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new Ax(this, n, !0);
    return r.addAll(e, Ft.none, n.from, n.to), De.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (Az(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (o.getAttrs) {
          let l = o.getAttrs(n);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < n.length; o++) {
        let a = n[o];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      n.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Nx(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Nx(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new vy(e, vy.schemaRules(e)));
  }
};
const aN = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, Oz = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, lN = { ol: !0, ul: !0 }, fg = 1, hg = 2, Ju = 4;
function Mx(t, e, n) {
  return e != null ? (e ? fg : 0) | (e === "full" ? hg : 0) : t && t.whitespace == "pre" ? fg | hg : n & ~Ju;
}
class dh {
  constructor(e, n, r, i, s, o) {
    this.type = e, this.attrs = n, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = Ft.none, this.match = s || (o & Ju ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(pe.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & fg)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let n = pe.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(pe.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !aN.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Ax {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0;
    let i = n.topNode, s, o = Mx(null, n.preserveWhitespace, 0) | (r ? Ju : 0);
    i ? s = new dh(i.type, i.attrs, Ft.none, !0, n.topMatch || i.type.contentMatch, o) : r ? s = new dh(null, null, Ft.none, !0, null, o) : s = new dh(e.schema.topNodeType, null, Ft.none, !0, null, o), this.nodes = [s], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue, i = this.top;
    if (i.options & hg || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (i.options & fg)
        i.options & hg ? r = r.replace(/\r\n?/g, `
`) : r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let s = i.content[i.content.length - 1], o = e.previousSibling;
        (!s || o && o.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let i = e.nodeName.toLowerCase(), s;
    lN.hasOwnProperty(i) && this.parser.normalizeLists && Mz(e);
    let o = this.options.ruleFromNode && this.options.ruleFromNode(e) || (s = this.parser.matchTag(e, this, r));
    if (o ? o.ignore : Oz.hasOwnProperty(i))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!o || o.skip || o.closeParent) {
      o && o.closeParent ? this.open = Math.max(0, this.open - 1) : o && o.skip.nodeType && (e = o.skip);
      let a, l = this.top, c = this.needsBlock;
      if (aN.hasOwnProperty(i))
        l.content.length && l.content[0].isInline && this.open && (this.open--, l = this.top), a = !0, l.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        return;
      }
      let u = o && o.skip ? n : this.readStyles(e, n);
      u && this.addAll(e, u), a && this.sync(l), this.needsBlock = c;
    } else {
      let a = this.readStyles(e, n);
      a && this.addElementByRule(e, o, a, o.consuming === !1 ? s : void 0);
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s);
        if (o)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(s, o, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((c) => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, i) {
    let s, o;
    if (n.node)
      if (o = this.parser.schema.nodes[n.node], o.isLeaf)
        this.insertNode(o.create(n.attrs), r) || this.leafFallback(e, r);
      else {
        let l = this.enter(o, n.attrs || null, r, n.preserveWhitespace);
        l && (s = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      r = r.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1);
    }
    s && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, i) {
    let s = r || 0;
    for (let o = r ? e.childNodes[r] : e.firstChild, a = i == null ? null : e.childNodes[i]; o != a; o = o.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(o, n);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let r, i;
    for (let s = this.open; s >= 0; s--) {
      let o = this.nodes[s], a = o.findWrapping(e);
      if (a && (!r || r.length > a.length) && (r = a, i = o, !a.length) || o.solid)
        break;
    }
    if (!r)
      return null;
    this.sync(i);
    for (let s = 0; s < r.length; s++)
      n = this.enterInner(r[s], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let i = this.textblockFromContext();
      i && (n = this.enterInner(i, null, n));
    }
    let r = this.findPlace(e, n);
    if (r) {
      this.closeExtra();
      let i = this.top;
      i.match && (i.match = i.match.matchType(e.type));
      let s = Ft.none;
      for (let o of r.concat(e.marks))
        (i.type ? i.type.allowsMarkType(o.type) : Rx(o.type, e.type)) && (s = o.addToSet(s));
      return i.content.push(e.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, i) {
    let s = this.findPlace(e.create(n), r);
    return s && (s = this.enterInner(e, n, r, !0, i)), s;
  }
  // Open a node of the given type
  enterInner(e, n, r, i = !1, s) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let a = Mx(e, s, o.options);
    o.options & Ju && o.content.length == 0 && (a |= Ju);
    let l = Ft.none;
    return r = r.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : Rx(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new dh(e, n, l, i, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--)
      if (this.nodes[n] == e)
        return this.open = n, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (o(a - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function Mz(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && lN.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function Az(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function Nx(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function Rx(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(t))
      continue;
    let s = [], o = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
class dl {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = H0(n).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < o.marks.length; ) {
          let c = o.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(s[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          i = s.pop()[1];
        for (; l < o.marks.length; ) {
          let c = o.marks[l++], u = this.serializeMark(c, o.isInline, n);
          u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = mp(H0(n), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, n);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name];
    return i && mp(H0(r), i(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, i) {
    return mp(e, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new dl(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = Dx(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Dx(e.marks);
  }
}
function Dx(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function H0(t) {
  return t.document || window.document;
}
const Ix = /* @__PURE__ */ new WeakMap();
function Nz(t) {
  let e = Ix.get(t);
  return e === void 0 && Ix.set(t, e = Rz(t)), e;
}
function Rz(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(t), e;
}
function mp(t, e, n, r) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], s;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (s = Nz(r)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = i.indexOf(" ");
  o > 0 && (n = i.slice(0, o), i = i.slice(o + 1));
  let a, l = n ? t.createElementNS(n, i) : t.createElement(i), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : l.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: h, contentDOM: p } = mp(t, f, n, r);
      if (l.appendChild(h), p) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = p;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const cN = 65535, uN = Math.pow(2, 16);
function Dz(t, e) {
  return t + e * uN;
}
function Px(t) {
  return t & cN;
}
function Iz(t) {
  return (t - (t & cN)) / uN;
}
const dN = 1, fN = 2, vp = 4, hN = 8;
let by = class {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & hN) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (dN | vp)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (fN | vp)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & vp) > 0;
  }
}, za = class Dl {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Dl.empty)
      return Dl.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = Px(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + Iz(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = this.ranges[a + o], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : n : n, h = l + i + (f < 0 ? 0 : u);
        if (r)
          return h;
        let p = e == (n < 0 ? l : d) ? null : Dz(a / 3, e - l), g = e == l ? fN : e == d ? dN : vp;
        return (n < 0 ? e != l : e != d) && (g |= hN), new by(h, g, p);
      }
      i += u - c;
    }
    return r ? e + i : new by(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = Px(n), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = l + c;
      if (e <= u && a == i * 3)
        return !0;
      r += this.ranges[a + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), c = this.ranges[i + n], u = this.ranges[i + r];
      e(a, a + c, l, l + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Dl(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Dl.empty : new Dl(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
};
za.empty = new za([]);
class ic {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, r = 0, i = e.length) {
    this.maps = e, this.mirror = n, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new ic(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new ic(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new ic();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s], a = o.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, e = a.pos;
    }
    return r ? e : new by(e, i, null);
  }
}
const U0 = /* @__PURE__ */ Object.create(null);
let Hn = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return za.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = U0[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in U0)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return U0[e] = n, n.prototype.jsonID = e, n;
  }
}, Xn = class Tu {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Tu(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Tu(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return Tu.ok(e.replace(n, r, i));
    } catch (s) {
      if (s instanceof lg)
        return Tu.fail(s.message);
      throw s;
    }
  }
};
function Qw(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let s = t.child(i);
    s.content.size && (s = s.copy(Qw(s.content, e, s))), s.isInline && (s = e(s, n, i)), r.push(s);
  }
  return pe.fromArray(r);
}
let e_ = class Ou extends Hn {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new De(Qw(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), n.openStart, n.openEnd);
    return Xn.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new Rf(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new Ou(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ou && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ou(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Ou(n.from, n.to, e.markFromJSON(n.mark));
  }
};
Hn.jsonID("addMark", e_);
let Rf = class Mu extends Hn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new De(Qw(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return Xn.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new e_(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new Mu(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Mu && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Mu(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Mu(n.from, n.to, e.markFromJSON(n.mark));
  }
};
Hn.jsonID("removeMark", Rf);
let t_ = class Au extends Hn {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Xn.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Xn.fromReplace(e, this.pos, this.pos + 1, new De(pe.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new Au(this.pos, n.marks[i]);
        return new Au(this.pos, this.mark);
      }
    }
    return new n_(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Au(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Au(n.pos, e.markFromJSON(n.mark));
  }
};
Hn.jsonID("addNodeMark", t_);
let n_ = class yy extends Hn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Xn.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Xn.fromReplace(e, this.pos, this.pos + 1, new De(pe.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new t_(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new yy(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new yy(n.pos, e.markFromJSON(n.mark));
  }
};
Hn.jsonID("removeNodeMark", n_);
let rs = class Qo extends Hn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && wy(e, this.from, this.to) ? Xn.fail("Structure replace would overwrite content") : Xn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new za([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Qo(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new Qo(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof Qo) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? De.empty : new De(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Qo(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? De.empty : new De(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Qo(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Qo(n.from, n.to, De.fromJSON(e, n.slice), !!n.structure);
  }
};
Hn.jsonID("replace", rs);
let Br = class bp extends Hn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, s, o, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (wy(e, this.from, this.gapFrom) || wy(e, this.gapTo, this.to)))
      return Xn.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Xn.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? Xn.fromReplace(e, this.from, this.to, r) : Xn.fail("Content does not fit in gap");
  }
  getMap() {
    return new za([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new bp(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || s > r.pos ? null : new bp(n.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new bp(n.from, n.to, n.gapFrom, n.gapTo, De.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
};
Hn.jsonID("replaceAround", Br);
function wy(t, e, n) {
  let r = t.resolve(e), i = n - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function Pz(t, e, n, r) {
  let i = [], s = [], o, a;
  t.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), h = Math.min(c + l.nodeSize, n), p = r.addToSet(d);
      for (let g = 0; g < d.length; g++)
        d[g].isInSet(p) || (o && o.to == f && o.mark.eq(d[g]) ? o.to = h : i.push(o = new Rf(f, h, d[g])));
      a && a.to == f ? a.to = h : s.push(a = new e_(f, h, r));
    }
  }), i.forEach((l) => t.step(l)), s.forEach((l) => t.step(l));
}
function Lz(t, e, n, r) {
  let i = [], s = 0;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (!o.isInline)
      return;
    s++;
    let l = null;
    if (r instanceof yv) {
      let c = o.marks, u;
      for (; u = r.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else
      r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks;
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, n);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], f;
        for (let h = 0; h < i.length; h++) {
          let p = i[h];
          p.step == s - 1 && d.eq(i[h].style) && (f = p);
        }
        f ? (f.to = c, f.step = s) : i.push({ style: d, from: Math.max(a, e), to: c, step: s });
      }
    }
  }), i.forEach((o) => t.step(new Rf(o.from, o.to, o.style)));
}
function r_(t, e, n, r = n.contentMatch, i = !0) {
  let s = t.doc.nodeAt(e), o = [], a = e + 1;
  for (let l = 0; l < s.childCount; l++) {
    let c = s.child(l), u = a + c.nodeSize, d = r.matchType(c.type);
    if (!d)
      o.push(new rs(a, u, De.empty));
    else {
      r = d;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new Rf(a, u, c.marks[f]));
      if (i && c.isText && n.whitespace != "pre") {
        let f, h = /\r?\n|\r/g, p;
        for (; f = h.exec(c.text); )
          p || (p = new De(pe.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), o.push(new rs(a + f.index, a + f.index + f[0].length, p));
      }
    }
    a = u;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(pe.empty, !0);
    t.replace(a, a, new De(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    t.step(o[l]);
}
function $z(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function Qc(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let i = t.$from.node(r), s = t.$from.index(r), o = t.$to.indexAfter(r);
    if (r < t.depth && i.canReplace(s, o, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !$z(i, s, o))
      break;
  }
  return null;
}
function Bz(t, e, n) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), a = i.after(s + 1), l = o, c = a, u = pe.empty, d = 0;
  for (let p = s, g = !1; p > n; p--)
    g || r.index(p) > 0 ? (g = !0, u = pe.from(r.node(p).copy(u)), d++) : l--;
  let f = pe.empty, h = 0;
  for (let p = s, g = !1; p > n; p--)
    g || i.after(p + 1) < i.end(p) ? (g = !0, f = pe.from(i.node(p).copy(f)), h++) : c++;
  t.step(new Br(l, c, o, a, new De(u.append(f), d, h), u.size - d, !0));
}
function i_(t, e, n = null, r = t) {
  let i = Fz(t, e), s = i && zz(r, e);
  return s ? i.map(Lx).concat({ type: e, attrs: n }).concat(s.map(Lx)) : null;
}
function Lx(t) {
  return { type: t, attrs: null };
}
function Fz(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, s = n.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return n.canReplaceWith(r, i, o) ? s : null;
}
function zz(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, s = n.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = r; l && c < i; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : o;
}
function Hz(t, e, n) {
  let r = pe.empty;
  for (let o = n.length - 1; o >= 0; o--) {
    if (r.size) {
      let a = n[o].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = pe.from(n[o].type.create(n[o].attrs, r));
  }
  let i = e.start, s = e.end;
  t.step(new Br(i, s, i, s, new De(r, 0, 0), n.length, !0));
}
function Uz(t, e, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = t.steps.length;
  t.doc.nodesBetween(e, n, (o, a) => {
    let l = typeof i == "function" ? i(o) : i;
    if (o.isTextblock && !o.hasMarkup(r, l) && Vz(t.doc, t.mapping.slice(s).map(a), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let h = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        h && !p ? c = !1 : !h && p && (c = !0);
      }
      c === !1 && gN(t, o, a, s), r_(t, t.mapping.slice(s).map(a, 1), r, void 0, c === null);
      let u = t.mapping.slice(s), d = u.map(a, 1), f = u.map(a + o.nodeSize, 1);
      return t.step(new Br(d, f, d + 1, f - 1, new De(pe.from(r.create(l, null, o.marks)), 0, 0), 1, !0)), c === !0 && pN(t, o, a, s), !1;
    }
  });
}
function pN(t, e, n, r) {
  e.forEach((i, s) => {
    if (i.isText) {
      let o, a = /\r?\n|\r/g;
      for (; o = a.exec(i.text); ) {
        let l = t.mapping.slice(r).map(n + 1 + s + o.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function gN(t, e, n, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = t.mapping.slice(r).map(n + 1 + s);
      t.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function Vz(t, e, n) {
  let r = t.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function Wz(t, e, n, r, i) {
  let s = t.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  n || (n = s.type);
  let o = n.create(r, null, i || s.marks);
  if (s.isLeaf)
    return t.replaceWith(e, e + s.nodeSize, o);
  if (!n.validContent(s.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new Br(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new De(pe.from(o), 0, 0), 1, !0));
}
function sc(t, e, n = 1, r) {
  let i = t.resolve(e), s = i.depth - n, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, u = n - 2; c > s; c--, u--) {
    let d = i.node(c), f = i.index(c);
    if (d.type.spec.isolating)
      return !1;
    let h = d.content.cutByIndex(f, d.childCount), p = r && r[u + 1];
    p && (h = h.replaceChild(0, p.type.create(p.attrs)));
    let g = r && r[u] || d;
    if (!d.canReplace(f + 1, d.childCount) || !g.type.validContent(h))
      return !1;
  }
  let a = i.indexAfter(s), l = r && r[0];
  return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type);
}
function Gz(t, e, n = 1, r) {
  let i = t.doc.resolve(e), s = pe.empty, o = pe.empty;
  for (let a = i.depth, l = i.depth - n, c = n - 1; a > l; a--, c--) {
    s = pe.from(i.node(a).copy(s));
    let u = r && r[c];
    o = pe.from(u ? u.type.create(u.attrs, o) : i.node(a).copy(o));
  }
  t.step(new rs(e, e, new De(s.append(o), n, n), !0));
}
function Fo(t, e) {
  let n = t.resolve(e), r = n.index();
  return mN(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function jz(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i), o = s.type == r ? t.type.schema.nodes.text : s.type;
    if (n = n.matchType(o), !n || !t.type.allowsMarks(s.marks))
      return !1;
  }
  return n.validEnd;
}
function mN(t, e) {
  return !!(t && e && !t.isLeaf && jz(t, e));
}
function wv(t, e, n = -1) {
  let r = t.resolve(e);
  for (let i = r.depth; ; i--) {
    let s, o, a = r.index(i);
    if (i == r.depth ? (s = r.nodeBefore, o = r.nodeAfter) : n > 0 ? (s = r.node(i + 1), a++, o = r.node(i).maybeChild(a)) : (s = r.node(i).maybeChild(a - 1), o = r.node(i + 1)), s && !s.isTextblock && mN(s, o) && r.node(i).canReplace(a, a + 1))
      return e;
    if (i == 0)
      break;
    e = n < 0 ? r.before(i) : r.after(i);
  }
}
function qz(t, e, n) {
  let r = null, { linebreakReplacement: i } = t.doc.type.schema, s = t.doc.resolve(e - n), o = s.node().type;
  if (i && o.inlineContent) {
    let u = o.whitespace == "pre", d = !!o.contentMatch.matchType(i);
    u && !d ? r = !1 : !u && d && (r = !0);
  }
  let a = t.steps.length;
  if (r === !1) {
    let u = t.doc.resolve(e + n);
    gN(t, u.node(), u.before(), a);
  }
  o.inlineContent && r_(t, e + n - 1, o, s.node().contentMatchAt(s.index()), r == null);
  let l = t.mapping.slice(a), c = l.map(e - n);
  if (t.step(new rs(c, l.map(e + n, -1), De.empty, !0)), r === !0) {
    let u = t.doc.resolve(c);
    pN(t, u.node(), u.before(), t.steps.length);
  }
  return t;
}
function Kz(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function vN(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let i = n.content;
  for (let s = 0; s < n.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, l = r.index(o) + (a > 0 ? 1 : 0), c = r.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(l, l, i);
      else {
        let d = c.contentMatchAt(l).findWrapping(i.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function _v(t, e, n = e, r = De.empty) {
  if (e == n && !r.size)
    return null;
  let i = t.resolve(e), s = t.resolve(n);
  return bN(i, s, r) ? new rs(e, n, r) : new Yz(i, s, r).fit();
}
function bN(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class Yz {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = pe.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = pe.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, a = i.depth;
    for (; o && a && s.childCount == 1; )
      s = s.firstChild.content, o--, a--;
    let l = new De(s, o, a);
    return e > -1 ? new Br(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new rs(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = n.firstChild;
      if (n.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      n = s.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = V0(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, d = null;
          if (n == 1 && (o ? c.matchType(o.type) || (d = c.fillBefore(pe.from(o), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, inject: d };
          if (n == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = V0(e, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new De(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = V0(e, n);
    if (i.childCount <= 1 && n > 0) {
      let s = e.size - n <= n + i.size;
      this.unplaced = new De(Nu(e, n - 1, 1), n - 1, s ? n - 1 : r);
    } else
      this.unplaced = new De(Nu(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: s }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (s)
      for (let g = 0; g < s.length; g++)
        this.openFrontierNode(s[g]);
    let o = this.unplaced, a = r ? r.content : o.content, l = o.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[n];
    if (i) {
      for (let g = 0; g < i.childCount; g++)
        u.push(i.child(g));
      d = d.matchFragment(i);
    }
    let h = a.size + e - (o.content.size - o.openEnd);
    for (; c < a.childCount; ) {
      let g = a.child(c), m = d.matchType(g.type);
      if (!m)
        break;
      c++, (c > 1 || l == 0 || g.content.size) && (d = m, u.push(yN(g.mark(f.allowedMarks(g.marks)), c == 1 ? l : 0, c == a.childCount ? h : -1)));
    }
    let p = c == a.childCount;
    p || (h = -1), this.placed = Ru(this.placed, n, pe.from(u)), this.frontier[n].match = d, p && h < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, m = a; g < h; g++) {
      let v = m.lastChild;
      this.frontier.push({ type: v.type, match: v.contentMatchAt(v.childCount) }), m = v.content;
    }
    this.unplaced = p ? e == 0 ? De.empty : new De(Nu(o.content, e - 1, 1), e - 1, h < 0 ? o.openEnd : e - 1) : new De(Nu(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !W0(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e:
      for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
        let { match: r, type: i } = this.frontier[n], s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), o = W0(e, n, i, r, s);
        if (o) {
          for (let a = n - 1; a >= 0; a--) {
            let { match: l, type: c } = this.frontier[a], u = W0(e, a, c, l, !0);
            if (!u || u.childCount)
              continue e;
          }
          return { depth: n, fit: o, move: s ? e.doc.resolve(e.after(n + 1)) : e };
        }
      }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Ru(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = Ru(this.placed, this.depth, pe.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(pe.empty, !0);
    n.childCount && (this.placed = Ru(this.placed, this.frontier.length, n));
  }
}
function Nu(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Nu(t.firstChild.content, e - 1, n)));
}
function Ru(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Ru(t.lastChild.content, e - 1, n)));
}
function V0(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function yN(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, yN(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(pe.empty, !0)))), t.copy(r);
}
function W0(t, e, n, r, i) {
  let s = t.node(e), o = i ? t.indexAfter(e) : t.index(e);
  if (o == s.childCount && !n.compatibleContent(s.type))
    return null;
  let a = r.fillBefore(s.content, !0, o);
  return a && !Xz(n, s.content, o) ? a : null;
}
function Xz(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function Jz(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function Zz(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let i = t.doc.resolve(e), s = t.doc.resolve(n);
  if (bN(i, s, r))
    return t.step(new rs(e, n, r));
  let o = _N(i, t.doc.resolve(n));
  o[o.length - 1] == 0 && o.pop();
  let a = -(i.depth + 1);
  o.unshift(a);
  for (let f = i.depth, h = i.pos - 1; f > 0; f--, h--) {
    let p = i.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? a = f : i.before(f) == h && o.splice(1, 0, -f);
  }
  let l = o.indexOf(a), c = [], u = r.openStart;
  for (let f = r.content, h = 0; ; h++) {
    let p = f.firstChild;
    if (c.push(p), h == r.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let h = c[f], p = Jz(h.type);
    if (p && !h.sameMarkup(i.node(Math.abs(a) - 1)))
      u = f;
    else if (p || !h.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let h = (f + u + 1) % (r.openStart + 1), p = c[h];
    if (p)
      for (let g = 0; g < o.length; g++) {
        let m = o[(g + l) % o.length], v = !0;
        m < 0 && (v = !1, m = -m);
        let y = i.node(m - 1), E = i.index(m - 1);
        if (y.canReplaceWith(E, E, p.type, p.marks))
          return t.replace(i.before(m), v ? s.after(m) : n, new De(wN(r.content, 0, r.openStart, h), h, r.openEnd));
      }
  }
  let d = t.steps.length;
  for (let f = o.length - 1; f >= 0 && (t.replace(e, n, r), !(t.steps.length > d)); f--) {
    let h = o[f];
    h < 0 || (e = i.before(h), n = s.after(h));
  }
}
function wN(t, e, n, r, i) {
  if (e < n) {
    let s = t.firstChild;
    t = t.replaceChild(0, s.copy(wN(s.content, e + 1, n, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(t).append(t);
    t = o.append(s.matchFragment(o).fillBefore(pe.empty, !0));
  }
  return t;
}
function Qz(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = Kz(t.doc, e, r.type);
    i != null && (e = n = i);
  }
  t.replaceRange(e, n, new De(pe.from(r), 0, 0));
}
function eH(t, e, n) {
  let r = t.doc.resolve(e), i = t.doc.resolve(n), s = _N(r, i);
  for (let o = 0; o < s.length; o++) {
    let a = s[o], l = o == s.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), i.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return t.delete(r.before(a), i.after(a));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1)))
      return t.delete(r.before(o), n);
  t.delete(e, n);
}
function _N(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = t.start(i);
    if (s < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && n.push(i);
  }
  return n;
}
let EN = class yp extends Hn {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Xn.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in n.attrs)
      r[s] = n.attrs[s];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return Xn.fromReplace(e, this.pos, this.pos + 1, new De(pe.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return za.empty;
  }
  invert(e) {
    return new yp(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new yp(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new yp(n.pos, n.attr, n.value);
  }
};
Hn.jsonID("attr", EN);
let SN = class _y extends Hn {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      n[i] = e.attrs[i];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return Xn.ok(r);
  }
  getMap() {
    return za.empty;
  }
  invert(e) {
    return new _y(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _y(n.attr, n.value);
  }
};
Hn.jsonID("docAttr", SN);
let yc = class extends Error {
};
yc = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
yc.prototype = Object.create(Error.prototype);
yc.prototype.constructor = yc;
yc.prototype.name = "TransformError";
class xN {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new ic();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new yc(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = De.empty) {
    let i = _v(this.doc, e, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new De(pe.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, De.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return Zz(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return Qz(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return eH(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return Bz(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return qz(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return Hz(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, i = null) {
    return Uz(this, e, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, i) {
    return Wz(this, e, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new EN(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new SN(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new t_(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof Ft)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(r.marks), !n)
        return this;
    }
    return this.step(new n_(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, r) {
    return Gz(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return Pz(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return Lz(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return r_(this, e, n, r), this;
  }
}
const On = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, Od = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Ey = null;
const As = function(t, e, n) {
  let r = Ey || (Ey = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, tH = function() {
  Ey = null;
}, Ha = function(t, e, n, r) {
  return n && ($x(t, e, n, r, -1) || $x(t, e, n, r, 1));
}, nH = /^(img|br|input|textarea|hr)$/i;
function $x(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Xr(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || Df(t) || nH.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = On(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = i < 0 ? Xr(t) : 0;
    } else
      return !1;
  }
}
function Xr(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function rH(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = Xr(t);
    } else if (t.parentNode && !Df(t))
      e = On(t), t = t.parentNode;
    else
      return null;
  }
}
function iH(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !Df(t))
      e = On(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function sH(t, e, n) {
  for (let r = e == 0, i = e == Xr(t); r || i; ) {
    if (t == n)
      return !0;
    let s = On(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && s == 0, i = i && s == Xr(t);
  }
}
function Df(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Ev = function(t) {
  return t.focusNode && Ha(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function na(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function oH(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function aH(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Xr(r.offsetNode), r.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(Xr(r.startContainer), r.startOffset) };
  }
}
const is = typeof navigator < "u" ? navigator : null, Bx = typeof document < "u" ? document : null, zo = is && is.userAgent || "", Sy = /Edge\/(\d+)/.exec(zo), kN = /MSIE \d/.exec(zo), xy = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(zo), dr = !!(kN || xy || Sy), So = kN ? document.documentMode : xy ? +xy[1] : Sy ? +Sy[1] : 0, Mi = !dr && /gecko\/(\d+)/i.test(zo);
Mi && +(/Firefox\/(\d+)/.exec(zo) || [0, 0])[1];
const ky = !dr && /Chrome\/(\d+)/.exec(zo), Pn = !!ky, CN = ky ? +ky[1] : 0, Qn = !dr && !!is && /Apple Computer/.test(is.vendor), wc = Qn && (/Mobile\/\w+/.test(zo) || !!is && is.maxTouchPoints > 2), jr = wc || (is ? /Mac/.test(is.platform) : !1), lH = is ? /Win/.test(is.platform) : !1, yi = /Android \d/.test(zo), If = !!Bx && "webkitFontSmoothing" in Bx.documentElement.style, cH = If ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function uH(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function ws(t, e) {
  return typeof t == "number" ? t : t[e];
}
function dH(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function Fx(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, i = t.someProp("scrollMargin") || 5, s = t.dom.ownerDocument;
  for (let o = n || t.dom; o; o = Od(o)) {
    if (o.nodeType != 1)
      continue;
    let a = o, l = a == s.body, c = l ? uH(s) : dH(a), u = 0, d = 0;
    if (e.top < c.top + ws(r, "top") ? d = -(c.top - e.top + ws(i, "top")) : e.bottom > c.bottom - ws(r, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + ws(i, "top") - c.top : e.bottom - c.bottom + ws(i, "bottom")), e.left < c.left + ws(r, "left") ? u = -(c.left - e.left + ws(i, "left")) : e.right > c.right - ws(r, "right") && (u = e.right - c.right + ws(i, "right")), u || d)
      if (l)
        s.defaultView.scrollBy(u, d);
      else {
        let f = a.scrollLeft, h = a.scrollTop;
        d && (a.scrollTop += d), u && (a.scrollLeft += u);
        let p = a.scrollLeft - f, g = a.scrollTop - h;
        e = { left: e.left - p, top: e.top - g, right: e.right - p, bottom: e.bottom - g };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(o).position))
      break;
  }
}
function fH(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = n + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = t.root.elementFromPoint(s, o);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = a, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: TN(t.dom) };
}
function TN(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = Od(r))
    ;
  return e;
}
function hH({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  ON(n, r == 0 ? 0 : r - e);
}
function ON(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: i, left: s } = t[n];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let wl = null;
function pH(t) {
  if (t.setActive)
    return t.setActive();
  if (wl)
    return t.focus(wl);
  let e = TN(t);
  t.focus(wl == null ? {
    get preventScroll() {
      return wl = { preventScroll: !0 }, !0;
    }
  } : void 0), wl || (wl = !1, ON(e, 0));
}
function MN(t, e) {
  let n, r = 2e8, i, s = 0, o = e.top, a = e.top, l, c;
  for (let u = t.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = As(u).getClientRects();
    else
      continue;
    for (let h = 0; h < f.length; h++) {
      let p = f[h];
      if (p.top <= o && p.bottom >= a) {
        o = Math.max(p.bottom, o), a = Math.min(p.top, a);
        let g = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (g < r) {
          n = u, r = g, i = g && n.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && g && (s = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else
        p.top > e.top && !l && p.left <= e.left && p.right >= e.left && (l = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !n && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = d + 1);
    }
  }
  return !n && l && (n = l, i = c, r = 0), n && n.nodeType == 3 ? gH(n, i) : !n || r && n.nodeType == 1 ? { node: t, offset: s } : MN(n, i);
}
function gH(t, e) {
  let n = t.nodeValue.length, r = document.createRange();
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i);
    let s = ro(r, 1);
    if (s.top != s.bottom && s_(e, s))
      return { node: t, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function s_(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function mH(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function vH(t, e, n) {
  let { node: r, offset: i } = MN(e, n), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, i, s);
}
function bH(t, e, n, r) {
  let i = -1;
  for (let s = e, o = !1; s != t.dom; ) {
    let a = t.docView.nearestDesc(s, !0);
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM)) {
      let l = a.dom.getBoundingClientRect();
      if (a.node.isBlock && a.parent && (!o && l.left > r.left || l.top > r.top ? i = a.posBefore : (!o && l.right < r.left || l.bottom < r.top) && (i = a.posAfter), o = !0), !a.contentDOM && i < 0 && !a.node.isText)
        return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    }
    s = a.dom.parentNode;
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function AN(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = i; ; ) {
      let o = t.childNodes[s];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (s_(e, c))
            return AN(o, e, c);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return t;
}
function yH(t, e) {
  let n = t.dom.ownerDocument, r, i = 0, s = aH(n, e.left, e.top);
  s && ({ node: r, offset: i } = s);
  let o = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!o || !t.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = t.dom.getBoundingClientRect();
    if (!s_(e, c) || (o = AN(t.dom, e, c), !o))
      return null;
  }
  if (Qn)
    for (let c = o; r && c; c = Od(c))
      c.draggable && (r = void 0);
  if (o = mH(o, e), r) {
    if (Mi && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && i++;
    }
    let c;
    If && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = bH(t, r, i, e));
  }
  a == null && (a = vH(t, o, e));
  let l = t.docView.nearestDesc(o, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function zx(t) {
  return t.top < t.bottom || t.left < t.right;
}
function ro(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (zx(r))
      return r;
  }
  return Array.prototype.find.call(n, zx) || t.getBoundingClientRect();
}
const wH = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function NN(t, e, n) {
  let { node: r, offset: i, atom: s } = t.docView.domFromPos(e, n < 0 ? -1 : 1), o = If || Mi;
  if (r.nodeType == 3)
    if (o && (wH.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = ro(As(r, i, i), n);
      if (Mi && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = ro(As(r, i - 1, i - 1), -1);
        if (c.top == l.top) {
          let u = ro(As(r, i, i + 1), -1);
          if (u.top != l.top)
            return pu(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = i, c = i, u = n < 0 ? 1 : -1;
      return n < 0 && !i ? (c++, u = -1) : n >= 0 && i == r.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c++, pu(ro(As(r, l, c), u), u < 0);
    }
  if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (n < 0 || i == Xr(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return G0(l.getBoundingClientRect(), !1);
    }
    if (s == null && i < Xr(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return G0(l.getBoundingClientRect(), !0);
    }
    return G0(r.getBoundingClientRect(), n >= 0);
  }
  if (s == null && i && (n < 0 || i == Xr(r))) {
    let l = r.childNodes[i - 1], c = l.nodeType == 3 ? As(l, Xr(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return pu(ro(c, 1), !1);
  }
  if (s == null && i < Xr(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? As(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return pu(ro(c, -1), !0);
  }
  return pu(ro(r.nodeType == 3 ? As(r) : r, -n), n >= 0);
}
function pu(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function G0(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function RN(t, e, n) {
  let r = t.state, i = t.root.activeElement;
  r != e && t.updateState(e), i != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus();
  }
}
function _H(t, e, n) {
  let r = e.selection, i = n == "up" ? r.$from : r.$to;
  return RN(t, e, () => {
    let { node: s } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(s, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom;
        break;
      }
      s = a.dom.parentNode;
    }
    let o = NN(t, i.pos, 1);
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = As(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (n == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const EH = /[\u0590-\u08ac]/;
function SH(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, a = t.domSelection();
  return a ? !EH.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? s : o : RN(t, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = t.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", n, "character");
    let h = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: p, focusOffset: g } = t.domSelectionRange(), m = p && !h.contains(p.nodeType == 1 ? p : p.parentNode) || l == p && c == g;
    try {
      a.collapse(u, d), l && (l != u || c != d) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), m;
  }) : r.pos == r.start() || r.pos == r.end();
}
let Hx = null, Ux = null, Vx = !1;
function xH(t, e, n) {
  return Hx == e && Ux == n ? Vx : (Hx = e, Ux = n, Vx = n == "up" || n == "down" ? _H(t, e, n) : SH(t, e, n));
}
const Qr = 0, Wx = 1, fa = 2, ss = 3;
class Pf {
  constructor(e, n, r, i) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Qr, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = n > On(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && n == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!n || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], a = s + o.size;
      if (a > e || o instanceof IN) {
        i = e - s;
        break;
      }
      s = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof DN && s.side >= 0; r--)
      ;
    if (n <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && n && o && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : { node: this.contentDOM, offset: s ? On(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, n) : { node: this.contentDOM, offset: s ? On(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, a = 0; ; a++) {
      let l = this.children[a], c = o + l.size;
      if (i == -1 && e <= c) {
        let u = o + l.border;
        if (e >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, u);
        e = o;
        for (let d = a; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = On(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > n || a == this.children.length - 1)) {
        n = c;
        for (let u = a + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            s = On(d.dom);
            break;
          }
          n += d.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, i = !1) {
    let s = Math.min(e, n), o = Math.max(e, n);
    for (let f = 0, h = 0; f < this.children.length; f++) {
      let p = this.children[f], g = h + p.size;
      if (s > h && o < g)
        return p.setSelection(e - h - p.border, n - h - p.border, r, i);
      h = g;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c = r.getSelection(), u = !1;
    if ((Mi || Qn) && e == n) {
      let { node: f, offset: h } = a;
      if (f.nodeType == 3) {
        if (u = !!(h && f.nodeValue[h - 1] == `
`), u && h == f.nodeValue.length)
          for (let p = f, g; p; p = p.parentNode) {
            if (g = p.nextSibling) {
              g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: On(g) + 1 });
              break;
            }
            let m = p.pmViewDesc;
            if (m && m.node && m.node.isBlock)
              break;
          }
      } else {
        let p = f.childNodes[h - 1];
        u = p && (p.nodeName == "BR" || p.contentEditable == "false");
      }
    }
    if (Mi && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
      let f = c.focusNode.childNodes[c.focusOffset];
      f && f.contentEditable == "false" && (i = !0);
    }
    if (!(i || u && Qn) && Ha(a.node, a.offset, c.anchorNode, c.anchorOffset) && Ha(l.node, l.offset, c.focusNode, c.focusOffset))
      return;
    let d = !1;
    if ((c.extend || e == n) && !u) {
      c.collapse(a.node, a.offset);
      try {
        e != n && c.extend(l.node, l.offset), d = !0;
      } catch {
      }
    }
    if (!d) {
      if (e > n) {
        let h = a;
        a = l, l = h;
      }
      let f = document.createRange();
      f.setEnd(l.node, l.offset), f.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(f);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && n >= r : e < o && n > r) {
        let a = r + s.border, l = o - s.border;
        if (e >= a && n <= l) {
          this.dirty = e == r || n == o ? fa : Wx, e == a && n == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = ss : s.markDirty(e - a, n - a);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? fa : ss;
      }
      r = o;
    }
    this.dirty = fa;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? fa : Wx;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class DN extends Pf {
  constructor(e, n, r, i) {
    let s, o = n.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !n.type.spec.raw) {
      if (o.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(o), o = a;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = n, this.widget = n, s = this;
  }
  matchesWidget(e) {
    return this.dirty == Qr && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class kH extends Pf {
  constructor(e, n, r, i) {
    super(e, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Ua extends Pf {
  constructor(e, n, r, i, s) {
    super(e, [], r, i), this.mark = n, this.spec = s;
  }
  static create(e, n, r, i) {
    let s = i.nodeViews[n.type.name], o = s && s(n, i, r);
    return (!o || !o.dom) && (o = dl.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new Ua(e, n, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & ss || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != ss && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != Qr) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Qr;
    }
  }
  slice(e, n, r) {
    let i = Ua.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    n < o && (s = Ty(s, n, o, r)), e > 0 && (s = Ty(s, 0, e, r));
    for (let a = 0; a < s.length; a++)
      s[a].parent = i;
    return i.children = s, i;
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class xo extends Pf {
  constructor(e, n, r, i, s, o, a, l, c) {
    super(e, [], s, o), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, i, s, o) {
    let a = s.nodeViews[n.type.name], l, c = a && a(n, s, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), u = c && c.dom, d = c && c.contentDOM;
    if (n.isText) {
      if (!u)
        u = document.createTextNode(n.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      u || ({ dom: u, contentDOM: d } = dl.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = $N(u, r, n), c ? l = new CH(e, n, r, i, u, d || null, f, c, s, o + 1) : n.isText ? new Sv(e, n, r, i, u, f, s) : new xo(e, n, r, i, u, d || null, f, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => pe.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == Qr && e.eq(this.node) && pg(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, i = n, s = e.composing ? this.localCompositionInfo(e, n) : null, o = s && s.pos > -1 ? s : null, a = s && s.pos < 0, l = new OH(this, o && o.node, e);
    NH(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Ft.none : this.node.child(u).marks, r, e), l.placeWidget(c, e, i);
    }, (c, u, d, f) => {
      l.syncToMarks(c.marks, r, e);
      let h;
      l.findNodeMatch(c, u, d, f) || a && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (h = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(c, u, d, h, e) || l.updateNextNode(c, u, d, e, f, i) || l.addNode(c, u, d, e, i), i += c.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == fa) && (o && this.protectLocalComposition(e, o), PN(this.contentDOM, this.children, e), wc && RH(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof Te) || r < n || i > n + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, a = DH(this.node.content, o, r - n, i - n);
      return a < 0 ? null : { node: s, pos: a, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let s = n;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new kH(this, s, n, i);
    e.input.compositionNodes.push(o), this.children = Ty(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, i) {
    return this.dirty == ss || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0);
  }
  updateInner(e, n, r, i) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Qr;
  }
  updateOuterDeco(e) {
    if (pg(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = LN(this.dom, this.nodeDOM, Cy(this.outerDeco, this.node, n), Cy(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Gx(t, e, n, r, i) {
  $N(r, e, t);
  let s = new xo(void 0, t, e, n, r, r, r, i, 0);
  return s.contentDOM && s.updateChildren(i, 0), s;
}
class Sv extends xo {
  constructor(e, n, r, i, s, o, a) {
    super(e, n, r, i, s, null, o, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, i) {
    return this.dirty == ss || this.dirty != Qr && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Qr || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Qr, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let i = this.node.cut(e, n), s = document.createTextNode(i.text);
    return new Sv(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = ss);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class IN extends Pf {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Qr && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CH extends xo {
  constructor(e, n, r, i, s, o, a, l, c, u) {
    super(e, n, r, i, s, o, a, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, i) {
    if (this.dirty == ss)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, n, r);
      return s && this.updateInner(e, n, r, i), s;
    } else
      return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r) : super.setSelection(e, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function PN(t, e, n) {
  let r = t.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], a = o.dom;
    if (a.parentNode == t) {
      for (; a != r; )
        r = jx(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, t.insertBefore(a, r);
    if (o instanceof Ua) {
      let l = r ? r.previousSibling : t.lastChild;
      PN(o.contentDOM, o.children, n), r = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = jx(r), i = !0;
  i && n.trackWrites == t && (n.trackWrites = null);
}
const Zu = function(t) {
  t && (this.nodeName = t);
};
Zu.prototype = /* @__PURE__ */ Object.create(null);
const ha = [new Zu()];
function Cy(t, e, n) {
  if (t.length == 0)
    return ha;
  let r = n ? ha[0] : new Zu(), i = [r];
  for (let s = 0; s < t.length; s++) {
    let o = t[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new Zu(o.nodeName));
      for (let a in o) {
        let l = o[a];
        l != null && (n && i.length == 1 && i.push(r = new Zu(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return i;
}
function LN(t, e, n, r) {
  if (n == ha && r == ha)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], a = n[s];
    if (s) {
      let l;
      a && a.nodeName == o.nodeName && i != t && (l = i.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(i), a = ha[0]), i = l;
    }
    TH(i, a || ha[0], o);
  }
  return i;
}
function TH(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && t.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && t.classList.add(i[s]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        t.style.removeProperty(i[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function $N(t, e, n) {
  return LN(t, t, ha, Cy(e, n, t.nodeType != 1));
}
function pg(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function jx(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class OH {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = MH(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = Qr, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = Ua.create(this.top, e[s], n, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, n, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
          s = a;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, n, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == ss && o.dom == o.contentDOM && (o.dirty = fa), o.update(e, n, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, i, s, o) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof xo) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != s)
          return !1;
        let u = l.dom, d, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != ss && pg(n, l.outerDeco));
        if (!f && l.update(e, n, r, i))
          return this.destroyBetween(this.index, a), l.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (d = this.recreateWrapper(l, e, n, r, i, o)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = fa, d.updateChildren(i, o + 1), d.dirty = Qr), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, i, s, o) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !pg(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let a = xo.create(this.top, n, r, i, s, o);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, i, s) {
    let o = xo.create(this.top, e, n, r, i, s);
    o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new DN(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Ua; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof Sv) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Qn || Pn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new IN(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function MH(t, e) {
  let n = e, r = n.children.length, i = t.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e:
    for (; i > 0; ) {
      let a;
      for (; ; )
        if (r) {
          let c = n.children[r - 1];
          if (c instanceof Ua)
            n = c, r = c.children.length;
          else {
            a = c, r--;
            break;
          }
        } else {
          if (n == e)
            break e;
          r = n.parent.children.indexOf(n), n = n.parent;
        }
      let l = a.node;
      if (l) {
        if (l != t.child(i - 1))
          break;
        --i, s.set(a, i), o.push(a);
      }
    }
  return { index: i, matched: s, matches: o.reverse() };
}
function AH(t, e) {
  return t.type.side - e.type.side;
}
function NH(t, e, n, r) {
  let i = e.locals(t), s = 0;
  if (i.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let u = t.child(c);
      r(u, i, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; o < i.length && i[o].to == s; ) {
      let m = i[o++];
      m.widget && (u ? (d || (d = [u])).push(m) : u = m);
    }
    if (u)
      if (d) {
        d.sort(AH);
        for (let m = 0; m < d.length; m++)
          n(d[m], c, !!l);
      } else
        n(u, c, !!l);
    let f, h;
    if (l)
      h = -1, f = l, l = null;
    else if (c < t.childCount)
      h = c, f = t.child(c++);
    else
      break;
    for (let m = 0; m < a.length; m++)
      a[m].to <= s && a.splice(m--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      a.push(i[o++]);
    let p = s + f.nodeSize;
    if (f.isText) {
      let m = p;
      o < i.length && i[o].from < m && (m = i[o].from);
      for (let v = 0; v < a.length; v++)
        a[v].to < m && (m = a[v].to);
      m < p && (l = f.cut(m - s), f = f.cut(0, m - s), p = m, h = -1);
    } else
      for (; o < i.length && i[o].to < p; )
        o++;
    let g = f.isInline && !f.isLeaf ? a.filter((m) => !m.inline) : a.slice();
    r(f, g, e.forChild(s, f), h), s = p;
  }
}
function RH(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function DH(t, e, n, r) {
  for (let i = 0, s = 0; i < t.childCount && s <= r; ) {
    let o = t.child(i++), a = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; i < t.childCount; ) {
      let c = t.child(i++);
      if (s += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (s >= n) {
      if (s >= r && l.slice(r - e.length - a, r - a) == e)
        return r - e.length;
      let c = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= n)
        return a + c;
      if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Ty(t, e, n, r, i) {
  let s = [];
  for (let o = 0, a = 0; o < t.length; o++) {
    let l = t[o], c = a, u = a += l.size;
    c >= n || u <= e ? s.push(l) : (c < e && s.push(l.slice(0, e - c, r)), i && (s.push(i), i = void 0), u > n && s.push(l.slice(n - c, l.size, r)));
  }
  return s;
}
function o_(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let i = t.docView.nearestDesc(n.focusNode), s = i && i.size == 0, o = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (o < 0)
    return null;
  let a = r.resolve(o), l, c;
  if (Ev(n)) {
    for (l = o; i && !i.node; )
      i = i.parent;
    let d = i.node;
    if (i && d.isAtom && ve.isSelectable(d) && i.parent && !(d.isInline && sH(n.focusNode, n.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new ve(o == f ? a : r.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let d = o, f = o;
      for (let h = 0; h < n.rangeCount; h++) {
        let p = n.getRangeAt(h);
        d = Math.min(d, t.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, o] = f == t.state.selection.anchor ? [f, d] : [d, f], a = r.resolve(o);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let u = r.resolve(l);
  if (!c) {
    let d = e == "pointer" || t.state.selection.head < a.pos && !s ? 1 : -1;
    c = a_(t, u, a, d);
  }
  return c;
}
function BN(t) {
  return t.editable ? t.hasFocus() : zN(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Ls(t, e = !1) {
  let n = t.state.selection;
  if (FN(t, n), !!BN(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Pn) {
      let r = t.domSelectionRange(), i = t.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Ha(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      PH(t);
    else {
      let { anchor: r, head: i } = n, s, o;
      qx && !(n instanceof Te) && (n.$from.parent.inlineContent || (s = Kx(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (o = Kx(t, n.to))), t.docView.setSelection(r, i, t.root, e), qx && (s && Yx(s), o && Yx(o)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && IH(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const qx = Qn || Pn && CN < 63;
function Kx(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, s = r ? n.childNodes[r - 1] : null;
  if (Qn && i && i.contentEditable == "false")
    return j0(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return j0(i);
    if (s)
      return j0(s);
  }
}
function j0(t) {
  return t.contentEditable = "true", Qn && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function Yx(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function IH(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!BN(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function PH(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let r = t.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setStart(r.parentNode, On(r) + 1) : n.setStart(r, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && dr && So <= 11 && (r.disabled = !0, r.disabled = !1);
}
function FN(t, e) {
  if (e instanceof ve) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (Xx(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    Xx(t);
}
function Xx(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function a_(t, e, n, r) {
  return t.someProp("createSelectionBetween", (i) => i(t, e, n)) || Te.between(e, n, r);
}
function Jx(t) {
  return t.editable && !t.hasFocus() ? !1 : zN(t);
}
function zN(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function LH(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return Ha(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Oy(t, e) {
  let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), s = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && $e.findFrom(s, e);
}
function so(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Zx(t, e, n) {
  let r = t.state.selection;
  if (r instanceof Te)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = t.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return so(t, new Te(r.$anchor, o));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = Oy(t.state, e);
        return i && i instanceof ve ? so(t, i) : !1;
      } else if (!(jr && n.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let a = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = t.docView.descAt(a)) && !o.contentDOM ? ve.isSelectable(s) ? so(t, new ve(e < 0 ? t.state.doc.resolve(i.pos - s.nodeSize) : i)) : If ? so(t, new Te(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
      }
    } else
      return !1;
  else {
    if (r instanceof ve && r.node.isInline)
      return so(t, new Te(e > 0 ? r.$to : r.$from));
    {
      let i = Oy(t.state, e);
      return i ? so(t, i) : !1;
    }
  }
}
function gg(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Qu(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function _l(t, e) {
  return e < 0 ? $H(t) : BH(t);
}
function $H(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i, s, o = !1;
  for (Mi && n.nodeType == 1 && r < gg(n) && Qu(n.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (Qu(a, -1))
          i = n, s = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (HN(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && Qu(a, -1); )
          i = n.parentNode, s = On(a), a = a.previousSibling;
        if (a)
          n = a, r = gg(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  o ? My(t, n, r) : i && My(t, i, s);
}
function BH(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i = gg(n), s, o;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (Qu(a, 1))
        s = n, o = ++r;
      else
        break;
    } else {
      if (HN(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && Qu(a, 1); )
          s = a.parentNode, o = On(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = gg(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && My(t, s, o);
}
function HN(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function FH(t, e) {
  for (; t && e == t.childNodes.length && !Df(t); )
    e = On(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function zH(t, e) {
  for (; t && !e && !Df(t); )
    e = On(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function My(t, e, n) {
  if (e.nodeType != 3) {
    let s, o;
    (o = FH(e, n)) ? (e = o, n = 0) : (s = zH(e, n)) && (e = s, n = s.nodeValue.length);
  }
  let r = t.domSelection();
  if (!r)
    return;
  if (Ev(r)) {
    let s = document.createRange();
    s.setEnd(e, n), s.setStart(e, n), r.removeAllRanges(), r.addRange(s);
  } else
    r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: i } = t;
  setTimeout(() => {
    t.state == i && Ls(t);
  }, 50);
}
function Qx(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(Pn || lH) && n.parent.inlineContent) {
    let i = t.coordsAtPos(e);
    if (e > n.start()) {
      let s = t.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let s = t.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function ek(t, e, n) {
  let r = t.state.selection;
  if (r instanceof Te && !r.empty || n.indexOf("s") > -1 || jr && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Oy(t.state, e);
    if (o && o instanceof ve)
      return so(t, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, a = r instanceof ur ? $e.near(o, e) : $e.findFrom(o, e);
    return a ? so(t, a) : !1;
  }
  return !1;
}
function tk(t, e) {
  if (!(t.state.selection instanceof Te))
    return !0;
  let { $head: n, $anchor: r, empty: i } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (s && !s.isText) {
    let o = t.state.tr;
    return e < 0 ? o.delete(n.pos - s.nodeSize, n.pos) : o.delete(n.pos, n.pos + s.nodeSize), t.dispatch(o), !0;
  }
  return !1;
}
function nk(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function HH(t) {
  if (!Qn || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    nk(t, r, "true"), setTimeout(() => nk(t, r, "false"), 20);
  }
  return !1;
}
function UH(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function VH(t, e) {
  let n = e.keyCode, r = UH(e);
  if (n == 8 || jr && n == 72 && r == "c")
    return tk(t, -1) || _l(t, -1);
  if (n == 46 && !e.shiftKey || jr && n == 68 && r == "c")
    return tk(t, 1) || _l(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || jr && n == 66 && r == "c") {
    let i = n == 37 ? Qx(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Zx(t, i, r) || _l(t, i);
  } else if (n == 39 || jr && n == 70 && r == "c") {
    let i = n == 39 ? Qx(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Zx(t, i, r) || _l(t, i);
  } else {
    if (n == 38 || jr && n == 80 && r == "c")
      return ek(t, -1, r) || _l(t, -1);
    if (n == 40 || jr && n == 78 && r == "c")
      return HH(t) || ek(t, 1, r) || _l(t, 1);
    if (r == (jr ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function l_(t, e) {
  t.someProp("transformCopied", (h) => {
    e = h(e, t);
  });
  let n = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let h = r.firstChild;
    n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), r = h.content;
  }
  let o = t.someProp("clipboardSerializer") || dl.fromSchema(t.state.schema), a = qN(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(r, { document: a }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = jN[c.nodeName.toLowerCase()]); ) {
    for (let h = u.length - 1; h >= 0; h--) {
      let p = a.createElement(u[h]);
      for (; l.firstChild; )
        p.appendChild(l.firstChild);
      l.appendChild(p), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (h) => h(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function UN(t, e, n, r, i) {
  let s = i.parent.type.spec.code, o, a;
  if (!n && !e)
    return null;
  let l = e && (r || s || !n);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, s || r, t);
    }), s)
      return e ? new De(pe.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : De.empty;
    let d = t.someProp("clipboardTextParser", (f) => f(e, i, r, t));
    if (d)
      a = d;
    else {
      let f = i.marks(), { schema: h } = t.state, p = dl.fromSchema(h);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let m = o.appendChild(document.createElement("p"));
        g && m.appendChild(p.serializeNode(h.text(g, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), o = qH(n), If && KH(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || Xu.fromSchema(t.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !WH.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    a = YH(rk(a, +u[1], +u[2]), u[4]);
  else if (a = De.maxOpen(GH(a.content, i), !0), a.openStart || a.openEnd) {
    let d = 0, f = 0;
    for (let h = a.content.firstChild; d < a.openStart && !h.type.spec.isolating; d++, h = h.firstChild)
      ;
    for (let h = a.content.lastChild; f < a.openEnd && !h.type.spec.isolating; f++, h = h.lastChild)
      ;
    a = rk(a, d, f);
  }
  return t.someProp("transformPasted", (d) => {
    a = d(a, t);
  }), a;
}
const WH = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function GH(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)), s, o = [];
    if (t.forEach((a) => {
      if (!o)
        return;
      let l = i.findWrapping(a.type), c;
      if (!l)
        return o = null;
      if (c = o.length && s.length && WN(l, s, a, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = GN(o[o.length - 1], s.length));
        let u = VN(a, l);
        o.push(u), i = i.matchType(u.type), s = l;
      }
    }), o)
      return pe.from(o);
  }
  return t;
}
function VN(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, pe.from(t));
  return t;
}
function WN(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let s = WN(t, e, n, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(pe.from(VN(n, t, i + 1))));
  }
}
function GN(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, GN(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(pe.empty, !0);
  return t.copy(n.append(r));
}
function Ay(t, e, n, r, i, s) {
  let o = e < 0 ? t.firstChild : t.lastChild, a = o.content;
  return t.childCount > 1 && (s = 0), i < r - 1 && (a = Ay(a, e, n, r, i + 1, s)), i >= n && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, s <= i).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(pe.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, o.copy(a));
}
function rk(t, e, n) {
  return e < t.openStart && (t = new De(Ay(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new De(Ay(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const jN = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let ik = null;
function qN() {
  return ik || (ik = document.implementation.createHTMLDocument("title"));
}
let q0 = null;
function jH(t) {
  let e = window.trustedTypes;
  return e ? (q0 || (q0 = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), q0.createHTML(t)) : t;
}
function qH(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = qN().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
  if ((i = r && jN[r[1].toLowerCase()]) && (t = i.map((s) => "<" + s + ">").join("") + t + i.map((s) => "</" + s + ">").reverse().join("")), n.innerHTML = jH(t), i)
    for (let s = 0; s < i.length; s++)
      n = n.querySelector(i[s]) || n;
  return n;
}
function KH(t) {
  let e = t.querySelectorAll(Pn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function YH(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: i, openStart: s, openEnd: o } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = pe.from(l.create(r[a + 1], i)), s++, o++;
  }
  return new De(i, s, o);
}
const er = {}, tr = {}, XH = { touchstart: !0, touchmove: !0 };
class JH {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function ZH(t) {
  for (let e in er) {
    let n = er[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      eU(t, r) && !c_(t, r) && (t.editable || !(r.type in tr)) && n(t, r);
    }, XH[e] ? { passive: !0 } : void 0);
  }
  Qn && t.dom.addEventListener("input", () => null), Ny(t);
}
function po(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function QH(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Ny(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => c_(t, r));
  });
}
function c_(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function eU(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function tU(t, e) {
  !c_(t, e) && er[e.type] && (t.editable || !(e.type in tr)) && er[e.type](t, e);
}
tr.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !YN(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(yi && Pn && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), wc && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (i) => i(t, na(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else
      t.someProp("handleKeyDown", (r) => r(t, n)) || VH(t, n) ? n.preventDefault() : po(t, "key");
};
tr.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
tr.keypress = (t, e) => {
  let n = e;
  if (YN(t, n) || !n.charCode || n.ctrlKey && !n.altKey || jr && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (i) => i(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof Te) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(i) && !t.someProp("handleTextInput", (s) => s(t, r.$from.pos, r.$to.pos, i)) && t.dispatch(t.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
  }
};
function xv(t) {
  return { left: t.clientX, top: t.clientY };
}
function nU(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function u_(t, e, n, r, i) {
  if (r == -1)
    return !1;
  let s = t.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (t.someProp(e, (a) => o > s.depth ? a(t, n, s.nodeAfter, s.before(o), i, !0) : a(t, n, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function oc(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let r = t.state.tr.setSelection(e);
  n == "pointer" && r.setMeta("pointer", !0), t.dispatch(r);
}
function rU(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && ve.isSelectable(r) ? (oc(t, new ve(n), "pointer"), !0) : !1;
}
function iU(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, i;
  n instanceof ve && (r = n.node);
  let s = t.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o);
    if (ve.isSelectable(a)) {
      r && n.$from.depth > 0 && o >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? i = s.before(n.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (oc(t, ve.create(t.state.doc, i), "pointer"), !0) : !1;
}
function sU(t, e, n, r, i) {
  return u_(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (s) => s(t, e, r)) || (i ? iU(t, n) : rU(t, n));
}
function oU(t, e, n, r) {
  return u_(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (i) => i(t, e, r));
}
function aU(t, e, n, r) {
  return u_(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (i) => i(t, e, r)) || lU(t, n, r);
}
function lU(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (oc(t, Te.create(r, 0, r.content.size), "pointer"), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), a = i.before(s);
    if (o.inlineContent)
      oc(t, Te.create(r, a + 1, a + 1 + o.content.size), "pointer");
    else if (ve.isSelectable(o))
      oc(t, ve.create(r, a), "pointer");
    else
      continue;
    return !0;
  }
}
function d_(t) {
  return mg(t);
}
const KN = jr ? "metaKey" : "ctrlKey";
er.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = d_(t), i = Date.now(), s = "singleClick";
  i - t.input.lastClick.time < 500 && nU(n, t.input.lastClick) && !n[KN] && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: s };
  let o = t.posAtCoords(xv(n));
  o && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new cU(t, o, n, !!r)) : (s == "doubleClick" ? oU : aU)(t, o.pos, o.inside, n) ? n.preventDefault() : po(t, "pointer"));
};
let cU = class {
  constructor(e, n, r, i) {
    this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[KN], this.allowDefault = r.shiftKey;
    let s, o;
    if (n.inside > -1)
      s = e.state.doc.nodeAt(n.inside), o = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const a = i ? null : r.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof ve && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Mi && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), po(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Ls(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(xv(e))), this.updateAllowDefault(e), this.allowDefault || !n ? po(this.view, "pointer") : sU(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Qn && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Pn && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (oc(this.view, $e.near(this.view.state.doc.resolve(n.pos)), "pointer"), e.preventDefault()) : po(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), po(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
};
er.touchstart = (t) => {
  t.input.lastTouch = Date.now(), d_(t), po(t, "pointer");
};
er.touchmove = (t) => {
  t.input.lastTouch = Date.now(), po(t, "pointer");
};
er.contextmenu = (t) => d_(t);
function YN(t, e) {
  return t.composing ? !0 : Qn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const uU = yi ? 5e3 : -1;
tr.compositionstart = tr.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof Te && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), mg(t, !0), t.markCursor = null;
    else if (mg(t, !e.selection.empty), Mi && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    t.input.composing = !0;
  }
  XN(t, uU);
};
tr.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, XN(t, 20));
};
function XN(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => mg(t), e));
}
function JN(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = fU()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function dU(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = rH(e.focusNode, e.focusOffset), r = iH(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, s = t.domObserver.lastChangedTextNode;
    if (n == s || r == s)
      return s;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (t.input.compositionNode == r) {
      let o = n.pmViewDesc;
      if (!(!o || !o.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function fU() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function mg(t, e = !1) {
  if (!(yi && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), JN(t), e || t.docView && t.docView.dirty) {
      let n = o_(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !t.state.selection.empty ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function hU(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const Md = dr && So < 15 || wc && cH < 604;
er.copy = tr.cut = (t, e) => {
  let n = e, r = t.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let s = Md ? null : n.clipboardData, o = r.content(), { dom: a, text: l } = l_(t, o);
  s ? (n.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : hU(t, a), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function pU(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function gU(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? Ad(t, r.value, null, i, e) : Ad(t, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function Ad(t, e, n, r, i) {
  let s = UN(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, i, s || De.empty)))
    return !0;
  if (!s)
    return !1;
  let o = pU(s), a = o ? t.state.tr.replaceSelectionWith(o, r) : t.state.tr.replaceSelection(s);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function ZN(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
tr.paste = (t, e) => {
  let n = e;
  if (t.composing && !yi)
    return;
  let r = Md ? null : n.clipboardData, i = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && Ad(t, ZN(r), r.getData("text/html"), i, n) ? n.preventDefault() : gU(t, n);
};
let QN = class {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
};
const eR = jr ? "altKey" : "ctrlKey";
er.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = t.state.selection, s = i.empty ? null : t.posAtCoords(xv(n)), o;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof ve ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = ve.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (o = ve.create(t.state.doc, d.posBefore));
    }
  }
  let a = (o || t.state.selection).content(), { dom: l, text: c, slice: u } = l_(t, a);
  (!n.dataTransfer.files.length || !Pn || CN > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Md ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Md || n.dataTransfer.setData("text/plain", c), t.dragging = new QN(u, !n[eR], o);
};
er.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
tr.dragover = tr.dragenter = (t, e) => e.preventDefault();
tr.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let i = t.posAtCoords(xv(n));
  if (!i)
    return;
  let s = t.state.doc.resolve(i.pos), o = r && r.slice;
  o ? t.someProp("transformPasted", (p) => {
    o = p(o, t);
  }) : o = UN(t, ZN(n.dataTransfer), Md ? null : n.dataTransfer.getData("text/html"), !1, s);
  let a = !!(r && !n[eR]);
  if (t.someProp("handleDrop", (p) => p(t, n, o || De.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!o)
    return;
  n.preventDefault();
  let l = o ? vN(t.state.doc, s.pos, o) : s.pos;
  l == null && (l = s.pos);
  let c = t.state.tr;
  if (a) {
    let { node: p } = r;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (d ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let h = c.doc.resolve(u);
  if (d && ve.isSelectable(o.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ve(h));
  else {
    let p = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((g, m, v, y) => p = y), c.setSelection(a_(t, h, c.doc.resolve(p)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
er.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Ls(t);
  }, 20));
};
er.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
er.beforeinput = (t, e) => {
  if (Pn && yi && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (s) => s(t, na(8, "Backspace")))))
        return;
      let { $cursor: i } = t.state.selection;
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in tr)
  er[t] = tr[t];
function Nd(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
let sk = class tR {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || ka, this.side = this.spec.side || 0;
  }
  map(e, n, r, i) {
    let { pos: s, deleted: o } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new xn(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof tR && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Nd(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}, ed = class Ry {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ka;
  }
  map(e, n, r, i) {
    let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new xn(s, o, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Ry && Nd(this.attrs, e.attrs) && Nd(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Ry;
  }
  destroy() {
  }
}, mU = class nR {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ka;
  }
  map(e, n, r, i) {
    let s = e.mapResult(n.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(n.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new xn(s.pos - r, o.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from), s;
    return i == n.from && !(s = e.child(r)).isText && i + s.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof nR && Nd(this.attrs, e.attrs) && Nd(this.spec, e.spec);
  }
  destroy() {
  }
}, xn = class Du {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new Du(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new Du(e, e, new sk(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, i) {
    return new Du(e, n, new ed(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, i) {
    return new Du(e, n, new mU(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof ed;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof sk;
  }
};
const Il = [], ka = {};
let Ht = class io {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : Il, this.children = n.length ? n : Il;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? vg(n, e, 0, ka) : Dn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let i = [];
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(e, n, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= n && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < n && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, n - a, r, i + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == Dn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || ka);
  }
  /**
  @internal
  */
  mapInner(e, n, r, i, s) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, i);
      l && l.type.valid(n, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? vU(this.children, o || [], e, n, r, i, s) : o ? new io(o.sort(Ca), Il) : Dn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Dn ? io.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let i, s = 0;
    e.forEach((a, l) => {
      let c = l + r, u;
      if (u = sR(n, a, c)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < l; )
          s += 3;
        i[s] == l ? i[s + 2] = i[s + 2].addInner(a, u, c + 1) : i.splice(s, 0, l, l + a.nodeSize, vg(u, a, c + 1, ka)), s += 3;
      }
    });
    let o = iR(s ? oR(n) : n, -r);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new io(o.length ? this.local.concat(o).sort(Ca) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Dn ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, a = r[s] + n, l = r[s + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (o || (o = [])).push(d));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[s + 2].removeInner(o, a + 1);
      c != Dn ? r[s + 2] = c : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let a = 0; a < i.length; a++)
            i[a].eq(o, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new io(i, r) : Dn;
  }
  forChild(e, n) {
    if (this == Dn)
      return this;
    if (n.isLeaf)
      return io.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let s = e + 1, o = s + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > s && l.type instanceof ed) {
        let c = Math.max(s, l.from) - s, u = Math.min(o, l.to) - s;
        c < u && (i || (i = [])).push(l.copy(c, u));
      }
    }
    if (i) {
      let a = new io(i.sort(Ca), Il);
      return r ? new rR([a, r]) : a;
    }
    return r || Dn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof io) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return f_(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Dn)
      return Il;
    if (e.inlineContent || !this.local.some(ed.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof ed || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
};
Ht.empty = new Ht([], []);
Ht.removeOverlap = f_;
const Dn = Ht.empty;
let rR = class Pl {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, ka));
    return Pl.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Ht.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, n);
      s != Dn && (s instanceof Pl ? r = r.concat(s.members) : r.push(s));
    }
    return Pl.from(r);
  }
  eq(e) {
    if (!(e instanceof Pl) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!n)
          n = s;
        else {
          r && (n = n.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            n.push(s[o]);
        }
    }
    return n ? f_(r ? n : n.sort(Ca)) : Il;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Dn;
      case 1:
        return e[0];
      default:
        return new Pl(e.every((n) => n instanceof Ht) ? e : e.reduce((n, r) => n.concat(r instanceof Ht ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
};
function vU(t, e, n, r, i, s, o) {
  let a = t.slice();
  for (let c = 0, u = s; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((f, h, p, g) => {
      let m = g - p - (h - f);
      for (let v = 0; v < a.length; v += 3) {
        let y = a[v + 1];
        if (y < 0 || f > y + u - d)
          continue;
        let E = a[v] + u - d;
        h >= E ? a[v + 1] = f <= E ? -2 : -1 : f >= u && m && (a[v] += m, a[v + 1] += m);
      }
      d += m;
    }), u = n.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let u = n.map(t[c] + s), d = u - i;
      if (d < 0 || d >= r.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[c + 1] + s, -1), h = f - i, { index: p, offset: g } = r.content.findIndex(d), m = r.maybeChild(p);
      if (m && g == d && g + m.nodeSize == h) {
        let v = a[c + 2].mapInner(n, m, u + 1, t[c] + s + 1, o);
        v != Dn ? (a[c] = d, a[c + 1] = h, a[c + 2] = v) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = bU(a, t, e, n, i, s, o), u = vg(c, r, 0, o);
    e = u.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let h = u.children[d];
      for (; f < a.length && a[f] < h; )
        f += 3;
      a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new Ht(e.sort(Ca), a);
}
function iR(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    n.push(new xn(i.from + e, i.to + e, i.type));
  }
  return n;
}
function bU(t, e, n, r, i, s, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(r, i, c);
      d ? n.push(d) : o.onRemove && o.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1);
  return n;
}
function sR(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, i = null;
  for (let s = 0, o; s < t.length; s++)
    (o = t[s]) && o.from > n && o.to < r && ((i || (i = [])).push(o), t[s] = null);
  return i;
}
function oR(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function vg(t, e, n, r) {
  let i = [], s = !1;
  e.forEach((a, l) => {
    let c = sR(t, a, l + n);
    if (c) {
      s = !0;
      let u = vg(c, a, n + l + 1, r);
      u != Dn && i.push(l, l + a.nodeSize, u);
    }
  });
  let o = iR(s ? oR(t) : t, -n).sort(Ca);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || i.length ? new Ht(o, i) : Dn;
}
function Ca(t, e) {
  return t.from - e.from || t.to - e.to;
}
function f_(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == t && (e = t.slice()), e[i] = s.copy(s.from, r.to), ok(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, s.from), ok(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function ok(t, e, n) {
  for (; e < t.length && Ca(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function K0(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != Dn && e.push(r);
  }), t.cursorWrapper && e.push(Ht.create(t.state.doc, [t.cursorWrapper.deco])), rR.from(e);
}
const yU = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, wU = dr && So <= 11;
class _U {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class EU {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new _U(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      dr && So <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), wU && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, yU)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Jx(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Ls(this.view);
      if (dr && So <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Ha(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = Od(s))
      n.add(s);
    for (let s = e.anchorNode; s; s = Od(s))
      if (n.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Jx(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, a = !1, l = [];
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], l);
        d && (s = s < 0 ? d.from : Math.min(d.from, s), o = o < 0 ? d.to : Math.max(d.to, o), d.typeOver && (a = !0));
      }
    if (Mi && l.length) {
      let u = l.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, f] = u;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of u) {
          let h = f.parentNode;
          h && h.nodeName == "LI" && (!d || kU(e, d) != h) && f.remove();
        }
      }
    }
    let c = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Ev(r) && (c = o_(e)) && c.eq($e.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Ls(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), SU(e)), this.handleDOMChange(s, o, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Ls(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (dr && So <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (i = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f);
        }
      let o = i && i.parentNode == e.target ? On(i) + 1 : 0, a = r.localPosFromDOM(e.target, o, -1), l = s && s.parentNode == e.target ? On(s) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else
      return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
        from: r.posAtStart,
        to: r.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: e.target.nodeValue == e.oldValue
      });
  }
}
let ak = /* @__PURE__ */ new WeakMap(), lk = !1;
function SU(t) {
  if (!ak.has(t) && (ak.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = Mi, lk)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), lk = !0;
  }
}
function ck(t, e) {
  let n = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = t.domAtPos(t.state.selection.anchor);
  return Ha(o.node, o.offset, i, s) && ([n, r, i, s] = [i, s, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s };
}
function xU(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return ck(t, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? ck(t, n) : null;
}
function kU(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function CU(t, e, n) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, u = l.anchorNode;
  if (u && t.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], Ev(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), Pn && t.input.lastKeyCode === 8)
    for (let m = s; m > i; m--) {
      let v = r.childNodes[m - 1], y = v.pmViewDesc;
      if (v.nodeName == "BR" && !y) {
        s = m;
        break;
      }
      if (!y || y.size)
        break;
    }
  let d = t.state.doc, f = t.someProp("domParser") || Xu.fromSchema(t.state.schema), h = d.resolve(o), p = null, g = f.parse(r, {
    topNode: h.parent,
    topMatch: h.parent.contentMatchAt(h.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: TU,
    context: h
  });
  if (c && c[0].pos != null) {
    let m = c[0].pos, v = c[1] && c[1].pos;
    v == null && (v = m), p = { anchor: m + o, head: v + o };
  }
  return { doc: g, sel: p, from: o, to: a };
}
function TU(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (Qn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || Qn && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const OU = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function MU(t, e, n, r, i) {
  let s = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let k = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, T = o_(t, k);
    if (T && !t.state.selection.eq(T)) {
      if (Pn && yi && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (R) => R(t, na(13, "Enter"))))
        return;
      let I = t.state.tr.setSelection(T);
      k == "pointer" ? I.setMeta("pointer", !0) : k == "key" && I.scrollIntoView(), s && I.setMeta("composition", s), t.dispatch(I);
    }
    return;
  }
  let o = t.state.doc.resolve(e), a = o.sharedDepth(n);
  e = o.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let l = t.state.selection, c = CU(t, e, n), u = t.state.doc, d = u.slice(c.from, c.to), f, h;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, h = "end") : (f = t.state.selection.from, h = "start"), t.input.lastKeyCode = null;
  let p = RU(d.content, c.doc.content, c.from, f, h);
  if (p && t.input.domChangeCount++, (wc && t.input.lastIOSEnter > Date.now() - 225 || yi) && i.some((k) => k.nodeType == 1 && !OU.test(k.nodeName)) && (!p || p.endA >= p.endB) && t.someProp("handleKeyDown", (k) => k(t, na(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (r && l instanceof Te && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let k = uk(t, t.state.doc, c.sel);
        if (k && !k.eq(t.state.selection)) {
          let T = t.state.tr.setSelection(k);
          s && T.setMeta("composition", s), t.dispatch(T);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && p.start == p.endB && t.state.selection instanceof Te && (p.start > t.state.selection.from && p.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? p.start = t.state.selection.from : p.endA < t.state.selection.to && p.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (p.endB += t.state.selection.to - p.endA, p.endA = t.state.selection.to)), dr && So <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == "  " && (p.start--, p.endA--, p.endB--);
  let g = c.doc.resolveNoCache(p.start - c.from), m = c.doc.resolveNoCache(p.endB - c.from), v = u.resolve(p.start), y = g.sameParent(m) && g.parent.inlineContent && v.end() >= p.endA, E;
  if ((wc && t.input.lastIOSEnter > Date.now() - 225 && (!y || i.some((k) => k.nodeName == "DIV" || k.nodeName == "P")) || !y && g.pos < c.doc.content.size && !g.sameParent(m) && (E = $e.findFrom(c.doc.resolve(g.pos + 1), 1, !0)) && E.head == m.pos) && t.someProp("handleKeyDown", (k) => k(t, na(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > p.start && NU(u, p.start, p.endA, g, m) && t.someProp("handleKeyDown", (k) => k(t, na(8, "Backspace")))) {
    yi && Pn && t.domObserver.suppressSelectionUpdates();
    return;
  }
  Pn && yi && p.endB == p.start && (t.input.lastAndroidDelete = Date.now()), yi && !y && g.start() != m.start() && m.parentOffset == 0 && g.depth == m.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, m = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(k) {
      return k(t, na(13, "Enter"));
    });
  }, 20));
  let b = p.start, _ = p.endA, w, S, x;
  if (y) {
    if (g.pos == m.pos)
      dr && So <= 11 && g.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Ls(t), 20)), w = t.state.tr.delete(b, _), S = u.resolve(p.start).marksAcross(u.resolve(p.endA));
    else if (
      // Adding or removing a mark
      p.endA == p.endB && (x = AU(g.parent.content.cut(g.parentOffset, m.parentOffset), v.parent.content.cut(v.parentOffset, p.endA - v.start())))
    )
      w = t.state.tr, x.type == "add" ? w.addMark(b, _, x.mark) : w.removeMark(b, _, x.mark);
    else if (g.parent.child(g.index()).isText && g.index() == m.index() - (m.textOffset ? 0 : 1)) {
      let k = g.parent.textBetween(g.parentOffset, m.parentOffset);
      if (t.someProp("handleTextInput", (T) => T(t, b, _, k)))
        return;
      w = t.state.tr.insertText(k, b, _);
    }
  }
  if (w || (w = t.state.tr.replace(b, _, c.doc.slice(p.start - c.from, p.endB - c.from))), c.sel) {
    let k = uk(t, w.doc, c.sel);
    k && !(Pn && yi && t.composing && k.empty && (p.start != p.endB || t.input.lastAndroidDelete < Date.now() - 100) && (k.head == b || k.head == w.mapping.map(_) - 1) || dr && k.empty && k.head == b) && w.setSelection(k);
  }
  S && w.ensureMarks(S), s && w.setMeta("composition", s), t.dispatch(w.scrollIntoView());
}
function uk(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : a_(t, e.resolve(n.anchor), e.resolve(n.head));
}
function AU(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, i = n, s = r, o, a, l;
  for (let u = 0; u < r.length; u++)
    i = r[u].removeFromSet(i);
  for (let u = 0; u < n.length; u++)
    s = n[u].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    a = i[0], o = "add", l = (u) => u.mark(a.addToSet(u.marks));
  else if (i.length == 0 && s.length == 1)
    a = s[0], o = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if (pe.from(c).eq(t))
    return { mark: a, type: o };
}
function NU(t, e, n, r, i) {
  if (
    // The content must have shrunk
    n - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Y0(r, !0, !1) < i.pos
  )
    return !1;
  let s = t.resolve(e);
  if (!r.parent.isTextblock) {
    let a = s.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = t.resolve(Y0(s, !0, !0));
  return !o.parent.isTextblock || o.pos > n || Y0(o, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function Y0(t, e, n) {
  let r = t.depth, i = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, i++, e = !1;
  if (n) {
    let s = t.node(r).maybeChild(t.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function RU(t, e, n, r, i) {
  let s = t.findDiffStart(e, n);
  if (s == null)
    return null;
  let { a: o, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (i == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    r -= o + l - s;
  }
  if (o < s && t.size < e.size) {
    let l = r <= s && r >= o ? s - r : 0;
    s -= l, s && s < e.size && dk(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), a = s + (a - o), o = s;
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0;
    s -= l, s && s < t.size && dk(t.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), o = s + (o - a), a = s;
  }
  return { start: s, endA: o, endB: a };
}
function dk(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
const DU = l_;
class IU {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new JH(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(mk), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = pk(this), hk(this), this.nodeViews = gk(this), this.docView = Gx(this.state.doc, fk(this), K0(this), this.dom, this), this.domObserver = new EU(this, (r, i, s, o) => MU(this, r, i, s, o)), this.domObserver.start(), ZH(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Ny(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(mk), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let i = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (JN(this), o = !0), this.state = e;
    let a = i.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let h = gk(this);
      LU(h, this.nodeViews) && (this.nodeViews = h, s = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Ny(this), this.editable = pk(this), hk(this);
    let l = K0(this), c = fk(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", d = s || !this.docView.matchesNode(e.doc, c, l);
    (d || !e.selection.eq(i.selection)) && (o = !0);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && fH(this);
    if (o) {
      this.domObserver.stop();
      let h = d && (dr || Pn) && !this.composing && !i.selection.empty && !e.selection.empty && PU(i.selection, e.selection);
      if (d) {
        let p = Pn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = dU(this)), (s || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = Gx(e.doc, c, l, this.dom, this)), p && !this.trackWrites && (h = !0);
      }
      h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && LH(this)) ? Ls(this, h) : (FN(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && hH(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this)))
      if (this.state.selection instanceof ve) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && Fx(this, n.getBoundingClientRect(), e);
      } else
        Fx(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let s = r.from + (this.state.doc.content.size - n.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s);
    }
    this.dragging = new QN(e.slice, e.move, i < 0 ? void 0 : ve.create(this.state.doc, i));
  }
  someProp(e, n) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (dr) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && pH(this.dom), Ls(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return yH(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return NN(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let i = this.docView.posFromDOM(e, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return xH(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return Ad(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return Ad(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (QH(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], K0(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, tH());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return tU(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Qn && this.root.nodeType === 11 && oH(this.dom.ownerDocument) == this.dom && xU(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function fk(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), e.translate || (e.translate = "no"), [xn.node(0, t.state.doc.content.size, e)];
}
function hk(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: xn.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function pk(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function PU(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function gk(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function LU(t, e) {
  let n = 0, r = 0;
  for (let i in t) {
    if (t[i] != e[i])
      return !0;
    n++;
  }
  for (let i in e)
    r++;
  return n != r;
}
function mk(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Ao = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, bg = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, $U = typeof navigator < "u" && /Mac/.test(navigator.platform), BU = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Mn = 0; Mn < 10; Mn++)
  Ao[48 + Mn] = Ao[96 + Mn] = String(Mn);
for (var Mn = 1; Mn <= 24; Mn++)
  Ao[Mn + 111] = "F" + Mn;
for (var Mn = 65; Mn <= 90; Mn++)
  Ao[Mn] = String.fromCharCode(Mn + 32), bg[Mn] = String.fromCharCode(Mn);
for (var X0 in Ao)
  bg.hasOwnProperty(X0) || (bg[X0] = Ao[X0]);
function FU(t) {
  var e = $U && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || BU && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? bg : Ao)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const zU = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function HU(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, i, s, o;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      zU ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), o && (n = "Meta-" + n), s && (n = "Shift-" + n), n;
}
function UU(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[HU(n)] = t[n];
  return e;
}
function J0(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function VU(t) {
  return new ut({ props: { handleKeyDown: kv(t) } });
}
function kv(t) {
  let e = UU(t);
  return function(n, r) {
    let i = FU(r), s, o = e[J0(i, r)];
    if (o && o(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = e[J0(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (s = Ao[r.keyCode]) && s != i) {
        let a = e[J0(s, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const aR = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function lR(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const WU = (t, e, n) => {
  let r = lR(t, n);
  if (!r)
    return !1;
  let i = h_(r);
  if (!i) {
    let o = r.blockRange(), a = o && Qc(o);
    return a == null ? !1 : (e && e(t.tr.lift(o, a).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (fR(t, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (_c(s, "end") || ve.isSelectable(s)))
    for (let o = r.depth; ; o--) {
      let a = _v(t.doc, r.before(o), r.after(o), De.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(_c(s, "end") ? $e.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : ve.create(l.doc, i.pos - s.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || r.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, GU = (t, e, n) => {
  let r = lR(t, n);
  if (!r)
    return !1;
  let i = h_(r);
  return i ? cR(t, i, e) : !1;
}, jU = (t, e, n) => {
  let r = uR(t, n);
  if (!r)
    return !1;
  let i = p_(r);
  return i ? cR(t, i, e) : !1;
};
function cR(t, e, n) {
  let r = e.nodeBefore, i = r, s = e.pos - 1;
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let o = e.nodeAfter, a = o, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let u = a.firstChild;
    if (!u)
      return !1;
    a = u;
  }
  let c = _v(t.doc, s, l, De.empty);
  if (!c || c.from != s || c instanceof rs && c.slice.size >= l - s)
    return !1;
  if (n) {
    let u = t.tr.step(c);
    u.setSelection(Te.create(u.doc, s)), n(u.scrollIntoView());
  }
  return !0;
}
function _c(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const qU = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    s = h_(r);
  }
  let o = s && s.nodeBefore;
  return !o || !ve.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ve.create(t.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function h_(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function uR(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const KU = (t, e, n) => {
  let r = uR(t, n);
  if (!r)
    return !1;
  let i = p_(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (fR(t, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (_c(s, "start") || ve.isSelectable(s))) {
    let o = _v(t.doc, r.before(), r.after(), De.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = t.tr.step(o);
        a.setSelection(_c(s, "start") ? $e.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ve.create(a.doc, a.mapping.map(i.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, YU = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    s = p_(r);
  }
  let o = s && s.nodeAfter;
  return !o || !ve.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ve.create(t.doc, s.pos)).scrollIntoView()), !0);
};
function p_(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const XU = (t, e) => {
  let n = t.selection, r = n instanceof ve, i;
  if (r) {
    if (n.node.isTextblock || !Fo(t.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = wv(t.doc, n.from, -1), i == null)
    return !1;
  if (e) {
    let s = t.tr.join(i);
    r && s.setSelection(ve.create(s.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, JU = (t, e) => {
  let n = t.selection, r;
  if (n instanceof ve) {
    if (n.node.isTextblock || !Fo(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = wv(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, ZU = (t, e) => {
  let { $from: n, $to: r } = t.selection, i = n.blockRange(r), s = i && Qc(i);
  return s == null ? !1 : (e && e(t.tr.lift(i, s).scrollIntoView()), !0);
}, QU = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function dR(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const e4 = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), s = n.indexAfter(-1), o = dR(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, o.createAndFill());
    l.setSelection($e.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, t4 = (t, e) => {
  let n = t.selection, { $from: r, $to: i } = n;
  if (n instanceof ur || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = dR(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = t.tr.insert(o, s.createAndFill());
    a.setSelection(Te.create(a.doc, o + 1)), e(a.scrollIntoView());
  }
  return !0;
}, n4 = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let s = n.before();
    if (sc(t.doc, s))
      return e && e(t.tr.split(s).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && Qc(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
}, r4 = (t, e) => {
  let { $from: n, to: r } = t.selection, i, s = n.sharedDepth(r);
  return s == 0 ? !1 : (i = n.before(s), e && e(t.tr.setSelection(ve.create(t.doc, i))), !0);
};
function i4(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || Fo(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function fR(t, e, n, r) {
  let i = e.nodeBefore, s = e.nodeAfter, o, a, l = i.type.spec.isolating || s.type.spec.isolating;
  if (!l && i4(t, e, n))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (a = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && a.matchType(o[0] || s.type).validEnd) {
    if (n) {
      let h = e.pos + s.nodeSize, p = pe.empty;
      for (let v = o.length - 1; v >= 0; v--)
        p = pe.from(o[v].create(null, p));
      p = pe.from(i.copy(p));
      let g = t.tr.step(new Br(e.pos - 1, h, e.pos, h, new De(p, 1, 0), o.length, !0)), m = g.doc.resolve(h + 2 * o.length);
      m.nodeAfter && m.nodeAfter.type == i.type && Fo(g.doc, m.pos) && g.join(m.pos), n(g.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || r > 0 && l ? null : $e.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && Qc(d);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
  if (c && _c(s, "start", !0) && _c(i, "end")) {
    let h = i, p = [];
    for (; p.push(h), !h.isTextblock; )
      h = h.lastChild;
    let g = s, m = 1;
    for (; !g.isTextblock; g = g.firstChild)
      m++;
    if (h.canReplace(h.childCount, h.childCount, g.content)) {
      if (n) {
        let v = pe.empty;
        for (let E = p.length - 1; E >= 0; E--)
          v = pe.from(p[E].copy(v));
        let y = t.tr.step(new Br(e.pos - p.length, e.pos + s.nodeSize, e.pos + m, e.pos + s.nodeSize - m, new De(v, p.length, 0), 0, !0));
        n(y.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function hR(t) {
  return function(e, n) {
    let r = e.selection, i = t < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (n && n(e.tr.setSelection(Te.create(e.doc, t < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const s4 = hR(-1), o4 = hR(1);
function a4(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: s } = n.selection, o = i.blockRange(s), a = o && i_(o, t, e);
    return a ? (r && r(n.tr.wrap(o, a).scrollIntoView()), !0) : !1;
  };
}
function vk(t, e = null) {
  return function(n, r) {
    let i = !1;
    for (let s = 0; s < n.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: a } } = n.selection.ranges[s];
      n.doc.nodesBetween(o, a, (l, c) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            i = !0;
          else {
            let u = n.doc.resolve(c), d = u.index();
            i = u.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = n.tr;
      for (let o = 0; o < n.selection.ranges.length; o++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[o];
        s.setBlockType(a, l, t, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function l4(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: s } = n.selection, o = i.blockRange(s), a = !1, l = o;
    if (!o)
      return !1;
    if (o.depth >= 2 && i.node(o.depth - 1).type.compatibleContent(t) && o.startIndex == 0) {
      if (i.index(o.depth - 1) == 0)
        return !1;
      let u = n.doc.resolve(o.start - 2);
      l = new ug(u, u, o.depth), o.endIndex < o.parent.childCount && (o = new ug(i, n.doc.resolve(s.end(o.depth)), o.depth)), a = !0;
    }
    let c = i_(l, t, e, o);
    return c ? (r && r(c4(n.tr, o, c, a, t).scrollIntoView()), !0) : !1;
  };
}
function c4(t, e, n, r, i) {
  let s = pe.empty;
  for (let u = n.length - 1; u >= 0; u--)
    s = pe.from(n[u].type.create(n[u].attrs, s));
  t.step(new Br(e.start - (r ? 2 : 0), e.end, e.start, e.end, new De(s, 0, 0), n.length, !0));
  let o = 0;
  for (let u = 0; u < n.length; u++)
    n[u].type == i && (o = u + 1);
  let a = n.length - o, l = e.start + n.length - (r ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)
    !f && sc(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += c.child(u).nodeSize;
  return t;
}
function u4(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == t);
    return s ? n ? r.node(s.depth - 1).type == t ? d4(e, n, t, s) : f4(e, n, s) : !0 : !1;
  };
}
function d4(t, e, n, r) {
  let i = t.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Br(s - 1, o, s, o, new De(pe.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new ug(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const a = Qc(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let l = i.mapping.map(s, -1) - 1;
  return Fo(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0;
}
function f4(t, e, n) {
  let r = t.tr, i = n.parent;
  for (let h = n.end, p = n.endIndex - 1, g = n.startIndex; p > g; p--)
    h -= i.child(p).nodeSize, r.delete(h - 1, h + 1);
  let s = r.doc.resolve(n.start), o = s.nodeAfter;
  if (r.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == i.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, o.content.append(l ? pe.empty : pe.from(i))))
    return !1;
  let d = s.pos, f = d + o.nodeSize;
  return r.step(new Br(d - (a ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new De((a ? pe.empty : pe.from(i.copy(pe.empty))).append(l ? pe.empty : pe.from(i.copy(pe.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function h4(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let a = s.parent, l = a.child(o - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type, u = pe.from(c ? t.create() : null), d = new De(pe.from(t.create(null, pe.from(a.type.create(null, u)))), c ? 3 : 1, 0), f = s.start, h = s.end;
      n(e.tr.step(new Br(f - (c ? 3 : 1), h, f, h, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function Cv(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: i } = n, { storedMarks: s } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, s = n.storedMarks, n;
    }
  };
}
class Tv {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this, { view: i } = n, { tr: s } = r, o = this.buildProps(s);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...u) => {
      const d = l(...u)(o);
      return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), d;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, a = [], l = !!e, c = e || s.tr, u = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), a.every((f) => f === !0)), d = {
      ...Object.fromEntries(Object.entries(r).map(([f, h]) => [f, (...g) => {
        const m = this.buildProps(c, n), v = h(...g)(m);
        return a.push(v), d;
      }])),
      run: u
    };
    return d;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this, i = !1, s = e || r.tr, o = this.buildProps(s, i);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({ ...o, dispatch: void 0 })])),
      chain: () => this.createChain(s, i)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, a = {
      tr: e,
      editor: i,
      view: o,
      state: Cv({
        state: s,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(a)]));
      }
    };
    return a;
  }
}
let p4 = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return r && (n ? this.callbacks[e] = r.filter((i) => i !== n) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function Le(t, e, n) {
  return t.config[e] === void 0 && t.parent ? Le(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? Le(t.parent, e, n) : null
  }) : t.config[e];
}
function Ov(t) {
  const e = t.filter((i) => i.type === "extension"), n = t.filter((i) => i.type === "node"), r = t.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function pR(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = Ov(t), i = [...n, ...r], s = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage,
      extensions: i
    }, l = Le(o, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, h]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...s,
              ...h
            }
          });
        });
      });
    });
  }), i.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = Le(o, "addAttributes", a);
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...s,
        ...d
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: o.name,
        name: u,
        attribute: f
      });
    });
  }), e;
}
function mn(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function _t(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([i, s]) => {
      if (!r[i]) {
        r[i] = s;
        return;
      }
      if (i === "class") {
        const a = s ? s.split(" ") : [], l = r[i] ? r[i].split(" ") : [], c = a.filter((u) => !l.includes(u));
        r[i] = [...l, ...c].join(" ");
      } else if (i === "style") {
        const a = s ? s.split(";").map((u) => u.trim()).filter(Boolean) : [], l = r[i] ? r[i].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), a.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), r[i] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        r[i] = s;
    }), r;
  }, {});
}
function Dy(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => _t(n, r), {});
}
function gR(t) {
  return typeof t == "function";
}
function lt(t, e = void 0, ...n) {
  return gR(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function g4(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function m4(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function bk(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const i = e.reduce((s, o) => {
        const a = o.attribute.parseHTML ? o.attribute.parseHTML(n) : m4(n.getAttribute(o.name));
        return a == null ? s : {
          ...s,
          [o.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function yk(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && g4(n) ? !1 : n != null)
  );
}
function v4(t, e) {
  var n;
  const r = pR(t), { nodeExtensions: i, markExtensions: s } = Ov(t), o = (n = i.find((c) => Le(c, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(i.map((c) => {
    const u = r.filter((v) => v.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((v, y) => {
      const E = Le(y, "extendNodeSchema", d);
      return {
        ...v,
        ...E ? E(c) : {}
      };
    }, {}), h = yk({
      ...f,
      content: lt(Le(c, "content", d)),
      marks: lt(Le(c, "marks", d)),
      group: lt(Le(c, "group", d)),
      inline: lt(Le(c, "inline", d)),
      atom: lt(Le(c, "atom", d)),
      selectable: lt(Le(c, "selectable", d)),
      draggable: lt(Le(c, "draggable", d)),
      code: lt(Le(c, "code", d)),
      whitespace: lt(Le(c, "whitespace", d)),
      defining: lt(Le(c, "defining", d)),
      isolating: lt(Le(c, "isolating", d)),
      attrs: Object.fromEntries(u.map((v) => {
        var y;
        return [v.name, { default: (y = v == null ? void 0 : v.attribute) === null || y === void 0 ? void 0 : y.default }];
      }))
    }), p = lt(Le(c, "parseHTML", d));
    p && (h.parseDOM = p.map((v) => bk(v, u)));
    const g = Le(c, "renderHTML", d);
    g && (h.toDOM = (v) => g({
      node: v,
      HTMLAttributes: Dy(v, u)
    }));
    const m = Le(c, "renderText", d);
    return m && (h.toText = m), [c.name, h];
  })), l = Object.fromEntries(s.map((c) => {
    const u = r.filter((m) => m.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((m, v) => {
      const y = Le(v, "extendMarkSchema", d);
      return {
        ...m,
        ...y ? y(c) : {}
      };
    }, {}), h = yk({
      ...f,
      inclusive: lt(Le(c, "inclusive", d)),
      excludes: lt(Le(c, "excludes", d)),
      group: lt(Le(c, "group", d)),
      spanning: lt(Le(c, "spanning", d)),
      code: lt(Le(c, "code", d)),
      attrs: Object.fromEntries(u.map((m) => {
        var v;
        return [m.name, { default: (v = m == null ? void 0 : m.attribute) === null || v === void 0 ? void 0 : v.default }];
      }))
    }), p = lt(Le(c, "parseHTML", d));
    p && (h.parseDOM = p.map((m) => bk(m, u)));
    const g = Le(c, "renderHTML", d);
    return g && (h.toDOM = (m) => g({
      mark: m,
      HTMLAttributes: Dy(m, u)
    })), [c.name, h];
  }));
  return new oN({
    topNode: o,
    nodes: a,
    marks: l
  });
}
function Z0(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function wk(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
const b4 = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, a) => {
    var l, c;
    const u = ((c = (l = i.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
      node: i,
      pos: s,
      parent: o,
      index: a
    })) || i.textContent || "%leaf%";
    n += i.isAtom && !i.isText ? u : u.slice(0, Math.max(0, r - s));
  }), n;
};
function g_(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class Mv {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const y4 = (t, e) => {
  if (g_(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function fh(t) {
  var e;
  const { editor: n, from: r, to: i, text: s, rules: o, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(r);
  if (
    // check for code node
    c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = b4(c) + s;
  return o.forEach((f) => {
    if (u)
      return;
    const h = y4(d, f.find);
    if (!h)
      return;
    const p = l.state.tr, g = Cv({
      state: l.state,
      transaction: p
    }), m = {
      from: r - (h[0].length - s.length),
      to: i
    }, { commands: v, chain: y, can: E } = new Tv({
      editor: n,
      state: g
    });
    f.handler({
      state: g,
      range: m,
      match: h,
      commands: v,
      chain: y,
      can: E
    }) === null || !p.steps.length || (p.setMeta(a, {
      transform: p,
      from: r,
      to: i,
      text: s
    }), l.dispatch(p), u = !0);
  }), u;
}
function w4(t) {
  const { editor: e, rules: n } = t, r = new ut({
    state: {
      init() {
        return null;
      },
      apply(i, s) {
        const o = i.getMeta(r);
        if (o)
          return o;
        const a = i.getMeta("applyInputRules");
        return !!a && setTimeout(() => {
          const { from: c, text: u } = a, d = c + u.length;
          fh({
            editor: e,
            from: c,
            to: d,
            text: u,
            rules: n,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : s;
      }
    },
    props: {
      handleTextInput(i, s, o, a) {
        return fh({
          editor: e,
          from: s,
          to: o,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: s } = i.state.selection;
          s && fh({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, s) {
        if (s.key !== "Enter")
          return !1;
        const { $cursor: o } = i.state.selection;
        return o ? fh({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function _4(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function hh(t) {
  return _4(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function Av(t, e) {
  const n = { ...t };
  return hh(t) && hh(e) && Object.keys(e).forEach((r) => {
    hh(e[r]) && hh(t[r]) ? n[r] = Av(t[r], e[r]) : n[r] = e[r];
  }), n;
}
class mr {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = lt(Le(this, "addOptions", {
      name: this.name
    }))), this.storage = lt(Le(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new mr(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Av(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new mr(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = lt(Le(n, "addOptions", {
      name: n.name
    })), n.storage = lt(Le(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const o = i.marks();
      if (!!!o.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1;
      const l = o.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
function Rd(t) {
  return typeof t == "number";
}
class E4 {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const S4 = (t, e, n) => {
  if (g_(e))
    return [...t.matchAll(e)];
  const r = e(t, n);
  return r ? r.map((i) => {
    const s = [i.text];
    return s.index = i.index, s.input = t, s.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(i.replaceWith)), s;
  }) : [];
};
function x4(t) {
  const { editor: e, state: n, from: r, to: i, rule: s, pasteEvent: o, dropEvent: a } = t, { commands: l, chain: c, can: u } = new Tv({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(r, i, (h, p) => {
    if (!h.isTextblock || h.type.spec.code)
      return;
    const g = Math.max(r, p), m = Math.min(i, p + h.content.size), v = h.textBetween(g - p, m - p, void 0, "￼");
    S4(v, s.find, o).forEach((E) => {
      if (E.index === void 0)
        return;
      const b = g + E.index + 1, _ = b + E[0].length, w = {
        from: n.tr.mapping.map(b),
        to: n.tr.mapping.map(_)
      }, S = s.handler({
        state: n,
        range: w,
        match: E,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: o,
        dropEvent: a
      });
      d.push(S);
    });
  }), d.every((h) => h !== null);
}
const k4 = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function C4(t) {
  const { editor: e, rules: n } = t;
  let r = null, i = !1, s = !1, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  const l = ({ state: u, from: d, to: f, rule: h, pasteEvt: p }) => {
    const g = u.tr, m = Cv({
      state: u,
      transaction: g
    });
    if (!(!x4({
      editor: e,
      state: m,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: h,
      pasteEvent: p,
      dropEvent: a
    }) || !g.steps.length))
      return a = typeof DragEvent < "u" ? new DragEvent("drop") : null, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, g;
  };
  return n.map((u) => new ut({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (h) => {
        var p;
        r = !((p = d.dom.parentElement) === null || p === void 0) && p.contains(h.target) ? d.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", f), {
        destroy() {
          window.removeEventListener("dragstart", f);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => (s = r === d.dom.parentElement, a = f, !1),
        paste: (d, f) => {
          var h;
          const p = (h = f.clipboardData) === null || h === void 0 ? void 0 : h.getData("text/html");
          return o = f, i = !!(p != null && p.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, f, h) => {
      const p = d[0], g = p.getMeta("uiEvent") === "paste" && !i, m = p.getMeta("uiEvent") === "drop" && !s, v = p.getMeta("applyPasteRules"), y = !!v;
      if (!g && !m && !y)
        return;
      if (y) {
        const { from: _, text: w } = v, S = _ + w.length, x = k4(w);
        return l({
          rule: u,
          state: h,
          from: _,
          to: { b: S },
          pasteEvt: x
        });
      }
      const E = f.doc.content.findDiffStart(h.doc.content), b = f.doc.content.findDiffEnd(h.doc.content);
      if (!(!Rd(E) || !b || E === b.b))
        return l({
          rule: u,
          state: h,
          from: E,
          to: b,
          pasteEvt: o
        });
    }
  }));
}
function T4(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
class Yl {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = Yl.resolve(e), this.schema = v4(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = Yl.sort(Yl.flatten(e)), r = T4(n.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, i = Le(n, "addExtensions", r);
      return i ? [n, ...this.flatten(i())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((r, i) => {
      const s = Le(r, "priority") || 100, o = Le(i, "priority") || 100;
      return s > o ? -1 : s < o ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: Z0(n.name, this.schema)
      }, i = Le(n, "addCommands", r);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = Yl.sort([...this.extensions].reverse()), r = [], i = [], s = n.map((o) => {
      const a = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: Z0(o.name, this.schema)
      }, l = [], c = Le(o, "addKeyboardShortcuts", a);
      let u = {};
      if (o.type === "mark" && Le(o, "exitable", a) && (u.ArrowRight = () => mr.handleExit({ editor: e, mark: o })), c) {
        const g = Object.fromEntries(Object.entries(c()).map(([m, v]) => [m, () => v({ editor: e })]));
        u = { ...u, ...g };
      }
      const d = VU(u);
      l.push(d);
      const f = Le(o, "addInputRules", a);
      wk(o, e.options.enableInputRules) && f && r.push(...f());
      const h = Le(o, "addPasteRules", a);
      wk(o, e.options.enablePasteRules) && h && i.push(...h());
      const p = Le(o, "addProseMirrorPlugins", a);
      if (p) {
        const g = p();
        l.push(...g);
      }
      return l;
    }).flat();
    return [
      w4({
        editor: e,
        rules: r
      }),
      ...C4({
        editor: e,
        rules: i
      }),
      ...s
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return pR(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = Ov(this.extensions);
    return Object.fromEntries(n.filter((r) => !!Le(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((l) => l.type === r.name), s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: mn(r.name, this.schema)
      }, o = Le(r, "addNodeView", s);
      if (!o)
        return [];
      const a = (l, c, u, d, f) => {
        const h = Dy(l, i);
        return o()({
          // pass-through
          node: l,
          view: c,
          getPos: u,
          decorations: d,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: r,
          HTMLAttributes: h
        });
      };
      return [r.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: Z0(e.name, this.schema)
      };
      e.type === "mark" && (!((n = lt(Le(e, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const i = Le(e, "onBeforeCreate", r), s = Le(e, "onCreate", r), o = Le(e, "onUpdate", r), a = Le(e, "onSelectionUpdate", r), l = Le(e, "onTransaction", r), c = Le(e, "onFocus", r), u = Le(e, "onBlur", r), d = Le(e, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), s && this.editor.on("create", s), o && this.editor.on("update", o), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
}
class Et {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = lt(Le(this, "addOptions", {
      name: this.name
    }))), this.storage = lt(Le(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Et(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Av(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Et({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = lt(Le(n, "addOptions", {
      name: n.name
    })), n.storage = lt(Le(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function mR(t, e, n) {
  const { from: r, to: i } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = n || {};
  let a = "";
  return t.nodesBetween(r, i, (l, c, u, d) => {
    var f;
    l.isBlock && c > r && (a += s);
    const h = o == null ? void 0 : o[l.type.name];
    if (h)
      return u && (a += h({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(r, c) - c, i - c));
  }), a;
}
function vR(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const O4 = Et.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: i } = e, { ranges: s } = i, o = Math.min(...s.map((u) => u.$from.pos)), a = Math.max(...s.map((u) => u.$to.pos)), l = vR(n);
            return mR(r, { from: o, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), M4 = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), A4 = (t = !1) => ({ commands: e }) => e.setContent("", t), N4 = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: i } = r;
  return n && i.forEach(({ $from: s, $to: o }) => {
    t.doc.nodesBetween(s.pos, o.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + a.nodeSize)), h = d.blockRange(f);
      if (!h)
        return;
      const p = Qc(h);
      if (a.type.isTextblock) {
        const { defaultType: g } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(h.start, g);
      }
      (p || p === 0) && e.lift(h, p);
    });
  }), !0;
}, R4 = (t) => (e) => t(e), D4 = () => ({ state: t, dispatch: e }) => t4(t, e), I4 = (t, e) => ({ editor: n, tr: r }) => {
  const { state: i } = n, s = i.doc.slice(t.from, t.to);
  r.deleteRange(t.from, t.to);
  const o = r.mapping.map(e);
  return r.insert(o, s.content), r.setSelection(new Te(r.doc.resolve(o - 1))), !0;
}, P4 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = t.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === r.type) {
      if (e) {
        const a = i.before(s), l = i.after(s);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, L4 = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const i = mn(t, n.schema), s = e.selection.$anchor;
  for (let o = s.depth; o > 0; o -= 1)
    if (s.node(o).type === i) {
      if (r) {
        const l = s.before(o), c = s.after(o);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, $4 = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: i } = t;
  return n && e.delete(r, i), !0;
}, B4 = () => ({ state: t, dispatch: e }) => aR(t, e), F4 = () => ({ commands: t }) => t.keyboardShortcut("Enter"), z4 = () => ({ state: t, dispatch: e }) => e4(t, e);
function yg(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((i) => n.strict ? e[i] === t[i] : g_(e[i]) ? e[i].test(t[i]) : e[i] === t[i]) : !0;
}
function Iy(t, e, n = {}) {
  return t.find((r) => r.type === e && yg(r.attrs, n));
}
function H4(t, e, n = {}) {
  return !!Iy(t, e, n);
}
function Nv(t, e, n = {}) {
  if (!t || !e)
    return;
  let r = t.parent.childAfter(t.parentOffset);
  if ((!r.node || !r.node.marks.some((c) => c.type === e)) && (r = t.parent.childBefore(t.parentOffset)), !r.node || !r.node.marks.some((c) => c.type === e))
    return;
  const i = Iy([...r.node.marks], e, n);
  if (!i)
    return;
  let s = r.index, o = t.start() + r.offset, a = s + 1, l = o + r.node.nodeSize;
  for (Iy([...r.node.marks], e, n); s > 0 && i.isInSet(t.parent.child(s - 1).marks); )
    s -= 1, o -= t.parent.child(s).nodeSize;
  for (; a < t.parent.childCount && H4([...t.parent.child(a).marks], e, n); )
    l += t.parent.child(a).nodeSize, a += 1;
  return {
    from: o,
    to: l
  };
}
function Ho(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const U4 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const s = Ho(t, r.schema), { doc: o, selection: a } = n, { $from: l, from: c, to: u } = a;
  if (i) {
    const d = Nv(l, s, e);
    if (d && d.from <= c && d.to >= u) {
      const f = Te.create(o, d.from, d.to);
      n.setSelection(f);
    }
  }
  return !0;
}, V4 = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function m_(t) {
  return t instanceof Te;
}
function Ds(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function bR(t, e = null) {
  if (!e)
    return null;
  const n = $e.atStart(t), r = $e.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const i = n.from, s = r.to;
  return e === "all" ? Te.create(t, Ds(0, i, s), Ds(t.content.size, i, s)) : Te.create(t, Ds(e, i, s), Ds(e, i, s));
}
function Rv() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const W4 = (t = null, e = {}) => ({ editor: n, view: r, tr: i, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const o = () => {
    Rv() && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && t === null || t === !1)
    return !0;
  if (s && t === null && !m_(n.state.selection))
    return o(), !0;
  const a = bR(i.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return s && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0;
}, G4 = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i })), j4 = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), yR = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const r = e[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && yR(r);
  }
  return t;
};
function ph(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return yR(n);
}
function wg(t, e, n) {
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof t == "object" && t !== null, i = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return pe.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const o = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && o.check(), o;
    } catch (s) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: s });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", s), wg("", e, n);
    }
  if (i) {
    if (n.errorOnInvalidContent) {
      let o = !1, a = "";
      const l = new oN({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (o = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Xu.fromSchema(l).parseSlice(ph(t), n.parseOptions) : Xu.fromSchema(l).parse(ph(t), n.parseOptions), n.errorOnInvalidContent && o)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const s = Xu.fromSchema(e);
    return n.slice ? s.parseSlice(ph(t), n.parseOptions).content : s.parse(ph(t), n.parseOptions);
  }
  return wg("", e, n);
}
function q4(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const i = t.steps[r];
  if (!(i instanceof rs || i instanceof Br))
    return;
  const s = t.mapping.maps[r];
  let o = 0;
  s.forEach((a, l, c, u) => {
    o === 0 && (o = u);
  }), t.setSelection($e.near(t.doc.resolve(o), n));
}
const K4 = (t) => !("type" in t), Y4 = (t, e, n) => ({ tr: r, dispatch: i, editor: s }) => {
  var o;
  if (i) {
    n = {
      parseOptions: s.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    try {
      a = wg(e, s.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (o = n.errorOnInvalidContent) !== null && o !== void 0 ? o : s.options.enableContentCheck
      });
    } catch (p) {
      return s.emit("contentError", {
        editor: s,
        error: p,
        disableCollaboration: () => {
          s.storage.collaboration && (s.storage.collaboration.isDisabled = !0);
        }
      }), !1;
    }
    let { from: l, to: c } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, u = !0, d = !0;
    if ((K4(a) ? a : [a]).forEach((p) => {
      p.check(), u = u ? p.isText && p.marks.length === 0 : !1, d = d ? p.isBlock : !1;
    }), l === c && d) {
      const { parent: p } = r.doc.resolve(l);
      p.isTextblock && !p.type.spec.code && !p.childCount && (l -= 1, c += 1);
    }
    let h;
    u ? (Array.isArray(e) ? h = e.map((p) => p.text || "").join("") : typeof e == "object" && e && e.text ? h = e.text : h = e, r.insertText(h, l, c)) : (h = a, r.replaceWith(l, c, h)), n.updateSelection && q4(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: l, text: h }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: l, text: h });
  }
  return !0;
}, X4 = () => ({ state: t, dispatch: e }) => XU(t, e), J4 = () => ({ state: t, dispatch: e }) => JU(t, e), Z4 = () => ({ state: t, dispatch: e }) => WU(t, e), Q4 = () => ({ state: t, dispatch: e }) => KU(t, e), eV = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = wv(t.doc, t.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, tV = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = wv(t.doc, t.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, nV = () => ({ state: t, dispatch: e }) => GU(t, e), rV = () => ({ state: t, dispatch: e }) => jU(t, e);
function wR() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function iV(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, i, s, o;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      Rv() || wR() ? o = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), o && (n = `Meta-${n}`), s && (n = `Shift-${n}`), n;
}
const sV = (t) => ({ editor: e, view: n, tr: r, dispatch: i }) => {
  const s = iV(t).split(/-(?!$)/), o = s.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(r.mapping);
    u && i && r.maybeStep(u);
  }), !0;
};
function Dd(t, e, n = {}) {
  const { from: r, to: i, empty: s } = t.selection, o = e ? mn(e, t.schema) : null, a = [];
  t.doc.nodesBetween(r, i, (d, f) => {
    if (d.isText)
      return;
    const h = Math.max(r, f), p = Math.min(i, f + d.nodeSize);
    a.push({
      node: d,
      from: h,
      to: p
    });
  });
  const l = i - r, c = a.filter((d) => o ? o.name === d.node.type.name : !0).filter((d) => yg(d.node.attrs, n, { strict: !1 }));
  return s ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
const oV = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = mn(t, n.schema);
  return Dd(n, i, e) ? ZU(n, r) : !1;
}, aV = () => ({ state: t, dispatch: e }) => n4(t, e), lV = (t) => ({ state: e, dispatch: n }) => {
  const r = mn(t, e.schema);
  return u4(r)(e, n);
}, cV = () => ({ state: t, dispatch: e }) => QU(t, e);
function Dv(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function _k(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {});
}
const uV = (t, e) => ({ tr: n, state: r, dispatch: i }) => {
  let s = null, o = null;
  const a = Dv(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (s = mn(t, r.schema)), a === "mark" && (o = Ho(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
      s && s === c.type && n.setNodeMarkup(u, void 0, _k(c.attrs, e)), o && c.marks.length && c.marks.forEach((d) => {
        o === d.type && n.addMark(u, u + c.nodeSize, o.create(_k(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, dV = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), fV = () => ({ tr: t, commands: e }) => e.setTextSelection({
  from: 0,
  to: t.doc.content.size
}), hV = () => ({ state: t, dispatch: e }) => qU(t, e), pV = () => ({ state: t, dispatch: e }) => YU(t, e), gV = () => ({ state: t, dispatch: e }) => r4(t, e), mV = () => ({ state: t, dispatch: e }) => o4(t, e), vV = () => ({ state: t, dispatch: e }) => s4(t, e);
function Py(t, e, n = {}, r = {}) {
  return wg(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
const bV = (t, e = !1, n = {}, r = {}) => ({ editor: i, tr: s, dispatch: o, commands: a }) => {
  var l, c;
  const { doc: u } = s;
  if (n.preserveWhitespace !== "full") {
    const d = Py(t, i.schema, n, {
      errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
    });
    return o && s.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), !0;
  }
  return o && s.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: u.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : i.options.enableContentCheck
  });
};
function v_(t, e) {
  const n = Ho(e, t.schema), { from: r, to: i, empty: s } = t.selection, o = [];
  s ? (t.storedMarks && o.push(...t.storedMarks), o.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, i, (l) => {
    o.push(...l.marks);
  });
  const a = o.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function yV(t, e) {
  const n = new xN(t);
  return e.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function wV(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function Ly(t, e) {
  const n = [];
  return t.descendants((r, i) => {
    e(r) && n.push({
      node: r,
      pos: i
    });
  }), n;
}
function _V(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (i, s) => {
    n(i) && r.push({
      node: i,
      pos: s
    });
  }), r;
}
function _R(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function Iv(t) {
  return (e) => _R(e.$from, t);
}
function EV(t, e) {
  const n = dl.fromSchema(e).serializeFragment(t), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
function SV(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return mR(t, n, e);
}
function xV(t, e) {
  const n = mn(e, t.schema), { from: r, to: i } = t.selection, s = [];
  t.doc.nodesBetween(r, i, (a) => {
    s.push(a);
  });
  const o = s.reverse().find((a) => a.type.name === n.name);
  return o ? { ...o.attrs } : {};
}
function b_(t, e) {
  const n = Dv(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? xV(t, e) : n === "mark" ? v_(t, e) : {};
}
function kV(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const i = e(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function CV(t) {
  const e = kV(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((s, o) => o !== r).some((s) => n.oldRange.from >= s.oldRange.from && n.oldRange.to <= s.oldRange.to && n.newRange.from >= s.newRange.from && n.newRange.to <= s.newRange.to));
}
function TV(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((i, s) => {
    const o = [];
    if (i.ranges.length)
      i.forEach((a, l) => {
        o.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[s];
      if (a === void 0 || l === void 0)
        return;
      o.push({ from: a, to: l });
    }
    o.forEach(({ from: a, to: l }) => {
      const c = e.slice(s).map(a, -1), u = e.slice(s).map(l), d = e.invert().map(c, -1), f = e.invert().map(u);
      r.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), CV(r);
}
function y_(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((i) => {
    const s = n.resolve(t), o = Nv(s, i.type);
    o && r.push({
      mark: i,
      ...o
    });
  }) : n.nodesBetween(t, e, (i, s) => {
    !i || (i == null ? void 0 : i.nodeSize) === void 0 || r.push(...i.marks.map((o) => ({
      from: s,
      to: s + i.nodeSize,
      mark: o
    })));
  }), r;
}
function wp(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([r]) => {
    const i = t.find((s) => s.type === e && s.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function $y(t, e, n = {}) {
  const { empty: r, ranges: i } = t.selection, s = e ? Ho(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((d) => s ? s.name === d.type.name : !0).find((d) => yg(d.attrs, n, { strict: !1 }));
  let o = 0;
  const a = [];
  if (i.forEach(({ $from: d, $to: f }) => {
    const h = d.pos, p = f.pos;
    t.doc.nodesBetween(h, p, (g, m) => {
      if (!g.isText && !g.marks.length)
        return;
      const v = Math.max(h, m), y = Math.min(p, m + g.nodeSize), E = y - v;
      o += E, a.push(...g.marks.map((b) => ({
        mark: b,
        from: v,
        to: y
      })));
    });
  }), o === 0)
    return !1;
  const l = a.filter((d) => s ? s.name === d.mark.type.name : !0).filter((d) => yg(d.mark.attrs, n, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = a.filter((d) => s ? d.mark.type !== s && d.mark.type.excludes(s) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= o;
}
function OV(t, e, n = {}) {
  if (!e)
    return Dd(t, null, n) || $y(t, null, n);
  const r = Dv(e, t.schema);
  return r === "node" ? Dd(t, e, n) : r === "mark" ? $y(t, e, n) : !1;
}
function By(t, e) {
  const { nodeExtensions: n } = Ov(e), r = n.find((o) => o.name === t);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, s = lt(Le(r, "group", i));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function w_(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let i = !0;
    return t.content.forEach((s) => {
      i !== !1 && (w_(s, { ignoreWhitespace: n, checkChildren: e }) || (i = !1));
    }), i;
  }
  return !1;
}
function ER(t) {
  return t instanceof ve;
}
function SR(t, e, n) {
  const i = t.state.doc.content.size, s = Ds(e, 0, i), o = Ds(n, 0, i), a = t.coordsAtPos(s), l = t.coordsAtPos(o, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), f = Math.max(a.right, l.right), h = f - d, p = u - c, v = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: h,
    height: p,
    x: d,
    y: c
  };
  return {
    ...v,
    toJSON: () => v
  };
}
function MV(t, e, n) {
  var r;
  const { selection: i } = e;
  let s = null;
  if (m_(i) && (s = i.$cursor), s) {
    const a = (r = t.storedMarks) !== null && r !== void 0 ? r : s.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: o } = i;
  return o.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const h = !f || f.type.allowsMarkType(n), p = !!n.isInSet(u.marks) || !u.marks.some((g) => g.type.excludes(n));
        c = h && p;
      }
      return !c;
    }), c;
  });
}
const AV = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: s } = n, { empty: o, ranges: a } = s, l = Ho(t, r.schema);
  if (i)
    if (o) {
      const c = v_(r, l);
      n.addStoredMark(l.create({
        ...c,
        ...e
      }));
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        r.doc.nodesBetween(u, d, (f, h) => {
          const p = Math.max(h, u), g = Math.min(h + f.nodeSize, d);
          f.marks.find((v) => v.type === l) ? f.marks.forEach((v) => {
            l === v.type && n.addMark(p, g, l.create({
              ...v.attrs,
              ...e
            }));
          }) : n.addMark(p, g, l.create(e));
        });
      });
  return MV(r, n, l);
}, NV = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), RV = (t, e = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const s = mn(t, n.schema);
  return s.isTextblock ? i().command(({ commands: o }) => vk(s, e)(n) ? !0 : o.clearNodes()).command(({ state: o }) => vk(s, e)(o, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, DV = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, i = Ds(t, 0, r.content.size), s = ve.create(r, i);
    e.setSelection(s);
  }
  return !0;
}, IV = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: i, to: s } = typeof t == "number" ? { from: t, to: t } : t, o = Te.atStart(r).from, a = Te.atEnd(r).to, l = Ds(i, o, a), c = Ds(s, o, a), u = Te.create(r, l, c);
    e.setSelection(u);
  }
  return !0;
}, PV = (t) => ({ state: e, dispatch: n }) => {
  const r = mn(t, e.schema);
  return h4(r)(e, n);
};
function Ek(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    t.tr.ensureMarks(r);
  }
}
const LV = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
  const { selection: s, doc: o } = e, { $from: a, $to: l } = s, c = i.extensionManager.attributes, u = wp(c, a.node().type.name, a.node().attrs);
  if (s instanceof ve && s.node.isBlock)
    return !a.parentOffset || !sc(o, a.pos) ? !1 : (r && (t && Ek(n, i.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : wV(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let h = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, p = sc(e.doc, e.mapping.map(a.pos), 1, h);
  if (!h && !p && sc(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), r) {
    if (p && (s instanceof Te && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, h), f && !d && !a.parentOffset && a.parent.type !== f)) {
      const g = e.mapping.map(a.before()), m = e.doc.resolve(g);
      a.node(-1).canReplaceWith(m.index(), m.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t && Ek(n, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return p;
}, $V = (t, e = {}) => ({ tr: n, state: r, dispatch: i, editor: s }) => {
  var o;
  const a = mn(t, r.schema), { $from: l, $to: c } = r.selection, u = r.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const d = l.node(-1);
  if (d.type !== a)
    return !1;
  const f = s.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (i) {
      let v = pe.empty;
      const y = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let x = l.depth - y; x >= l.depth - 3; x -= 1)
        v = pe.from(l.node(x).copy(v));
      const E = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, b = {
        ...wp(f, l.node().type.name, l.node().attrs),
        ...e
      }, _ = ((o = a.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(b)) || void 0;
      v = v.append(pe.from(a.createAndFill(null, _) || void 0));
      const w = l.before(l.depth - (y - 1));
      n.replace(w, l.after(-E), new De(v, 4 - y, 0));
      let S = -1;
      n.doc.nodesBetween(w, n.doc.content.size, (x, k) => {
        if (S > -1)
          return !1;
        x.isTextblock && x.content.size === 0 && (S = k + 1);
      }), S > -1 && n.setSelection(Te.near(n.doc.resolve(S))), n.scrollIntoView();
    }
    return !0;
  }
  const h = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = {
    ...wp(f, d.type.name, d.attrs),
    ...e
  }, g = {
    ...wp(f, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, c.pos);
  const m = h ? [
    { type: a, attrs: p },
    { type: h, attrs: g }
  ] : [{ type: a, attrs: p }];
  if (!sc(n.doc, l.pos, 2))
    return !1;
  if (i) {
    const { selection: v, storedMarks: y } = r, { splittableMarks: E } = s.extensionManager, b = y || v.$to.parentOffset && v.$from.marks();
    if (n.split(l.pos, 2, m).scrollIntoView(), !b || !i)
      return !0;
    const _ = b.filter((w) => E.includes(w.type.name));
    n.ensureMarks(_);
  }
  return !0;
}, Q0 = (t, e) => {
  const n = Iv((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Fo(t.doc, n.pos) && t.join(n.pos), !0;
}, eb = (t, e) => {
  const n = Iv((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Fo(t.doc, r) && t.join(r), !0;
}, BV = (t, e, n, r = {}) => ({ editor: i, tr: s, state: o, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = i.extensionManager, h = mn(t, o.schema), p = mn(e, o.schema), { selection: g, storedMarks: m } = o, { $from: v, $to: y } = g, E = v.blockRange(y), b = m || g.$to.parentOffset && g.$from.marks();
  if (!E)
    return !1;
  const _ = Iv((w) => By(w.type.name, d))(g);
  if (E.depth >= 1 && _ && E.depth - _.depth <= 1) {
    if (_.node.type === h)
      return c.liftListItem(p);
    if (By(_.node.type.name, d) && h.validContent(_.node.content) && a)
      return l().command(() => (s.setNodeMarkup(_.pos, h), !0)).command(() => Q0(s, h)).command(() => eb(s, h)).run();
  }
  return !n || !b || !a ? l().command(() => u().wrapInList(h, r) ? !0 : c.clearNodes()).wrapInList(h, r).command(() => Q0(s, h)).command(() => eb(s, h)).run() : l().command(() => {
    const w = u().wrapInList(h, r), S = b.filter((x) => f.includes(x.type.name));
    return s.ensureMarks(S), w ? !0 : c.clearNodes();
  }).wrapInList(h, r).command(() => Q0(s, h)).command(() => eb(s, h)).run();
}, FV = (t, e = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: s = !1 } = n, o = Ho(t, r.schema);
  return $y(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: s }) : i.setMark(o, e);
}, zV = (t, e, n = {}) => ({ state: r, commands: i }) => {
  const s = mn(t, r.schema), o = mn(e, r.schema), a = Dd(r, s, n);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? i.setNode(o, l) : i.setNode(s, { ...l, ...n });
}, HV = (t, e = {}) => ({ state: n, commands: r }) => {
  const i = mn(t, n.schema);
  return Dd(n, i, e) ? r.lift(i) : r.wrapIn(i, e);
}, UV = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let s;
    if (i.spec.isInputRules && (s = i.getState(t))) {
      if (e) {
        const o = t.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          o.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          const l = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, t.schema.text(s.text, l));
        } else
          o.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, VV = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: i } = n;
  return r || e && i.forEach((s) => {
    t.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, WV = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var s;
  const { extendEmptyMarkRange: o = !1 } = e, { selection: a } = n, l = Ho(t, r.schema), { $from: c, empty: u, ranges: d } = a;
  if (!i)
    return !0;
  if (u && o) {
    let { from: f, to: h } = a;
    const p = (s = c.marks().find((m) => m.type === l)) === null || s === void 0 ? void 0 : s.attrs, g = Nv(c, l, p);
    g && (f = g.from, h = g.to), n.removeMark(f, h, l);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, GV = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let s = null, o = null;
  const a = Dv(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (s = mn(t, r.schema)), a === "mark" && (o = Ho(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    const c = l.$from.pos, u = l.$to.pos;
    r.doc.nodesBetween(c, u, (d, f) => {
      s && s === d.type && n.setNodeMarkup(f, void 0, {
        ...d.attrs,
        ...e
      }), o && d.marks.length && d.marks.forEach((h) => {
        if (o === h.type) {
          const p = Math.max(f, c), g = Math.min(f + d.nodeSize, u);
          n.addMark(p, g, o.create({
            ...h.attrs,
            ...e
          }));
        }
      });
    });
  }), !0) : !1;
}, jV = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = mn(t, n.schema);
  return a4(i, e)(n, r);
}, qV = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = mn(t, n.schema);
  return l4(i, e)(n, r);
};
var KV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: M4,
  clearContent: A4,
  clearNodes: N4,
  command: R4,
  createParagraphNear: D4,
  cut: I4,
  deleteCurrentNode: P4,
  deleteNode: L4,
  deleteRange: $4,
  deleteSelection: B4,
  enter: F4,
  exitCode: z4,
  extendMarkRange: U4,
  first: V4,
  focus: W4,
  forEach: G4,
  insertContent: j4,
  insertContentAt: Y4,
  joinBackward: Z4,
  joinDown: J4,
  joinForward: Q4,
  joinItemBackward: eV,
  joinItemForward: tV,
  joinTextblockBackward: nV,
  joinTextblockForward: rV,
  joinUp: X4,
  keyboardShortcut: sV,
  lift: oV,
  liftEmptyBlock: aV,
  liftListItem: lV,
  newlineInCode: cV,
  resetAttributes: uV,
  scrollIntoView: dV,
  selectAll: fV,
  selectNodeBackward: hV,
  selectNodeForward: pV,
  selectParentNode: gV,
  selectTextblockEnd: mV,
  selectTextblockStart: vV,
  setContent: bV,
  setMark: AV,
  setMeta: NV,
  setNode: RV,
  setNodeSelection: DV,
  setTextSelection: IV,
  sinkListItem: PV,
  splitBlock: LV,
  splitListItem: $V,
  toggleList: BV,
  toggleMark: FV,
  toggleNode: zV,
  toggleWrap: HV,
  undoInputRule: UV,
  unsetAllMarks: VV,
  unsetMark: WV,
  updateAttributes: GV,
  wrapIn: jV,
  wrapInList: qV
});
const YV = Et.create({
  name: "commands",
  addCommands() {
    return {
      ...KV
    };
  }
}), XV = Et.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), JV = Et.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), ZV = Et.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new ut({
        key: new ft("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), QV = Et.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      // maybe convert first text block node to default node
      () => o.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d, g = p.parent.type.spec.isolating, m = d.pos - d.parentOffset, v = g && p.parent.childCount === 1 ? m === d.pos : $e.atStart(c).from === f;
        return !u || !h.type.isTextblock || h.textContent.length || !v || v && d.parent.type.name === "paragraph" ? !1 : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, s = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Rv() || wR() ? s : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new ut({
        key: new ft("clearDocument"),
        appendTransaction: (t, e, n) => {
          const r = t.some((g) => g.docChanged) && !e.doc.eq(n.doc), i = t.some((g) => g.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: s, from: o, to: a } = e.selection, l = $e.atStart(e.doc).from, c = $e.atEnd(e.doc).to;
          if (s || !(o === l && a === c) || !w_(n.doc))
            return;
          const f = n.tr, h = Cv({
            state: n,
            transaction: f
          }), { commands: p } = new Tv({
            editor: this.editor,
            state: h
          });
          if (p.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), e5 = Et.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), t5 = Et.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class ra {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = i;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new ra(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new ra(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new ra(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, r) => {
      const i = n.isBlock && !n.isTextblock, s = n.isAtom && !n.isText, o = this.pos + r + (s ? 0 : 1), a = this.resolvedPos.doc.resolve(o);
      if (!i && a.depth <= this.depth)
        return;
      const l = new ra(a, this.editor, i, i ? n : null);
      i && (l.actualDepth = this.depth + 1), e.push(new ra(a, this.editor, i, i ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const s = i.node.attrs, o = Object.keys(n);
          for (let a = 0; a < o.length; a += 1) {
            const l = o[a];
            if (s[l] !== n[l])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const s = Object.keys(n);
    return this.children.forEach((o) => {
      r && i.length > 0 || (o.node.type.name === e && s.every((l) => n[l] === o.node.attrs[l]) && i.push(o), !(r && i.length > 0) && (i = i.concat(o.querySelectorAll(e, n, r))));
    }), i;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}
const n5 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function r5(t, e, n) {
  const r = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ""}]`);
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return e && i.setAttribute("nonce", e), i.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""), i.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(i), i;
}
let xR = class extends p4 {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: r, moved: i }) => this.options.onDrop(n, r, i)), this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = r5(n5, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const r = gR(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r });
    return this.view.updateState(i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let r = n;
    if ([].concat(e).forEach((s) => {
      const o = typeof s == "string" ? `${s}$` : s.key;
      r = n.filter((a) => !a.key.startsWith(o));
    }), n.length === r.length)
      return;
    const i = this.state.reconfigure({
      plugins: r
    });
    return this.view.updateState(i), i;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const i = [...this.options.enableCoreExtensions ? [
      JV,
      O4.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      YV,
      ZV,
      QV,
      t5,
      XV,
      e5
    ].filter((s) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== !1 : !0) : [], ...this.options.extensions].filter((s) => ["extension", "node", "mark"].includes(s == null ? void 0 : s.type));
    this.extensionManager = new Yl(i, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Tv({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    let e;
    try {
      e = Py(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (s) {
      if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((o) => o.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = Py(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const n = bR(e, this.options.autofocus);
    this.view = new IU(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Kl.create({
        doc: e,
        selection: n || void 0
      })
    }), this.view.dom.setAttribute("role", "textbox"), this.view.dom.getAttribute("aria-label") || this.view.dom.setAttribute("aria-label", "Rich-Text Editor");
    const r = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(r), this.createNodeViews(), this.prependClass();
    const i = this.view.dom;
    i.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((o) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o);
      });
      return;
    }
    const n = this.state.apply(e), r = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), s = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), s && this.emit("blur", {
      editor: this,
      event: s.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return b_(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null, i = typeof e == "string" ? n : e;
    return OV(this.state, r, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return EV(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
    return SV(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...vR(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return w_(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new ra(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Va(t) {
  return new Mv({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = lt(t.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, o = r[r.length - 1], a = r[0];
      if (o) {
        const l = a.search(/\S/), c = n.from + a.indexOf(o), u = c + o.length;
        if (y_(n.from, n.to, e.doc).filter((h) => h.mark.type.excluded.find((g) => g === t.type && g !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        u < n.to && s.delete(u, n.to), c > n.from && s.delete(n.from + l, c);
        const f = n.from + l + o.length;
        s.addMark(n.from + l, f, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function kR(t) {
  return new Mv({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = lt(t.getAttributes, void 0, r) || {}, { tr: s } = e, o = n.from;
      let a = n.to;
      const l = t.type.create(i);
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1]);
        let u = o + c;
        u > a ? u = a : a = u + r[1].length;
        const d = r[0][r[0].length - 1];
        s.insertText(d, o + r[0].length - 1), s.replaceWith(u, a, l);
      } else if (r[0]) {
        const c = t.type.isInline ? o : o - 1;
        s.insert(c, t.type.create(i)).delete(s.mapping.map(o), s.mapping.map(a));
      }
      s.scrollIntoView();
    }
  });
}
function Fy(t) {
  return new Mv({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = e.doc.resolve(n.from), s = lt(t.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s);
    }
  });
}
function Ec(t) {
  return new Mv({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: i }) => {
      const s = lt(t.getAttributes, void 0, r) || {}, o = e.tr.delete(n.from, n.to), l = o.doc.resolve(n.from).blockRange(), c = l && i_(l, t.type, s);
      if (!c)
        return null;
      if (o.wrap(l, c), t.keepMarks && t.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: h } = t.editor.extensionManager, p = f || d.$to.parentOffset && d.$from.marks();
        if (p) {
          const g = p.filter((m) => h.includes(m.type.name));
          o.ensureMarks(g);
        }
      }
      if (t.keepAttributes) {
        const d = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(d, s).run();
      }
      const u = o.doc.resolve(n.from - 1).nodeBefore;
      u && u.type === t.type && Fo(o.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, u)) && o.join(n.from - 1);
    }
  });
}
let an = class zy {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = lt(Le(this, "addOptions", {
      name: this.name
    }))), this.storage = lt(Le(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new zy(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Av(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new zy(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = lt(Le(n, "addOptions", {
      name: n.name
    })), n.storage = lt(Le(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function i5() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
class s5 {
  constructor(e, n, r) {
    this.isDragging = !1, this.component = e, this.editor = n.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...r
    }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.innerDecorations = n.innerDecorations, this.view = n.view, this.HTMLAttributes = n.HTMLAttributes, this.getPos = n.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var n, r, i, s, o, a, l;
    const { view: c } = this.editor, u = e.target, d = u.nodeType === 3 ? (n = u.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
    if (!this.dom || !((r = this.contentDOM) === null || r === void 0) && r.contains(u) || !d)
      return;
    let f = 0, h = 0;
    if (this.dom !== d) {
      const v = this.dom.getBoundingClientRect(), y = d.getBoundingClientRect(), E = (i = e.offsetX) !== null && i !== void 0 ? i : (s = e.nativeEvent) === null || s === void 0 ? void 0 : s.offsetX, b = (o = e.offsetY) !== null && o !== void 0 ? o : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
      f = y.x - v.x + E, h = y.y - v.y + b;
    }
    (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(this.dom, f, h);
    const p = this.getPos();
    if (typeof p != "number")
      return;
    const g = ve.create(c.state.doc, p), m = c.state.tr.setSelection(g);
    c.dispatch(m);
  }
  stopEvent(e) {
    var n;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const r = e.target;
    if (!(this.dom.contains(r) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(r))))
      return !1;
    const s = e.type.startsWith("drag"), o = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) || r.isContentEditable) && !o && !s)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, d = ve.isSelectable(this.node), f = e.type === "copy", h = e.type === "paste", p = e.type === "cut", g = e.type === "mousedown";
    if (!u && d && s && e.preventDefault(), u && s && !c)
      return e.preventDefault(), !1;
    if (u && l && !c && g) {
      const m = r.closest("[data-drag-handle]");
      m && (this.dom === m || this.dom.contains(m)) && (this.isDragging = !0, document.addEventListener("dragend", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("drop", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("mouseup", () => {
        this.isDragging = !1;
      }, { once: !0 }));
    }
    return !(c || o || f || h || p || g && d);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (Rv() || i5()) && this.editor.isFocused && [
      ...Array.from(e.addedNodes),
      ...Array.from(e.removedNodes)
    ].every((r) => r.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: n }) => {
      const r = this.getPos();
      return typeof r != "number" ? !1 : (n.setNodeMarkup(r, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const n = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: n });
  }
}
function No(t) {
  return new E4({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: i }) => {
      const s = lt(t.getAttributes, void 0, r, i);
      if (s === !1 || s === null)
        return null;
      const { tr: o } = e, a = r[r.length - 1], l = r[0];
      let c = n.to;
      if (a) {
        const u = l.search(/\S/), d = n.from + l.indexOf(a), f = d + a.length;
        if (y_(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((m) => m === t.type && m !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        f < n.to && o.delete(f, n.to), d > n.from && o.delete(n.from + u, d), c = n.from + u + a.length, o.addMark(n.from + u, c, t.type.create(s || {})), o.removeStoredMark(t.type);
      }
    }
  });
}
function o5(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var fr = "top", si = "bottom", oi = "right", hr = "left", __ = "auto", Lf = [fr, si, oi, hr], Sc = "start", Id = "end", a5 = "clippingParents", CR = "viewport", gu = "popper", l5 = "reference", Sk = /* @__PURE__ */ Lf.reduce(function(t, e) {
  return t.concat([e + "-" + Sc, e + "-" + Id]);
}, []), TR = /* @__PURE__ */ [].concat(Lf, [__]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Sc, e + "-" + Id]);
}, []), c5 = "beforeRead", u5 = "read", d5 = "afterRead", f5 = "beforeMain", h5 = "main", p5 = "afterMain", g5 = "beforeWrite", m5 = "write", v5 = "afterWrite", b5 = [c5, u5, d5, f5, h5, p5, g5, m5, v5];
function as(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function Fr(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Wa(t) {
  var e = Fr(t).Element;
  return t instanceof e || t instanceof Element;
}
function ei(t) {
  var e = Fr(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function E_(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Fr(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function y5(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !ei(s) || !as(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function w5(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = o.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !ei(i) || !as(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const OR = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: y5,
  effect: w5,
  requires: ["computeStyles"]
};
function Qi(t) {
  return t.split("-")[0];
}
var Ta = Math.max, _g = Math.min, xc = Math.round;
function Hy() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function MR() {
  return !/^((?!chrome|android).)*safari/i.test(Hy());
}
function kc(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var r = t.getBoundingClientRect(), i = 1, s = 1;
  e && ei(t) && (i = t.offsetWidth > 0 && xc(r.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && xc(r.height) / t.offsetHeight || 1);
  var o = Wa(t) ? Fr(t) : window, a = o.visualViewport, l = !MR() && n, c = (r.left + (l && a ? a.offsetLeft : 0)) / i, u = (r.top + (l && a ? a.offsetTop : 0)) / s, d = r.width / i, f = r.height / s;
  return {
    width: d,
    height: f,
    top: u,
    right: c + d,
    bottom: u + f,
    left: c,
    x: c,
    y: u
  };
}
function S_(t) {
  var e = kc(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}
function AR(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && E_(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Vs(t) {
  return Fr(t).getComputedStyle(t);
}
function _5(t) {
  return ["table", "td", "th"].indexOf(as(t)) >= 0;
}
function Uo(t) {
  return ((Wa(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function Pv(t) {
  return as(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (E_(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Uo(t)
  );
}
function xk(t) {
  return !ei(t) || // https://github.com/popperjs/popper-core/issues/837
  Vs(t).position === "fixed" ? null : t.offsetParent;
}
function E5(t) {
  var e = /firefox/i.test(Hy()), n = /Trident/i.test(Hy());
  if (n && ei(t)) {
    var r = Vs(t);
    if (r.position === "fixed")
      return null;
  }
  var i = Pv(t);
  for (E_(i) && (i = i.host); ei(i) && ["html", "body"].indexOf(as(i)) < 0; ) {
    var s = Vs(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function $f(t) {
  for (var e = Fr(t), n = xk(t); n && _5(n) && Vs(n).position === "static"; )
    n = xk(n);
  return n && (as(n) === "html" || as(n) === "body" && Vs(n).position === "static") ? e : n || E5(t) || e;
}
function x_(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function td(t, e, n) {
  return Ta(t, _g(e, n));
}
function S5(t, e, n) {
  var r = td(t, e, n);
  return r > n ? n : r;
}
function NR() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function RR(t) {
  return Object.assign({}, NR(), t);
}
function DR(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var x5 = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, RR(typeof e != "number" ? e : DR(e, Lf));
};
function k5(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = Qi(n.placement), l = x_(a), c = [hr, oi].indexOf(a) >= 0, u = c ? "height" : "width";
  if (!(!s || !o)) {
    var d = x5(i.padding, n), f = S_(s), h = l === "y" ? fr : hr, p = l === "y" ? si : oi, g = n.rects.reference[u] + n.rects.reference[l] - o[l] - n.rects.popper[u], m = o[l] - n.rects.reference[l], v = $f(s), y = v ? l === "y" ? v.clientHeight || 0 : v.clientWidth || 0 : 0, E = g / 2 - m / 2, b = d[h], _ = y - f[u] - d[p], w = y / 2 - f[u] / 2 + E, S = td(b, w, _), x = l;
    n.modifiersData[r] = (e = {}, e[x] = S, e.centerOffset = S - w, e);
  }
}
function C5(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || AR(e.elements.popper, i) && (e.elements.arrow = i));
}
const T5 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: k5,
  effect: C5,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Cc(t) {
  return t.split("-")[1];
}
var O5 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function M5(t, e) {
  var n = t.x, r = t.y, i = e.devicePixelRatio || 1;
  return {
    x: xc(n * i) / i || 0,
    y: xc(r * i) / i || 0
  };
}
function kk(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, d = t.isFixed, f = o.x, h = f === void 0 ? 0 : f, p = o.y, g = p === void 0 ? 0 : p, m = typeof u == "function" ? u({
    x: h,
    y: g
  }) : {
    x: h,
    y: g
  };
  h = m.x, g = m.y;
  var v = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), E = hr, b = fr, _ = window;
  if (c) {
    var w = $f(n), S = "clientHeight", x = "clientWidth";
    if (w === Fr(n) && (w = Uo(n), Vs(w).position !== "static" && a === "absolute" && (S = "scrollHeight", x = "scrollWidth")), w = w, i === fr || (i === hr || i === oi) && s === Id) {
      b = si;
      var k = d && w === _ && _.visualViewport ? _.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[S]
      );
      g -= k - r.height, g *= l ? 1 : -1;
    }
    if (i === hr || (i === fr || i === si) && s === Id) {
      E = oi;
      var T = d && w === _ && _.visualViewport ? _.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[x]
      );
      h -= T - r.width, h *= l ? 1 : -1;
    }
  }
  var I = Object.assign({
    position: a
  }, c && O5), R = u === !0 ? M5({
    x: h,
    y: g
  }, Fr(n)) : {
    x: h,
    y: g
  };
  if (h = R.x, g = R.y, l) {
    var N;
    return Object.assign({}, I, (N = {}, N[b] = y ? "0" : "", N[E] = v ? "0" : "", N.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + g + "px)" : "translate3d(" + h + "px, " + g + "px, 0)", N));
  }
  return Object.assign({}, I, (e = {}, e[b] = y ? g + "px" : "", e[E] = v ? h + "px" : "", e.transform = "", e));
}
function A5(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: Qi(e.placement),
    variation: Cc(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, kk(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, kk(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const N5 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: A5,
  data: {}
};
var gh = {
  passive: !0
};
function R5(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, l = Fr(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, gh);
  }), a && l.addEventListener("resize", n.update, gh), function() {
    s && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, gh);
    }), a && l.removeEventListener("resize", n.update, gh);
  };
}
const D5 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: R5,
  data: {}
};
var I5 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function _p(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return I5[e];
  });
}
var P5 = {
  start: "end",
  end: "start"
};
function Ck(t) {
  return t.replace(/start|end/g, function(e) {
    return P5[e];
  });
}
function k_(t) {
  var e = Fr(t), n = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function C_(t) {
  return kc(Uo(t)).left + k_(t).scrollLeft;
}
function L5(t, e) {
  var n = Fr(t), r = Uo(t), i = n.visualViewport, s = r.clientWidth, o = r.clientHeight, a = 0, l = 0;
  if (i) {
    s = i.width, o = i.height;
    var c = MR();
    (c || !c && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a + C_(t),
    y: l
  };
}
function $5(t) {
  var e, n = Uo(t), r = k_(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = Ta(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Ta(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + C_(t), l = -r.scrollTop;
  return Vs(i || n).direction === "rtl" && (a += Ta(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function T_(t) {
  var e = Vs(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function IR(t) {
  return ["html", "body", "#document"].indexOf(as(t)) >= 0 ? t.ownerDocument.body : ei(t) && T_(t) ? t : IR(Pv(t));
}
function nd(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = IR(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Fr(r), o = i ? [s].concat(s.visualViewport || [], T_(r) ? r : []) : r, a = e.concat(o);
  return i ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(nd(Pv(o)))
  );
}
function Uy(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function B5(t, e) {
  var n = kc(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function Tk(t, e, n) {
  return e === CR ? Uy(L5(t, n)) : Wa(e) ? B5(e, n) : Uy($5(Uo(t)));
}
function F5(t) {
  var e = nd(Pv(t)), n = ["absolute", "fixed"].indexOf(Vs(t).position) >= 0, r = n && ei(t) ? $f(t) : t;
  return Wa(r) ? e.filter(function(i) {
    return Wa(i) && AR(i, r) && as(i) !== "body";
  }) : [];
}
function z5(t, e, n, r) {
  var i = e === "clippingParents" ? F5(t) : [].concat(e), s = [].concat(i, [n]), o = s[0], a = s.reduce(function(l, c) {
    var u = Tk(t, c, r);
    return l.top = Ta(u.top, l.top), l.right = _g(u.right, l.right), l.bottom = _g(u.bottom, l.bottom), l.left = Ta(u.left, l.left), l;
  }, Tk(t, o, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function PR(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? Qi(r) : null, s = r ? Cc(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (i) {
    case fr:
      l = {
        x: o,
        y: e.y - n.height
      };
      break;
    case si:
      l = {
        x: o,
        y: e.y + e.height
      };
      break;
    case oi:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case hr:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = i ? x_(i) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (s) {
      case Sc:
        l[c] = l[c] - (e[u] / 2 - n[u] / 2);
        break;
      case Id:
        l[c] = l[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function Pd(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.strategy, o = s === void 0 ? t.strategy : s, a = n.boundary, l = a === void 0 ? a5 : a, c = n.rootBoundary, u = c === void 0 ? CR : c, d = n.elementContext, f = d === void 0 ? gu : d, h = n.altBoundary, p = h === void 0 ? !1 : h, g = n.padding, m = g === void 0 ? 0 : g, v = RR(typeof m != "number" ? m : DR(m, Lf)), y = f === gu ? l5 : gu, E = t.rects.popper, b = t.elements[p ? y : f], _ = z5(Wa(b) ? b : b.contextElement || Uo(t.elements.popper), l, u, o), w = kc(t.elements.reference), S = PR({
    reference: w,
    element: E,
    strategy: "absolute",
    placement: i
  }), x = Uy(Object.assign({}, E, S)), k = f === gu ? x : w, T = {
    top: _.top - k.top + v.top,
    bottom: k.bottom - _.bottom + v.bottom,
    left: _.left - k.left + v.left,
    right: k.right - _.right + v.right
  }, I = t.modifiersData.offset;
  if (f === gu && I) {
    var R = I[i];
    Object.keys(T).forEach(function(N) {
      var $ = [oi, si].indexOf(N) >= 0 ? 1 : -1, B = [fr, si].indexOf(N) >= 0 ? "y" : "x";
      T[N] += R[B] * $;
    });
  }
  return T;
}
function H5(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? TR : l, u = Cc(r), d = u ? a ? Sk : Sk.filter(function(p) {
    return Cc(p) === u;
  }) : Lf, f = d.filter(function(p) {
    return c.indexOf(p) >= 0;
  });
  f.length === 0 && (f = d);
  var h = f.reduce(function(p, g) {
    return p[g] = Pd(t, {
      placement: g,
      boundary: i,
      rootBoundary: s,
      padding: o
    })[Qi(g)], p;
  }, {});
  return Object.keys(h).sort(function(p, g) {
    return h[p] - h[g];
  });
}
function U5(t) {
  if (Qi(t) === __)
    return [];
  var e = _p(t);
  return [Ck(t), e, Ck(e)];
}
function V5(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, h = n.flipVariations, p = h === void 0 ? !0 : h, g = n.allowedAutoPlacements, m = e.options.placement, v = Qi(m), y = v === m, E = l || (y || !p ? [_p(m)] : U5(m)), b = [m].concat(E).reduce(function(ie, Z) {
      return ie.concat(Qi(Z) === __ ? H5(e, {
        placement: Z,
        boundary: u,
        rootBoundary: d,
        padding: c,
        flipVariations: p,
        allowedAutoPlacements: g
      }) : Z);
    }, []), _ = e.rects.reference, w = e.rects.popper, S = /* @__PURE__ */ new Map(), x = !0, k = b[0], T = 0; T < b.length; T++) {
      var I = b[T], R = Qi(I), N = Cc(I) === Sc, $ = [fr, si].indexOf(R) >= 0, B = $ ? "width" : "height", G = Pd(e, {
        placement: I,
        boundary: u,
        rootBoundary: d,
        altBoundary: f,
        padding: c
      }), M = $ ? N ? oi : hr : N ? si : fr;
      _[B] > w[B] && (M = _p(M));
      var A = _p(M), z = [];
      if (s && z.push(G[R] <= 0), a && z.push(G[M] <= 0, G[A] <= 0), z.every(function(ie) {
        return ie;
      })) {
        k = I, x = !1;
        break;
      }
      S.set(I, z);
    }
    if (x)
      for (var V = p ? 3 : 1, U = function(Z) {
        var Q = b.find(function(fe) {
          var ge = S.get(fe);
          if (ge)
            return ge.slice(0, Z).every(function(Re) {
              return Re;
            });
        });
        if (Q)
          return k = Q, "break";
      }, Y = V; Y > 0; Y--) {
        var ne = U(Y);
        if (ne === "break")
          break;
      }
    e.placement !== k && (e.modifiersData[r]._skip = !0, e.placement = k, e.reset = !0);
  }
}
const W5 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: V5,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Ok(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function Mk(t) {
  return [fr, oi, si, hr].some(function(e) {
    return t[e] >= 0;
  });
}
function G5(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, o = Pd(e, {
    elementContext: "reference"
  }), a = Pd(e, {
    altBoundary: !0
  }), l = Ok(o, r), c = Ok(a, i, s), u = Mk(l), d = Mk(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
const j5 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: G5
};
function q5(t, e, n) {
  var r = Qi(t), i = [hr, fr].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [hr, oi].indexOf(r) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function K5(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = TR.reduce(function(u, d) {
    return u[d] = q5(d, e.rects, s), u;
  }, {}), a = o[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = o;
}
const Y5 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: K5
};
function X5(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = PR({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const J5 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: X5,
  data: {}
};
function Z5(t) {
  return t === "x" ? "y" : "x";
}
function Q5(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, f = n.tether, h = f === void 0 ? !0 : f, p = n.tetherOffset, g = p === void 0 ? 0 : p, m = Pd(e, {
    boundary: l,
    rootBoundary: c,
    padding: d,
    altBoundary: u
  }), v = Qi(e.placement), y = Cc(e.placement), E = !y, b = x_(v), _ = Z5(b), w = e.modifiersData.popperOffsets, S = e.rects.reference, x = e.rects.popper, k = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, T = typeof k == "number" ? {
    mainAxis: k,
    altAxis: k
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, k), I = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, R = {
    x: 0,
    y: 0
  };
  if (w) {
    if (s) {
      var N, $ = b === "y" ? fr : hr, B = b === "y" ? si : oi, G = b === "y" ? "height" : "width", M = w[b], A = M + m[$], z = M - m[B], V = h ? -x[G] / 2 : 0, U = y === Sc ? S[G] : x[G], Y = y === Sc ? -x[G] : -S[G], ne = e.elements.arrow, ie = h && ne ? S_(ne) : {
        width: 0,
        height: 0
      }, Z = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : NR(), Q = Z[$], fe = Z[B], ge = td(0, S[G], ie[G]), Re = E ? S[G] / 2 - V - ge - Q - T.mainAxis : U - ge - Q - T.mainAxis, Be = E ? -S[G] / 2 + V + ge + fe + T.mainAxis : Y + ge + fe + T.mainAxis, le = e.elements.arrow && $f(e.elements.arrow), Ee = le ? b === "y" ? le.clientTop || 0 : le.clientLeft || 0 : 0, Se = (N = I == null ? void 0 : I[b]) != null ? N : 0, xe = M + Re - Se - Ee, Ce = M + Be - Se, _e = td(h ? _g(A, xe) : A, M, h ? Ta(z, Ce) : z);
      w[b] = _e, R[b] = _e - M;
    }
    if (a) {
      var Je, P = b === "x" ? fr : hr, O = b === "x" ? si : oi, q = w[_], ee = _ === "y" ? "height" : "width", ce = q + m[P], Pe = q - m[O], ye = [fr, hr].indexOf(v) !== -1, j = (Je = I == null ? void 0 : I[_]) != null ? Je : 0, re = ye ? ce : q - S[ee] - x[ee] - j + T.altAxis, H = ye ? q + S[ee] + x[ee] - j - T.altAxis : Pe, K = h && ye ? S5(re, q, H) : td(h ? re : ce, q, h ? H : Pe);
      w[_] = K, R[_] = K - q;
    }
    e.modifiersData[r] = R;
  }
}
const e8 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Q5,
  requiresIfExists: ["offset"]
};
function t8(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function n8(t) {
  return t === Fr(t) || !ei(t) ? k_(t) : t8(t);
}
function r8(t) {
  var e = t.getBoundingClientRect(), n = xc(e.width) / t.offsetWidth || 1, r = xc(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function i8(t, e, n) {
  n === void 0 && (n = !1);
  var r = ei(e), i = ei(e) && r8(e), s = Uo(e), o = kc(t, i, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((as(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  T_(s)) && (a = n8(e)), ei(e) ? (l = kc(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = C_(s))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function s8(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function o8(t) {
  var e = s8(t);
  return b5.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function a8(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function l8(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Ak = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Nk() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function c8(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? Ak : i;
  return function(a, l, c) {
    c === void 0 && (c = s);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Ak, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, h = {
      state: u,
      setOptions: function(v) {
        var y = typeof v == "function" ? v(u.options) : v;
        g(), u.options = Object.assign({}, s, u.options, y), u.scrollParents = {
          reference: Wa(a) ? nd(a) : a.contextElement ? nd(a.contextElement) : [],
          popper: nd(l)
        };
        var E = o8(l8([].concat(r, u.options.modifiers)));
        return u.orderedModifiers = E.filter(function(b) {
          return b.enabled;
        }), p(), h.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var v = u.elements, y = v.reference, E = v.popper;
          if (Nk(y, E)) {
            u.rects = {
              reference: i8(y, $f(E), u.options.strategy === "fixed"),
              popper: S_(E)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(T) {
              return u.modifiersData[T.name] = Object.assign({}, T.data);
            });
            for (var b = 0; b < u.orderedModifiers.length; b++) {
              if (u.reset === !0) {
                u.reset = !1, b = -1;
                continue;
              }
              var _ = u.orderedModifiers[b], w = _.fn, S = _.options, x = S === void 0 ? {} : S, k = _.name;
              typeof w == "function" && (u = w({
                state: u,
                options: x,
                name: k,
                instance: h
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: a8(function() {
        return new Promise(function(m) {
          h.forceUpdate(), m(u);
        });
      }),
      destroy: function() {
        g(), f = !0;
      }
    };
    if (!Nk(a, l))
      return h;
    h.setOptions(c).then(function(m) {
      !f && c.onFirstUpdate && c.onFirstUpdate(m);
    });
    function p() {
      u.orderedModifiers.forEach(function(m) {
        var v = m.name, y = m.options, E = y === void 0 ? {} : y, b = m.effect;
        if (typeof b == "function") {
          var _ = b({
            state: u,
            name: v,
            instance: h,
            options: E
          }), w = function() {
          };
          d.push(_ || w);
        }
      });
    }
    function g() {
      d.forEach(function(m) {
        return m();
      }), d = [];
    }
    return h;
  };
}
var u8 = [D5, J5, N5, OR, Y5, W5, e8, T5, j5], d8 = /* @__PURE__ */ c8({
  defaultModifiers: u8
}), f8 = "tippy-box", LR = "tippy-content", h8 = "tippy-backdrop", $R = "tippy-arrow", BR = "tippy-svg-arrow", ea = {
  passive: !0,
  capture: !0
}, FR = function() {
  return document.body;
};
function p8(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function tb(t, e, n) {
  if (Array.isArray(t)) {
    var r = t[e];
    return r ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function O_(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function zR(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function Rk(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(r) {
    clearTimeout(n), n = setTimeout(function() {
      t(r);
    }, e);
  };
}
function g8(t, e) {
  var n = Object.assign({}, t);
  return e.forEach(function(r) {
    delete n[r];
  }), n;
}
function m8(t) {
  return t.split(/\s+/).filter(Boolean);
}
function Ll(t) {
  return [].concat(t);
}
function Dk(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function v8(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function b8(t) {
  return t.split("-")[0];
}
function Eg(t) {
  return [].slice.call(t);
}
function Ik(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function rd() {
  return document.createElement("div");
}
function Ld(t) {
  return ["Element", "Fragment"].some(function(e) {
    return O_(t, e);
  });
}
function y8(t) {
  return O_(t, "NodeList");
}
function w8(t) {
  return O_(t, "MouseEvent");
}
function _8(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function E8(t) {
  return Ld(t) ? [t] : y8(t) ? Eg(t) : Array.isArray(t) ? t : Eg(document.querySelectorAll(t));
}
function nb(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function Pk(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function S8(t) {
  var e, n = Ll(t), r = n[0];
  return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
}
function x8(t, e) {
  var n = e.clientX, r = e.clientY;
  return t.every(function(i) {
    var s = i.popperRect, o = i.popperState, a = i.props, l = a.interactiveBorder, c = b8(o.placement), u = o.modifiersData.offset;
    if (!u)
      return !0;
    var d = c === "bottom" ? u.top.y : 0, f = c === "top" ? u.bottom.y : 0, h = c === "right" ? u.left.x : 0, p = c === "left" ? u.right.x : 0, g = s.top - r + d > l, m = r - s.bottom - f > l, v = s.left - n + h > l, y = n - s.right - p > l;
    return g || m || v || y;
  });
}
function rb(t, e, n) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    t[r](i, n);
  });
}
function Lk(t, e) {
  for (var n = e; n; ) {
    var r;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var Ki = {
  isTouch: !1
}, $k = 0;
function k8() {
  Ki.isTouch || (Ki.isTouch = !0, window.performance && document.addEventListener("mousemove", HR));
}
function HR() {
  var t = performance.now();
  t - $k < 20 && (Ki.isTouch = !1, document.removeEventListener("mousemove", HR)), $k = t;
}
function C8() {
  var t = document.activeElement;
  if (_8(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function T8() {
  document.addEventListener("touchstart", k8, ea), window.addEventListener("blur", C8);
}
var O8 = typeof window < "u" && typeof document < "u", M8 = O8 ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function El(t) {
  var e = t === "destroy" ? "n already-" : " ";
  return [t + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function Bk(t) {
  var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return t.replace(e, " ").replace(n, "").trim();
}
function A8(t) {
  return Bk(`
  %ctippy.js

  %c` + Bk(t) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function UR(t) {
  return [
    A8(t),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var $d;
process.env.NODE_ENV !== "production" && N8();
function N8() {
  $d = /* @__PURE__ */ new Set();
}
function Ns(t, e) {
  if (t && !$d.has(e)) {
    var n;
    $d.add(e), (n = console).warn.apply(n, UR(e));
  }
}
function Vy(t, e) {
  if (t && !$d.has(e)) {
    var n;
    $d.add(e), (n = console).error.apply(n, UR(e));
  }
}
function R8(t) {
  var e = !t, n = Object.prototype.toString.call(t) === "[object Object]" && !t.addEventListener;
  Vy(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), Vy(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var VR = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, D8 = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, Mr = Object.assign({
  appendTo: FR,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, VR, D8), I8 = Object.keys(Mr), P8 = function(e) {
  process.env.NODE_ENV !== "production" && GR(e, []);
  var n = Object.keys(e);
  n.forEach(function(r) {
    Mr[r] = e[r];
  });
};
function WR(t) {
  var e = t.plugins || [], n = e.reduce(function(r, i) {
    var s = i.name, o = i.defaultValue;
    if (s) {
      var a;
      r[s] = t[s] !== void 0 ? t[s] : (a = Mr[s]) != null ? a : o;
    }
    return r;
  }, {});
  return Object.assign({}, t, n);
}
function L8(t, e) {
  var n = e ? Object.keys(WR(Object.assign({}, Mr, {
    plugins: e
  }))) : I8, r = n.reduce(function(i, s) {
    var o = (t.getAttribute("data-tippy-" + s) || "").trim();
    if (!o)
      return i;
    if (s === "content")
      i[s] = o;
    else
      try {
        i[s] = JSON.parse(o);
      } catch {
        i[s] = o;
      }
    return i;
  }, {});
  return r;
}
function Fk(t, e) {
  var n = Object.assign({}, e, {
    content: zR(e.content, [t])
  }, e.ignoreAttributes ? {} : L8(t, e.plugins));
  return n.aria = Object.assign({}, Mr.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function GR(t, e) {
  t === void 0 && (t = {}), e === void 0 && (e = []);
  var n = Object.keys(t);
  n.forEach(function(r) {
    var i = g8(Mr, Object.keys(VR)), s = !p8(i, r);
    s && (s = e.filter(function(o) {
      return o.name === r;
    }).length === 0), Ns(s, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var $8 = function() {
  return "innerHTML";
};
function Wy(t, e) {
  t[$8()] = e;
}
function zk(t) {
  var e = rd();
  return t === !0 ? e.className = $R : (e.className = BR, Ld(t) ? e.appendChild(t) : Wy(e, t)), e;
}
function Hk(t, e) {
  Ld(e.content) ? (Wy(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? Wy(t, e.content) : t.textContent = e.content);
}
function Gy(t) {
  var e = t.firstElementChild, n = Eg(e.children);
  return {
    box: e,
    content: n.find(function(r) {
      return r.classList.contains(LR);
    }),
    arrow: n.find(function(r) {
      return r.classList.contains($R) || r.classList.contains(BR);
    }),
    backdrop: n.find(function(r) {
      return r.classList.contains(h8);
    })
  };
}
function jR(t) {
  var e = rd(), n = rd();
  n.className = f8, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var r = rd();
  r.className = LR, r.setAttribute("data-state", "hidden"), Hk(r, t.props), e.appendChild(n), n.appendChild(r), i(t.props, t.props);
  function i(s, o) {
    var a = Gy(e), l = a.box, c = a.content, u = a.arrow;
    o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (s.content !== o.content || s.allowHTML !== o.allowHTML) && Hk(c, t.props), o.arrow ? u ? s.arrow !== o.arrow && (l.removeChild(u), l.appendChild(zk(o.arrow))) : l.appendChild(zk(o.arrow)) : u && l.removeChild(u);
  }
  return {
    popper: e,
    onUpdate: i
  };
}
jR.$$tippy = !0;
var B8 = 1, mh = [], ib = [];
function F8(t, e) {
  var n = Fk(t, Object.assign({}, Mr, WR(Ik(e)))), r, i, s, o = !1, a = !1, l = !1, c = !1, u, d, f, h = [], p = Rk(xe, n.interactiveDebounce), g, m = B8++, v = null, y = v8(n.plugins), E = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: m,
    reference: t,
    popper: rd(),
    popperInstance: v,
    props: n,
    state: E,
    plugins: y,
    // methods
    clearDelayTimeouts: re,
    setProps: H,
    setContent: K,
    show: de,
    hide: Oe,
    hideWithInteractivity: Xe,
    enable: ye,
    disable: j,
    unmount: pt,
    destroy: hi
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && Vy(!0, "render() function has not been supplied."), b;
  var _ = n.render(b), w = _.popper, S = _.onUpdate;
  w.setAttribute("data-tippy-root", ""), w.id = "tippy-" + b.id, b.popper = w, t._tippy = b, w._tippy = b;
  var x = y.map(function(D) {
    return D.fn(b);
  }), k = t.hasAttribute("aria-expanded");
  return le(), V(), M(), A("onCreate", [b]), n.showOnCreate && ce(), w.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), w.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && $().addEventListener("mousemove", p);
  }), b;
  function T() {
    var D = b.props.touch;
    return Array.isArray(D) ? D : [D, 0];
  }
  function I() {
    return T()[0] === "hold";
  }
  function R() {
    var D;
    return !!((D = b.props.render) != null && D.$$tippy);
  }
  function N() {
    return g || t;
  }
  function $() {
    var D = N().parentNode;
    return D ? S8(D) : document;
  }
  function B() {
    return Gy(w);
  }
  function G(D) {
    return b.state.isMounted && !b.state.isVisible || Ki.isTouch || u && u.type === "focus" ? 0 : tb(b.props.delay, D ? 0 : 1, Mr.delay);
  }
  function M(D) {
    D === void 0 && (D = !1), w.style.pointerEvents = b.props.interactive && !D ? "" : "none", w.style.zIndex = "" + b.props.zIndex;
  }
  function A(D, te, ue) {
    if (ue === void 0 && (ue = !0), x.forEach(function(Ae) {
      Ae[D] && Ae[D].apply(Ae, te);
    }), ue) {
      var ze;
      (ze = b.props)[D].apply(ze, te);
    }
  }
  function z() {
    var D = b.props.aria;
    if (D.content) {
      var te = "aria-" + D.content, ue = w.id, ze = Ll(b.props.triggerTarget || t);
      ze.forEach(function(Ae) {
        var gt = Ae.getAttribute(te);
        if (b.state.isVisible)
          Ae.setAttribute(te, gt ? gt + " " + ue : ue);
        else {
          var Ye = gt && gt.replace(ue, "").trim();
          Ye ? Ae.setAttribute(te, Ye) : Ae.removeAttribute(te);
        }
      });
    }
  }
  function V() {
    if (!(k || !b.props.aria.expanded)) {
      var D = Ll(b.props.triggerTarget || t);
      D.forEach(function(te) {
        b.props.interactive ? te.setAttribute("aria-expanded", b.state.isVisible && te === N() ? "true" : "false") : te.removeAttribute("aria-expanded");
      });
    }
  }
  function U() {
    $().removeEventListener("mousemove", p), mh = mh.filter(function(D) {
      return D !== p;
    });
  }
  function Y(D) {
    if (!(Ki.isTouch && (l || D.type === "mousedown"))) {
      var te = D.composedPath && D.composedPath()[0] || D.target;
      if (!(b.props.interactive && Lk(w, te))) {
        if (Ll(b.props.triggerTarget || t).some(function(ue) {
          return Lk(ue, te);
        })) {
          if (Ki.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          A("onClickOutside", [b, D]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), b.state.isMounted || Q());
      }
    }
  }
  function ne() {
    l = !0;
  }
  function ie() {
    l = !1;
  }
  function Z() {
    var D = $();
    D.addEventListener("mousedown", Y, !0), D.addEventListener("touchend", Y, ea), D.addEventListener("touchstart", ie, ea), D.addEventListener("touchmove", ne, ea);
  }
  function Q() {
    var D = $();
    D.removeEventListener("mousedown", Y, !0), D.removeEventListener("touchend", Y, ea), D.removeEventListener("touchstart", ie, ea), D.removeEventListener("touchmove", ne, ea);
  }
  function fe(D, te) {
    Re(D, function() {
      !b.state.isVisible && w.parentNode && w.parentNode.contains(w) && te();
    });
  }
  function ge(D, te) {
    Re(D, te);
  }
  function Re(D, te) {
    var ue = B().box;
    function ze(Ae) {
      Ae.target === ue && (rb(ue, "remove", ze), te());
    }
    if (D === 0)
      return te();
    rb(ue, "remove", d), rb(ue, "add", ze), d = ze;
  }
  function Be(D, te, ue) {
    ue === void 0 && (ue = !1);
    var ze = Ll(b.props.triggerTarget || t);
    ze.forEach(function(Ae) {
      Ae.addEventListener(D, te, ue), h.push({
        node: Ae,
        eventType: D,
        handler: te,
        options: ue
      });
    });
  }
  function le() {
    I() && (Be("touchstart", Se, {
      passive: !0
    }), Be("touchend", Ce, {
      passive: !0
    })), m8(b.props.trigger).forEach(function(D) {
      if (D !== "manual")
        switch (Be(D, Se), D) {
          case "mouseenter":
            Be("mouseleave", Ce);
            break;
          case "focus":
            Be(M8 ? "focusout" : "blur", _e);
            break;
          case "focusin":
            Be("focusout", _e);
            break;
        }
    });
  }
  function Ee() {
    h.forEach(function(D) {
      var te = D.node, ue = D.eventType, ze = D.handler, Ae = D.options;
      te.removeEventListener(ue, ze, Ae);
    }), h = [];
  }
  function Se(D) {
    var te, ue = !1;
    if (!(!b.state.isEnabled || Je(D) || a)) {
      var ze = ((te = u) == null ? void 0 : te.type) === "focus";
      u = D, g = D.currentTarget, V(), !b.state.isVisible && w8(D) && mh.forEach(function(Ae) {
        return Ae(D);
      }), D.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || o) && b.props.hideOnClick !== !1 && b.state.isVisible ? ue = !0 : ce(D), D.type === "click" && (o = !ue), ue && !ze && Pe(D);
    }
  }
  function xe(D) {
    var te = D.target, ue = N().contains(te) || w.contains(te);
    if (!(D.type === "mousemove" && ue)) {
      var ze = ee().concat(w).map(function(Ae) {
        var gt, Ye = Ae._tippy, xt = (gt = Ye.popperInstance) == null ? void 0 : gt.state;
        return xt ? {
          popperRect: Ae.getBoundingClientRect(),
          popperState: xt,
          props: n
        } : null;
      }).filter(Boolean);
      x8(ze, D) && (U(), Pe(D));
    }
  }
  function Ce(D) {
    var te = Je(D) || b.props.trigger.indexOf("click") >= 0 && o;
    if (!te) {
      if (b.props.interactive) {
        b.hideWithInteractivity(D);
        return;
      }
      Pe(D);
    }
  }
  function _e(D) {
    b.props.trigger.indexOf("focusin") < 0 && D.target !== N() || b.props.interactive && D.relatedTarget && w.contains(D.relatedTarget) || Pe(D);
  }
  function Je(D) {
    return Ki.isTouch ? I() !== D.type.indexOf("touch") >= 0 : !1;
  }
  function P() {
    O();
    var D = b.props, te = D.popperOptions, ue = D.placement, ze = D.offset, Ae = D.getReferenceClientRect, gt = D.moveTransition, Ye = R() ? Gy(w).arrow : null, xt = Ae ? {
      getBoundingClientRect: Ae,
      contextElement: Ae.contextElement || N()
    } : t, Js = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Er) {
        var Sr = Er.state;
        if (R()) {
          var M0 = B(), Yo = M0.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(ys) {
            ys === "placement" ? Yo.setAttribute("data-placement", Sr.placement) : Sr.attributes.popper["data-popper-" + ys] ? Yo.setAttribute("data-" + ys, "") : Yo.removeAttribute("data-" + ys);
          }), Sr.attributes.popper = {};
        }
      }
    }, vn = [{
      name: "offset",
      options: {
        offset: ze
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !gt
      }
    }, Js];
    R() && Ye && vn.push({
      name: "arrow",
      options: {
        element: Ye,
        padding: 3
      }
    }), vn.push.apply(vn, (te == null ? void 0 : te.modifiers) || []), b.popperInstance = d8(xt, w, Object.assign({}, te, {
      placement: ue,
      onFirstUpdate: f,
      modifiers: vn
    }));
  }
  function O() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function q() {
    var D = b.props.appendTo, te, ue = N();
    b.props.interactive && D === FR || D === "parent" ? te = ue.parentNode : te = zR(D, [ue]), te.contains(w) || te.appendChild(w), b.state.isMounted = !0, P(), process.env.NODE_ENV !== "production" && Ns(b.props.interactive && D === Mr.appendTo && ue.nextElementSibling !== w, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function ee() {
    return Eg(w.querySelectorAll("[data-tippy-root]"));
  }
  function ce(D) {
    b.clearDelayTimeouts(), D && A("onTrigger", [b, D]), Z();
    var te = G(!0), ue = T(), ze = ue[0], Ae = ue[1];
    Ki.isTouch && ze === "hold" && Ae && (te = Ae), te ? r = setTimeout(function() {
      b.show();
    }, te) : b.show();
  }
  function Pe(D) {
    if (b.clearDelayTimeouts(), A("onUntrigger", [b, D]), !b.state.isVisible) {
      Q();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(D.type) >= 0 && o)) {
      var te = G(!1);
      te ? i = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, te) : s = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function ye() {
    b.state.isEnabled = !0;
  }
  function j() {
    b.hide(), b.state.isEnabled = !1;
  }
  function re() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(s);
  }
  function H(D) {
    if (process.env.NODE_ENV !== "production" && Ns(b.state.isDestroyed, El("setProps")), !b.state.isDestroyed) {
      A("onBeforeUpdate", [b, D]), Ee();
      var te = b.props, ue = Fk(t, Object.assign({}, te, Ik(D), {
        ignoreAttributes: !0
      }));
      b.props = ue, le(), te.interactiveDebounce !== ue.interactiveDebounce && (U(), p = Rk(xe, ue.interactiveDebounce)), te.triggerTarget && !ue.triggerTarget ? Ll(te.triggerTarget).forEach(function(ze) {
        ze.removeAttribute("aria-expanded");
      }) : ue.triggerTarget && t.removeAttribute("aria-expanded"), V(), M(), S && S(te, ue), b.popperInstance && (P(), ee().forEach(function(ze) {
        requestAnimationFrame(ze._tippy.popperInstance.forceUpdate);
      })), A("onAfterUpdate", [b, D]);
    }
  }
  function K(D) {
    b.setProps({
      content: D
    });
  }
  function de() {
    process.env.NODE_ENV !== "production" && Ns(b.state.isDestroyed, El("show"));
    var D = b.state.isVisible, te = b.state.isDestroyed, ue = !b.state.isEnabled, ze = Ki.isTouch && !b.props.touch, Ae = tb(b.props.duration, 0, Mr.duration);
    if (!(D || te || ue || ze) && !N().hasAttribute("disabled") && (A("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, R() && (w.style.visibility = "visible"), M(), Z(), b.state.isMounted || (w.style.transition = "none"), R()) {
        var gt = B(), Ye = gt.box, xt = gt.content;
        nb([Ye, xt], 0);
      }
      f = function() {
        var vn;
        if (!(!b.state.isVisible || c)) {
          if (c = !0, w.offsetHeight, w.style.transition = b.props.moveTransition, R() && b.props.animation) {
            var bs = B(), Er = bs.box, Sr = bs.content;
            nb([Er, Sr], Ae), Pk([Er, Sr], "visible");
          }
          z(), V(), Dk(ib, b), (vn = b.popperInstance) == null || vn.forceUpdate(), A("onMount", [b]), b.props.animation && R() && ge(Ae, function() {
            b.state.isShown = !0, A("onShown", [b]);
          });
        }
      }, q();
    }
  }
  function Oe() {
    process.env.NODE_ENV !== "production" && Ns(b.state.isDestroyed, El("hide"));
    var D = !b.state.isVisible, te = b.state.isDestroyed, ue = !b.state.isEnabled, ze = tb(b.props.duration, 1, Mr.duration);
    if (!(D || te || ue) && (A("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, c = !1, o = !1, R() && (w.style.visibility = "hidden"), U(), Q(), M(!0), R()) {
        var Ae = B(), gt = Ae.box, Ye = Ae.content;
        b.props.animation && (nb([gt, Ye], ze), Pk([gt, Ye], "hidden"));
      }
      z(), V(), b.props.animation ? R() && fe(ze, b.unmount) : b.unmount();
    }
  }
  function Xe(D) {
    process.env.NODE_ENV !== "production" && Ns(b.state.isDestroyed, El("hideWithInteractivity")), $().addEventListener("mousemove", p), Dk(mh, p), p(D);
  }
  function pt() {
    process.env.NODE_ENV !== "production" && Ns(b.state.isDestroyed, El("unmount")), b.state.isVisible && b.hide(), b.state.isMounted && (O(), ee().forEach(function(D) {
      D._tippy.unmount();
    }), w.parentNode && w.parentNode.removeChild(w), ib = ib.filter(function(D) {
      return D !== b;
    }), b.state.isMounted = !1, A("onHidden", [b]));
  }
  function hi() {
    process.env.NODE_ENV !== "production" && Ns(b.state.isDestroyed, El("destroy")), !b.state.isDestroyed && (b.clearDelayTimeouts(), b.unmount(), Ee(), delete t._tippy, b.state.isDestroyed = !0, A("onDestroy", [b]));
  }
}
function Vo(t, e) {
  e === void 0 && (e = {});
  var n = Mr.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (R8(t), GR(e, n)), T8();
  var r = Object.assign({}, e, {
    plugins: n
  }), i = E8(t);
  if (process.env.NODE_ENV !== "production") {
    var s = Ld(r.content), o = i.length > 1;
    Ns(s && o, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = i.reduce(function(l, c) {
    var u = c && F8(c, r);
    return u && l.push(u), l;
  }, []);
  return Ld(t) ? a[0] : a;
}
Vo.defaultProps = Mr;
Vo.setDefaultProps = P8;
Vo.currentInput = Ki;
Object.assign({}, OR, {
  effect: function(e) {
    var n = e.state, r = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  }
});
Vo.setDefaultProps({
  render: jR
});
class z8 {
  constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, updateDelay: s = 250, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: c, to: u }) => {
      const { doc: d, selection: f } = l, { empty: h } = f, p = !d.textBetween(c, u).length && m_(l.selection), g = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || g) || h || p || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const c = !(l != null && l.selection.eq(a.state.selection)), u = !(l != null && l.doc.eq(a.state.doc));
      !c && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, c, u, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, c, u) => {
      var d, f, h;
      const { state: p, composing: g } = a, { selection: m } = p;
      if (g || !l && !c)
        return;
      this.createTooltip();
      const { ranges: y } = m, E = Math.min(...y.map((w) => w.$from.pos)), b = Math.max(...y.map((w) => w.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        view: a,
        state: p,
        oldState: u,
        from: E,
        to: b
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((h = this.tippyOptions) === null || h === void 0 ? void 0 : h.getReferenceClientRect) || (() => {
          if (ER(p.selection)) {
            let w = a.nodeDOM(E);
            const S = w.dataset.nodeViewWrapper ? w : w.querySelector("[data-node-view-wrapper]");
            if (S && (w = S.firstChild), w)
              return w.getBoundingClientRect();
          }
          return SR(a, E, b);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = r, this.updateDelay = s, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Vo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: r } = e, i = r.selection.from !== r.selection.to;
    if (this.updateDelay > 0 && i) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const s = !(n != null && n.selection.eq(e.state.selection)), o = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, s, o, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const qR = (t) => new ut({
  key: typeof t.pluginKey == "string" ? new ft(t.pluginKey) : t.pluginKey,
  view: (e) => new z8({ view: e, ...t })
});
Et.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      qR({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class H8 {
  constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: o, state: a }) => {
      const { selection: l } = a, { $anchor: c, empty: u } = l, d = c.depth === 1, f = c.parent.isTextblock && !c.parent.type.spec.code && !c.parent.textContent;
      return !(!o.hasFocus() || !u || !d || !f || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: o }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      o != null && o.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(o.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (o) => {
      this.blurHandler({ event: o });
    }, this.editor = e, this.element = n, this.view = r, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Vo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var r, i, s;
    const { state: o } = e, { doc: a, selection: l } = o, { from: c, to: u } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
      editor: this.editor,
      view: e,
      state: o,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (i = this.tippy) === null || i === void 0 || i.setProps({
      getReferenceClientRect: ((s = this.tippyOptions) === null || s === void 0 ? void 0 : s.getReferenceClientRect) || (() => SR(e, c, u))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const KR = (t) => new ut({
  key: typeof t.pluginKey == "string" ? new ft(t.pluginKey) : t.pluginKey,
  view: (e) => new H8({ view: e, ...t })
});
Et.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      KR({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const U8 = ae({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = X(null);
    return Zt(() => {
      const { updateDelay: r, editor: i, pluginKey: s, shouldShow: o, tippyOptions: a } = t;
      i.registerPlugin(qR({
        updateDelay: r,
        editor: i,
        element: n.value,
        pluginKey: s,
        shouldShow: o,
        tippyOptions: a
      }));
    }), Zc(() => {
      const { pluginKey: r, editor: i } = t;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return mt("div", { ref: n }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
    };
  }
});
function Uk(t) {
  return d3((e, n) => ({
    get() {
      return e(), t;
    },
    set(r) {
      t = r, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
class V8 extends xR {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = Uk(this.view.state), this.reactiveExtensionStorage = Uk(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), pA(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    const r = super.registerPlugin(e, n);
    return this.reactiveState && (this.reactiveState.value = r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const n = super.unregisterPlugin(e);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
}
const W8 = ae({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(t) {
    const e = X(), n = Oo();
    return ps(() => {
      const r = t.editor;
      r && r.options.element && e.value && Af(() => {
        if (!e.value || !r.options.element.firstChild)
          return;
        const i = C(e.value);
        e.value.append(...r.options.element.childNodes), r.contentComponent = n.ctx._, n && (r.appContext = {
          ...n.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: n.provides
        }), r.setOptions({
          element: i
        }), r.createNodeViews();
      });
    }), Zc(() => {
      const r = t.editor;
      r && (r.contentComponent = null, r.appContext = null);
    }), { rootEl: e };
  },
  render() {
    return mt("div", {
      ref: (t) => {
        this.rootEl = t;
      }
    });
  }
}), G8 = ae({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = X(null);
    return Zt(() => {
      const { pluginKey: r, editor: i, tippyOptions: s, shouldShow: o } = t;
      i.registerPlugin(KR({
        pluginKey: r,
        editor: i,
        element: n.value,
        tippyOptions: s,
        shouldShow: o
      }));
    }), Zc(() => {
      const { pluginKey: r, editor: i } = t;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return mt("div", { ref: n }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
    };
  }
});
ae({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return mt(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
const M_ = ae({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var t, e;
    return mt(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (t = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t));
  }
});
class YR {
  constructor(e, { props: n = {}, editor: r }) {
    this.editor = r, this.component = pA(e), this.el = document.createElement("div"), this.props = Gw(n), this.renderedComponent = this.renderComponent();
  }
  get element() {
    return this.renderedComponent.el;
  }
  get ref() {
    var e, n, r, i;
    return !((n = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || n === void 0) && n.exposed ? this.renderedComponent.vNode.component.exposed : (i = (r = this.renderedComponent.vNode) === null || r === void 0 ? void 0 : r.component) === null || i === void 0 ? void 0 : i.proxy;
  }
  renderComponent() {
    let e = mt(this.component, this.props);
    return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && cx(e, this.el), { vNode: e, destroy: () => {
      this.el && cx(null, this.el), this.el = null, e = null;
    }, el: this.el ? this.el.firstElementChild : null };
  }
  updateProps(e = {}) {
    Object.entries(e).forEach(([n, r]) => {
      this.props[n] = r;
    }), this.renderComponent();
  }
  destroy() {
    this.renderedComponent.destroy();
  }
}
const A_ = {
  editor: {
    type: Object,
    required: !0
  },
  node: {
    type: Object,
    required: !0
  },
  decorations: {
    type: Object,
    required: !0
  },
  selected: {
    type: Boolean,
    required: !0
  },
  extension: {
    type: Object,
    required: !0
  },
  getPos: {
    type: Function,
    required: !0
  },
  updateAttributes: {
    type: Function,
    required: !0
  },
  deleteNode: {
    type: Function,
    required: !0
  }
};
class j8 extends s5 {
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (i = {}) => this.updateAttributes(i),
      deleteNode: () => this.deleteNode()
    }, n = this.onDragStart.bind(this);
    this.decorationClasses = X(this.getDecorationClasses());
    const r = ae({
      extends: { ...this.component },
      props: Object.keys(e),
      template: this.component.template,
      setup: (i) => {
        var s, o;
        return cr("onDragStart", n), cr("decorationClasses", this.decorationClasses), (o = (s = this.component).setup) === null || o === void 0 ? void 0 : o.call(s, i, {
          expose: () => {
          }
        });
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file
    });
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new YR(r, {
      editor: this.editor,
      props: e
    });
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: e, to: n } = this.editor.state.selection, r = this.getPos();
    if (typeof r == "number")
      if (e <= r && n >= r + this.node.nodeSize) {
        if (this.renderer.props.selected)
          return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected)
          return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, n, r) {
    const i = (s) => {
      this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(s);
    };
    if (typeof this.options.update == "function") {
      const s = this.node, o = this.decorations, a = this.innerDecorations;
      return this.node = e, this.decorations = n, this.innerDecorations = r, this.options.update({
        oldNode: s,
        oldDecorations: o,
        newNode: e,
        newDecorations: n,
        oldInnerDecorations: a,
        innerDecorations: r,
        updateProps: () => i({ node: e, decorations: n, innerDecorations: r })
      });
    }
    return e.type !== this.node.type ? !1 : (e === this.node && this.decorations === n && this.innerDecorations === r || (this.node = e, this.decorations = n, this.innerDecorations = r, i({ node: e, decorations: n, innerDecorations: r })), !0);
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  getDecorationClasses() {
    return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
}
function Lv(t, e) {
  return (n) => {
    if (!n.editor.contentComponent)
      return {};
    const r = typeof t == "function" && "__vccOpts" in t ? t.__vccOpts : t;
    return new j8(r, n, e);
  };
}
var Vk;
const q8 = typeof window < "u";
q8 && ((Vk = window == null ? void 0 : window.navigator) != null && Vk.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function XR(t, e) {
  function n(...r) {
    t(() => e.apply(this, r), { fn: e, thisArg: this, args: r });
  }
  return n;
}
function K8(t, e = {}) {
  let n, r;
  return (s) => {
    const o = C(t), a = C(e.maxWait);
    if (n && clearTimeout(n), o <= 0 || a !== void 0 && a <= 0)
      return r && (clearTimeout(r), r = null), s();
    a && !r && (r = setTimeout(() => {
      n && clearTimeout(n), r = null, s();
    }, a)), n = setTimeout(() => {
      r && clearTimeout(r), r = null, s();
    }, o);
  };
}
function Y8(t, e = !0, n = !0) {
  let r = 0, i, s = !0;
  const o = () => {
    i && (clearTimeout(i), i = void 0);
  };
  return (l) => {
    const c = C(t), u = Date.now() - r;
    if (o(), c <= 0)
      return r = Date.now(), l();
    u > c && (n || !s) ? (r = Date.now(), l()) : e && (i = setTimeout(() => {
      r = Date.now(), s = !0, o(), l();
    }, c)), !n && !i && (i = setTimeout(() => s = !0, c)), s = !1;
  };
}
function N_(t) {
  let e = !1, n;
  const r = gA(!0);
  return () => (e || (n = r.run(t), e = !0), n);
}
function jy(t, e = 200, n = {}) {
  return XR(K8(e, n), t);
}
function X8(t, e = 200, n = !0, r = !0) {
  return XR(Y8(e, n, r), t);
}
function J8(t, e, n) {
  const r = Bt(t, (...i) => (Af(() => r()), e(...i)), n);
}
const Z8 = /^\s*>\s$/, JR = an.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Ec({
        find: Z8,
        type: this.type
      })
    ];
  }
});
/*!
  * vue-tippy v6.5.0
  * (c) 2024 
  * @license MIT
  */
var pr = "top", ai = "bottom", li = "right", gr = "left", R_ = "auto", Bf = [pr, ai, li, gr], Tc = "start", Bd = "end", Q8 = "clippingParents", ZR = "viewport", mu = "popper", eW = "reference", Wk = /* @__PURE__ */ Bf.reduce(function(t, e) {
  return t.concat([e + "-" + Tc, e + "-" + Bd]);
}, []), QR = /* @__PURE__ */ [].concat(Bf, [R_]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Tc, e + "-" + Bd]);
}, []), tW = "beforeRead", nW = "read", rW = "afterRead", iW = "beforeMain", sW = "main", oW = "afterMain", aW = "beforeWrite", lW = "write", cW = "afterWrite", uW = [tW, nW, rW, iW, sW, oW, aW, lW, cW];
function ls(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function Pi(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Oc(t) {
  var e = Pi(t).Element;
  return t instanceof e || t instanceof Element;
}
function ti(t) {
  var e = Pi(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function eD(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Pi(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function dW(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !ti(s) || !ls(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function fW(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = o.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !ti(i) || !ls(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
var tD = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: dW,
  effect: fW,
  requires: ["computeStyles"]
};
function es(t) {
  return t.split("-")[0];
}
var Oa = Math.max, Sg = Math.min, Mc = Math.round;
function Ac(t, e) {
  e === void 0 && (e = !1);
  var n = t.getBoundingClientRect(), r = 1, i = 1;
  if (ti(t) && e) {
    var s = t.offsetHeight, o = t.offsetWidth;
    o > 0 && (r = Mc(n.width) / o || 1), s > 0 && (i = Mc(n.height) / s || 1);
  }
  return {
    width: n.width / r,
    height: n.height / i,
    top: n.top / i,
    right: n.right / r,
    bottom: n.bottom / i,
    left: n.left / r,
    x: n.left / r,
    y: n.top / i
  };
}
function D_(t) {
  var e = Ac(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}
function nD(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && eD(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function cs(t) {
  return Pi(t).getComputedStyle(t);
}
function hW(t) {
  return ["table", "td", "th"].indexOf(ls(t)) >= 0;
}
function Wo(t) {
  return ((Oc(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function $v(t) {
  return ls(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (eD(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Wo(t)
  );
}
function Gk(t) {
  return !ti(t) || // https://github.com/popperjs/popper-core/issues/837
  cs(t).position === "fixed" ? null : t.offsetParent;
}
function pW(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && ti(t)) {
    var r = cs(t);
    if (r.position === "fixed")
      return null;
  }
  for (var i = $v(t); ti(i) && ["html", "body"].indexOf(ls(i)) < 0; ) {
    var s = cs(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Ff(t) {
  for (var e = Pi(t), n = Gk(t); n && hW(n) && cs(n).position === "static"; )
    n = Gk(n);
  return n && (ls(n) === "html" || ls(n) === "body" && cs(n).position === "static") ? e : n || pW(t) || e;
}
function I_(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function id(t, e, n) {
  return Oa(t, Sg(e, n));
}
function gW(t, e, n) {
  var r = id(t, e, n);
  return r > n ? n : r;
}
function rD() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function iD(t) {
  return Object.assign({}, rD(), t);
}
function sD(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var mW = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, iD(typeof e != "number" ? e : sD(e, Bf));
};
function vW(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = es(n.placement), l = I_(a), c = [gr, li].indexOf(a) >= 0, u = c ? "height" : "width";
  if (!(!s || !o)) {
    var d = mW(i.padding, n), f = D_(s), h = l === "y" ? pr : gr, p = l === "y" ? ai : li, g = n.rects.reference[u] + n.rects.reference[l] - o[l] - n.rects.popper[u], m = o[l] - n.rects.reference[l], v = Ff(s), y = v ? l === "y" ? v.clientHeight || 0 : v.clientWidth || 0 : 0, E = g / 2 - m / 2, b = d[h], _ = y - f[u] - d[p], w = y / 2 - f[u] / 2 + E, S = id(b, w, _), x = l;
    n.modifiersData[r] = (e = {}, e[x] = S, e.centerOffset = S - w, e);
  }
}
function bW(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || nD(e.elements.popper, i) && (e.elements.arrow = i));
}
var yW = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: vW,
  effect: bW,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Nc(t) {
  return t.split("-")[1];
}
var wW = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function _W(t) {
  var e = t.x, n = t.y, r = window, i = r.devicePixelRatio || 1;
  return {
    x: Mc(e * i) / i || 0,
    y: Mc(n * i) / i || 0
  };
}
function jk(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, d = t.isFixed, f = u === !0 ? _W(o) : typeof u == "function" ? u(o) : o, h = f.x, p = h === void 0 ? 0 : h, g = f.y, m = g === void 0 ? 0 : g, v = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), E = gr, b = pr, _ = window;
  if (c) {
    var w = Ff(n), S = "clientHeight", x = "clientWidth";
    if (w === Pi(n) && (w = Wo(n), cs(w).position !== "static" && a === "absolute" && (S = "scrollHeight", x = "scrollWidth")), w = w, i === pr || (i === gr || i === li) && s === Bd) {
      b = ai;
      var k = d && _.visualViewport ? _.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[S]
      );
      m -= k - r.height, m *= l ? 1 : -1;
    }
    if (i === gr || (i === pr || i === ai) && s === Bd) {
      E = li;
      var T = d && _.visualViewport ? _.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[x]
      );
      p -= T - r.width, p *= l ? 1 : -1;
    }
  }
  var I = Object.assign({
    position: a
  }, c && wW);
  if (l) {
    var R;
    return Object.assign({}, I, (R = {}, R[b] = y ? "0" : "", R[E] = v ? "0" : "", R.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", R));
  }
  return Object.assign({}, I, (e = {}, e[b] = y ? m + "px" : "", e[E] = v ? p + "px" : "", e.transform = "", e));
}
function EW(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: es(e.placement),
    variation: Nc(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, jk(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, jk(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
var SW = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: EW,
  data: {}
}, vh = {
  passive: !0
};
function xW(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, l = Pi(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, vh);
  }), a && l.addEventListener("resize", n.update, vh), function() {
    s && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, vh);
    }), a && l.removeEventListener("resize", n.update, vh);
  };
}
var kW = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: xW,
  data: {}
}, CW = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Ep(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return CW[e];
  });
}
var TW = {
  start: "end",
  end: "start"
};
function qk(t) {
  return t.replace(/start|end/g, function(e) {
    return TW[e];
  });
}
function P_(t) {
  var e = Pi(t), n = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function L_(t) {
  return Ac(Wo(t)).left + P_(t).scrollLeft;
}
function OW(t) {
  var e = Pi(t), n = Wo(t), r = e.visualViewport, i = n.clientWidth, s = n.clientHeight, o = 0, a = 0;
  return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), {
    width: i,
    height: s,
    x: o + L_(t),
    y: a
  };
}
function MW(t) {
  var e, n = Wo(t), r = P_(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = Oa(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Oa(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + L_(t), l = -r.scrollTop;
  return cs(i || n).direction === "rtl" && (a += Oa(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function $_(t) {
  var e = cs(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function oD(t) {
  return ["html", "body", "#document"].indexOf(ls(t)) >= 0 ? t.ownerDocument.body : ti(t) && $_(t) ? t : oD($v(t));
}
function sd(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = oD(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Pi(r), o = i ? [s].concat(s.visualViewport || [], $_(r) ? r : []) : r, a = e.concat(o);
  return i ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(sd($v(o)))
  );
}
function qy(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function AW(t) {
  var e = Ac(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Kk(t, e) {
  return e === ZR ? qy(OW(t)) : Oc(e) ? AW(e) : qy(MW(Wo(t)));
}
function NW(t) {
  var e = sd($v(t)), n = ["absolute", "fixed"].indexOf(cs(t).position) >= 0, r = n && ti(t) ? Ff(t) : t;
  return Oc(r) ? e.filter(function(i) {
    return Oc(i) && nD(i, r) && ls(i) !== "body" && (n ? cs(i).position !== "static" : !0);
  }) : [];
}
function RW(t, e, n) {
  var r = e === "clippingParents" ? NW(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], o = i.reduce(function(a, l) {
    var c = Kk(t, l);
    return a.top = Oa(c.top, a.top), a.right = Sg(c.right, a.right), a.bottom = Sg(c.bottom, a.bottom), a.left = Oa(c.left, a.left), a;
  }, Kk(t, s));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function aD(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? es(r) : null, s = r ? Nc(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (i) {
    case pr:
      l = {
        x: o,
        y: e.y - n.height
      };
      break;
    case ai:
      l = {
        x: o,
        y: e.y + e.height
      };
      break;
    case li:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case gr:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = i ? I_(i) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (s) {
      case Tc:
        l[c] = l[c] - (e[u] / 2 - n[u] / 2);
        break;
      case Bd:
        l[c] = l[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function Fd(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.boundary, o = s === void 0 ? Q8 : s, a = n.rootBoundary, l = a === void 0 ? ZR : a, c = n.elementContext, u = c === void 0 ? mu : c, d = n.altBoundary, f = d === void 0 ? !1 : d, h = n.padding, p = h === void 0 ? 0 : h, g = iD(typeof p != "number" ? p : sD(p, Bf)), m = u === mu ? eW : mu, v = t.rects.popper, y = t.elements[f ? m : u], E = RW(Oc(y) ? y : y.contextElement || Wo(t.elements.popper), o, l), b = Ac(t.elements.reference), _ = aD({
    reference: b,
    element: v,
    strategy: "absolute",
    placement: i
  }), w = qy(Object.assign({}, v, _)), S = u === mu ? w : b, x = {
    top: E.top - S.top + g.top,
    bottom: S.bottom - E.bottom + g.bottom,
    left: E.left - S.left + g.left,
    right: S.right - E.right + g.right
  }, k = t.modifiersData.offset;
  if (u === mu && k) {
    var T = k[i];
    Object.keys(x).forEach(function(I) {
      var R = [li, ai].indexOf(I) >= 0 ? 1 : -1, N = [pr, ai].indexOf(I) >= 0 ? "y" : "x";
      x[I] += T[N] * R;
    });
  }
  return x;
}
function DW(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? QR : l, u = Nc(r), d = u ? a ? Wk : Wk.filter(function(p) {
    return Nc(p) === u;
  }) : Bf, f = d.filter(function(p) {
    return c.indexOf(p) >= 0;
  });
  f.length === 0 && (f = d);
  var h = f.reduce(function(p, g) {
    return p[g] = Fd(t, {
      placement: g,
      boundary: i,
      rootBoundary: s,
      padding: o
    })[es(g)], p;
  }, {});
  return Object.keys(h).sort(function(p, g) {
    return h[p] - h[g];
  });
}
function IW(t) {
  if (es(t) === R_)
    return [];
  var e = Ep(t);
  return [qk(t), e, qk(e)];
}
function PW(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, h = n.flipVariations, p = h === void 0 ? !0 : h, g = n.allowedAutoPlacements, m = e.options.placement, v = es(m), y = v === m, E = l || (y || !p ? [Ep(m)] : IW(m)), b = [m].concat(E).reduce(function(ie, Z) {
      return ie.concat(es(Z) === R_ ? DW(e, {
        placement: Z,
        boundary: u,
        rootBoundary: d,
        padding: c,
        flipVariations: p,
        allowedAutoPlacements: g
      }) : Z);
    }, []), _ = e.rects.reference, w = e.rects.popper, S = /* @__PURE__ */ new Map(), x = !0, k = b[0], T = 0; T < b.length; T++) {
      var I = b[T], R = es(I), N = Nc(I) === Tc, $ = [pr, ai].indexOf(R) >= 0, B = $ ? "width" : "height", G = Fd(e, {
        placement: I,
        boundary: u,
        rootBoundary: d,
        altBoundary: f,
        padding: c
      }), M = $ ? N ? li : gr : N ? ai : pr;
      _[B] > w[B] && (M = Ep(M));
      var A = Ep(M), z = [];
      if (s && z.push(G[R] <= 0), a && z.push(G[M] <= 0, G[A] <= 0), z.every(function(ie) {
        return ie;
      })) {
        k = I, x = !1;
        break;
      }
      S.set(I, z);
    }
    if (x)
      for (var V = p ? 3 : 1, U = function(Z) {
        var Q = b.find(function(fe) {
          var ge = S.get(fe);
          if (ge)
            return ge.slice(0, Z).every(function(Re) {
              return Re;
            });
        });
        if (Q)
          return k = Q, "break";
      }, Y = V; Y > 0; Y--) {
        var ne = U(Y);
        if (ne === "break")
          break;
      }
    e.placement !== k && (e.modifiersData[r]._skip = !0, e.placement = k, e.reset = !0);
  }
}
var LW = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: PW,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Yk(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function Xk(t) {
  return [pr, li, ai, gr].some(function(e) {
    return t[e] >= 0;
  });
}
function $W(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, o = Fd(e, {
    elementContext: "reference"
  }), a = Fd(e, {
    altBoundary: !0
  }), l = Yk(o, r), c = Yk(a, i, s), u = Xk(l), d = Xk(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
var BW = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: $W
};
function FW(t, e, n) {
  var r = es(t), i = [gr, pr].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [gr, li].indexOf(r) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function zW(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = QR.reduce(function(u, d) {
    return u[d] = FW(d, e.rects, s), u;
  }, {}), a = o[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = o;
}
var HW = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: zW
};
function UW(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = aD({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
var VW = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: UW,
  data: {}
};
function WW(t) {
  return t === "x" ? "y" : "x";
}
function GW(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, f = n.tether, h = f === void 0 ? !0 : f, p = n.tetherOffset, g = p === void 0 ? 0 : p, m = Fd(e, {
    boundary: l,
    rootBoundary: c,
    padding: d,
    altBoundary: u
  }), v = es(e.placement), y = Nc(e.placement), E = !y, b = I_(v), _ = WW(b), w = e.modifiersData.popperOffsets, S = e.rects.reference, x = e.rects.popper, k = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, T = typeof k == "number" ? {
    mainAxis: k,
    altAxis: k
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, k), I = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, R = {
    x: 0,
    y: 0
  };
  if (w) {
    if (s) {
      var N, $ = b === "y" ? pr : gr, B = b === "y" ? ai : li, G = b === "y" ? "height" : "width", M = w[b], A = M + m[$], z = M - m[B], V = h ? -x[G] / 2 : 0, U = y === Tc ? S[G] : x[G], Y = y === Tc ? -x[G] : -S[G], ne = e.elements.arrow, ie = h && ne ? D_(ne) : {
        width: 0,
        height: 0
      }, Z = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : rD(), Q = Z[$], fe = Z[B], ge = id(0, S[G], ie[G]), Re = E ? S[G] / 2 - V - ge - Q - T.mainAxis : U - ge - Q - T.mainAxis, Be = E ? -S[G] / 2 + V + ge + fe + T.mainAxis : Y + ge + fe + T.mainAxis, le = e.elements.arrow && Ff(e.elements.arrow), Ee = le ? b === "y" ? le.clientTop || 0 : le.clientLeft || 0 : 0, Se = (N = I == null ? void 0 : I[b]) != null ? N : 0, xe = M + Re - Se - Ee, Ce = M + Be - Se, _e = id(h ? Sg(A, xe) : A, M, h ? Oa(z, Ce) : z);
      w[b] = _e, R[b] = _e - M;
    }
    if (a) {
      var Je, P = b === "x" ? pr : gr, O = b === "x" ? ai : li, q = w[_], ee = _ === "y" ? "height" : "width", ce = q + m[P], Pe = q - m[O], ye = [pr, gr].indexOf(v) !== -1, j = (Je = I == null ? void 0 : I[_]) != null ? Je : 0, re = ye ? ce : q - S[ee] - x[ee] - j + T.altAxis, H = ye ? q + S[ee] + x[ee] - j - T.altAxis : Pe, K = h && ye ? gW(re, q, H) : id(h ? re : ce, q, h ? H : Pe);
      w[_] = K, R[_] = K - q;
    }
    e.modifiersData[r] = R;
  }
}
var jW = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: GW,
  requiresIfExists: ["offset"]
};
function qW(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function KW(t) {
  return t === Pi(t) || !ti(t) ? P_(t) : qW(t);
}
function YW(t) {
  var e = t.getBoundingClientRect(), n = Mc(e.width) / t.offsetWidth || 1, r = Mc(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function XW(t, e, n) {
  n === void 0 && (n = !1);
  var r = ti(e), i = ti(e) && YW(e), s = Wo(e), o = Ac(t, i), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((ls(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  $_(s)) && (a = KW(e)), ti(e) ? (l = Ac(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = L_(s))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function JW(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function ZW(t) {
  var e = JW(t);
  return uW.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function QW(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function e6(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Jk = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Zk() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function t6(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? Jk : i;
  return function(a, l, c) {
    c === void 0 && (c = s);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Jk, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, h = {
      state: u,
      setOptions: function(v) {
        var y = typeof v == "function" ? v(u.options) : v;
        g(), u.options = Object.assign({}, s, u.options, y), u.scrollParents = {
          reference: Oc(a) ? sd(a) : a.contextElement ? sd(a.contextElement) : [],
          popper: sd(l)
        };
        var E = ZW(e6([].concat(r, u.options.modifiers)));
        return u.orderedModifiers = E.filter(function(b) {
          return b.enabled;
        }), p(), h.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var v = u.elements, y = v.reference, E = v.popper;
          if (Zk(y, E)) {
            u.rects = {
              reference: XW(y, Ff(E), u.options.strategy === "fixed"),
              popper: D_(E)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(T) {
              return u.modifiersData[T.name] = Object.assign({}, T.data);
            });
            for (var b = 0; b < u.orderedModifiers.length; b++) {
              if (u.reset === !0) {
                u.reset = !1, b = -1;
                continue;
              }
              var _ = u.orderedModifiers[b], w = _.fn, S = _.options, x = S === void 0 ? {} : S, k = _.name;
              typeof w == "function" && (u = w({
                state: u,
                options: x,
                name: k,
                instance: h
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: QW(function() {
        return new Promise(function(m) {
          h.forceUpdate(), m(u);
        });
      }),
      destroy: function() {
        g(), f = !0;
      }
    };
    if (!Zk(a, l))
      return h;
    h.setOptions(c).then(function(m) {
      !f && c.onFirstUpdate && c.onFirstUpdate(m);
    });
    function p() {
      u.orderedModifiers.forEach(function(m) {
        var v = m.name, y = m.options, E = y === void 0 ? {} : y, b = m.effect;
        if (typeof b == "function") {
          var _ = b({
            state: u,
            name: v,
            instance: h,
            options: E
          }), w = function() {
          };
          d.push(_ || w);
        }
      });
    }
    function g() {
      d.forEach(function(m) {
        return m();
      }), d = [];
    }
    return h;
  };
}
var n6 = [kW, VW, SW, tD, HW, LW, jW, yW, BW], r6 = /* @__PURE__ */ t6({
  defaultModifiers: n6
}), i6 = "tippy-box", lD = "tippy-content", cD = "tippy-backdrop", uD = "tippy-arrow", dD = "tippy-svg-arrow", ta = {
  passive: !0,
  capture: !0
}, fD = function() {
  return document.body;
};
function sb(t, e, n) {
  if (Array.isArray(t)) {
    var r = t[e];
    return r ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function B_(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function hD(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function Qk(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(r) {
    clearTimeout(n), n = setTimeout(function() {
      t(r);
    }, e);
  };
}
function s6(t, e) {
  var n = Object.assign({}, t);
  return e.forEach(function(r) {
    delete n[r];
  }), n;
}
function o6(t) {
  return t.split(/\s+/).filter(Boolean);
}
function ia(t) {
  return [].concat(t);
}
function eC(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function a6(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function pD(t) {
  return t.split("-")[0];
}
function Rc(t) {
  return [].slice.call(t);
}
function tC(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function Ma() {
  return document.createElement("div");
}
function Bv(t) {
  return ["Element", "Fragment"].some(function(e) {
    return B_(t, e);
  });
}
function l6(t) {
  return B_(t, "NodeList");
}
function F_(t) {
  return B_(t, "MouseEvent");
}
function c6(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function u6(t) {
  return Bv(t) ? [t] : l6(t) ? Rc(t) : Array.isArray(t) ? t : Rc(document.querySelectorAll(t));
}
function ob(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function zd(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function gD(t) {
  var e, n = ia(t), r = n[0];
  return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
}
function d6(t, e) {
  var n = e.clientX, r = e.clientY;
  return t.every(function(i) {
    var s = i.popperRect, o = i.popperState, a = i.props, l = a.interactiveBorder, c = pD(o.placement), u = o.modifiersData.offset;
    if (!u)
      return !0;
    var d = c === "bottom" ? u.top.y : 0, f = c === "top" ? u.bottom.y : 0, h = c === "right" ? u.left.x : 0, p = c === "left" ? u.right.x : 0, g = s.top - r + d > l, m = r - s.bottom - f > l, v = s.left - n + h > l, y = n - s.right - p > l;
    return g || m || v || y;
  });
}
function ab(t, e, n) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    t[r](i, n);
  });
}
function nC(t, e) {
  for (var n = e; n; ) {
    var r;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var Yi = {
  isTouch: !1
}, rC = 0;
function f6() {
  Yi.isTouch || (Yi.isTouch = !0, window.performance && document.addEventListener("mousemove", mD));
}
function mD() {
  var t = performance.now();
  t - rC < 20 && (Yi.isTouch = !1, document.removeEventListener("mousemove", mD)), rC = t;
}
function h6() {
  var t = document.activeElement;
  if (c6(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function p6() {
  document.addEventListener("touchstart", f6, ta), window.addEventListener("blur", h6);
}
var g6 = typeof window < "u" && typeof document < "u", m6 = g6 ? (
  // @ts-ignore
  !!window.msCrypto
) : !1, v6 = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, b6 = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, _i = Object.assign({
  appendTo: fD,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, v6, b6), y6 = Object.keys(_i), w6 = function(e) {
  var n = Object.keys(e);
  n.forEach(function(r) {
    _i[r] = e[r];
  });
};
function vD(t) {
  var e = t.plugins || [], n = e.reduce(function(r, i) {
    var s = i.name, o = i.defaultValue;
    if (s) {
      var a;
      r[s] = t[s] !== void 0 ? t[s] : (a = _i[s]) != null ? a : o;
    }
    return r;
  }, {});
  return Object.assign({}, t, n);
}
function _6(t, e) {
  var n = e ? Object.keys(vD(Object.assign({}, _i, {
    plugins: e
  }))) : y6, r = n.reduce(function(i, s) {
    var o = (t.getAttribute("data-tippy-" + s) || "").trim();
    if (!o)
      return i;
    if (s === "content")
      i[s] = o;
    else
      try {
        i[s] = JSON.parse(o);
      } catch {
        i[s] = o;
      }
    return i;
  }, {});
  return r;
}
function iC(t, e) {
  var n = Object.assign({}, e, {
    content: hD(e.content, [t])
  }, e.ignoreAttributes ? {} : _6(t, e.plugins));
  return n.aria = Object.assign({}, _i.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
var E6 = function() {
  return "innerHTML";
};
function Ky(t, e) {
  t[E6()] = e;
}
function sC(t) {
  var e = Ma();
  return t === !0 ? e.className = uD : (e.className = dD, Bv(t) ? e.appendChild(t) : Ky(e, t)), e;
}
function oC(t, e) {
  Bv(e.content) ? (Ky(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? Ky(t, e.content) : t.textContent = e.content);
}
function xg(t) {
  var e = t.firstElementChild, n = Rc(e.children);
  return {
    box: e,
    content: n.find(function(r) {
      return r.classList.contains(lD);
    }),
    arrow: n.find(function(r) {
      return r.classList.contains(uD) || r.classList.contains(dD);
    }),
    backdrop: n.find(function(r) {
      return r.classList.contains(cD);
    })
  };
}
function bD(t) {
  var e = Ma(), n = Ma();
  n.className = i6, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var r = Ma();
  r.className = lD, r.setAttribute("data-state", "hidden"), oC(r, t.props), e.appendChild(n), n.appendChild(r), i(t.props, t.props);
  function i(s, o) {
    var a = xg(e), l = a.box, c = a.content, u = a.arrow;
    o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (s.content !== o.content || s.allowHTML !== o.allowHTML) && oC(c, t.props), o.arrow ? u ? s.arrow !== o.arrow && (l.removeChild(u), l.appendChild(sC(o.arrow))) : l.appendChild(sC(o.arrow)) : u && l.removeChild(u);
  }
  return {
    popper: e,
    onUpdate: i
  };
}
bD.$$tippy = !0;
var S6 = 1, bh = [], lb = [];
function x6(t, e) {
  var n = iC(t, Object.assign({}, _i, vD(tC(e)))), r, i, s, o = !1, a = !1, l = !1, c = !1, u, d, f, h = [], p = Qk(xe, n.interactiveDebounce), g, m = S6++, v = null, y = a6(n.plugins), E = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: m,
    reference: t,
    popper: Ma(),
    popperInstance: v,
    props: n,
    state: E,
    plugins: y,
    // methods
    clearDelayTimeouts: re,
    setProps: H,
    setContent: K,
    show: de,
    hide: Oe,
    hideWithInteractivity: Xe,
    enable: ye,
    disable: j,
    unmount: pt,
    destroy: hi
  };
  if (!n.render)
    return b;
  var _ = n.render(b), w = _.popper, S = _.onUpdate;
  w.setAttribute("data-tippy-root", ""), w.id = "tippy-" + b.id, b.popper = w, t._tippy = b, w._tippy = b;
  var x = y.map(function(D) {
    return D.fn(b);
  }), k = t.hasAttribute("aria-expanded");
  return le(), V(), M(), A("onCreate", [b]), n.showOnCreate && ce(), w.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), w.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && $().addEventListener("mousemove", p);
  }), b;
  function T() {
    var D = b.props.touch;
    return Array.isArray(D) ? D : [D, 0];
  }
  function I() {
    return T()[0] === "hold";
  }
  function R() {
    var D;
    return !!((D = b.props.render) != null && D.$$tippy);
  }
  function N() {
    return g || t;
  }
  function $() {
    var D = N().parentNode;
    return D ? gD(D) : document;
  }
  function B() {
    return xg(w);
  }
  function G(D) {
    return b.state.isMounted && !b.state.isVisible || Yi.isTouch || u && u.type === "focus" ? 0 : sb(b.props.delay, D ? 0 : 1, _i.delay);
  }
  function M(D) {
    D === void 0 && (D = !1), w.style.pointerEvents = b.props.interactive && !D ? "" : "none", w.style.zIndex = "" + b.props.zIndex;
  }
  function A(D, te, ue) {
    if (ue === void 0 && (ue = !0), x.forEach(function(Ae) {
      Ae[D] && Ae[D].apply(Ae, te);
    }), ue) {
      var ze;
      (ze = b.props)[D].apply(ze, te);
    }
  }
  function z() {
    var D = b.props.aria;
    if (D.content) {
      var te = "aria-" + D.content, ue = w.id, ze = ia(b.props.triggerTarget || t);
      ze.forEach(function(Ae) {
        var gt = Ae.getAttribute(te);
        if (b.state.isVisible)
          Ae.setAttribute(te, gt ? gt + " " + ue : ue);
        else {
          var Ye = gt && gt.replace(ue, "").trim();
          Ye ? Ae.setAttribute(te, Ye) : Ae.removeAttribute(te);
        }
      });
    }
  }
  function V() {
    if (!(k || !b.props.aria.expanded)) {
      var D = ia(b.props.triggerTarget || t);
      D.forEach(function(te) {
        b.props.interactive ? te.setAttribute("aria-expanded", b.state.isVisible && te === N() ? "true" : "false") : te.removeAttribute("aria-expanded");
      });
    }
  }
  function U() {
    $().removeEventListener("mousemove", p), bh = bh.filter(function(D) {
      return D !== p;
    });
  }
  function Y(D) {
    if (!(Yi.isTouch && (l || D.type === "mousedown"))) {
      var te = D.composedPath && D.composedPath()[0] || D.target;
      if (!(b.props.interactive && nC(w, te))) {
        if (ia(b.props.triggerTarget || t).some(function(ue) {
          return nC(ue, te);
        })) {
          if (Yi.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          A("onClickOutside", [b, D]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), b.state.isMounted || Q());
      }
    }
  }
  function ne() {
    l = !0;
  }
  function ie() {
    l = !1;
  }
  function Z() {
    var D = $();
    D.addEventListener("mousedown", Y, !0), D.addEventListener("touchend", Y, ta), D.addEventListener("touchstart", ie, ta), D.addEventListener("touchmove", ne, ta);
  }
  function Q() {
    var D = $();
    D.removeEventListener("mousedown", Y, !0), D.removeEventListener("touchend", Y, ta), D.removeEventListener("touchstart", ie, ta), D.removeEventListener("touchmove", ne, ta);
  }
  function fe(D, te) {
    Re(D, function() {
      !b.state.isVisible && w.parentNode && w.parentNode.contains(w) && te();
    });
  }
  function ge(D, te) {
    Re(D, te);
  }
  function Re(D, te) {
    var ue = B().box;
    function ze(Ae) {
      Ae.target === ue && (ab(ue, "remove", ze), te());
    }
    if (D === 0)
      return te();
    ab(ue, "remove", d), ab(ue, "add", ze), d = ze;
  }
  function Be(D, te, ue) {
    ue === void 0 && (ue = !1);
    var ze = ia(b.props.triggerTarget || t);
    ze.forEach(function(Ae) {
      Ae.addEventListener(D, te, ue), h.push({
        node: Ae,
        eventType: D,
        handler: te,
        options: ue
      });
    });
  }
  function le() {
    I() && (Be("touchstart", Se, {
      passive: !0
    }), Be("touchend", Ce, {
      passive: !0
    })), o6(b.props.trigger).forEach(function(D) {
      if (D !== "manual")
        switch (Be(D, Se), D) {
          case "mouseenter":
            Be("mouseleave", Ce);
            break;
          case "focus":
            Be(m6 ? "focusout" : "blur", _e);
            break;
          case "focusin":
            Be("focusout", _e);
            break;
        }
    });
  }
  function Ee() {
    h.forEach(function(D) {
      var te = D.node, ue = D.eventType, ze = D.handler, Ae = D.options;
      te.removeEventListener(ue, ze, Ae);
    }), h = [];
  }
  function Se(D) {
    var te, ue = !1;
    if (!(!b.state.isEnabled || Je(D) || a)) {
      var ze = ((te = u) == null ? void 0 : te.type) === "focus";
      u = D, g = D.currentTarget, V(), !b.state.isVisible && F_(D) && bh.forEach(function(Ae) {
        return Ae(D);
      }), D.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || o) && b.props.hideOnClick !== !1 && b.state.isVisible ? ue = !0 : ce(D), D.type === "click" && (o = !ue), ue && !ze && Pe(D);
    }
  }
  function xe(D) {
    var te = D.target, ue = N().contains(te) || w.contains(te);
    if (!(D.type === "mousemove" && ue)) {
      var ze = ee().concat(w).map(function(Ae) {
        var gt, Ye = Ae._tippy, xt = (gt = Ye.popperInstance) == null ? void 0 : gt.state;
        return xt ? {
          popperRect: Ae.getBoundingClientRect(),
          popperState: xt,
          props: n
        } : null;
      }).filter(Boolean);
      d6(ze, D) && (U(), Pe(D));
    }
  }
  function Ce(D) {
    var te = Je(D) || b.props.trigger.indexOf("click") >= 0 && o;
    if (!te) {
      if (b.props.interactive) {
        b.hideWithInteractivity(D);
        return;
      }
      Pe(D);
    }
  }
  function _e(D) {
    b.props.trigger.indexOf("focusin") < 0 && D.target !== N() || b.props.interactive && D.relatedTarget && w.contains(D.relatedTarget) || Pe(D);
  }
  function Je(D) {
    return Yi.isTouch ? I() !== D.type.indexOf("touch") >= 0 : !1;
  }
  function P() {
    O();
    var D = b.props, te = D.popperOptions, ue = D.placement, ze = D.offset, Ae = D.getReferenceClientRect, gt = D.moveTransition, Ye = R() ? xg(w).arrow : null, xt = Ae ? {
      getBoundingClientRect: Ae,
      contextElement: Ae.contextElement || N()
    } : t, Js = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Er) {
        var Sr = Er.state;
        if (R()) {
          var M0 = B(), Yo = M0.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(ys) {
            ys === "placement" ? Yo.setAttribute("data-placement", Sr.placement) : Sr.attributes.popper["data-popper-" + ys] ? Yo.setAttribute("data-" + ys, "") : Yo.removeAttribute("data-" + ys);
          }), Sr.attributes.popper = {};
        }
      }
    }, vn = [{
      name: "offset",
      options: {
        offset: ze
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !gt
      }
    }, Js];
    R() && Ye && vn.push({
      name: "arrow",
      options: {
        element: Ye,
        padding: 3
      }
    }), vn.push.apply(vn, (te == null ? void 0 : te.modifiers) || []), b.popperInstance = r6(xt, w, Object.assign({}, te, {
      placement: ue,
      onFirstUpdate: f,
      modifiers: vn
    }));
  }
  function O() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function q() {
    var D = b.props.appendTo, te, ue = N();
    b.props.interactive && D === fD || D === "parent" ? te = ue.parentNode : te = hD(D, [ue]), te.contains(w) || te.appendChild(w), b.state.isMounted = !0, P();
  }
  function ee() {
    return Rc(w.querySelectorAll("[data-tippy-root]"));
  }
  function ce(D) {
    b.clearDelayTimeouts(), D && A("onTrigger", [b, D]), Z();
    var te = G(!0), ue = T(), ze = ue[0], Ae = ue[1];
    Yi.isTouch && ze === "hold" && Ae && (te = Ae), te ? r = setTimeout(function() {
      b.show();
    }, te) : b.show();
  }
  function Pe(D) {
    if (b.clearDelayTimeouts(), A("onUntrigger", [b, D]), !b.state.isVisible) {
      Q();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(D.type) >= 0 && o)) {
      var te = G(!1);
      te ? i = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, te) : s = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function ye() {
    b.state.isEnabled = !0;
  }
  function j() {
    b.hide(), b.state.isEnabled = !1;
  }
  function re() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(s);
  }
  function H(D) {
    if (!b.state.isDestroyed) {
      A("onBeforeUpdate", [b, D]), Ee();
      var te = b.props, ue = iC(t, Object.assign({}, te, tC(D), {
        ignoreAttributes: !0
      }));
      b.props = ue, le(), te.interactiveDebounce !== ue.interactiveDebounce && (U(), p = Qk(xe, ue.interactiveDebounce)), te.triggerTarget && !ue.triggerTarget ? ia(te.triggerTarget).forEach(function(ze) {
        ze.removeAttribute("aria-expanded");
      }) : ue.triggerTarget && t.removeAttribute("aria-expanded"), V(), M(), S && S(te, ue), b.popperInstance && (P(), ee().forEach(function(ze) {
        requestAnimationFrame(ze._tippy.popperInstance.forceUpdate);
      })), A("onAfterUpdate", [b, D]);
    }
  }
  function K(D) {
    b.setProps({
      content: D
    });
  }
  function de() {
    var D = b.state.isVisible, te = b.state.isDestroyed, ue = !b.state.isEnabled, ze = Yi.isTouch && !b.props.touch, Ae = sb(b.props.duration, 0, _i.duration);
    if (!(D || te || ue || ze) && !N().hasAttribute("disabled") && (A("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, R() && (w.style.visibility = "visible"), M(), Z(), b.state.isMounted || (w.style.transition = "none"), R()) {
        var gt = B(), Ye = gt.box, xt = gt.content;
        ob([Ye, xt], 0);
      }
      f = function() {
        var vn;
        if (!(!b.state.isVisible || c)) {
          if (c = !0, w.offsetHeight, w.style.transition = b.props.moveTransition, R() && b.props.animation) {
            var bs = B(), Er = bs.box, Sr = bs.content;
            ob([Er, Sr], Ae), zd([Er, Sr], "visible");
          }
          z(), V(), eC(lb, b), (vn = b.popperInstance) == null || vn.forceUpdate(), A("onMount", [b]), b.props.animation && R() && ge(Ae, function() {
            b.state.isShown = !0, A("onShown", [b]);
          });
        }
      }, q();
    }
  }
  function Oe() {
    var D = !b.state.isVisible, te = b.state.isDestroyed, ue = !b.state.isEnabled, ze = sb(b.props.duration, 1, _i.duration);
    if (!(D || te || ue) && (A("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, c = !1, o = !1, R() && (w.style.visibility = "hidden"), U(), Q(), M(!0), R()) {
        var Ae = B(), gt = Ae.box, Ye = Ae.content;
        b.props.animation && (ob([gt, Ye], ze), zd([gt, Ye], "hidden"));
      }
      z(), V(), b.props.animation ? R() && fe(ze, b.unmount) : b.unmount();
    }
  }
  function Xe(D) {
    $().addEventListener("mousemove", p), eC(bh, p), p(D);
  }
  function pt() {
    b.state.isVisible && b.hide(), b.state.isMounted && (O(), ee().forEach(function(D) {
      D._tippy.unmount();
    }), w.parentNode && w.parentNode.removeChild(w), lb = lb.filter(function(D) {
      return D !== b;
    }), b.state.isMounted = !1, A("onHidden", [b]));
  }
  function hi() {
    b.state.isDestroyed || (b.clearDelayTimeouts(), b.unmount(), Ee(), delete t._tippy, b.state.isDestroyed = !0, A("onDestroy", [b]));
  }
}
function We(t, e) {
  e === void 0 && (e = {});
  var n = _i.plugins.concat(e.plugins || []);
  p6();
  var r = Object.assign({}, e, {
    plugins: n
  }), i = u6(t), s = i.reduce(function(o, a) {
    var l = a && x6(a, r);
    return l && o.push(l), o;
  }, []);
  return Bv(t) ? s[0] : s;
}
We.defaultProps = _i;
We.setDefaultProps = w6;
We.currentInput = Yi;
var k6 = Object.assign({}, tD, {
  effect: function(e) {
    var n = e.state, r = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  }
}), C6 = function(e, n) {
  var r;
  n === void 0 && (n = {});
  var i = e, s = [], o = [], a, l = n.overrides, c = [], u = !1;
  function d() {
    o = i.map(function(b) {
      return ia(b.props.triggerTarget || b.reference);
    }).reduce(function(b, _) {
      return b.concat(_);
    }, []);
  }
  function f() {
    s = i.map(function(b) {
      return b.reference;
    });
  }
  function h(b) {
    i.forEach(function(_) {
      b ? _.enable() : _.disable();
    });
  }
  function p(b) {
    return i.map(function(_) {
      var w = _.setProps;
      return _.setProps = function(S) {
        w(S), _.reference === a && b.setProps(S);
      }, function() {
        _.setProps = w;
      };
    });
  }
  function g(b, _) {
    var w = o.indexOf(_);
    if (_ !== a) {
      a = _;
      var S = (l || []).concat("content").reduce(function(x, k) {
        return x[k] = i[w].props[k], x;
      }, {});
      b.setProps(Object.assign({}, S, {
        getReferenceClientRect: typeof S.getReferenceClientRect == "function" ? S.getReferenceClientRect : function() {
          var x;
          return (x = s[w]) == null ? void 0 : x.getBoundingClientRect();
        }
      }));
    }
  }
  h(!1), f(), d();
  var m = {
    fn: function() {
      return {
        onDestroy: function() {
          h(!0);
        },
        onHidden: function() {
          a = null;
        },
        onClickOutside: function(w) {
          w.props.showOnCreate && !u && (u = !0, a = null);
        },
        onShow: function(w) {
          w.props.showOnCreate && !u && (u = !0, g(w, s[0]));
        },
        onTrigger: function(w, S) {
          g(w, S.currentTarget);
        }
      };
    }
  }, v = We(Ma(), Object.assign({}, s6(n, ["overrides"]), {
    plugins: [m].concat(n.plugins || []),
    triggerTarget: o,
    popperOptions: Object.assign({}, n.popperOptions, {
      modifiers: [].concat(((r = n.popperOptions) == null ? void 0 : r.modifiers) || [], [k6])
    })
  })), y = v.show;
  v.show = function(b) {
    if (y(), !a && b == null)
      return g(v, s[0]);
    if (!(a && b == null)) {
      if (typeof b == "number")
        return s[b] && g(v, s[b]);
      if (i.indexOf(b) >= 0) {
        var _ = b.reference;
        return g(v, _);
      }
      if (s.indexOf(b) >= 0)
        return g(v, b);
    }
  }, v.showNext = function() {
    var b = s[0];
    if (!a)
      return v.show(0);
    var _ = s.indexOf(a);
    v.show(s[_ + 1] || b);
  }, v.showPrevious = function() {
    var b = s[s.length - 1];
    if (!a)
      return v.show(b);
    var _ = s.indexOf(a), w = s[_ - 1] || b;
    v.show(w);
  };
  var E = v.setProps;
  return v.setProps = function(b) {
    l = b.overrides || l, E(b);
  }, v.setInstances = function(b) {
    h(!0), c.forEach(function(_) {
      return _();
    }), i = b, h(!1), f(), d(), c = p(v), v.setProps({
      triggerTarget: o
    });
  }, c = p(v), v;
}, T6 = {
  name: "animateFill",
  defaultValue: !1,
  fn: function(e) {
    var n;
    if (!((n = e.props.render) != null && n.$$tippy))
      return {};
    var r = xg(e.popper), i = r.box, s = r.content, o = e.props.animateFill ? O6() : null;
    return {
      onCreate: function() {
        o && (i.insertBefore(o, i.firstElementChild), i.setAttribute("data-animatefill", ""), i.style.overflow = "hidden", e.setProps({
          arrow: !1,
          animation: "shift-away"
        }));
      },
      onMount: function() {
        if (o) {
          var l = i.style.transitionDuration, c = Number(l.replace("ms", ""));
          s.style.transitionDelay = Math.round(c / 10) + "ms", o.style.transitionDuration = l, zd([o], "visible");
        }
      },
      onShow: function() {
        o && (o.style.transitionDuration = "0ms");
      },
      onHide: function() {
        o && zd([o], "hidden");
      }
    };
  }
};
function O6() {
  var t = Ma();
  return t.className = cD, zd([t], "hidden"), t;
}
var Yy = {
  clientX: 0,
  clientY: 0
}, yh = [];
function yD(t) {
  var e = t.clientX, n = t.clientY;
  Yy = {
    clientX: e,
    clientY: n
  };
}
function M6(t) {
  t.addEventListener("mousemove", yD);
}
function A6(t) {
  t.removeEventListener("mousemove", yD);
}
var N6 = {
  name: "followCursor",
  defaultValue: !1,
  fn: function(e) {
    var n = e.reference, r = gD(e.props.triggerTarget || n), i = !1, s = !1, o = !0, a = e.props;
    function l() {
      return e.props.followCursor === "initial" && e.state.isVisible;
    }
    function c() {
      r.addEventListener("mousemove", f);
    }
    function u() {
      r.removeEventListener("mousemove", f);
    }
    function d() {
      i = !0, e.setProps({
        getReferenceClientRect: null
      }), i = !1;
    }
    function f(g) {
      var m = g.target ? n.contains(g.target) : !0, v = e.props.followCursor, y = g.clientX, E = g.clientY, b = n.getBoundingClientRect(), _ = y - b.left, w = E - b.top;
      (m || !e.props.interactive) && e.setProps({
        // @ts-ignore - unneeded DOMRect properties
        getReferenceClientRect: function() {
          var x = n.getBoundingClientRect(), k = y, T = E;
          v === "initial" && (k = x.left + _, T = x.top + w);
          var I = v === "horizontal" ? x.top : T, R = v === "vertical" ? x.right : k, N = v === "horizontal" ? x.bottom : T, $ = v === "vertical" ? x.left : k;
          return {
            width: R - $,
            height: N - I,
            top: I,
            right: R,
            bottom: N,
            left: $
          };
        }
      });
    }
    function h() {
      e.props.followCursor && (yh.push({
        instance: e,
        doc: r
      }), M6(r));
    }
    function p() {
      yh = yh.filter(function(g) {
        return g.instance !== e;
      }), yh.filter(function(g) {
        return g.doc === r;
      }).length === 0 && A6(r);
    }
    return {
      onCreate: h,
      onDestroy: p,
      onBeforeUpdate: function() {
        a = e.props;
      },
      onAfterUpdate: function(m, v) {
        var y = v.followCursor;
        i || y !== void 0 && a.followCursor !== y && (p(), y ? (h(), e.state.isMounted && !s && !l() && c()) : (u(), d()));
      },
      onMount: function() {
        e.props.followCursor && !s && (o && (f(Yy), o = !1), l() || c());
      },
      onTrigger: function(m, v) {
        F_(v) && (Yy = {
          clientX: v.clientX,
          clientY: v.clientY
        }), s = v.type === "focus";
      },
      onHidden: function() {
        e.props.followCursor && (d(), u(), o = !0);
      }
    };
  }
};
function R6(t, e) {
  var n;
  return {
    popperOptions: Object.assign({}, t.popperOptions, {
      modifiers: [].concat((((n = t.popperOptions) == null ? void 0 : n.modifiers) || []).filter(function(r) {
        var i = r.name;
        return i !== e.name;
      }), [e])
    })
  };
}
var D6 = {
  name: "inlinePositioning",
  defaultValue: !1,
  fn: function(e) {
    var n = e.reference;
    function r() {
      return !!e.props.inlinePositioning;
    }
    var i, s = -1, o = !1, a = [], l = {
      name: "tippyInlinePositioning",
      enabled: !0,
      phase: "afterWrite",
      fn: function(h) {
        var p = h.state;
        r() && (a.indexOf(p.placement) !== -1 && (a = []), i !== p.placement && a.indexOf(p.placement) === -1 && (a.push(p.placement), e.setProps({
          // @ts-ignore - unneeded DOMRect properties
          getReferenceClientRect: function() {
            return c(p.placement);
          }
        })), i = p.placement);
      }
    };
    function c(f) {
      return I6(pD(f), n.getBoundingClientRect(), Rc(n.getClientRects()), s);
    }
    function u(f) {
      o = !0, e.setProps(f), o = !1;
    }
    function d() {
      o || u(R6(e.props, l));
    }
    return {
      onCreate: d,
      onAfterUpdate: d,
      onTrigger: function(h, p) {
        if (F_(p)) {
          var g = Rc(e.reference.getClientRects()), m = g.find(function(y) {
            return y.left - 2 <= p.clientX && y.right + 2 >= p.clientX && y.top - 2 <= p.clientY && y.bottom + 2 >= p.clientY;
          }), v = g.indexOf(m);
          s = v > -1 ? v : s;
        }
      },
      onHidden: function() {
        s = -1;
      }
    };
  }
};
function I6(t, e, n, r) {
  if (n.length < 2 || t === null)
    return e;
  if (n.length === 2 && r >= 0 && n[0].left > n[1].right)
    return n[r] || e;
  switch (t) {
    case "top":
    case "bottom": {
      var i = n[0], s = n[n.length - 1], o = t === "top", a = i.top, l = s.bottom, c = o ? i.left : s.left, u = o ? i.right : s.right, d = u - c, f = l - a;
      return {
        top: a,
        bottom: l,
        left: c,
        right: u,
        width: d,
        height: f
      };
    }
    case "left":
    case "right": {
      var h = Math.min.apply(Math, n.map(function(w) {
        return w.left;
      })), p = Math.max.apply(Math, n.map(function(w) {
        return w.right;
      })), g = n.filter(function(w) {
        return t === "left" ? w.left === h : w.right === p;
      }), m = g[0].top, v = g[g.length - 1].bottom, y = h, E = p, b = E - y, _ = v - m;
      return {
        top: m,
        bottom: v,
        left: y,
        right: E,
        width: b,
        height: _
      };
    }
    default:
      return e;
  }
}
var P6 = {
  name: "sticky",
  defaultValue: !1,
  fn: function(e) {
    var n = e.reference, r = e.popper;
    function i() {
      return e.popperInstance ? e.popperInstance.state.elements.reference : n;
    }
    function s(c) {
      return e.props.sticky === !0 || e.props.sticky === c;
    }
    var o = null, a = null;
    function l() {
      var c = s("reference") ? i().getBoundingClientRect() : null, u = s("popper") ? r.getBoundingClientRect() : null;
      (c && aC(o, c) || u && aC(a, u)) && e.popperInstance && e.popperInstance.update(), o = c, a = u, e.state.isMounted && requestAnimationFrame(l);
    }
    return {
      onMount: function() {
        e.props.sticky && l();
      }
    };
  }
};
function aC(t, e) {
  return t && e ? t.top !== e.top || t.right !== e.right || t.bottom !== e.bottom || t.left !== e.left : !0;
}
We.setDefaultProps({
  render: bD
});
We.setDefaultProps({
  //@ts-ignore
  onShow: (t) => {
    if (!t.props.content)
      return !1;
  }
});
function wD(t, e = {}, n = { mount: !0, appName: "Tippy" }) {
  n = Object.assign({ mount: !0, appName: "Tippy" }, n);
  const r = Oo(), i = X(), s = X({
    isEnabled: !1,
    isVisible: !1,
    isDestroyed: !1,
    isMounted: !1,
    isShown: !1
  }), o = mv();
  let a = null;
  const l = () => a || (a = document.createDocumentFragment(), a), c = (S) => {
    let x, k = Ss(S) ? S.value : S;
    return f3(k) ? (o.value || (o.value = dx({
      name: n.appName,
      setup: () => () => Ss(S) ? S.value : S
    }), r && Object.assign(o.value._context, r.appContext), o.value.mount(l())), x = () => l()) : typeof k == "object" ? (o.value || (o.value = dx({
      name: n.appName,
      setup: () => () => mt(Ss(S) ? S.value : S)
    }), r && Object.assign(o.value._context, r.appContext), o.value.mount(l())), x = () => l()) : x = k, x;
  }, u = (S) => {
    let x = {};
    return Ss(S) ? x = S.value || {} : ux(S) ? x = { ...S } : x = { ...S }, x.content && (x.content = c(x.content)), x.triggerTarget && (x.triggerTarget = Ss(x.triggerTarget) ? x.triggerTarget.value : x.triggerTarget), (!x.plugins || !Array.isArray(x.plugins)) && (x.plugins = []), x.plugins = x.plugins.filter((k) => k.name !== "vueTippyReactiveState"), x.plugins.push({
      name: "vueTippyReactiveState",
      fn: () => ({
        onCreate() {
          s.value.isEnabled = !0;
        },
        onMount() {
          s.value.isMounted = !0;
        },
        onShow() {
          s.value.isMounted = !0, s.value.isVisible = !0;
        },
        onShown() {
          s.value.isShown = !0;
        },
        onHide() {
          s.value.isMounted = !1, s.value.isVisible = !1;
        },
        onHidden() {
          s.value.isShown = !1;
        },
        onUnmounted() {
          s.value.isMounted = !1;
        },
        onDestroy() {
          s.value.isDestroyed = !0;
        }
      })
    }), x;
  }, d = () => {
    i.value && i.value.setProps(u(e));
  }, f = () => {
    !i.value || !e.content || i.value.setContent(c(e.content));
  }, h = (S) => {
    var x;
    (x = i.value) === null || x === void 0 || x.setContent(c(S));
  }, p = (S) => {
    var x;
    (x = i.value) === null || x === void 0 || x.setProps(u(S));
  }, g = () => {
    var S;
    i.value && (i.value.destroy(), i.value = void 0), a = null, (S = o.value) === null || S === void 0 || S.unmount(), o.value = void 0;
  }, m = () => {
    var S;
    (S = i.value) === null || S === void 0 || S.show();
  }, v = () => {
    var S;
    (S = i.value) === null || S === void 0 || S.hide();
  }, y = () => {
    var S;
    (S = i.value) === null || S === void 0 || S.disable(), s.value.isEnabled = !1;
  }, E = () => {
    var S;
    (S = i.value) === null || S === void 0 || S.enable(), s.value.isEnabled = !0;
  }, b = () => {
    var S;
    (S = i.value) === null || S === void 0 || S.unmount();
  }, _ = () => {
    if (!t)
      return;
    let S = Ss(t) ? t.value : t;
    typeof S == "function" && (S = S()), S && (i.value = We(S, u(e)), S.$tippy = w);
  }, w = {
    tippy: i,
    refresh: d,
    refreshContent: f,
    setContent: h,
    setProps: p,
    destroy: g,
    hide: v,
    show: m,
    disable: y,
    enable: E,
    unmount: b,
    mount: _,
    state: s
  };
  return n.mount && (r ? r.isMounted ? _() : Zt(_) : _()), r && Mo(() => {
    g();
  }), Ss(e) || ux(e) ? Bt(e, d, { immediate: !1 }) : Ss(e.content) && Bt(e.content, f, { immediate: !1 }), w;
}
function L6(t, e) {
  const n = X();
  return Zt(() => {
    const i = (Array.isArray(t) ? t.map((s) => s.value) : typeof t == "function" ? t() : t.value).map((s) => s instanceof Element ? s._tippy : s).filter(Boolean);
    n.value = C6(i, e ? { allowHTML: !0, ...e } : { allowHTML: !0 });
  }), {
    singleton: n
  };
}
function $6(t) {
  return typeof t == "function" ? t() : C(t);
}
function B6(t) {
  var e, n;
  const r = $6(t);
  return (n = (e = r) === null || e === void 0 ? void 0 : e.$el) !== null && n !== void 0 ? n : r;
}
const _D = ae({
  props: {
    to: {
      type: [String, Function]
    },
    tag: {
      type: [String, Object],
      default: "span"
    },
    contentTag: {
      type: [String, Object],
      default: "span"
    },
    contentClass: {
      type: String,
      default: null
    },
    appendTo: { default: () => We.defaultProps.appendTo },
    aria: { default: () => We.defaultProps.aria },
    delay: { default: () => We.defaultProps.delay },
    duration: { default: () => We.defaultProps.duration },
    getReferenceClientRect: { default: () => We.defaultProps.getReferenceClientRect },
    hideOnClick: { type: [Boolean, String], default: () => We.defaultProps.hideOnClick },
    ignoreAttributes: { type: Boolean, default: () => We.defaultProps.ignoreAttributes },
    interactive: { type: Boolean, default: () => We.defaultProps.interactive },
    interactiveBorder: { default: () => We.defaultProps.interactiveBorder },
    interactiveDebounce: { default: () => We.defaultProps.interactiveDebounce },
    moveTransition: { default: () => We.defaultProps.moveTransition },
    offset: { default: () => We.defaultProps.offset },
    onAfterUpdate: { default: () => We.defaultProps.onAfterUpdate },
    onBeforeUpdate: { default: () => We.defaultProps.onBeforeUpdate },
    onCreate: { default: () => We.defaultProps.onCreate },
    onDestroy: { default: () => We.defaultProps.onDestroy },
    onHidden: { default: () => We.defaultProps.onHidden },
    onHide: { default: () => We.defaultProps.onHide },
    onMount: { default: () => We.defaultProps.onMount },
    onShow: { default: () => We.defaultProps.onShow },
    onShown: { default: () => We.defaultProps.onShown },
    onTrigger: { default: () => We.defaultProps.onTrigger },
    onUntrigger: { default: () => We.defaultProps.onUntrigger },
    onClickOutside: { default: () => We.defaultProps.onClickOutside },
    placement: { default: () => We.defaultProps.placement },
    plugins: { default: () => We.defaultProps.plugins },
    popperOptions: { default: () => We.defaultProps.popperOptions },
    render: { default: () => We.defaultProps.render },
    showOnCreate: { type: Boolean, default: () => We.defaultProps.showOnCreate },
    touch: { type: [Boolean, String, Array], default: () => We.defaultProps.touch },
    trigger: { default: () => We.defaultProps.trigger },
    triggerTarget: { default: () => We.defaultProps.triggerTarget },
    animateFill: { type: Boolean, default: () => We.defaultProps.animateFill },
    followCursor: { type: [Boolean, String], default: () => We.defaultProps.followCursor },
    inlinePositioning: { type: Boolean, default: () => We.defaultProps.inlinePositioning },
    sticky: { type: [Boolean, String], default: () => We.defaultProps.sticky },
    allowHTML: { type: Boolean, default: () => We.defaultProps.allowHTML },
    animation: { default: () => We.defaultProps.animation },
    arrow: { default: () => We.defaultProps.arrow },
    content: { default: () => We.defaultProps.content },
    inertia: { default: () => We.defaultProps.inertia },
    maxWidth: { default: () => We.defaultProps.maxWidth },
    role: { default: () => We.defaultProps.role },
    theme: { default: () => We.defaultProps.theme },
    zIndex: { default: () => We.defaultProps.zIndex }
  },
  emits: ["state"],
  setup(t, { slots: e, emit: n, expose: r }) {
    const i = X(), s = X(), o = X(), a = X(!1), l = () => {
      let h = { ...t };
      for (const p of ["to", "tag", "contentTag", "contentClass"])
        h.hasOwnProperty(p) && delete h[p];
      return h;
    };
    let c = () => B6(i);
    t.to && (typeof Element < "u" && t.to instanceof Element ? c = () => t.to : t.to === "parent" ? c = () => {
      let h = i.value;
      return h || (h = i.value = s.value.parentElement), h;
    } : (typeof t.to == "string" || t.to instanceof String) && (c = () => document.querySelector(t.to)));
    const u = wD(c, l());
    let d = e.content;
    !d && t.to === "parent" && (d = e.default), Zt(() => {
      a.value = !0, Af(() => {
        d && u.setContent(() => o.value);
      });
    }), Bt(u.state, () => {
      n("state", C(u.state));
    }, { immediate: !0, deep: !0 }), Bt(() => t, () => {
      u.setProps(l()), d && u.setContent(() => o.value);
    }, { deep: !0 });
    let f = Gw({
      elem: i,
      contentElem: o,
      mounted: a,
      ...u
    });
    return r(f), () => {
      const h = (typeof t.contentTag == "string", t.contentTag), p = d ? mt(h, {
        ref: o,
        style: { display: a.value ? "inherit" : "none" },
        class: t.contentClass
      }, d(f)) : null;
      if (t.to === "parent") {
        const v = [];
        if (!i.value) {
          const y = mt("span", {
            ref: s,
            "data-v-tippy": "",
            style: { display: "none" }
          });
          v.push(y);
        }
        return p && v.push(p), v;
      }
      const g = e.default ? e.default(f) : [];
      if (!t.tag) {
        const v = mt(g[0], {
          ref: i,
          "data-v-tippy": ""
        });
        return p ? [v, p] : v;
      }
      const m = (typeof t.tag == "string", t.tag);
      return mt(m, { ref: i, "data-v-tippy": "" }, p ? [g, p] : g);
    };
  }
}), F6 = [
  "a11y",
  "allowHTML",
  "arrow",
  "flip",
  "flipOnUpdate",
  "hideOnClick",
  "ignoreAttributes",
  "inertia",
  "interactive",
  "lazy",
  "multiple",
  "showOnInit",
  "touch",
  "touchHold"
];
let Xy = {};
Object.keys(We.defaultProps).forEach((t) => {
  F6.includes(t) ? Xy[t] = {
    type: Boolean,
    default: function() {
      return We.defaultProps[t];
    }
  } : Xy[t] = {
    default: function() {
      return We.defaultProps[t];
    }
  };
});
const z6 = ae({
  props: Xy,
  setup(t) {
    const e = X([]), { singleton: n } = L6(e, t);
    return { instances: e, singleton: n };
  },
  mounted() {
    var t;
    const n = this.$el.parentElement.querySelectorAll("[data-v-tippy]");
    this.instances = Array.from(n).map((r) => r._tippy).filter(Boolean), (t = this.singleton) === null || t === void 0 || t.setInstances(this.instances);
  },
  render() {
    let t = this.$slots.default ? this.$slots.default() : [];
    return mt(() => t);
  }
}), H6 = {
  mounted(t, e, n) {
    const r = typeof e.value == "string" ? { content: e.value } : e.value || {}, i = Object.keys(e.modifiers || {}), s = i.find((a) => a !== "arrow"), o = i.findIndex((a) => a === "arrow") !== -1;
    s && (r.placement = r.placement || s), o && (r.arrow = r.arrow !== void 0 ? r.arrow : !0), n.props && n.props.onTippyShow && (r.onShow = function(...a) {
      var l;
      return (l = n.props) === null || l === void 0 ? void 0 : l.onTippyShow(...a);
    }), n.props && n.props.onTippyShown && (r.onShown = function(...a) {
      var l;
      return (l = n.props) === null || l === void 0 ? void 0 : l.onTippyShown(...a);
    }), n.props && n.props.onTippyHidden && (r.onHidden = function(...a) {
      var l;
      return (l = n.props) === null || l === void 0 ? void 0 : l.onTippyHidden(...a);
    }), n.props && n.props.onTippyHide && (r.onHide = function(...a) {
      var l;
      return (l = n.props) === null || l === void 0 ? void 0 : l.onTippyHide(...a);
    }), n.props && n.props.onTippyMount && (r.onMount = function(...a) {
      var l;
      return (l = n.props) === null || l === void 0 ? void 0 : l.onTippyMount(...a);
    }), t.getAttribute("title") && !r.content && (r.content = t.getAttribute("title"), t.removeAttribute("title")), t.getAttribute("content") && !r.content && (r.content = t.getAttribute("content")), wD(t, r);
  },
  unmounted(t) {
    t.$tippy ? t.$tippy.destroy() : t._tippy && t._tippy.destroy();
  },
  updated(t, e) {
    const n = typeof e.value == "string" ? { content: e.value } : e.value || {};
    t.getAttribute("title") && !n.content && (n.content = t.getAttribute("title"), t.removeAttribute("title")), t.getAttribute("content") && !n.content && (n.content = t.getAttribute("content")), t.$tippy ? t.$tippy.setProps(n || {}) : t._tippy && t._tippy.setProps(n || {});
  }
}, U6 = {
  install(t, e = {}) {
    We.setDefaultProps(e.defaultProps || {}), t.directive(e.directive || "tippy", H6), t.component(e.component || "tippy", _D), t.component(e.componentSingleton || "tippy-singleton", z6);
  }
}, V6 = We.setDefaultProps;
V6({
  ignoreAttributes: !0,
  plugins: [P6, D6, N6, T6]
});
const W6 = { class: "px-1.5 py-0.5" }, kg = /* @__PURE__ */ ae({
  __name: "LangTippy",
  setup(t) {
    const e = X();
    return Zt(() => {
      e.value = document.body;
    }), (n, r) => (J(), Ze(C(_D), {
      "allow-h-t-m-l": !0,
      "append-to": e.value,
      interactive: !0,
      theme: "black-tippy"
    }, {
      content: Ue(() => [
        se("div", W6, [
          Lt(n.$slots, "content")
        ])
      ]),
      default: Ue(() => [
        Lt(n.$slots, "button")
      ]),
      _: 3
    }, 8, ["append-to"]));
  }
}), Ve = {
  __name: "LangMenuItem",
  props: {
    icon: {
      type: [Object, Function, String],
      required: !1
    },
    title: {
      type: String,
      required: !0
    },
    action: {
      type: Function,
      required: !1
    },
    isActive: {
      type: Function,
      default: null
    },
    color: {
      type: String,
      required: !1
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    return (e, n) => (J(), Ze(kg, null, {
      content: Ue(() => [
        vv(Ut(t.title), 1)
      ]),
      button: Ue(() => [
        se("button", {
          class: It([t.mini ? "!px-1.5 !py-1.5" : "", "p-2 rounded flex items-center cursor-pointer transition-all langeditor-text langeditor-hover"]),
          type: "button",
          onClick: n[0] || (n[0] = (...r) => t.action && t.action(...r))
        }, [
          Lt(e.$slots, "text"),
          typeof t.icon == "function" || typeof t.icon == "object" ? (J(), Ze(ii(t.icon), {
            key: 0,
            class: It([{ "text-blue-500": t.isActive ? t.isActive() : null }, "w-4 h-4"]),
            style: Rr({ color: t.color })
          }, null, 8, ["class", "style"])) : (J(), be("i", {
            key: 1,
            class: It(`ri-${t.icon}`)
          }, null, 2))
        ], 2)
      ]),
      _: 3
    }));
  }
};
function et() {
  return Ln("editorInstance");
}
function nt(t) {
  Ln("useExtension")(t);
}
function G6(t) {
  Ln("removeExtension")(t);
}
function zf(t) {
  const e = et();
  return J8(e, () => {
    t();
  }), e;
}
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const j6 = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var wh = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const q6 = ({ size: t, strokeWidth: e = 2, absoluteStrokeWidth: n, color: r, iconNode: i, name: s, class: o, ...a }, { slots: l }) => mt(
  "svg",
  {
    ...wh,
    width: t || wh.width,
    height: t || wh.height,
    stroke: r || wh.stroke,
    "stroke-width": n ? Number(e) * 24 / Number(t) : e,
    class: ["lucide", `lucide-${j6(s ?? "icon")}`],
    ...a
  },
  [...i.map((c) => mt(...c)), ...l.default ? [l.default()] : []]
);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Me = (t, e) => (n, { slots: r }) => mt(
  q6,
  {
    ...n,
    iconNode: e,
    name: t
  },
  r
);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const z_ = Me("AlignCenterIcon", [
  ["path", { d: "M17 12H7", key: "16if0g" }],
  ["path", { d: "M19 18H5", key: "18s9l3" }],
  ["path", { d: "M21 6H3", key: "1jwq7v" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const K6 = Me("AlignJustifyIcon", [
  ["path", { d: "M3 12h18", key: "1i2n21" }],
  ["path", { d: "M3 18h18", key: "1h113x" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Hd = Me("AlignLeftIcon", [
  ["path", { d: "M15 12H3", key: "6jk70r" }],
  ["path", { d: "M17 18H3", key: "1amg6g" }],
  ["path", { d: "M21 6H3", key: "1jwq7v" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const H_ = Me("AlignRightIcon", [
  ["path", { d: "M21 12H9", key: "dn1m92" }],
  ["path", { d: "M21 18H7", key: "1ygte8" }],
  ["path", { d: "M21 6H3", key: "1jwq7v" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Y6 = Me("ArrowDownToLineIcon", [
  ["path", { d: "M12 17V3", key: "1cwfxf" }],
  ["path", { d: "m6 11 6 6 6-6", key: "12ii2o" }],
  ["path", { d: "M19 21H5", key: "150jfl" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X6 = Me("ArrowLeftToLineIcon", [
  ["path", { d: "M3 19V5", key: "rwsyhb" }],
  ["path", { d: "m13 6-6 6 6 6", key: "1yhaz7" }],
  ["path", { d: "M7 12h14", key: "uoisry" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const J6 = Me("ArrowRightToLineIcon", [
  ["path", { d: "M17 12H3", key: "8awo09" }],
  ["path", { d: "m11 18 6-6-6-6", key: "8c2y43" }],
  ["path", { d: "M21 5v14", key: "nzette" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Z6 = Me("ArrowUpToLineIcon", [
  ["path", { d: "M5 3h14", key: "7usisc" }],
  ["path", { d: "m18 13-6-6-6 6", key: "1kf1n9" }],
  ["path", { d: "M12 7v14", key: "1akyts" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Q6 = Me("BaselineIcon", [
  ["path", { d: "M4 20h16", key: "14thso" }],
  ["path", { d: "m6 16 6-12 6 12", key: "1b4byz" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eG = Me("BoldIcon", [
  [
    "path",
    { d: "M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8", key: "mg9rjx" }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tG = Me("BrushIcon", [
  ["path", { d: "m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08", key: "1styjt" }],
  [
    "path",
    {
      d: "M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2 2.02 1.08 1.1 2.49 2.02 4 2.02 2.2 0 4-1.8 4-4.04a3.01 3.01 0 0 0-3-3.02z",
      key: "z0l1mu"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Fv = Me("CheckIcon", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nG = Me("ChevronDownIcon", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lC = Me("CircleStopIcon", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["rect", { x: "9", y: "9", width: "6", height: "6", rx: "1", key: "1ssd4o" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rG = Me("CloudUploadIcon", [
  ["path", { d: "M12 13v8", key: "1l5pq0" }],
  ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242", key: "1pljnt" }],
  ["path", { d: "m8 17 4-4 4 4", key: "1quai1" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ED = Me("CodeIcon", [
  ["polyline", { points: "16 18 22 12 16 6", key: "z7tu5w" }],
  ["polyline", { points: "8 6 2 12 8 18", key: "1eg1df" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iG = Me("EraserIcon", [
  [
    "path",
    {
      d: "m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21",
      key: "182aya"
    }
  ],
  ["path", { d: "M22 21H7", key: "t4ddhn" }],
  ["path", { d: "m5 11 9 9", key: "1mo9qw" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sG = Me("ExternalLinkIcon", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jy = Me("EyeIcon", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oG = Me("FoldHorizontalIcon", [
  ["path", { d: "M2 12h6", key: "1wqiqv" }],
  ["path", { d: "M22 12h-6", key: "1eg9hc" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M12 8v2", key: "1woqiv" }],
  ["path", { d: "M12 14v2", key: "8jcxud" }],
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "m19 9-3 3 3 3", key: "12ol22" }],
  ["path", { d: "m5 15 3-3-3-3", key: "1kdhjc" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aG = Me("Grid3x3Icon", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M3 15h18", key: "5xshup" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SD = Me("Heading1Icon", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "m17 12 3-2v8", key: "1hhhft" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xD = Me("Heading2Icon", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1", key: "9jr5yi" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kD = Me("Heading3Icon", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2", key: "68ncm8" }],
  ["path", { d: "M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2", key: "1ejuhz" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lG = Me("Heading4Icon", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "M17 10v4h4", key: "13sv97" }],
  ["path", { d: "M21 10v8", key: "1kdml4" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cG = Me("Heading5Icon", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "M17 13v-3h4", key: "1nvgqp" }],
  [
    "path",
    { d: "M17 17.7c.4.2.8.3 1.3.3 1.5 0 2.7-1.1 2.7-2.5S19.8 13 18.3 13H17", key: "2nebdn" }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uG = Me("Heading6Icon", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["circle", { cx: "19", cy: "16", r: "2", key: "15mx69" }],
  ["path", { d: "M20 10c-2 2-3 3.5-3 6", key: "f35dl0" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const U_ = Me("ImageIcon", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dG = Me("ItalicIcon", [
  ["line", { x1: "19", x2: "10", y1: "4", y2: "4", key: "15jd3p" }],
  ["line", { x1: "14", x2: "5", y1: "20", y2: "20", key: "bu0au3" }],
  ["line", { x1: "15", x2: "9", y1: "4", y2: "20", key: "uljnxc" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fG = Me("LanguagesIcon", [
  ["path", { d: "m5 8 6 6", key: "1wu5hv" }],
  ["path", { d: "m4 14 6-6 2-3", key: "1k1g8d" }],
  ["path", { d: "M2 5h12", key: "or177f" }],
  ["path", { d: "M7 2h1", key: "1t2jsx" }],
  ["path", { d: "m22 22-5-10-5 10", key: "don7ne" }],
  ["path", { d: "M14 18h6", key: "1m8k6r" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Dc = Me("LinkIcon", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CD = Me("ListMinusIcon", [
  ["path", { d: "M11 12H3", key: "51ecnj" }],
  ["path", { d: "M16 6H3", key: "1wxfjs" }],
  ["path", { d: "M16 18H3", key: "12xzn7" }],
  ["path", { d: "M21 12h-6", key: "bt1uis" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hG = Me("ListOrderedIcon", [
  ["path", { d: "M10 12h11", key: "6m4ad9" }],
  ["path", { d: "M10 18h11", key: "11hvi2" }],
  ["path", { d: "M10 6h11", key: "c7qv1k" }],
  ["path", { d: "M4 10h2", key: "16xx2s" }],
  ["path", { d: "M4 6h1v4", key: "cnovpq" }],
  ["path", { d: "M6 18H4c0-1 2-2 2-3s-1-1.5-2-1", key: "m9a95d" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pG = Me("ListTodoIcon", [
  ["rect", { x: "3", y: "5", width: "6", height: "6", rx: "1", key: "1defrl" }],
  ["path", { d: "m3 17 2 2 4-4", key: "1jhpwq" }],
  ["path", { d: "M13 6h8", key: "15sg57" }],
  ["path", { d: "M13 12h8", key: "h98zly" }],
  ["path", { d: "M13 18h8", key: "oe0vm4" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TD = Me("ListIcon", [
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 18h.01", key: "1tta3j" }],
  ["path", { d: "M3 6h.01", key: "1rqtza" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 18h13", key: "1lx6n3" }],
  ["path", { d: "M8 6h13", key: "ik3vkj" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const OD = Me("Maximize2Icon", [
  ["polyline", { points: "15 3 21 3 21 9", key: "mznyad" }],
  ["polyline", { points: "9 21 3 21 3 15", key: "1avn1i" }],
  ["line", { x1: "21", x2: "14", y1: "3", y2: "10", key: "ota7mn" }],
  ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gG = Me("MaximizeIcon", [
  ["path", { d: "M8 3H5a2 2 0 0 0-2 2v3", key: "1dcmit" }],
  ["path", { d: "M21 8V5a2 2 0 0 0-2-2h-3", key: "1e4gt3" }],
  ["path", { d: "M3 16v3a2 2 0 0 0 2 2h3", key: "wsl5sc" }],
  ["path", { d: "M16 21h3a2 2 0 0 0 2-2v-3", key: "18trek" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MD = Me("Minimize2Icon", [
  ["polyline", { points: "4 14 10 14 10 20", key: "11kfnr" }],
  ["polyline", { points: "20 10 14 10 14 4", key: "rlmsce" }],
  ["line", { x1: "14", x2: "21", y1: "10", y2: "3", key: "o5lafz" }],
  ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mG = Me("MinimizeIcon", [
  ["path", { d: "M8 3v3a2 2 0 0 1-2 2H3", key: "hohbtr" }],
  ["path", { d: "M21 8h-3a2 2 0 0 1-2-2V3", key: "5jw1f3" }],
  ["path", { d: "M3 16h3a2 2 0 0 1 2 2v3", key: "198tvr" }],
  ["path", { d: "M16 21v-3a2 2 0 0 1 2-2h3", key: "ph8mxp" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vG = Me("MinusIcon", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bG = Me("NotebookTextIcon", [
  ["path", { d: "M2 6h4", key: "aawbzj" }],
  ["path", { d: "M2 10h4", key: "l0bgd4" }],
  ["path", { d: "M2 14h4", key: "1gsvsf" }],
  ["path", { d: "M2 18h4", key: "1bu2t1" }],
  ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2", key: "1nb95v" }],
  ["path", { d: "M9.5 8h5", key: "11mslq" }],
  ["path", { d: "M9.5 12H16", key: "ktog6x" }],
  ["path", { d: "M9.5 16H14", key: "p1seyn" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yG = Me("PenIcon", [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wG = Me("PencilLineIcon", [
  ["path", { d: "M12 20h9", key: "t2du7b" }],
  [
    "path",
    {
      d: "M16.376 3.622a1 1 0 0 1 3.002 3.002L7.368 18.635a2 2 0 0 1-.855.506l-2.872.838a.5.5 0 0 1-.62-.62l.838-2.872a2 2 0 0 1 .506-.854z",
      key: "1ykcvy"
    }
  ],
  ["path", { d: "m15 5 3 3", key: "1w25hb" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _G = Me("PencilRulerIcon", [
  [
    "path",
    { d: "M13 7 8.7 2.7a2.41 2.41 0 0 0-3.4 0L2.7 5.3a2.41 2.41 0 0 0 0 3.4L7 13", key: "orapub" }
  ],
  ["path", { d: "m8 6 2-2", key: "115y1s" }],
  ["path", { d: "m18 16 2-2", key: "ee94s4" }],
  [
    "path",
    {
      d: "m17 11 4.3 4.3c.94.94.94 2.46 0 3.4l-2.6 2.6c-.94.94-2.46.94-3.4 0L11 17",
      key: "cfq27r"
    }
  ],
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ],
  ["path", { d: "m15 5 4 4", key: "1mk7zo" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EG = Me("PencilIcon", [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ],
  ["path", { d: "m15 5 4 4", key: "1mk7zo" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SG = Me("PilcrowIcon", [
  ["path", { d: "M13 4v16", key: "8vvj80" }],
  ["path", { d: "M17 4v16", key: "7dpous" }],
  ["path", { d: "M19 4H9.5a4.5 4.5 0 0 0 0 9H13", key: "sh4n9v" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xG = Me("PrinterIcon", [
  [
    "path",
    {
      d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2",
      key: "143wyd"
    }
  ],
  ["path", { d: "M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6", key: "1itne7" }],
  ["rect", { x: "6", y: "14", width: "12", height: "8", rx: "1", key: "1ue0tg" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AD = Me("QuoteIcon", [
  [
    "path",
    {
      d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
      key: "rib7q0"
    }
  ],
  [
    "path",
    {
      d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
      key: "1ymkrd"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kG = Me("Redo2Icon", [
  ["path", { d: "m15 14 5-5-5-5", key: "12vg1m" }],
  ["path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13", key: "6uklza" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CG = Me("Repeat2Icon", [
  ["path", { d: "m2 9 3-3 3 3", key: "1ltn5i" }],
  ["path", { d: "M13 18H7a2 2 0 0 1-2-2V6", key: "1r6tfw" }],
  ["path", { d: "m22 15-3 3-3-3", key: "4rnwn2" }],
  ["path", { d: "M11 6h6a2 2 0 0 1 2 2v10", key: "2f72bc" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ga = Me("SendIcon", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TG = Me("SeparatorHorizontalIcon", [
  ["line", { x1: "3", x2: "21", y1: "12", y2: "12", key: "10d38w" }],
  ["polyline", { points: "8 8 12 4 16 8", key: "zo8t4w" }],
  ["polyline", { points: "16 16 12 20 8 16", key: "1oyrid" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const OG = Me("SeparatorVerticalIcon", [
  ["line", { x1: "12", x2: "12", y1: "3", y2: "21", key: "1efggb" }],
  ["polyline", { points: "8 8 4 12 8 16", key: "bnfmv4" }],
  ["polyline", { points: "16 16 20 12 16 8", key: "u90052" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ND = Me("SigmaIcon", [
  [
    "path",
    {
      d: "M18 7V5a1 1 0 0 0-1-1H6.5a.5.5 0 0 0-.4.8l4.5 6a2 2 0 0 1 0 2.4l-4.5 6a.5.5 0 0 0 .4.8H17a1 1 0 0 0 1-1v-2",
      key: "wuwx1p"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MG = Me("SparklesIcon", [
  [
    "path",
    {
      d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
      key: "4pj2yx"
    }
  ],
  ["path", { d: "M20 3v4", key: "1olli1" }],
  ["path", { d: "M22 5h-4", key: "1gvqau" }],
  ["path", { d: "M4 17v2", key: "vumght" }],
  ["path", { d: "M5 18H3", key: "zchphs" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RD = Me("SquareCodeIcon", [
  ["path", { d: "M10 9.5 8 12l2 2.5", key: "3mjy60" }],
  ["path", { d: "m14 9.5 2 2.5-2 2.5", key: "1bir2l" }],
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AG = Me("StrikethroughIcon", [
  ["path", { d: "M16 4H9a3 3 0 0 0-2.83 4", key: "43sutm" }],
  ["path", { d: "M14 12a4 4 0 0 1 0 8H6", key: "nlfj13" }],
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const NG = Me("SubscriptIcon", [
  ["path", { d: "m4 5 8 8", key: "1eunvl" }],
  ["path", { d: "m12 5-8 8", key: "1ah0jp" }],
  [
    "path",
    {
      d: "M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07",
      key: "e8ta8j"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RG = Me("SuperscriptIcon", [
  ["path", { d: "m4 19 8-8", key: "hr47gm" }],
  ["path", { d: "m12 19-8-8", key: "1dhhmo" }],
  [
    "path",
    {
      d: "M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06",
      key: "1dfcux"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zv = Me("Trash2Icon", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const DG = Me("TvMinimalIcon", [
  ["path", { d: "M7 21h10", key: "1b0cd5" }],
  ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2", key: "48i651" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const IG = Me("UnderlineIcon", [
  ["path", { d: "M6 4v6a6 6 0 0 0 12 0V4", key: "9kb039" }],
  ["line", { x1: "4", x2: "20", y1: "20", y2: "20", key: "nun2al" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const PG = Me("Undo2Icon", [
  ["path", { d: "M9 14 4 9l5-5", key: "102s5s" }],
  ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11", key: "f3b9sd" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LG = Me("UnfoldHorizontalIcon", [
  ["path", { d: "M16 12h6", key: "15xry1" }],
  ["path", { d: "M8 12H2", key: "1jqql6" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M12 8v2", key: "1woqiv" }],
  ["path", { d: "M12 14v2", key: "8jcxud" }],
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "m19 15 3-3-3-3", key: "wjy7rq" }],
  ["path", { d: "m5 9-3 3 3 3", key: "j64kie" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $G = Me("UnlinkIcon", [
  [
    "path",
    {
      d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71",
      key: "yqzxt4"
    }
  ],
  [
    "path",
    {
      d: "m5.17 11.75-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71",
      key: "4qinb0"
    }
  ],
  ["line", { x1: "8", x2: "8", y1: "2", y2: "5", key: "1041cp" }],
  ["line", { x1: "2", x2: "5", y1: "8", y2: "8", key: "14m1p5" }],
  ["line", { x1: "16", x2: "16", y1: "19", y2: "22", key: "rzdirn" }],
  ["line", { x1: "19", x2: "22", y1: "16", y2: "16", key: "ox905f" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const DD = Me("VideoIcon", [
  [
    "path",
    {
      d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
      key: "ftymec"
    }
  ],
  ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BG = Me("VolumeOffIcon", [
  ["path", { d: "M16 9a5 5 0 0 1 .95 2.293", key: "1fgyg8" }],
  ["path", { d: "M19.364 5.636a9 9 0 0 1 1.889 9.96", key: "l3zxae" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  [
    "path",
    {
      d: "m7 7-.587.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298V11",
      key: "1gbwow"
    }
  ],
  ["path", { d: "M9.828 4.172A.686.686 0 0 1 11 4.657v.686", key: "s2je0y" }]
]);
/**
 * @license lucide-vue-next v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FG = Me("WrapTextIcon", [
  ["line", { x1: "3", x2: "21", y1: "6", y2: "6", key: "4m8b97" }],
  ["path", { d: "M3 12h15a3 3 0 1 1 0 6h-4", key: "1cl7v7" }],
  ["polyline", { points: "16 16 14 18 16 20", key: "1jznyi" }],
  ["line", { x1: "3", x2: "10", y1: "18", y2: "18", key: "1h33wv" }]
]);
/*!
  * shared v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const Ai = typeof window < "u";
let Dr, ja;
if (process.env.NODE_ENV !== "production") {
  const t = Ai && window.performance;
  t && t.mark && t.measure && t.clearMarks && // @ts-ignore browser compat
  t.clearMeasures && (Dr = (e) => {
    t.mark(e);
  }, ja = (e, n, r) => {
    t.measure(e, n, r), t.clearMarks(n), t.clearMarks(r);
  });
}
const zG = /\{([0-9a-zA-Z]+)\}/g;
function Hv(t, ...e) {
  return e.length === 1 && bt(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(zG, (n, r) => e.hasOwnProperty(r) ? e[r] : "");
}
const gs = (t, e = !1) => e ? Symbol.for(t) : Symbol(t), HG = (t, e, n) => UG({ l: t, k: e, s: n }), UG = (t) => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), dn = (t) => typeof t == "number" && isFinite(t), VG = (t) => V_(t) === "[object Date]", Ic = (t) => V_(t) === "[object RegExp]", Uv = (t) => at(t) && Object.keys(t).length === 0, gn = Object.assign;
let cC;
const pa = () => cC || (cC = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function uC(t) {
  return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const WG = Object.prototype.hasOwnProperty;
function Cg(t, e) {
  return WG.call(t, e);
}
const Kt = Array.isArray, Rt = (t) => typeof t == "function", ke = (t) => typeof t == "string", yt = (t) => typeof t == "boolean", bt = (t) => t !== null && typeof t == "object", GG = (t) => bt(t) && Rt(t.then) && Rt(t.catch), ID = Object.prototype.toString, V_ = (t) => ID.call(t), at = (t) => V_(t) === "[object Object]", jG = (t) => t == null ? "" : Kt(t) || at(t) && t.toString === ID ? JSON.stringify(t, null, 2) : String(t);
function W_(t, e = "") {
  return t.reduce((n, r, i) => i === 0 ? n + r : n + e + r, "");
}
const dC = 2;
function qG(t, e = 0, n = t.length) {
  const r = t.split(/\r?\n/);
  let i = 0;
  const s = [];
  for (let o = 0; o < r.length; o++)
    if (i += r[o].length + 1, i >= e) {
      for (let a = o - dC; a <= o + dC || n > i; a++) {
        if (a < 0 || a >= r.length)
          continue;
        const l = a + 1;
        s.push(`${l}${" ".repeat(3 - String(l).length)}|  ${r[a]}`);
        const c = r[a].length;
        if (a === o) {
          const u = e - (i - c) + 1, d = Math.max(1, n > i ? c - u : n - e);
          s.push("   |  " + " ".repeat(u) + "^".repeat(d));
        } else if (a > o) {
          if (n > i) {
            const u = Math.max(Math.min(n - i, c), 1);
            s.push("   |  " + "^".repeat(u));
          }
          i += c + 1;
        }
      }
      break;
    }
  return s.join(`
`);
}
function Go(t, e) {
  typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack));
}
const fC = {};
function PD(t) {
  fC[t] || (fC[t] = !0, Go(t));
}
function G_() {
  const t = /* @__PURE__ */ new Map();
  return {
    events: t,
    on(n, r) {
      const i = t.get(n);
      i && i.push(r) || t.set(n, [r]);
    },
    off(n, r) {
      const i = t.get(n);
      i && i.splice(i.indexOf(r) >>> 0, 1);
    },
    emit(n, r) {
      (t.get(n) || []).slice().map((i) => i(r)), (t.get("*") || []).slice().map((i) => i(n, r));
    }
  };
}
const _h = (t) => !bt(t) || Kt(t);
function Sp(t, e) {
  if (_h(t) || _h(e))
    throw new Error("Invalid value");
  const n = [{ src: t, des: e }];
  for (; n.length; ) {
    const { src: r, des: i } = n.pop();
    Object.keys(r).forEach((s) => {
      bt(r[s]) && !bt(i[s]) && (i[s] = Array.isArray(r[s]) ? [] : {}), _h(i[s]) || _h(r[s]) ? i[s] = r[s] : n.push({ src: r[s], des: i[s] });
    });
  }
}
/*!
  * message-compiler v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function KG(t, e, n) {
  return { line: t, column: e, offset: n };
}
function Zy(t, e, n) {
  const r = { start: t, end: e };
  return n != null && (r.source = n), r;
}
const Qe = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16
}, YG = 17, XG = {
  // tokenizer error messages
  [Qe.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [Qe.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [Qe.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [Qe.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [Qe.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [Qe.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [Qe.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [Qe.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [Qe.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [Qe.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [Qe.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [Qe.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [Qe.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [Qe.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [Qe.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [Qe.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function eu(t, e, n = {}) {
  const { domain: r, messages: i, args: s } = n, o = process.env.NODE_ENV !== "production" ? Hv((i || XG)[t] || "", ...s || []) : t, a = new SyntaxError(String(o));
  return a.code = t, e && (a.location = e), a.domain = r, a;
}
function JG(t) {
  throw t;
}
const ZG = /<\/?[\w\s="/.':;#-\/]+>/, QG = (t) => ZG.test(t), _s = " ", ej = "\r", Gn = `
`, tj = String.fromCharCode(8232), nj = String.fromCharCode(8233);
function rj(t) {
  const e = t;
  let n = 0, r = 1, i = 1, s = 0;
  const o = (S) => e[S] === ej && e[S + 1] === Gn, a = (S) => e[S] === Gn, l = (S) => e[S] === nj, c = (S) => e[S] === tj, u = (S) => o(S) || a(S) || l(S) || c(S), d = () => n, f = () => r, h = () => i, p = () => s, g = (S) => o(S) || l(S) || c(S) ? Gn : e[S], m = () => g(n), v = () => g(n + s);
  function y() {
    return s = 0, u(n) && (r++, i = 0), o(n) && n++, n++, i++, e[n];
  }
  function E() {
    return o(n + s) && s++, s++, e[n + s];
  }
  function b() {
    n = 0, r = 1, i = 1, s = 0;
  }
  function _(S = 0) {
    s = S;
  }
  function w() {
    const S = n + s;
    for (; S !== n; )
      y();
    s = 0;
  }
  return {
    index: d,
    line: f,
    column: h,
    peekOffset: p,
    charAt: g,
    currentChar: m,
    currentPeek: v,
    next: y,
    peek: E,
    reset: b,
    resetPeek: _,
    skipToPeek: w
  };
}
const Zs = void 0, ij = ".", hC = "'", sj = "tokenizer";
function oj(t, e = {}) {
  const n = e.location !== !1, r = rj(t), i = () => r.index(), s = () => KG(r.line(), r.column(), r.index()), o = s(), a = i(), l = {
    currentType: 13,
    offset: a,
    startLoc: o,
    endLoc: o,
    lastType: 13,
    lastOffset: a,
    lastStartLoc: o,
    lastEndLoc: o,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, c = () => l, { onError: u } = e;
  function d(P, O, q, ...ee) {
    const ce = c();
    if (O.column += q, O.offset += q, u) {
      const Pe = n ? Zy(ce.startLoc, O) : null, ye = eu(P, Pe, {
        domain: sj,
        args: ee
      });
      u(ye);
    }
  }
  function f(P, O, q) {
    P.endLoc = s(), P.currentType = O;
    const ee = { type: O };
    return n && (ee.loc = Zy(P.startLoc, P.endLoc)), q != null && (ee.value = q), ee;
  }
  const h = (P) => f(
    P,
    13
    /* TokenTypes.EOF */
  );
  function p(P, O) {
    return P.currentChar() === O ? (P.next(), O) : (d(Qe.EXPECTED_TOKEN, s(), 0, O), "");
  }
  function g(P) {
    let O = "";
    for (; P.currentPeek() === _s || P.currentPeek() === Gn; )
      O += P.currentPeek(), P.peek();
    return O;
  }
  function m(P) {
    const O = g(P);
    return P.skipToPeek(), O;
  }
  function v(P) {
    if (P === Zs)
      return !1;
    const O = P.charCodeAt(0);
    return O >= 97 && O <= 122 || // a-z
    O >= 65 && O <= 90 || // A-Z
    O === 95;
  }
  function y(P) {
    if (P === Zs)
      return !1;
    const O = P.charCodeAt(0);
    return O >= 48 && O <= 57;
  }
  function E(P, O) {
    const { currentType: q } = O;
    if (q !== 2)
      return !1;
    g(P);
    const ee = v(P.currentPeek());
    return P.resetPeek(), ee;
  }
  function b(P, O) {
    const { currentType: q } = O;
    if (q !== 2)
      return !1;
    g(P);
    const ee = P.currentPeek() === "-" ? P.peek() : P.currentPeek(), ce = y(ee);
    return P.resetPeek(), ce;
  }
  function _(P, O) {
    const { currentType: q } = O;
    if (q !== 2)
      return !1;
    g(P);
    const ee = P.currentPeek() === hC;
    return P.resetPeek(), ee;
  }
  function w(P, O) {
    const { currentType: q } = O;
    if (q !== 7)
      return !1;
    g(P);
    const ee = P.currentPeek() === ".";
    return P.resetPeek(), ee;
  }
  function S(P, O) {
    const { currentType: q } = O;
    if (q !== 8)
      return !1;
    g(P);
    const ee = v(P.currentPeek());
    return P.resetPeek(), ee;
  }
  function x(P, O) {
    const { currentType: q } = O;
    if (!(q === 7 || q === 11))
      return !1;
    g(P);
    const ee = P.currentPeek() === ":";
    return P.resetPeek(), ee;
  }
  function k(P, O) {
    const { currentType: q } = O;
    if (q !== 9)
      return !1;
    const ee = () => {
      const Pe = P.currentPeek();
      return Pe === "{" ? v(P.peek()) : Pe === "@" || Pe === "|" || Pe === ":" || Pe === "." || Pe === _s || !Pe ? !1 : Pe === Gn ? (P.peek(), ee()) : I(P, !1);
    }, ce = ee();
    return P.resetPeek(), ce;
  }
  function T(P) {
    g(P);
    const O = P.currentPeek() === "|";
    return P.resetPeek(), O;
  }
  function I(P, O = !0) {
    const q = (ce = !1, Pe = "") => {
      const ye = P.currentPeek();
      return ye === "{" || ye === "@" || !ye ? ce : ye === "|" ? !(Pe === _s || Pe === Gn) : ye === _s ? (P.peek(), q(!0, _s)) : ye === Gn ? (P.peek(), q(!0, Gn)) : !0;
    }, ee = q();
    return O && P.resetPeek(), ee;
  }
  function R(P, O) {
    const q = P.currentChar();
    return q === Zs ? Zs : O(q) ? (P.next(), q) : null;
  }
  function N(P) {
    const O = P.charCodeAt(0);
    return O >= 97 && O <= 122 || // a-z
    O >= 65 && O <= 90 || // A-Z
    O >= 48 && O <= 57 || // 0-9
    O === 95 || // _
    O === 36;
  }
  function $(P) {
    return R(P, N);
  }
  function B(P) {
    const O = P.charCodeAt(0);
    return O >= 97 && O <= 122 || // a-z
    O >= 65 && O <= 90 || // A-Z
    O >= 48 && O <= 57 || // 0-9
    O === 95 || // _
    O === 36 || // $
    O === 45;
  }
  function G(P) {
    return R(P, B);
  }
  function M(P) {
    const O = P.charCodeAt(0);
    return O >= 48 && O <= 57;
  }
  function A(P) {
    return R(P, M);
  }
  function z(P) {
    const O = P.charCodeAt(0);
    return O >= 48 && O <= 57 || // 0-9
    O >= 65 && O <= 70 || // A-F
    O >= 97 && O <= 102;
  }
  function V(P) {
    return R(P, z);
  }
  function U(P) {
    let O = "", q = "";
    for (; O = A(P); )
      q += O;
    return q;
  }
  function Y(P) {
    let O = "";
    for (; ; ) {
      const q = P.currentChar();
      if (q === "{" || q === "}" || q === "@" || q === "|" || !q)
        break;
      if (q === _s || q === Gn)
        if (I(P))
          O += q, P.next();
        else {
          if (T(P))
            break;
          O += q, P.next();
        }
      else
        O += q, P.next();
    }
    return O;
  }
  function ne(P) {
    m(P);
    let O = "", q = "";
    for (; O = G(P); )
      q += O;
    return P.currentChar() === Zs && d(Qe.UNTERMINATED_CLOSING_BRACE, s(), 0), q;
  }
  function ie(P) {
    m(P);
    let O = "";
    return P.currentChar() === "-" ? (P.next(), O += `-${U(P)}`) : O += U(P), P.currentChar() === Zs && d(Qe.UNTERMINATED_CLOSING_BRACE, s(), 0), O;
  }
  function Z(P) {
    return P !== hC && P !== Gn;
  }
  function Q(P) {
    m(P), p(P, "'");
    let O = "", q = "";
    for (; O = R(P, Z); )
      O === "\\" ? q += fe(P) : q += O;
    const ee = P.currentChar();
    return ee === Gn || ee === Zs ? (d(Qe.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0), ee === Gn && (P.next(), p(P, "'")), q) : (p(P, "'"), q);
  }
  function fe(P) {
    const O = P.currentChar();
    switch (O) {
      case "\\":
      case "'":
        return P.next(), `\\${O}`;
      case "u":
        return ge(P, O, 4);
      case "U":
        return ge(P, O, 6);
      default:
        return d(Qe.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, O), "";
    }
  }
  function ge(P, O, q) {
    p(P, O);
    let ee = "";
    for (let ce = 0; ce < q; ce++) {
      const Pe = V(P);
      if (!Pe) {
        d(Qe.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${O}${ee}${P.currentChar()}`);
        break;
      }
      ee += Pe;
    }
    return `\\${O}${ee}`;
  }
  function Re(P) {
    return P !== "{" && P !== "}" && P !== _s && P !== Gn;
  }
  function Be(P) {
    m(P);
    let O = "", q = "";
    for (; O = R(P, Re); )
      q += O;
    return q;
  }
  function le(P) {
    let O = "", q = "";
    for (; O = $(P); )
      q += O;
    return q;
  }
  function Ee(P) {
    const O = (q) => {
      const ee = P.currentChar();
      return ee === "{" || ee === "@" || ee === "|" || ee === "(" || ee === ")" || !ee || ee === _s ? q : (q += ee, P.next(), O(q));
    };
    return O("");
  }
  function Se(P) {
    m(P);
    const O = p(
      P,
      "|"
      /* TokenChars.Pipe */
    );
    return m(P), O;
  }
  function xe(P, O) {
    let q = null;
    switch (P.currentChar()) {
      case "{":
        return O.braceNest >= 1 && d(Qe.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0), P.next(), q = f(
          O,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), m(P), O.braceNest++, q;
      case "}":
        return O.braceNest > 0 && O.currentType === 2 && d(Qe.EMPTY_PLACEHOLDER, s(), 0), P.next(), q = f(
          O,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), O.braceNest--, O.braceNest > 0 && m(P), O.inLinked && O.braceNest === 0 && (O.inLinked = !1), q;
      case "@":
        return O.braceNest > 0 && d(Qe.UNTERMINATED_CLOSING_BRACE, s(), 0), q = Ce(P, O) || h(O), O.braceNest = 0, q;
      default: {
        let ce = !0, Pe = !0, ye = !0;
        if (T(P))
          return O.braceNest > 0 && d(Qe.UNTERMINATED_CLOSING_BRACE, s(), 0), q = f(O, 1, Se(P)), O.braceNest = 0, O.inLinked = !1, q;
        if (O.braceNest > 0 && (O.currentType === 4 || O.currentType === 5 || O.currentType === 6))
          return d(Qe.UNTERMINATED_CLOSING_BRACE, s(), 0), O.braceNest = 0, _e(P, O);
        if (ce = E(P, O))
          return q = f(O, 4, ne(P)), m(P), q;
        if (Pe = b(P, O))
          return q = f(O, 5, ie(P)), m(P), q;
        if (ye = _(P, O))
          return q = f(O, 6, Q(P)), m(P), q;
        if (!ce && !Pe && !ye)
          return q = f(O, 12, Be(P)), d(Qe.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, q.value), m(P), q;
        break;
      }
    }
    return q;
  }
  function Ce(P, O) {
    const { currentType: q } = O;
    let ee = null;
    const ce = P.currentChar();
    switch ((q === 7 || q === 8 || q === 11 || q === 9) && (ce === Gn || ce === _s) && d(Qe.INVALID_LINKED_FORMAT, s(), 0), ce) {
      case "@":
        return P.next(), ee = f(
          O,
          7,
          "@"
          /* TokenChars.LinkedAlias */
        ), O.inLinked = !0, ee;
      case ".":
        return m(P), P.next(), f(
          O,
          8,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return m(P), P.next(), f(
          O,
          9,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return T(P) ? (ee = f(O, 1, Se(P)), O.braceNest = 0, O.inLinked = !1, ee) : w(P, O) || x(P, O) ? (m(P), Ce(P, O)) : S(P, O) ? (m(P), f(O, 11, le(P))) : k(P, O) ? (m(P), ce === "{" ? xe(P, O) || ee : f(O, 10, Ee(P))) : (q === 7 && d(Qe.INVALID_LINKED_FORMAT, s(), 0), O.braceNest = 0, O.inLinked = !1, _e(P, O));
    }
  }
  function _e(P, O) {
    let q = {
      type: 13
      /* TokenTypes.EOF */
    };
    if (O.braceNest > 0)
      return xe(P, O) || h(O);
    if (O.inLinked)
      return Ce(P, O) || h(O);
    switch (P.currentChar()) {
      case "{":
        return xe(P, O) || h(O);
      case "}":
        return d(Qe.UNBALANCED_CLOSING_BRACE, s(), 0), P.next(), f(
          O,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return Ce(P, O) || h(O);
      default: {
        if (T(P))
          return q = f(O, 1, Se(P)), O.braceNest = 0, O.inLinked = !1, q;
        if (I(P))
          return f(O, 0, Y(P));
        break;
      }
    }
    return q;
  }
  function Je() {
    const { currentType: P, offset: O, startLoc: q, endLoc: ee } = l;
    return l.lastType = P, l.lastOffset = O, l.lastStartLoc = q, l.lastEndLoc = ee, l.offset = i(), l.startLoc = s(), r.currentChar() === Zs ? f(
      l,
      13
      /* TokenTypes.EOF */
    ) : _e(r, l);
  }
  return {
    nextToken: Je,
    currentOffset: i,
    currentPosition: s,
    context: c
  };
}
const aj = "parser", lj = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function cj(t, e, n) {
  switch (t) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const r = parseInt(e || n, 16);
      return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "�";
    }
  }
}
function uj(t = {}) {
  const e = t.location !== !1, { onError: n } = t;
  function r(v, y, E, b, ..._) {
    const w = v.currentPosition();
    if (w.offset += b, w.column += b, n) {
      const S = e ? Zy(E, w) : null, x = eu(y, S, {
        domain: aj,
        args: _
      });
      n(x);
    }
  }
  function i(v, y, E) {
    const b = { type: v };
    return e && (b.start = y, b.end = y, b.loc = { start: E, end: E }), b;
  }
  function s(v, y, E, b) {
    e && (v.end = y, v.loc && (v.loc.end = E));
  }
  function o(v, y) {
    const E = v.context(), b = i(3, E.offset, E.startLoc);
    return b.value = y, s(b, v.currentOffset(), v.currentPosition()), b;
  }
  function a(v, y) {
    const E = v.context(), { lastOffset: b, lastStartLoc: _ } = E, w = i(5, b, _);
    return w.index = parseInt(y, 10), v.nextToken(), s(w, v.currentOffset(), v.currentPosition()), w;
  }
  function l(v, y) {
    const E = v.context(), { lastOffset: b, lastStartLoc: _ } = E, w = i(4, b, _);
    return w.key = y, v.nextToken(), s(w, v.currentOffset(), v.currentPosition()), w;
  }
  function c(v, y) {
    const E = v.context(), { lastOffset: b, lastStartLoc: _ } = E, w = i(9, b, _);
    return w.value = y.replace(lj, cj), v.nextToken(), s(w, v.currentOffset(), v.currentPosition()), w;
  }
  function u(v) {
    const y = v.nextToken(), E = v.context(), { lastOffset: b, lastStartLoc: _ } = E, w = i(8, b, _);
    return y.type !== 11 ? (r(v, Qe.UNEXPECTED_EMPTY_LINKED_MODIFIER, E.lastStartLoc, 0), w.value = "", s(w, b, _), {
      nextConsumeToken: y,
      node: w
    }) : (y.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, zi(y)), w.value = y.value || "", s(w, v.currentOffset(), v.currentPosition()), {
      node: w
    });
  }
  function d(v, y) {
    const E = v.context(), b = i(7, E.offset, E.startLoc);
    return b.value = y, s(b, v.currentOffset(), v.currentPosition()), b;
  }
  function f(v) {
    const y = v.context(), E = i(6, y.offset, y.startLoc);
    let b = v.nextToken();
    if (b.type === 8) {
      const _ = u(v);
      E.modifier = _.node, b = _.nextConsumeToken || v.nextToken();
    }
    switch (b.type !== 9 && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(b)), b = v.nextToken(), b.type === 2 && (b = v.nextToken()), b.type) {
      case 10:
        b.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(b)), E.key = d(v, b.value || "");
        break;
      case 4:
        b.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(b)), E.key = l(v, b.value || "");
        break;
      case 5:
        b.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(b)), E.key = a(v, b.value || "");
        break;
      case 6:
        b.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(b)), E.key = c(v, b.value || "");
        break;
      default: {
        r(v, Qe.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
        const _ = v.context(), w = i(7, _.offset, _.startLoc);
        return w.value = "", s(w, _.offset, _.startLoc), E.key = w, s(E, _.offset, _.startLoc), {
          nextConsumeToken: b,
          node: E
        };
      }
    }
    return s(E, v.currentOffset(), v.currentPosition()), {
      node: E
    };
  }
  function h(v) {
    const y = v.context(), E = y.currentType === 1 ? v.currentOffset() : y.offset, b = y.currentType === 1 ? y.endLoc : y.startLoc, _ = i(2, E, b);
    _.items = [];
    let w = null;
    do {
      const k = w || v.nextToken();
      switch (w = null, k.type) {
        case 0:
          k.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(k)), _.items.push(o(v, k.value || ""));
          break;
        case 5:
          k.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(k)), _.items.push(a(v, k.value || ""));
          break;
        case 4:
          k.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(k)), _.items.push(l(v, k.value || ""));
          break;
        case 6:
          k.value == null && r(v, Qe.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, zi(k)), _.items.push(c(v, k.value || ""));
          break;
        case 7: {
          const T = f(v);
          _.items.push(T.node), w = T.nextConsumeToken || null;
          break;
        }
      }
    } while (y.currentType !== 13 && y.currentType !== 1);
    const S = y.currentType === 1 ? y.lastOffset : v.currentOffset(), x = y.currentType === 1 ? y.lastEndLoc : v.currentPosition();
    return s(_, S, x), _;
  }
  function p(v, y, E, b) {
    const _ = v.context();
    let w = b.items.length === 0;
    const S = i(1, y, E);
    S.cases = [], S.cases.push(b);
    do {
      const x = h(v);
      w || (w = x.items.length === 0), S.cases.push(x);
    } while (_.currentType !== 13);
    return w && r(v, Qe.MUST_HAVE_MESSAGES_IN_PLURAL, E, 0), s(S, v.currentOffset(), v.currentPosition()), S;
  }
  function g(v) {
    const y = v.context(), { offset: E, startLoc: b } = y, _ = h(v);
    return y.currentType === 13 ? _ : p(v, E, b, _);
  }
  function m(v) {
    const y = oj(v, gn({}, t)), E = y.context(), b = i(0, E.offset, E.startLoc);
    return e && b.loc && (b.loc.source = v), b.body = g(y), t.onCacheKey && (b.cacheKey = t.onCacheKey(v)), E.currentType !== 13 && r(y, Qe.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, v[E.offset] || ""), s(b, y.currentOffset(), y.currentPosition()), b;
  }
  return { parse: m };
}
function zi(t) {
  if (t.type === 13)
    return "EOF";
  const e = (t.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "…" : e;
}
function dj(t, e = {}) {
  const n = {
    ast: t,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (s) => (n.helpers.add(s), s) };
}
function pC(t, e) {
  for (let n = 0; n < t.length; n++)
    j_(t[n], e);
}
function j_(t, e) {
  switch (t.type) {
    case 1:
      pC(t.cases, e), e.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      pC(t.items, e);
      break;
    case 6: {
      j_(t.key, e), e.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), e.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function fj(t, e = {}) {
  const n = dj(t);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), t.body && j_(t.body, n);
  const r = n.context();
  t.helpers = Array.from(r.helpers);
}
function hj(t) {
  const e = t.body;
  return e.type === 2 ? gC(e) : e.cases.forEach((n) => gC(n)), t;
}
function gC(t) {
  if (t.items.length === 1) {
    const e = t.items[0];
    (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value);
  } else {
    const e = [];
    for (let n = 0; n < t.items.length; n++) {
      const r = t.items[n];
      if (!(r.type === 3 || r.type === 9) || r.value == null)
        break;
      e.push(r.value);
    }
    if (e.length === t.items.length) {
      t.static = W_(e);
      for (let n = 0; n < t.items.length; n++) {
        const r = t.items[n];
        (r.type === 3 || r.type === 9) && delete r.value;
      }
    }
  }
}
const pj = "minifier";
function $l(t) {
  switch (t.t = t.type, t.type) {
    case 0: {
      const e = t;
      $l(e.body), e.b = e.body, delete e.body;
      break;
    }
    case 1: {
      const e = t, n = e.cases;
      for (let r = 0; r < n.length; r++)
        $l(n[r]);
      e.c = n, delete e.cases;
      break;
    }
    case 2: {
      const e = t, n = e.items;
      for (let r = 0; r < n.length; r++)
        $l(n[r]);
      e.i = n, delete e.items, e.static && (e.s = e.static, delete e.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = t;
      e.value && (e.v = e.value, delete e.value);
      break;
    }
    case 6: {
      const e = t;
      $l(e.key), e.k = e.key, delete e.key, e.modifier && ($l(e.modifier), e.m = e.modifier, delete e.modifier);
      break;
    }
    case 5: {
      const e = t;
      e.i = e.index, delete e.index;
      break;
    }
    case 4: {
      const e = t;
      e.k = e.key, delete e.key;
      break;
    }
    default:
      if (process.env.NODE_ENV !== "production")
        throw eu(Qe.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: pj,
          args: [t.type]
        });
  }
  delete t.type;
}
const gj = "parser";
function mj(t, e) {
  const { sourceMap: n, filename: r, breakLineCode: i, needIndent: s } = e, o = e.location !== !1, a = {
    filename: r,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: i,
    needIndent: s,
    indentLevel: 0
  };
  o && t.loc && (a.source = t.loc.source);
  const l = () => a;
  function c(m, v) {
    a.code += m;
  }
  function u(m, v = !0) {
    const y = v ? i : "";
    c(s ? y + "  ".repeat(m) : y);
  }
  function d(m = !0) {
    const v = ++a.indentLevel;
    m && u(v);
  }
  function f(m = !0) {
    const v = --a.indentLevel;
    m && u(v);
  }
  function h() {
    u(a.indentLevel);
  }
  return {
    context: l,
    push: c,
    indent: d,
    deindent: f,
    newline: h,
    helper: (m) => `_${m}`,
    needIndent: () => a.needIndent
  };
}
function vj(t, e) {
  const { helper: n } = t;
  t.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), Pc(t, e.key), e.modifier ? (t.push(", "), Pc(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")");
}
function bj(t, e) {
  const { helper: n, needIndent: r } = t;
  t.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), t.indent(r());
  const i = e.items.length;
  for (let s = 0; s < i && (Pc(t, e.items[s]), s !== i - 1); s++)
    t.push(", ");
  t.deindent(r()), t.push("])");
}
function yj(t, e) {
  const { helper: n, needIndent: r } = t;
  if (e.cases.length > 1) {
    t.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), t.indent(r());
    const i = e.cases.length;
    for (let s = 0; s < i && (Pc(t, e.cases[s]), s !== i - 1); s++)
      t.push(", ");
    t.deindent(r()), t.push("])");
  }
}
function wj(t, e) {
  e.body ? Pc(t, e.body) : t.push("null");
}
function Pc(t, e) {
  const { helper: n } = t;
  switch (e.type) {
    case 0:
      wj(t, e);
      break;
    case 1:
      yj(t, e);
      break;
    case 2:
      bj(t, e);
      break;
    case 6:
      vj(t, e);
      break;
    case 8:
      t.push(JSON.stringify(e.value), e);
      break;
    case 7:
      t.push(JSON.stringify(e.value), e);
      break;
    case 5:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${e.index}))`, e);
      break;
    case 4:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(e.key)}))`, e);
      break;
    case 9:
      t.push(JSON.stringify(e.value), e);
      break;
    case 3:
      t.push(JSON.stringify(e.value), e);
      break;
    default:
      if (process.env.NODE_ENV !== "production")
        throw eu(Qe.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: gj,
          args: [e.type]
        });
  }
}
const _j = (t, e = {}) => {
  const n = ke(e.mode) ? e.mode : "normal", r = ke(e.filename) ? e.filename : "message.intl", i = !!e.sourceMap, s = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`, o = e.needIndent ? e.needIndent : n !== "arrow", a = t.helpers || [], l = mj(t, {
    mode: n,
    filename: r,
    sourceMap: i,
    breakLineCode: s,
    needIndent: o
  });
  l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(o), a.length > 0 && (l.push(`const { ${W_(a.map((d) => `${d}: _${d}`), ", ")} } = ctx`), l.newline()), l.push("return "), Pc(l, t), l.deindent(o), l.push("}"), delete t.helpers;
  const { code: c, map: u } = l.context();
  return {
    ast: t,
    code: c,
    map: u ? u.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function Ej(t, e = {}) {
  const n = gn({}, e), r = !!n.jit, i = !!n.minify, s = n.optimize == null ? !0 : n.optimize, a = uj(n).parse(t);
  return r ? (s && hj(a), i && $l(a), { ast: a, code: "" }) : (fj(a, n), _j(a, n));
}
/*!
  * core-base v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function Sj() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (pa().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (pa().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
}
function cb(t) {
  return (n) => xj(n, t);
}
function xj(t, e) {
  const n = e.b || e.body;
  if ((n.t || n.type) === 1) {
    const r = n, i = r.c || r.cases;
    return t.plural(i.reduce((s, o) => [
      ...s,
      mC(t, o)
    ], []));
  } else
    return mC(t, n);
}
function mC(t, e) {
  const n = e.s || e.static;
  if (n != null)
    return t.type === "text" ? n : t.normalize([n]);
  {
    const r = (e.i || e.items).reduce((i, s) => [...i, Qy(t, s)], []);
    return t.normalize(r);
  }
}
function Qy(t, e) {
  const n = e.t || e.type;
  switch (n) {
    case 3: {
      const r = e;
      return r.v || r.value;
    }
    case 9: {
      const r = e;
      return r.v || r.value;
    }
    case 4: {
      const r = e;
      return t.interpolate(t.named(r.k || r.key));
    }
    case 5: {
      const r = e;
      return t.interpolate(t.list(r.i != null ? r.i : r.index));
    }
    case 6: {
      const r = e, i = r.m || r.modifier;
      return t.linked(Qy(t, r.k || r.key), i ? Qy(t, i) : void 0, t.type);
    }
    case 7: {
      const r = e;
      return r.v || r.value;
    }
    case 8: {
      const r = e;
      return r.v || r.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${n}`);
  }
}
const kj = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function Cj(t, e) {
  e && QG(t) && Go(Hv(kj, { source: t }));
}
const Tj = (t) => t;
let Eh = /* @__PURE__ */ Object.create(null);
const Ro = (t) => bt(t) && (t.t === 0 || t.type === 0) && ("b" in t || "body" in t);
function Oj(t, e = {}) {
  let n = !1;
  const r = e.onError || JG;
  return e.onError = (i) => {
    n = !0, r(i);
  }, { ...Ej(t, e), detectError: n };
}
// @__NO_SIDE_EFFECTS__
function Mj(t, e) {
  if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && ke(t)) {
    const n = yt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && Cj(t, n);
    const i = (e.onCacheKey || Tj)(t), s = Eh[i];
    if (s)
      return s;
    const { ast: o, detectError: a } = Oj(t, {
      ...e,
      location: process.env.NODE_ENV !== "production",
      jit: !0
    }), l = cb(o);
    return a ? l : Eh[i] = l;
  } else {
    if (process.env.NODE_ENV !== "production" && !Ro(t))
      return Go(`the message that is resolve with key '${e.key}' is not supported for jit compilation`), () => t;
    const n = t.cacheKey;
    if (n) {
      const r = Eh[n];
      return r || (Eh[n] = cb(t));
    } else
      return cb(t);
  }
}
let Ud = null;
function Aj(t) {
  Ud = t;
}
function Nj(t, e, n) {
  Ud && Ud.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: t,
    version: e,
    meta: n
  });
}
const Rj = /* @__PURE__ */ Dj("function:translate");
function Dj(t) {
  return (e) => Ud && Ud.emit(t, e);
}
const In = {
  INVALID_ARGUMENT: YG,
  // 17
  INVALID_DATE_ARGUMENT: 18,
  INVALID_ISO_DATE_ARGUMENT: 19,
  NOT_SUPPORT_NON_STRING_MESSAGE: 20,
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
  NOT_SUPPORT_LOCALE_TYPE: 23
}, Ij = 24;
function Is(t) {
  return eu(t, null, process.env.NODE_ENV !== "production" ? { messages: Pj } : void 0);
}
const Pj = {
  [In.INVALID_ARGUMENT]: "Invalid arguments",
  [In.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [In.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [In.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [In.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [In.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [In.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function q_(t, e) {
  return e.locale != null ? vC(e.locale) : vC(t.locale);
}
let ub;
function vC(t) {
  if (ke(t))
    return t;
  if (Rt(t)) {
    if (t.resolvedOnce && ub != null)
      return ub;
    if (t.constructor.name === "Function") {
      const e = t();
      if (GG(e))
        throw Is(In.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return ub = e;
    } else
      throw Is(In.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw Is(In.NOT_SUPPORT_LOCALE_TYPE);
}
function Lj(t, e, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...Kt(e) ? e : bt(e) ? Object.keys(e) : ke(e) ? [e] : [n]
  ])];
}
function LD(t, e, n) {
  const r = ke(n) ? n : Vd, i = t;
  i.__localeChainCache || (i.__localeChainCache = /* @__PURE__ */ new Map());
  let s = i.__localeChainCache.get(r);
  if (!s) {
    s = [];
    let o = [n];
    for (; Kt(o); )
      o = bC(s, o, e);
    const a = Kt(e) || !at(e) ? e : e.default ? e.default : null;
    o = ke(a) ? [a] : a, Kt(o) && bC(s, o, !1), i.__localeChainCache.set(r, s);
  }
  return s;
}
function bC(t, e, n) {
  let r = !0;
  for (let i = 0; i < e.length && yt(r); i++) {
    const s = e[i];
    ke(s) && (r = $j(t, e[i], n));
  }
  return r;
}
function $j(t, e, n) {
  let r;
  const i = e.split("-");
  do {
    const s = i.join("-");
    r = Bj(t, s, n), i.splice(-1, 1);
  } while (i.length && r === !0);
  return r;
}
function Bj(t, e, n) {
  let r = !1;
  if (!t.includes(e) && (r = !0, e)) {
    r = e[e.length - 1] !== "!";
    const i = e.replace(/!/g, "");
    t.push(i), (Kt(n) || at(n)) && n[i] && (r = n[i]);
  }
  return r;
}
const jo = [];
jo[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
jo[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
jo[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
jo[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
jo[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
jo[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
jo[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const Fj = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function zj(t) {
  return Fj.test(t);
}
function Hj(t) {
  const e = t.charCodeAt(0), n = t.charCodeAt(t.length - 1);
  return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t;
}
function Uj(t) {
  if (t == null)
    return "o";
  switch (t.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return t;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function Vj(t) {
  const e = t.trim();
  return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : zj(e) ? Hj(e) : "*" + e;
}
function Wj(t) {
  const e = [];
  let n = -1, r = 0, i = 0, s, o, a, l, c, u, d;
  const f = [];
  f[
    0
    /* Actions.APPEND */
  ] = () => {
    o === void 0 ? o = a : o += a;
  }, f[
    1
    /* Actions.PUSH */
  ] = () => {
    o !== void 0 && (e.push(o), o = void 0);
  }, f[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    f[
      0
      /* Actions.APPEND */
    ](), i++;
  }, f[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (i > 0)
      i--, r = 4, f[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (i = 0, o === void 0 || (o = Vj(o), o === !1))
        return !1;
      f[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function h() {
    const p = t[n + 1];
    if (r === 5 && p === "'" || r === 6 && p === '"')
      return n++, a = "\\" + p, f[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; r !== null; )
    if (n++, s = t[n], !(s === "\\" && h())) {
      if (l = Uj(s), d = jo[r], c = d[l] || d.l || 8, c === 8 || (r = c[0], c[1] !== void 0 && (u = f[c[1]], u && (a = s, u() === !1))))
        return;
      if (r === 7)
        return e;
    }
}
const yC = /* @__PURE__ */ new Map();
function Gj(t, e) {
  return bt(t) ? t[e] : null;
}
function jj(t, e) {
  if (!bt(t))
    return null;
  let n = yC.get(e);
  if (n || (n = Wj(e), n && yC.set(e, n)), !n)
    return null;
  const r = n.length;
  let i = t, s = 0;
  for (; s < r; ) {
    const o = i[n[s]];
    if (o === void 0 || Rt(i))
      return null;
    i = o, s++;
  }
  return i;
}
const or = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7
}, qj = 8, Kj = {
  [or.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [or.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [or.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [or.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [or.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [or.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [or.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function qa(t, ...e) {
  return Hv(Kj[t], ...e);
}
const Yj = "10.0.4", Vv = -1, Vd = "en-US", Tg = "", wC = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
function Xj() {
  return {
    upper: (t, e) => e === "text" && ke(t) ? t.toUpperCase() : e === "vnode" && bt(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
    lower: (t, e) => e === "text" && ke(t) ? t.toLowerCase() : e === "vnode" && bt(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
    capitalize: (t, e) => e === "text" && ke(t) ? wC(t) : e === "vnode" && bt(t) && "__v_isVNode" in t ? wC(t.children) : t
  };
}
let $D;
function Jj(t) {
  $D = t;
}
let BD;
function Zj(t) {
  BD = t;
}
let FD;
function Qj(t) {
  FD = t;
}
let zD = null;
const eq = /* @__NO_SIDE_EFFECTS__ */ (t) => {
  zD = t;
}, tq = /* @__NO_SIDE_EFFECTS__ */ () => zD;
let HD = null;
const _C = (t) => {
  HD = t;
}, nq = () => HD;
let EC = 0;
function rq(t = {}) {
  const e = Rt(t.onWarn) ? t.onWarn : Go, n = ke(t.version) ? t.version : Yj, r = ke(t.locale) || Rt(t.locale) ? t.locale : Vd, i = Rt(r) ? Vd : r, s = Kt(t.fallbackLocale) || at(t.fallbackLocale) || ke(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : i, o = at(t.messages) ? t.messages : { [i]: {} }, a = at(t.datetimeFormats) ? t.datetimeFormats : { [i]: {} }, l = at(t.numberFormats) ? t.numberFormats : { [i]: {} }, c = gn({}, t.modifiers || {}, Xj()), u = t.pluralRules || {}, d = Rt(t.missing) ? t.missing : null, f = yt(t.missingWarn) || Ic(t.missingWarn) ? t.missingWarn : !0, h = yt(t.fallbackWarn) || Ic(t.fallbackWarn) ? t.fallbackWarn : !0, p = !!t.fallbackFormat, g = !!t.unresolving, m = Rt(t.postTranslation) ? t.postTranslation : null, v = at(t.processor) ? t.processor : null, y = yt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, E = !!t.escapeParameter, b = Rt(t.messageCompiler) ? t.messageCompiler : $D;
  process.env.NODE_ENV !== "production" && Rt(t.messageCompiler) && PD(qa(or.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const _ = Rt(t.messageResolver) ? t.messageResolver : BD || Gj, w = Rt(t.localeFallbacker) ? t.localeFallbacker : FD || Lj, S = bt(t.fallbackContext) ? t.fallbackContext : void 0, x = t, k = bt(x.__datetimeFormatters) ? x.__datetimeFormatters : /* @__PURE__ */ new Map(), T = bt(x.__numberFormatters) ? x.__numberFormatters : /* @__PURE__ */ new Map(), I = bt(x.__meta) ? x.__meta : {};
  EC++;
  const R = {
    version: n,
    cid: EC,
    locale: r,
    fallbackLocale: s,
    messages: o,
    modifiers: c,
    pluralRules: u,
    missing: d,
    missingWarn: f,
    fallbackWarn: h,
    fallbackFormat: p,
    unresolving: g,
    postTranslation: m,
    processor: v,
    warnHtmlMessage: y,
    escapeParameter: E,
    messageCompiler: b,
    messageResolver: _,
    localeFallbacker: w,
    fallbackContext: S,
    onWarn: e,
    __meta: I
  };
  return R.datetimeFormats = a, R.numberFormats = l, R.__datetimeFormatters = k, R.__numberFormatters = T, process.env.NODE_ENV !== "production" && (R.__v_emitter = x.__v_emitter != null ? x.__v_emitter : void 0), (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) && Nj(R, n, I), R;
}
function Wv(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function UD(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function K_(t, e, n, r, i) {
  const { missing: s, onWarn: o } = t;
  if (process.env.NODE_ENV !== "production") {
    const a = t.__v_emitter;
    a && a.emit("missing", {
      locale: n,
      key: e,
      type: i,
      groupId: `${i}:${e}`
    });
  }
  if (s !== null) {
    const a = s(t, n, e, i);
    return ke(a) ? a : e;
  } else
    return process.env.NODE_ENV !== "production" && UD(r, e) && o(qa(or.NOT_FOUND_KEY, { key: e, locale: n })), e;
}
function vu(t, e, n) {
  const r = t;
  r.__localeChainCache = /* @__PURE__ */ new Map(), t.localeFallbacker(t, n, e);
}
function VD(t, e) {
  return t === e ? !1 : t.split("-")[0] === e.split("-")[0];
}
function iq(t, e) {
  const n = e.indexOf(t);
  if (n === -1)
    return !1;
  for (let r = n + 1; r < e.length; r++)
    if (VD(t, e[r]))
      return !0;
  return !1;
}
const SC = typeof Intl < "u", WD = {
  dateTimeFormat: SC && typeof Intl.DateTimeFormat < "u",
  numberFormat: SC && typeof Intl.NumberFormat < "u"
};
function xC(t, ...e) {
  const { datetimeFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o } = t, { __datetimeFormatters: a } = t;
  if (process.env.NODE_ENV !== "production" && !WD.dateTimeFormat)
    return s(qa(or.CANNOT_FORMAT_DATE)), Tg;
  const [l, c, u, d] = e1(...e), f = yt(u.missingWarn) ? u.missingWarn : t.missingWarn, h = yt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, p = !!u.part, g = q_(t, u), m = o(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    i,
    g
  );
  if (!ke(l) || l === "")
    return new Intl.DateTimeFormat(g, d).format(c);
  let v = {}, y, E = null, b = g, _ = null;
  const w = "datetime format";
  for (let k = 0; k < m.length; k++) {
    if (y = _ = m[k], process.env.NODE_ENV !== "production" && g !== y && Wv(h, l) && s(qa(or.FALLBACK_TO_DATE_FORMAT, {
      key: l,
      target: y
    })), process.env.NODE_ENV !== "production" && g !== y) {
      const T = t.__v_emitter;
      T && T.emit("fallback", {
        type: w,
        key: l,
        from: b,
        to: _,
        groupId: `${w}:${l}`
      });
    }
    if (v = n[y] || {}, E = v[l], at(E))
      break;
    K_(t, l, y, f, w), b = _;
  }
  if (!at(E) || !ke(y))
    return r ? Vv : l;
  let S = `${y}__${l}`;
  Uv(d) || (S = `${S}__${JSON.stringify(d)}`);
  let x = a.get(S);
  return x || (x = new Intl.DateTimeFormat(y, gn({}, E, d)), a.set(S, x)), p ? x.formatToParts(c) : x.format(c);
}
const GD = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function e1(...t) {
  const [e, n, r, i] = t, s = {};
  let o = {}, a;
  if (ke(e)) {
    const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!l)
      throw Is(In.INVALID_ISO_DATE_ARGUMENT);
    const c = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
    a = new Date(c);
    try {
      a.toISOString();
    } catch {
      throw Is(In.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (VG(e)) {
    if (isNaN(e.getTime()))
      throw Is(In.INVALID_DATE_ARGUMENT);
    a = e;
  } else if (dn(e))
    a = e;
  else
    throw Is(In.INVALID_ARGUMENT);
  return ke(n) ? s.key = n : at(n) && Object.keys(n).forEach((l) => {
    GD.includes(l) ? o[l] = n[l] : s[l] = n[l];
  }), ke(r) ? s.locale = r : at(r) && (o = r), at(i) && (o = i), [s.key || "", a, s, o];
}
function kC(t, e, n) {
  const r = t;
  for (const i in n) {
    const s = `${e}__${i}`;
    r.__datetimeFormatters.has(s) && r.__datetimeFormatters.delete(s);
  }
}
function CC(t, ...e) {
  const { numberFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o } = t, { __numberFormatters: a } = t;
  if (process.env.NODE_ENV !== "production" && !WD.numberFormat)
    return s(qa(or.CANNOT_FORMAT_NUMBER)), Tg;
  const [l, c, u, d] = t1(...e), f = yt(u.missingWarn) ? u.missingWarn : t.missingWarn, h = yt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, p = !!u.part, g = q_(t, u), m = o(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    i,
    g
  );
  if (!ke(l) || l === "")
    return new Intl.NumberFormat(g, d).format(c);
  let v = {}, y, E = null, b = g, _ = null;
  const w = "number format";
  for (let k = 0; k < m.length; k++) {
    if (y = _ = m[k], process.env.NODE_ENV !== "production" && g !== y && Wv(h, l) && s(qa(or.FALLBACK_TO_NUMBER_FORMAT, {
      key: l,
      target: y
    })), process.env.NODE_ENV !== "production" && g !== y) {
      const T = t.__v_emitter;
      T && T.emit("fallback", {
        type: w,
        key: l,
        from: b,
        to: _,
        groupId: `${w}:${l}`
      });
    }
    if (v = n[y] || {}, E = v[l], at(E))
      break;
    K_(t, l, y, f, w), b = _;
  }
  if (!at(E) || !ke(y))
    return r ? Vv : l;
  let S = `${y}__${l}`;
  Uv(d) || (S = `${S}__${JSON.stringify(d)}`);
  let x = a.get(S);
  return x || (x = new Intl.NumberFormat(y, gn({}, E, d)), a.set(S, x)), p ? x.formatToParts(c) : x.format(c);
}
const jD = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function t1(...t) {
  const [e, n, r, i] = t, s = {};
  let o = {};
  if (!dn(e))
    throw Is(In.INVALID_ARGUMENT);
  const a = e;
  return ke(n) ? s.key = n : at(n) && Object.keys(n).forEach((l) => {
    jD.includes(l) ? o[l] = n[l] : s[l] = n[l];
  }), ke(r) ? s.locale = r : at(r) && (o = r), at(i) && (o = i), [s.key || "", a, s, o];
}
function TC(t, e, n) {
  const r = t;
  for (const i in n) {
    const s = `${e}__${i}`;
    r.__numberFormatters.has(s) && r.__numberFormatters.delete(s);
  }
}
const sq = (t) => t, oq = (t) => "", aq = "text", lq = (t) => t.length === 0 ? "" : W_(t), cq = jG;
function OC(t, e) {
  return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0;
}
function uq(t) {
  const e = dn(t.pluralIndex) ? t.pluralIndex : -1;
  return t.named && (dn(t.named.count) || dn(t.named.n)) ? dn(t.named.count) ? t.named.count : dn(t.named.n) ? t.named.n : e : e;
}
function dq(t, e) {
  e.count || (e.count = t), e.n || (e.n = t);
}
function fq(t = {}) {
  const e = t.locale, n = uq(t), r = bt(t.pluralRules) && ke(e) && Rt(t.pluralRules[e]) ? t.pluralRules[e] : OC, i = bt(t.pluralRules) && ke(e) && Rt(t.pluralRules[e]) ? OC : void 0, s = (v) => v[r(n, v.length, i)], o = t.list || [], a = (v) => o[v], l = t.named || {};
  dn(t.pluralIndex) && dq(n, l);
  const c = (v) => l[v];
  function u(v, y) {
    const E = Rt(t.messages) ? t.messages(v, !!y) : bt(t.messages) ? t.messages[v] : !1;
    return E || (t.parent ? t.parent.message(v) : oq);
  }
  const d = (v) => t.modifiers ? t.modifiers[v] : sq, f = at(t.processor) && Rt(t.processor.normalize) ? t.processor.normalize : lq, h = at(t.processor) && Rt(t.processor.interpolate) ? t.processor.interpolate : cq, p = at(t.processor) && ke(t.processor.type) ? t.processor.type : aq, m = {
    list: a,
    named: c,
    plural: s,
    linked: (v, ...y) => {
      const [E, b] = y;
      let _ = "text", w = "";
      y.length === 1 ? bt(E) ? (w = E.modifier || w, _ = E.type || _) : ke(E) && (w = E || w) : y.length === 2 && (ke(E) && (w = E || w), ke(b) && (_ = b || _));
      const S = u(v, !0)(m), x = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        _ === "vnode" && Kt(S) && w ? S[0] : S
      );
      return w ? d(w)(x, _) : x;
    },
    message: u,
    type: p,
    interpolate: h,
    normalize: f,
    values: gn({}, o, l)
  };
  return m;
}
const MC = () => "", Kr = (t) => Rt(t);
function AC(t, ...e) {
  const { fallbackFormat: n, postTranslation: r, unresolving: i, messageCompiler: s, fallbackLocale: o, messages: a } = t, [l, c] = n1(...e), u = yt(c.missingWarn) ? c.missingWarn : t.missingWarn, d = yt(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, f = yt(c.escapeParameter) ? c.escapeParameter : t.escapeParameter, h = !!c.resolvedMessage, p = ke(c.default) || yt(c.default) ? yt(c.default) ? s ? l : () => l : c.default : n ? s ? l : () => l : null, g = n || p != null && (ke(p) || Rt(p)), m = q_(t, c);
  f && hq(c);
  let [v, y, E] = h ? [
    l,
    m,
    a[m] || {}
  ] : qD(t, l, m, o, d, u), b = v, _ = l;
  if (!h && !(ke(b) || Ro(b) || Kr(b)) && g && (b = p, _ = b), !h && (!(ke(b) || Ro(b) || Kr(b)) || !ke(y)))
    return i ? Vv : l;
  if (process.env.NODE_ENV !== "production" && ke(b) && t.messageCompiler == null)
    return Go(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${l}'.`), l;
  let w = !1;
  const S = () => {
    w = !0;
  }, x = Kr(b) ? b : KD(t, l, y, b, _, S);
  if (w)
    return b;
  const k = vq(t, y, E, c), T = fq(k), I = pq(t, x, T), R = r ? r(I, l) : I;
  if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
    const N = {
      timestamp: Date.now(),
      key: ke(l) ? l : Kr(b) ? b.key : "",
      locale: y || (Kr(b) ? b.locale : ""),
      format: ke(b) ? b : Kr(b) ? b.source : "",
      message: R
    };
    N.meta = gn({}, t.__meta, /* @__PURE__ */ tq() || {}), Rj(N);
  }
  return R;
}
function hq(t) {
  Kt(t.list) ? t.list = t.list.map((e) => ke(e) ? uC(e) : e) : bt(t.named) && Object.keys(t.named).forEach((e) => {
    ke(t.named[e]) && (t.named[e] = uC(t.named[e]));
  });
}
function qD(t, e, n, r, i, s) {
  const { messages: o, onWarn: a, messageResolver: l, localeFallbacker: c } = t, u = c(t, r, n);
  let d = {}, f, h = null, p = n, g = null;
  const m = "translate";
  for (let v = 0; v < u.length; v++) {
    if (f = g = u[v], process.env.NODE_ENV !== "production" && n !== f && !VD(n, f) && Wv(i, e) && a(qa(or.FALLBACK_TO_TRANSLATE, {
      key: e,
      target: f
    })), process.env.NODE_ENV !== "production" && n !== f) {
      const _ = t.__v_emitter;
      _ && _.emit("fallback", {
        type: m,
        key: e,
        from: p,
        to: g,
        groupId: `${m}:${e}`
      });
    }
    d = o[f] || {};
    let y = null, E, b;
    if (process.env.NODE_ENV !== "production" && Ai && (y = window.performance.now(), E = "intlify-message-resolve-start", b = "intlify-message-resolve-end", Dr && Dr(E)), (h = l(d, e)) === null && (h = d[e]), process.env.NODE_ENV !== "production" && Ai) {
      const _ = window.performance.now(), w = t.__v_emitter;
      w && y && h && w.emit("message-resolve", {
        type: "message-resolve",
        key: e,
        message: h,
        time: _ - y,
        groupId: `${m}:${e}`
      }), E && b && Dr && ja && (Dr(b), ja("intlify message resolve", E, b));
    }
    if (ke(h) || Ro(h) || Kr(h))
      break;
    if (!iq(f, u)) {
      const _ = K_(
        t,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        e,
        f,
        s,
        m
      );
      _ !== e && (h = _);
    }
    p = g;
  }
  return [h, f, d];
}
function KD(t, e, n, r, i, s) {
  const { messageCompiler: o, warnHtmlMessage: a } = t;
  if (Kr(r)) {
    const f = r;
    return f.locale = f.locale || n, f.key = f.key || e, f;
  }
  if (o == null) {
    const f = () => r;
    return f.locale = n, f.key = e, f;
  }
  let l = null, c, u;
  process.env.NODE_ENV !== "production" && Ai && (l = window.performance.now(), c = "intlify-message-compilation-start", u = "intlify-message-compilation-end", Dr && Dr(c));
  const d = o(r, gq(t, n, i, r, a, s));
  if (process.env.NODE_ENV !== "production" && Ai) {
    const f = window.performance.now(), h = t.__v_emitter;
    h && l && h.emit("message-compilation", {
      type: "message-compilation",
      message: r,
      time: f - l,
      groupId: `translate:${e}`
    }), c && u && Dr && ja && (Dr(u), ja("intlify message compilation", c, u));
  }
  return d.locale = n, d.key = e, d.source = r, d;
}
function pq(t, e, n) {
  let r = null, i, s;
  process.env.NODE_ENV !== "production" && Ai && (r = window.performance.now(), i = "intlify-message-evaluation-start", s = "intlify-message-evaluation-end", Dr && Dr(i));
  const o = e(n);
  if (process.env.NODE_ENV !== "production" && Ai) {
    const a = window.performance.now(), l = t.__v_emitter;
    l && r && l.emit("message-evaluation", {
      type: "message-evaluation",
      value: o,
      time: a - r,
      groupId: `translate:${e.key}`
    }), i && s && Dr && ja && (Dr(s), ja("intlify message evaluation", i, s));
  }
  return o;
}
function n1(...t) {
  const [e, n, r] = t, i = {};
  if (!ke(e) && !dn(e) && !Kr(e) && !Ro(e))
    throw Is(In.INVALID_ARGUMENT);
  const s = dn(e) ? String(e) : (Kr(e), e);
  return dn(n) ? i.plural = n : ke(n) ? i.default = n : at(n) && !Uv(n) ? i.named = n : Kt(n) && (i.list = n), dn(r) ? i.plural = r : ke(r) ? i.default = r : at(r) && gn(i, r), [s, i];
}
function gq(t, e, n, r, i, s) {
  return {
    locale: e,
    key: n,
    warnHtmlMessage: i,
    onError: (o) => {
      if (s && s(o), process.env.NODE_ENV !== "production") {
        const a = mq(r), l = `Message compilation error: ${o.message}`, c = o.location && a && qG(a, o.location.start.offset, o.location.end.offset), u = t.__v_emitter;
        u && a && u.emit("compile-error", {
          message: a,
          error: o.message,
          start: o.location && o.location.start.offset,
          end: o.location && o.location.end.offset,
          groupId: `translate:${n}`
        }), console.error(c ? `${l}
${c}` : l);
      } else
        throw o;
    },
    onCacheKey: (o) => HG(e, n, o)
  };
}
function mq(t) {
  if (ke(t))
    return t;
  if (t.loc && t.loc.source)
    return t.loc.source;
}
function vq(t, e, n, r) {
  const { modifiers: i, pluralRules: s, messageResolver: o, fallbackLocale: a, fallbackWarn: l, missingWarn: c, fallbackContext: u } = t, f = {
    locale: e,
    modifiers: i,
    pluralRules: s,
    messages: (h, p) => {
      let g = o(n, h);
      if (g == null && (u || p)) {
        const [, , m] = qD(
          u || t,
          // NOTE: if has fallbackContext, fallback to root, else if use linked, fallback to local context
          h,
          e,
          a,
          l,
          c
        );
        g = o(m, h);
      }
      if (ke(g) || Ro(g)) {
        let m = !1;
        const y = KD(t, h, e, g, h, () => {
          m = !0;
        });
        return m ? MC : y;
      } else
        return Kr(g) ? g : MC;
    }
  };
  return t.processor && (f.processor = t.processor), r.list && (f.list = r.list), r.named && (f.named = r.named), dn(r.plural) && (f.pluralIndex = r.plural), f;
}
Sj();
function bq() {
  return YD().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function YD() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const yq = typeof Proxy == "function", wq = "devtools-plugin:setup", _q = "plugin:settings:set";
let Sl, r1;
function Eq() {
  var t;
  return Sl !== void 0 || (typeof window < "u" && window.performance ? (Sl = !0, r1 = window.performance) : typeof globalThis < "u" && (!((t = globalThis.perf_hooks) === null || t === void 0) && t.performance) ? (Sl = !0, r1 = globalThis.perf_hooks.performance) : Sl = !1), Sl;
}
function Sq() {
  return Eq() ? r1.now() : Date.now();
}
class xq {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const r = {};
    if (e.settings)
      for (const o in e.settings) {
        const a = e.settings[o];
        r[o] = a.defaultValue;
      }
    const i = `__vue-devtools-plugin-settings__${e.id}`;
    let s = Object.assign({}, r);
    try {
      const o = localStorage.getItem(i), a = JSON.parse(o);
      Object.assign(s, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return s;
      },
      setSettings(o) {
        try {
          localStorage.setItem(i, JSON.stringify(o));
        } catch {
        }
        s = o;
      },
      now() {
        return Sq();
      }
    }, n && n.on(_q, (o, a) => {
      o === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, a) => this.target ? this.target.on[a] : (...l) => {
        this.onQueue.push({
          method: a,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
        method: a,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[a](...l)) : (...l) => new Promise((c) => {
        this.targetQueue.push({
          method: a,
          args: l,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function kq(t, e) {
  const n = t, r = YD(), i = bq(), s = yq && n.enableEarlyProxy;
  if (i && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
    i.emit(wq, t, e);
  else {
    const o = s ? new xq(n, i) : null;
    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: o
    }), o && e(o.proxiedTarget);
  }
}
/*!
  * vue-i18n v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const Cq = "10.0.4";
function Tq() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (pa().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (pa().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (pa().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (pa().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const go = {
  FALLBACK_TO_ROOT: qj,
  // 8
  NOT_FOUND_PARENT_SCOPE: 9,
  IGNORE_OBJ_FLATTEN: 10,
  DEPRECATE_TC: 11
}, Oq = {
  [go.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [go.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [go.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  [go.DEPRECATE_TC]: "'tc' and '$tc' has been deprecated in v10. Use 't' or '$t' instead. 'tc' and '$tc’ are going to remove in v11."
};
function Gv(t, ...e) {
  return Hv(Oq[t], ...e);
}
const Nt = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: Ij,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: 25,
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  // directive module errors
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  // unexpected error
  UNEXPECTED_ERROR: 32,
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34
};
function nr(t, ...e) {
  return eu(t, null, process.env.NODE_ENV !== "production" ? { messages: Mq, args: e } : void 0);
}
const Mq = {
  [Nt.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [Nt.INVALID_ARGUMENT]: "Invalid argument",
  [Nt.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [Nt.NOT_INSTALLED]: "Need to install with `app.use` function",
  [Nt.UNEXPECTED_ERROR]: "Unexpected error",
  [Nt.REQUIRED_VALUE]: "Required in value: {0}",
  [Nt.INVALID_VALUE]: "Invalid value",
  [Nt.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [Nt.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [Nt.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [Nt.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
}, i1 = /* @__PURE__ */ gs("__translateVNode"), s1 = /* @__PURE__ */ gs("__datetimeParts"), o1 = /* @__PURE__ */ gs("__numberParts"), Ka = /* @__PURE__ */ gs("__enableEmitter"), Wd = /* @__PURE__ */ gs("__disableEmitter"), XD = gs("__setPluralRules"), JD = /* @__PURE__ */ gs("__injectWithOption"), a1 = /* @__PURE__ */ gs("__dispose");
function Gd(t) {
  if (!bt(t))
    return t;
  for (const e in t)
    if (Cg(t, e))
      if (!e.includes("."))
        bt(t[e]) && Gd(t[e]);
      else {
        const n = e.split("."), r = n.length - 1;
        let i = t, s = !1;
        for (let o = 0; o < r; o++) {
          if (n[o] in i || (i[n[o]] = {}), !bt(i[n[o]])) {
            process.env.NODE_ENV !== "production" && Go(Gv(go.IGNORE_OBJ_FLATTEN, {
              key: n[o]
            })), s = !0;
            break;
          }
          i = i[n[o]];
        }
        s || (i[n[r]] = t[e], delete t[e]), bt(i[n[r]]) && Gd(i[n[r]]);
      }
  return t;
}
function Y_(t, e) {
  const { messages: n, __i18n: r, messageResolver: i, flatJson: s } = e, o = at(n) ? n : Kt(r) ? {} : { [t]: {} };
  if (Kt(r) && r.forEach((a) => {
    if ("locale" in a && "resource" in a) {
      const { locale: l, resource: c } = a;
      l ? (o[l] = o[l] || {}, Sp(c, o[l])) : Sp(c, o);
    } else
      ke(a) && Sp(JSON.parse(a), o);
  }), i == null && s)
    for (const a in o)
      Cg(o, a) && Gd(o[a]);
  return o;
}
function ZD(t) {
  return t.type;
}
function QD(t, e, n) {
  let r = bt(e.messages) ? e.messages : {};
  "__i18nGlobal" in n && (r = Y_(t.locale.value, {
    messages: r,
    __i18n: n.__i18nGlobal
  }));
  const i = Object.keys(r);
  i.length && i.forEach((s) => {
    t.mergeLocaleMessage(s, r[s]);
  });
  {
    if (bt(e.datetimeFormats)) {
      const s = Object.keys(e.datetimeFormats);
      s.length && s.forEach((o) => {
        t.mergeDateTimeFormat(o, e.datetimeFormats[o]);
      });
    }
    if (bt(e.numberFormats)) {
      const s = Object.keys(e.numberFormats);
      s.length && s.forEach((o) => {
        t.mergeNumberFormat(o, e.numberFormats[o]);
      });
    }
  }
}
function NC(t) {
  return W(h3, null, t, 0);
}
const RC = "__INTLIFY_META__", DC = () => [], Aq = () => !1;
let IC = 0;
function PC(t) {
  return (e, n, r, i) => t(n, r, Oo() || void 0, i);
}
const Nq = /* @__NO_SIDE_EFFECTS__ */ () => {
  const t = Oo();
  let e = null;
  return t && (e = ZD(t)[RC]) ? { [RC]: e } : null;
};
function X_(t = {}) {
  const { __root: e, __injectWithOption: n } = t, r = e === void 0, i = t.flatJson, s = Ai ? X : mv;
  let o = yt(t.inheritLocale) ? t.inheritLocale : !0;
  const a = s(
    // prettier-ignore
    e && o ? e.locale.value : ke(t.locale) ? t.locale : Vd
  ), l = s(
    // prettier-ignore
    e && o ? e.fallbackLocale.value : ke(t.fallbackLocale) || Kt(t.fallbackLocale) || at(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : a.value
  ), c = s(Y_(a.value, t)), u = s(at(t.datetimeFormats) ? t.datetimeFormats : { [a.value]: {} }), d = s(at(t.numberFormats) ? t.numberFormats : { [a.value]: {} });
  let f = e ? e.missingWarn : yt(t.missingWarn) || Ic(t.missingWarn) ? t.missingWarn : !0, h = e ? e.fallbackWarn : yt(t.fallbackWarn) || Ic(t.fallbackWarn) ? t.fallbackWarn : !0, p = e ? e.fallbackRoot : yt(t.fallbackRoot) ? t.fallbackRoot : !0, g = !!t.fallbackFormat, m = Rt(t.missing) ? t.missing : null, v = Rt(t.missing) ? PC(t.missing) : null, y = Rt(t.postTranslation) ? t.postTranslation : null, E = e ? e.warnHtmlMessage : yt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, b = !!t.escapeParameter;
  const _ = e ? e.modifiers : at(t.modifiers) ? t.modifiers : {};
  let w = t.pluralRules || e && e.pluralRules, S;
  S = (() => {
    r && _C(null);
    const j = {
      version: Cq,
      locale: a.value,
      fallbackLocale: l.value,
      messages: c.value,
      modifiers: _,
      pluralRules: w,
      missing: v === null ? void 0 : v,
      missingWarn: f,
      fallbackWarn: h,
      fallbackFormat: g,
      unresolving: !0,
      postTranslation: y === null ? void 0 : y,
      warnHtmlMessage: E,
      escapeParameter: b,
      messageResolver: t.messageResolver,
      messageCompiler: t.messageCompiler,
      __meta: { framework: "vue" }
    };
    j.datetimeFormats = u.value, j.numberFormats = d.value, j.__datetimeFormatters = at(S) ? S.__datetimeFormatters : void 0, j.__numberFormatters = at(S) ? S.__numberFormatters : void 0, process.env.NODE_ENV !== "production" && (j.__v_emitter = at(S) ? S.__v_emitter : void 0);
    const re = rq(j);
    return r && _C(re), re;
  })(), vu(S, a.value, l.value);
  function k() {
    return [
      a.value,
      l.value,
      c.value,
      u.value,
      d.value
    ];
  }
  const T = rt({
    get: () => a.value,
    set: (j) => {
      a.value = j, S.locale = a.value;
    }
  }), I = rt({
    get: () => l.value,
    set: (j) => {
      l.value = j, S.fallbackLocale = l.value, vu(S, a.value, j);
    }
  }), R = rt(() => c.value), N = /* @__PURE__ */ rt(() => u.value), $ = /* @__PURE__ */ rt(() => d.value);
  function B() {
    return Rt(y) ? y : null;
  }
  function G(j) {
    y = j, S.postTranslation = j;
  }
  function M() {
    return m;
  }
  function A(j) {
    j !== null && (v = PC(j)), m = j, S.missing = v;
  }
  function z(j, re) {
    return j !== "translate" || !re.resolvedMessage;
  }
  const V = (j, re, H, K, de, Oe) => {
    k();
    let Xe;
    try {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = e ? nq() : void 0), Xe = j(S);
    } finally {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = void 0);
    }
    if (H !== "translate exists" && // for not `te` (e.g `t`)
    dn(Xe) && Xe === Vv || H === "translate exists" && !Xe) {
      const [pt, hi] = re();
      if (process.env.NODE_ENV !== "production" && e && ke(pt) && z(H, hi) && (p && (Wv(h, pt) || UD(f, pt)) && Go(Gv(go.FALLBACK_TO_ROOT, {
        key: pt,
        type: H
      })), process.env.NODE_ENV !== "production")) {
        const { __v_emitter: D } = S;
        D && p && D.emit("fallback", {
          type: H,
          key: pt,
          to: "global",
          groupId: `${H}:${pt}`
        });
      }
      return e && p ? K(e) : de(pt);
    } else {
      if (Oe(Xe))
        return Xe;
      throw nr(Nt.UNEXPECTED_RETURN_TYPE);
    }
  };
  function U(...j) {
    return V((re) => Reflect.apply(AC, null, [re, ...j]), () => n1(...j), "translate", (re) => Reflect.apply(re.t, re, [...j]), (re) => re, (re) => ke(re));
  }
  function Y(...j) {
    const [re, H, K] = j;
    if (K && !bt(K))
      throw nr(Nt.INVALID_ARGUMENT);
    return U(re, H, gn({ resolvedMessage: !0 }, K || {}));
  }
  function ne(...j) {
    return V((re) => Reflect.apply(xC, null, [re, ...j]), () => e1(...j), "datetime format", (re) => Reflect.apply(re.d, re, [...j]), () => Tg, (re) => ke(re));
  }
  function ie(...j) {
    return V((re) => Reflect.apply(CC, null, [re, ...j]), () => t1(...j), "number format", (re) => Reflect.apply(re.n, re, [...j]), () => Tg, (re) => ke(re));
  }
  function Z(j) {
    return j.map((re) => ke(re) || dn(re) || yt(re) ? NC(String(re)) : re);
  }
  const fe = {
    normalize: Z,
    interpolate: (j) => j,
    type: "vnode"
  };
  function ge(...j) {
    return V((re) => {
      let H;
      const K = re;
      try {
        K.processor = fe, H = Reflect.apply(AC, null, [K, ...j]);
      } finally {
        K.processor = null;
      }
      return H;
    }, () => n1(...j), "translate", (re) => re[i1](...j), (re) => [NC(re)], (re) => Kt(re));
  }
  function Re(...j) {
    return V((re) => Reflect.apply(CC, null, [re, ...j]), () => t1(...j), "number format", (re) => re[o1](...j), DC, (re) => ke(re) || Kt(re));
  }
  function Be(...j) {
    return V((re) => Reflect.apply(xC, null, [re, ...j]), () => e1(...j), "datetime format", (re) => re[s1](...j), DC, (re) => ke(re) || Kt(re));
  }
  function le(j) {
    w = j, S.pluralRules = w;
  }
  function Ee(j, re) {
    return V(() => {
      if (!j)
        return !1;
      const H = ke(re) ? re : a.value, K = Ce(H), de = S.messageResolver(K, j);
      return Ro(de) || Kr(de) || ke(de);
    }, () => [j], "translate exists", (H) => Reflect.apply(H.te, H, [j, re]), Aq, (H) => yt(H));
  }
  function Se(j) {
    let re = null;
    const H = LD(S, l.value, a.value);
    for (let K = 0; K < H.length; K++) {
      const de = c.value[H[K]] || {}, Oe = S.messageResolver(de, j);
      if (Oe != null) {
        re = Oe;
        break;
      }
    }
    return re;
  }
  function xe(j) {
    const re = Se(j);
    return re ?? (e ? e.tm(j) || {} : {});
  }
  function Ce(j) {
    return c.value[j] || {};
  }
  function _e(j, re) {
    if (i) {
      const H = { [j]: re };
      for (const K in H)
        Cg(H, K) && Gd(H[K]);
      re = H[j];
    }
    c.value[j] = re, S.messages = c.value;
  }
  function Je(j, re) {
    c.value[j] = c.value[j] || {};
    const H = { [j]: re };
    if (i)
      for (const K in H)
        Cg(H, K) && Gd(H[K]);
    re = H[j], Sp(re, c.value[j]), S.messages = c.value;
  }
  function P(j) {
    return u.value[j] || {};
  }
  function O(j, re) {
    u.value[j] = re, S.datetimeFormats = u.value, kC(S, j, re);
  }
  function q(j, re) {
    u.value[j] = gn(u.value[j] || {}, re), S.datetimeFormats = u.value, kC(S, j, re);
  }
  function ee(j) {
    return d.value[j] || {};
  }
  function ce(j, re) {
    d.value[j] = re, S.numberFormats = d.value, TC(S, j, re);
  }
  function Pe(j, re) {
    d.value[j] = gn(d.value[j] || {}, re), S.numberFormats = d.value, TC(S, j, re);
  }
  IC++, e && Ai && (Bt(e.locale, (j) => {
    o && (a.value = j, S.locale = j, vu(S, a.value, l.value));
  }), Bt(e.fallbackLocale, (j) => {
    o && (l.value = j, S.fallbackLocale = j, vu(S, a.value, l.value));
  }));
  const ye = {
    id: IC,
    locale: T,
    fallbackLocale: I,
    get inheritLocale() {
      return o;
    },
    set inheritLocale(j) {
      o = j, j && e && (a.value = e.locale.value, l.value = e.fallbackLocale.value, vu(S, a.value, l.value));
    },
    get availableLocales() {
      return Object.keys(c.value).sort();
    },
    messages: R,
    get modifiers() {
      return _;
    },
    get pluralRules() {
      return w || {};
    },
    get isGlobal() {
      return r;
    },
    get missingWarn() {
      return f;
    },
    set missingWarn(j) {
      f = j, S.missingWarn = f;
    },
    get fallbackWarn() {
      return h;
    },
    set fallbackWarn(j) {
      h = j, S.fallbackWarn = h;
    },
    get fallbackRoot() {
      return p;
    },
    set fallbackRoot(j) {
      p = j;
    },
    get fallbackFormat() {
      return g;
    },
    set fallbackFormat(j) {
      g = j, S.fallbackFormat = g;
    },
    get warnHtmlMessage() {
      return E;
    },
    set warnHtmlMessage(j) {
      E = j, S.warnHtmlMessage = j;
    },
    get escapeParameter() {
      return b;
    },
    set escapeParameter(j) {
      b = j, S.escapeParameter = j;
    },
    t: U,
    getLocaleMessage: Ce,
    setLocaleMessage: _e,
    mergeLocaleMessage: Je,
    getPostTranslationHandler: B,
    setPostTranslationHandler: G,
    getMissingHandler: M,
    setMissingHandler: A,
    [XD]: le
  };
  return ye.datetimeFormats = N, ye.numberFormats = $, ye.rt = Y, ye.te = Ee, ye.tm = xe, ye.d = ne, ye.n = ie, ye.getDateTimeFormat = P, ye.setDateTimeFormat = O, ye.mergeDateTimeFormat = q, ye.getNumberFormat = ee, ye.setNumberFormat = ce, ye.mergeNumberFormat = Pe, ye[JD] = n, ye[i1] = ge, ye[s1] = Be, ye[o1] = Re, process.env.NODE_ENV !== "production" && (ye[Ka] = (j) => {
    S.__v_emitter = j;
  }, ye[Wd] = () => {
    S.__v_emitter = void 0;
  }), ye;
}
const eI = "vue-i18n: composer properties", db = {
  "vue-devtools-plugin-vue-i18n": "Vue I18n DevTools",
  "vue-i18n-resource-inspector": "Vue I18n DevTools",
  "vue-i18n-timeline": "Vue I18n"
}, Rq = {
  "vue-i18n-resource-inspector": "Search for scopes ..."
}, Dq = {
  "vue-i18n-timeline": 16764185
};
let l1;
async function Iq(t, e) {
  return new Promise((n, r) => {
    try {
      kq({
        id: "vue-devtools-plugin-vue-i18n",
        label: db["vue-devtools-plugin-vue-i18n"],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [eI],
        app: t
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (i) => {
        l1 = i, i.on.visitComponentTree(({ componentInstance: o, treeNode: a }) => {
          Pq(o, a, e);
        }), i.on.inspectComponent(({ componentInstance: o, instanceData: a }) => {
          o.vnode.el && o.vnode.el.__VUE_I18N__ && a && (e.mode === "legacy" ? o.vnode.el.__VUE_I18N__ !== e.global.__composer && LC(a, o.vnode.el.__VUE_I18N__) : LC(a, o.vnode.el.__VUE_I18N__));
        }), i.addInspector({
          id: "vue-i18n-resource-inspector",
          label: db["vue-i18n-resource-inspector"],
          icon: "language",
          treeFilterPlaceholder: Rq["vue-i18n-resource-inspector"]
        }), i.on.getInspectorTree((o) => {
          o.app === t && o.inspectorId === "vue-i18n-resource-inspector" && zq(o, e);
        });
        const s = /* @__PURE__ */ new Map();
        i.on.getInspectorState(async (o) => {
          if (o.app === t && o.inspectorId === "vue-i18n-resource-inspector")
            if (i.unhighlightElement(), Uq(o, e), o.nodeId === "global") {
              if (!s.has(o.app)) {
                const [a] = await i.getComponentInstances(o.app);
                s.set(o.app, a);
              }
              i.highlightElement(s.get(o.app));
            } else {
              const a = Hq(o.nodeId, e);
              a && i.highlightElement(a);
            }
        }), i.on.editInspectorState((o) => {
          o.app === t && o.inspectorId === "vue-i18n-resource-inspector" && Wq(o, e);
        }), i.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: db["vue-i18n-timeline"],
          color: Dq["vue-i18n-timeline"]
        }), n(!0);
      });
    } catch (i) {
      console.error(i), r(!1);
    }
  });
}
function tI(t) {
  return t.type.name || t.type.displayName || t.type.__file || "Anonymous";
}
function Pq(t, e, n) {
  const r = n.mode === "composition" ? n.global : n.global.__composer;
  if (t && t.vnode.el && t.vnode.el.__VUE_I18N__ && t.vnode.el.__VUE_I18N__ !== r) {
    const i = {
      label: `i18n (${tI(t)} Scope)`,
      textColor: 0,
      backgroundColor: 16764185
    };
    e.tags.push(i);
  }
}
function LC(t, e) {
  const n = eI;
  t.state.push({
    type: n,
    key: "locale",
    editable: !0,
    value: e.locale.value
  }), t.state.push({
    type: n,
    key: "availableLocales",
    editable: !1,
    value: e.availableLocales
  }), t.state.push({
    type: n,
    key: "fallbackLocale",
    editable: !0,
    value: e.fallbackLocale.value
  }), t.state.push({
    type: n,
    key: "inheritLocale",
    editable: !0,
    value: e.inheritLocale
  }), t.state.push({
    type: n,
    key: "messages",
    editable: !1,
    value: J_(e.messages.value)
  }), t.state.push({
    type: n,
    key: "datetimeFormats",
    editable: !1,
    value: e.datetimeFormats.value
  }), t.state.push({
    type: n,
    key: "numberFormats",
    editable: !1,
    value: e.numberFormats.value
  });
}
function J_(t) {
  const e = {};
  return Object.keys(t).forEach((n) => {
    const r = t[n];
    Rt(r) && "source" in r ? e[n] = Fq(r) : Ro(r) && r.loc && r.loc.source ? e[n] = r.loc.source : bt(r) ? e[n] = J_(r) : e[n] = r;
  }), e;
}
const Lq = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function $q(t) {
  return t.replace(/[<>"&]/g, Bq);
}
function Bq(t) {
  return Lq[t] || t;
}
function Fq(t) {
  return {
    _custom: {
      type: "function",
      display: `<span>ƒ</span> ${t.source ? `("${$q(t.source)}")` : "(?)"}`
    }
  };
}
function zq(t, e) {
  t.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const n = e.mode === "composition" ? e.global : e.global.__composer;
  for (const [r, i] of e.__instances) {
    const s = e.mode === "composition" ? i : i.__composer;
    n !== s && t.rootNodes.push({
      id: s.id.toString(),
      label: `${tI(r)} Scope`
    });
  }
}
function Hq(t, e) {
  let n = null;
  if (t !== "global") {
    for (const [r, i] of e.__instances.entries())
      if (i.id.toString() === t) {
        n = r;
        break;
      }
  }
  return n;
}
function nI(t, e) {
  if (t === "global")
    return e.mode === "composition" ? e.global : e.global.__composer;
  {
    const n = Array.from(e.__instances.values()).find((r) => r.id.toString() === t);
    return n ? e.mode === "composition" ? n : n.__composer : null;
  }
}
function Uq(t, e) {
  const n = nI(t.nodeId, e);
  return n && (t.state = Vq(n)), null;
}
function Vq(t) {
  const e = {}, n = "Locale related info", r = [
    {
      type: n,
      key: "locale",
      editable: !0,
      value: t.locale.value
    },
    {
      type: n,
      key: "fallbackLocale",
      editable: !0,
      value: t.fallbackLocale.value
    },
    {
      type: n,
      key: "availableLocales",
      editable: !1,
      value: t.availableLocales
    },
    {
      type: n,
      key: "inheritLocale",
      editable: !0,
      value: t.inheritLocale
    }
  ];
  e[n] = r;
  const i = "Locale messages info", s = [
    {
      type: i,
      key: "messages",
      editable: !1,
      value: J_(t.messages.value)
    }
  ];
  e[i] = s;
  {
    const o = "Datetime formats info", a = [
      {
        type: o,
        key: "datetimeFormats",
        editable: !1,
        value: t.datetimeFormats.value
      }
    ];
    e[o] = a;
    const l = "Datetime formats info", c = [
      {
        type: l,
        key: "numberFormats",
        editable: !1,
        value: t.numberFormats.value
      }
    ];
    e[l] = c;
  }
  return e;
}
function jd(t, e) {
  if (l1) {
    let n;
    e && "groupId" in e && (n = e.groupId, delete e.groupId), l1.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: t,
        groupId: n,
        time: Date.now(),
        meta: {},
        data: e || {},
        logType: t === "compile-error" ? "error" : t === "fallback" || t === "missing" ? "warning" : "default"
      }
    });
  }
}
function Wq(t, e) {
  const n = nI(t.nodeId, e);
  if (n) {
    const [r] = t.path;
    r === "locale" && ke(t.state.value) ? n.locale.value = t.state.value : r === "fallbackLocale" && (ke(t.state.value) || Kt(t.state.value) || bt(t.state.value)) ? n.fallbackLocale.value = t.state.value : r === "inheritLocale" && yt(t.state.value) && (n.inheritLocale = t.state.value);
  }
}
function Gq(t) {
  const e = ke(t.locale) ? t.locale : Vd, n = ke(t.fallbackLocale) || Kt(t.fallbackLocale) || at(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e, r = Rt(t.missing) ? t.missing : void 0, i = yt(t.silentTranslationWarn) || Ic(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0, s = yt(t.silentFallbackWarn) || Ic(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0, o = yt(t.fallbackRoot) ? t.fallbackRoot : !0, a = !!t.formatFallbackMessages, l = at(t.modifiers) ? t.modifiers : {}, c = t.pluralizationRules, u = Rt(t.postTranslation) ? t.postTranslation : void 0, d = ke(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0, f = !!t.escapeParameterHtml, h = yt(t.sync) ? t.sync : !0;
  let p = t.messages;
  if (at(t.sharedMessages)) {
    const _ = t.sharedMessages;
    p = Object.keys(_).reduce((S, x) => {
      const k = S[x] || (S[x] = {});
      return gn(k, _[x]), S;
    }, p || {});
  }
  const { __i18n: g, __root: m, __injectWithOption: v } = t, y = t.datetimeFormats, E = t.numberFormats, b = t.flatJson;
  return {
    locale: e,
    fallbackLocale: n,
    messages: p,
    flatJson: b,
    datetimeFormats: y,
    numberFormats: E,
    missing: r,
    missingWarn: i,
    fallbackWarn: s,
    fallbackRoot: o,
    fallbackFormat: a,
    modifiers: l,
    pluralRules: c,
    postTranslation: u,
    warnHtmlMessage: d,
    escapeParameter: f,
    messageResolver: t.messageResolver,
    inheritLocale: h,
    __i18n: g,
    __root: m,
    __injectWithOption: v
  };
}
function c1(t = {}) {
  const e = X_(Gq(t)), { __extender: n } = t, r = {
    // id
    id: e.id,
    // locale
    get locale() {
      return e.locale.value;
    },
    set locale(i) {
      e.locale.value = i;
    },
    // fallbackLocale
    get fallbackLocale() {
      return e.fallbackLocale.value;
    },
    set fallbackLocale(i) {
      e.fallbackLocale.value = i;
    },
    // messages
    get messages() {
      return e.messages.value;
    },
    // datetimeFormats
    get datetimeFormats() {
      return e.datetimeFormats.value;
    },
    // numberFormats
    get numberFormats() {
      return e.numberFormats.value;
    },
    // availableLocales
    get availableLocales() {
      return e.availableLocales;
    },
    // missing
    get missing() {
      return e.getMissingHandler();
    },
    set missing(i) {
      e.setMissingHandler(i);
    },
    // silentTranslationWarn
    get silentTranslationWarn() {
      return yt(e.missingWarn) ? !e.missingWarn : e.missingWarn;
    },
    set silentTranslationWarn(i) {
      e.missingWarn = yt(i) ? !i : i;
    },
    // silentFallbackWarn
    get silentFallbackWarn() {
      return yt(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn;
    },
    set silentFallbackWarn(i) {
      e.fallbackWarn = yt(i) ? !i : i;
    },
    // modifiers
    get modifiers() {
      return e.modifiers;
    },
    // formatFallbackMessages
    get formatFallbackMessages() {
      return e.fallbackFormat;
    },
    set formatFallbackMessages(i) {
      e.fallbackFormat = i;
    },
    // postTranslation
    get postTranslation() {
      return e.getPostTranslationHandler();
    },
    set postTranslation(i) {
      e.setPostTranslationHandler(i);
    },
    // sync
    get sync() {
      return e.inheritLocale;
    },
    set sync(i) {
      e.inheritLocale = i;
    },
    // warnInHtmlMessage
    get warnHtmlInMessage() {
      return e.warnHtmlMessage ? "warn" : "off";
    },
    set warnHtmlInMessage(i) {
      e.warnHtmlMessage = i !== "off";
    },
    // escapeParameterHtml
    get escapeParameterHtml() {
      return e.escapeParameter;
    },
    set escapeParameterHtml(i) {
      e.escapeParameter = i;
    },
    // pluralizationRules
    get pluralizationRules() {
      return e.pluralRules || {};
    },
    // for internal
    __composer: e,
    // t
    t(...i) {
      return Reflect.apply(e.t, e, [...i]);
    },
    // rt
    rt(...i) {
      return Reflect.apply(e.rt, e, [...i]);
    },
    // tc
    tc(...i) {
      const [s, o, a] = i, l = { plural: 1 };
      let c = null, u = null;
      if (process.env.NODE_ENV !== "production" && PD(Gv(go.DEPRECATE_TC)), !ke(s))
        throw nr(Nt.INVALID_ARGUMENT);
      const d = s;
      return ke(o) ? l.locale = o : dn(o) ? l.plural = o : Kt(o) ? c = o : at(o) && (u = o), ke(a) ? l.locale = a : Kt(a) ? c = a : at(a) && (u = a), Reflect.apply(e.t, e, [
        d,
        c || u || {},
        l
      ]);
    },
    // te
    te(i, s) {
      return e.te(i, s);
    },
    // tm
    tm(i) {
      return e.tm(i);
    },
    // getLocaleMessage
    getLocaleMessage(i) {
      return e.getLocaleMessage(i);
    },
    // setLocaleMessage
    setLocaleMessage(i, s) {
      e.setLocaleMessage(i, s);
    },
    // mergeLocaleMessage
    mergeLocaleMessage(i, s) {
      e.mergeLocaleMessage(i, s);
    },
    // d
    d(...i) {
      return Reflect.apply(e.d, e, [...i]);
    },
    // getDateTimeFormat
    getDateTimeFormat(i) {
      return e.getDateTimeFormat(i);
    },
    // setDateTimeFormat
    setDateTimeFormat(i, s) {
      e.setDateTimeFormat(i, s);
    },
    // mergeDateTimeFormat
    mergeDateTimeFormat(i, s) {
      e.mergeDateTimeFormat(i, s);
    },
    // n
    n(...i) {
      return Reflect.apply(e.n, e, [...i]);
    },
    // getNumberFormat
    getNumberFormat(i) {
      return e.getNumberFormat(i);
    },
    // setNumberFormat
    setNumberFormat(i, s) {
      e.setNumberFormat(i, s);
    },
    // mergeNumberFormat
    mergeNumberFormat(i, s) {
      e.mergeNumberFormat(i, s);
    }
  };
  return r.__extender = n, process.env.NODE_ENV !== "production" && (r.__enableEmitter = (i) => {
    const s = e;
    s[Ka] && s[Ka](i);
  }, r.__disableEmitter = () => {
    const i = e;
    i[Wd] && i[Wd]();
  }), r;
}
function jq(t, e, n) {
  return {
    beforeCreate() {
      const r = Oo();
      if (!r)
        throw nr(Nt.UNEXPECTED_ERROR);
      const i = this.$options;
      if (i.i18n) {
        const s = i.i18n;
        if (i.__i18n && (s.__i18n = i.__i18n), s.__root = e, this === this.$root)
          this.$i18n = $C(t, s);
        else {
          s.__injectWithOption = !0, s.__extender = n.__vueI18nExtend, this.$i18n = c1(s);
          const o = this.$i18n;
          o.__extender && (o.__disposer = o.__extender(this.$i18n));
        }
      } else if (i.__i18n)
        if (this === this.$root)
          this.$i18n = $C(t, i);
        else {
          this.$i18n = c1({
            __i18n: i.__i18n,
            __injectWithOption: !0,
            __extender: n.__vueI18nExtend,
            __root: e
          });
          const s = this.$i18n;
          s.__extender && (s.__disposer = s.__extender(this.$i18n));
        }
      else
        this.$i18n = t;
      i.__i18nGlobal && QD(e, i, i), this.$t = (...s) => this.$i18n.t(...s), this.$rt = (...s) => this.$i18n.rt(...s), this.$tc = (...s) => this.$i18n.tc(...s), this.$te = (s, o) => this.$i18n.te(s, o), this.$d = (...s) => this.$i18n.d(...s), this.$n = (...s) => this.$i18n.n(...s), this.$tm = (s) => this.$i18n.tm(s), n.__setInstance(r, this.$i18n);
    },
    mounted() {
      if (process.env.NODE_ENV !== "production" && this.$el && this.$i18n) {
        const r = this.$i18n;
        this.$el.__VUE_I18N__ = r.__composer;
        const i = this.__v_emitter = G_();
        r.__enableEmitter && r.__enableEmitter(i), i.on("*", jd);
      }
    },
    unmounted() {
      const r = Oo();
      if (!r)
        throw nr(Nt.UNEXPECTED_ERROR);
      const i = this.$i18n;
      process.env.NODE_ENV !== "production" && this.$el && this.$el.__VUE_I18N__ && (this.__v_emitter && (this.__v_emitter.off("*", jd), delete this.__v_emitter), this.$i18n && (i.__disableEmitter && i.__disableEmitter(), delete this.$el.__VUE_I18N__)), delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), n.__deleteInstance(r), delete this.$i18n;
    }
  };
}
function $C(t, e) {
  t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[XD](e.pluralizationRules || t.pluralizationRules);
  const n = Y_(t.locale, {
    messages: e.messages,
    __i18n: e.__i18n
  });
  return Object.keys(n).forEach((r) => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach((r) => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach((r) => t.mergeNumberFormat(r, e.numberFormats[r])), t;
}
const Z_ = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (t) => t === "parent" || t === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function qq({ slots: t }, e) {
  return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, i) => [
    ...r,
    // prettier-ignore
    ...i.type === Vt ? i.children : [i]
  ], []) : e.reduce((n, r) => {
    const i = t[r];
    return i && (n[r] = i()), n;
  }, {});
}
function rI() {
  return Vt;
}
const Kq = /* @__PURE__ */ ae({
  /* eslint-disable */
  name: "i18n-t",
  props: gn({
    keypath: {
      type: String,
      required: !0
    },
    plural: {
      type: [Number, String],
      validator: (t) => dn(t) || !isNaN(t)
    }
  }, Z_),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const { slots: n, attrs: r } = e, i = t.i18n || Q_({
      useScope: t.scope,
      __useComponent: !0
    });
    return () => {
      const s = Object.keys(n).filter((d) => d !== "_"), o = {};
      t.locale && (o.locale = t.locale), t.plural !== void 0 && (o.plural = ke(t.plural) ? +t.plural : t.plural);
      const a = qq(e, s), l = i[i1](t.keypath, a, o), c = gn({}, r), u = ke(t.tag) || bt(t.tag) ? t.tag : rI();
      return mt(u, c, l);
    };
  }
}), BC = Kq;
function Yq(t) {
  return Kt(t) && !ke(t[0]);
}
function iI(t, e, n, r) {
  const { slots: i, attrs: s } = e;
  return () => {
    const o = { part: !0 };
    let a = {};
    t.locale && (o.locale = t.locale), ke(t.format) ? o.key = t.format : bt(t.format) && (ke(t.format.key) && (o.key = t.format.key), a = Object.keys(t.format).reduce((f, h) => n.includes(h) ? gn({}, f, { [h]: t.format[h] }) : f, {}));
    const l = r(t.value, o, a);
    let c = [o.key];
    Kt(l) ? c = l.map((f, h) => {
      const p = i[f.type], g = p ? p({ [f.type]: f.value, index: h, parts: l }) : [f.value];
      return Yq(g) && (g[0].key = `${f.type}-${h}`), g;
    }) : ke(l) && (c = [l]);
    const u = gn({}, s), d = ke(t.tag) || bt(t.tag) ? t.tag : rI();
    return mt(d, u, c);
  };
}
const Xq = /* @__PURE__ */ ae({
  /* eslint-disable */
  name: "i18n-n",
  props: gn({
    value: {
      type: Number,
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, Z_),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const n = t.i18n || Q_({
      useScope: t.scope,
      __useComponent: !0
    });
    return iI(t, e, jD, (...r) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[o1](...r)
    ));
  }
}), FC = Xq, Jq = /* @__PURE__ */ ae({
  /* eslint-disable */
  name: "i18n-d",
  props: gn({
    value: {
      type: [Number, Date],
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, Z_),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const n = t.i18n || Q_({
      useScope: t.scope,
      __useComponent: !0
    });
    return iI(t, e, GD, (...r) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[s1](...r)
    ));
  }
}), zC = Jq;
function Zq(t, e) {
  const n = t;
  if (t.mode === "composition")
    return n.__getInstance(e) || t.global;
  {
    const r = n.__getInstance(e);
    return r != null ? r.__composer : t.global.__composer;
  }
}
function Qq(t) {
  const e = (o) => {
    const { instance: a, value: l } = o;
    if (!a || !a.$)
      throw nr(Nt.UNEXPECTED_ERROR);
    const c = Zq(t, a.$), u = HC(l);
    return [
      Reflect.apply(c.t, c, [...UC(u)]),
      c
    ];
  };
  return {
    created: (o, a) => {
      const [l, c] = e(a);
      Ai && t.global === c && (o.__i18nWatcher = Bt(c.locale, () => {
        a.instance && a.instance.$forceUpdate();
      })), o.__composer = c, o.textContent = l;
    },
    unmounted: (o) => {
      Ai && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer);
    },
    beforeUpdate: (o, { value: a }) => {
      if (o.__composer) {
        const l = o.__composer, c = HC(a);
        o.textContent = Reflect.apply(l.t, l, [
          ...UC(c)
        ]);
      }
    },
    getSSRProps: (o) => {
      const [a] = e(o);
      return { textContent: a };
    }
  };
}
function HC(t) {
  if (ke(t))
    return { path: t };
  if (at(t)) {
    if (!("path" in t))
      throw nr(Nt.REQUIRED_VALUE, "path");
    return t;
  } else
    throw nr(Nt.INVALID_VALUE);
}
function UC(t) {
  const { path: e, locale: n, args: r, choice: i, plural: s } = t, o = {}, a = r || {};
  return ke(n) && (o.locale = n), dn(i) && (o.plural = i), dn(s) && (o.plural = s), [e, a, o];
}
function e9(t, e, ...n) {
  const r = at(n[0]) ? n[0] : {};
  (yt(r.globalInstall) ? r.globalInstall : !0) && ([BC.name, "I18nT"].forEach((s) => t.component(s, BC)), [FC.name, "I18nN"].forEach((s) => t.component(s, FC)), [zC.name, "I18nD"].forEach((s) => t.component(s, zC))), t.directive("t", Qq(e));
}
const t9 = /* @__PURE__ */ gs("global-vue-i18n");
function n9(t = {}, e) {
  const n = __VUE_I18N_LEGACY_API__ && yt(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__, r = yt(t.globalInjection) ? t.globalInjection : !0, i = /* @__PURE__ */ new Map(), [s, o] = r9(t, n), a = /* @__PURE__ */ gs(process.env.NODE_ENV !== "production" ? "vue-i18n" : "");
  function l(f) {
    return i.get(f) || null;
  }
  function c(f, h) {
    i.set(f, h);
  }
  function u(f) {
    i.delete(f);
  }
  const d = {
    // mode
    get mode() {
      return __VUE_I18N_LEGACY_API__ && n ? "legacy" : "composition";
    },
    // install plugin
    async install(f, ...h) {
      if (process.env.NODE_ENV !== "production" && (f.__VUE_I18N__ = d), f.__VUE_I18N_SYMBOL__ = a, f.provide(f.__VUE_I18N_SYMBOL__, d), at(h[0])) {
        const m = h[0];
        d.__composerExtend = m.__composerExtend, d.__vueI18nExtend = m.__vueI18nExtend;
      }
      let p = null;
      !n && r && (p = d9(f, d.global)), __VUE_I18N_FULL_INSTALL__ && e9(f, d, ...h), __VUE_I18N_LEGACY_API__ && n && f.mixin(jq(o, o.__composer, d));
      const g = f.unmount;
      if (f.unmount = () => {
        p && p(), d.dispose(), g();
      }, process.env.NODE_ENV !== "production") {
        if (!await Iq(f, d))
          throw nr(Nt.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
        const v = G_();
        if (n) {
          const y = o;
          y.__enableEmitter && y.__enableEmitter(v);
        } else {
          const y = o;
          y[Ka] && y[Ka](v);
        }
        v.on("*", jd);
      }
    },
    // global accessor
    get global() {
      return o;
    },
    dispose() {
      s.stop();
    },
    // @internal
    __instances: i,
    // @internal
    __getInstance: l,
    // @internal
    __setInstance: c,
    // @internal
    __deleteInstance: u
  };
  return d;
}
function Q_(t = {}) {
  const e = Oo();
  if (e == null)
    throw nr(Nt.MUST_BE_CALL_SETUP_TOP);
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw nr(Nt.NOT_INSTALLED);
  const n = i9(e), r = o9(n), i = ZD(e), s = s9(t, i);
  if (s === "global")
    return QD(r, t, i), r;
  if (s === "parent") {
    let l = a9(n, e, t.__useComponent);
    return l == null && (process.env.NODE_ENV !== "production" && Go(Gv(go.NOT_FOUND_PARENT_SCOPE)), l = r), l;
  }
  const o = n;
  let a = o.__getInstance(e);
  if (a == null) {
    const l = gn({}, t);
    "__i18n" in i && (l.__i18n = i.__i18n), r && (l.__root = r), a = X_(l), o.__composerExtend && (a[a1] = o.__composerExtend(a)), c9(o, e, a), o.__setInstance(e, a);
  }
  return a;
}
function r9(t, e, n) {
  const r = gA(), i = __VUE_I18N_LEGACY_API__ && e ? r.run(() => c1(t)) : r.run(() => X_(t));
  if (i == null)
    throw nr(Nt.UNEXPECTED_ERROR);
  return [r, i];
}
function i9(t) {
  const e = Ln(t.isCE ? t9 : t.appContext.app.__VUE_I18N_SYMBOL__);
  if (!e)
    throw nr(t.isCE ? Nt.NOT_INSTALLED_WITH_PROVIDE : Nt.UNEXPECTED_ERROR);
  return e;
}
function s9(t, e) {
  return Uv(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local";
}
function o9(t) {
  return t.mode === "composition" ? t.global : t.global.__composer;
}
function a9(t, e, n = !1) {
  let r = null;
  const i = e.root;
  let s = l9(e, n);
  for (; s != null; ) {
    const o = t;
    if (t.mode === "composition")
      r = o.__getInstance(s);
    else if (__VUE_I18N_LEGACY_API__) {
      const a = o.__getInstance(s);
      a != null && (r = a.__composer, n && r && !r[JD] && (r = null));
    }
    if (r != null || i === s)
      break;
    s = s.parent;
  }
  return r;
}
function l9(t, e = !1) {
  return t == null ? null : e && t.vnode.ctx || t.parent;
}
function c9(t, e, n) {
  let r = null;
  Zt(() => {
    if (process.env.NODE_ENV !== "production" && e.vnode.el) {
      e.vnode.el.__VUE_I18N__ = n, r = G_();
      const i = n;
      i[Ka] && i[Ka](r), r.on("*", jd);
    }
  }, e), Mo(() => {
    const i = n;
    process.env.NODE_ENV !== "production" && e.vnode.el && e.vnode.el.__VUE_I18N__ && (r && r.off("*", jd), i[Wd] && i[Wd](), delete e.vnode.el.__VUE_I18N__), t.__deleteInstance(e);
    const s = i[a1];
    s && (s(), delete i[a1]);
  }, e);
}
const u9 = [
  "locale",
  "fallbackLocale",
  "availableLocales"
], VC = ["t", "rt", "d", "n", "tm", "te"];
function d9(t, e) {
  const n = /* @__PURE__ */ Object.create(null);
  return u9.forEach((i) => {
    const s = Object.getOwnPropertyDescriptor(e, i);
    if (!s)
      throw nr(Nt.UNEXPECTED_ERROR);
    const o = Ss(s.value) ? {
      get() {
        return s.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(a) {
        s.value.value = a;
      }
    } : {
      get() {
        return s.get && s.get();
      }
    };
    Object.defineProperty(n, i, o);
  }), t.config.globalProperties.$i18n = n, VC.forEach((i) => {
    const s = Object.getOwnPropertyDescriptor(e, i);
    if (!s || !s.value)
      throw nr(Nt.UNEXPECTED_ERROR);
    Object.defineProperty(t.config.globalProperties, `$${i}`, s);
  }), () => {
    delete t.config.globalProperties.$i18n, VC.forEach((i) => {
      delete t.config.globalProperties[`$${i}`];
    });
  };
}
Tq();
Jj(Mj);
Zj(jj);
Qj(LD);
if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
  const t = pa();
  t.__INTLIFY__ = !0, Aj(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
process.env.NODE_ENV;
const f9 = {
  redo: "Redo",
  undo: "Undo",
  formatClear: "Format clear",
  bold: "Bold",
  italic: "Italic",
  strike: "Strike Line",
  underline: "Underline",
  textColor: "Text color",
  textLight: "Text light",
  heading: "Heading",
  align: "Align",
  alignLeft: "Align Left",
  alignCenter: "Align Center",
  alignRight: "Align Right",
  alignJustify: "Align Justify",
  lineHeight: "Line Height",
  subscript: "Subscript",
  superscript: "Superscript",
  image: "Image",
  video: "Video",
  link: "Link",
  code: "Code",
  codeBlock: "Code block",
  quote: "Quote",
  separator: "Separator",
  bulletList: "Bullet list",
  orderList: "Order list",
  taskList: "Task list",
  fullscreen: "Fullscreen",
  table: "Table",
  math: "Math",
  print: "Print document",
  outlineTree: "Toc outline",
  codeView: "Code view",
  fontFamily: "Font family",
  askAi: "Generate、Edit、Translate with AI",
  exportPdf: "Export PDF",
  exportWord: "Export Word",
  openLink: "Open link",
  unsetLink: "Unset link",
  saveLink: "Save link",
  insertLink: "Insert link",
  linkUrlTips: "Link url",
  linkTextTips: "Link text content",
  insertTable: "Insert table",
  mergeCells: "Merge cells",
  splitCells: "Merge cells",
  addTopRow: "Insert row above",
  addBottomRow: "Insert row below",
  addLeftCell: "Insert column left",
  addRightCell: "Insert column right",
  delRow: "Delete row",
  delCol: "Delete column",
  delTable: "Delete table",
  uploadFile: "Upload file",
  imageUrlTips: "Image url",
  uploadImageTips: "Upload image",
  uploadImage: "Upload submit",
  networkImage: "Network image",
  localImage: "Local image",
  videoUrlTips: "Video url",
  uploadVideoTips: "Upload video",
  uploadVideo: "Upload submit",
  networkVideo: "Network video",
  localVideo: "Local video",
  leftFloat: "Left float",
  rightFloat: "Right float",
  inline: "Inline",
  smallSize: "Small size",
  mediumSize: "Medium size",
  fullSize: "Full size",
  delete: "Delete",
  displayVideo: "Display control",
  loopPlay: "Loop play",
  soundOff: "Sound off",
  editing: "Editing",
  preview: "Viewing",
  tocHeadTips: "On This Page",
  tocEndTips: "Back to top",
  placeholderCommand: "Press '/' for commands",
  wordCount: "Word Count"
}, h9 = {
  redo: "重做",
  undo: "撤销",
  formatClear: "清除格式",
  bold: "加粗",
  italic: "斜体",
  strike: "删除线",
  underline: "下划线",
  textColor: "文本颜色",
  textLight: "文本亮度",
  heading: "标题",
  align: "对齐",
  alignLeft: "左对齐",
  alignCenter: "居中对齐",
  alignRight: "右对齐",
  alignJustify: "两端对齐",
  lineHeight: "行高",
  subscript: "下标",
  superscript: "上标",
  image: "图片",
  video: "视频",
  link: "链接",
  code: "代码",
  codeBlock: "代码块",
  quote: "引用",
  separator: "分隔符",
  bulletList: "无序列表",
  orderList: "有序列表",
  taskList: "任务列表",
  fullscreen: "全屏",
  table: "表格",
  math: "数学",
  print: "打印文档",
  outlineTree: "导航栏",
  codeView: "代码视图",
  fontFamily: "字体",
  askAi: "使用AI生成、编辑、翻译",
  exportPdf: "导出PDF",
  exportWord: "导出Word",
  openLink: "打开链接",
  unsetLink: "取消链接",
  saveLink: "保存链接",
  insertLink: "插入链接",
  linkUrlTips: "链接地址",
  linkTextTips: "链接文本内容",
  insertTable: "插入表格",
  mergeCells: "合并单元格",
  splitCells: "拆分单元格",
  addTopRow: "在上方插入行",
  addBottomRow: "在下方插入行",
  addLeftCell: "在左侧插入列",
  addRightCell: "在右侧插入列",
  delRow: "删除行",
  delCol: "删除列",
  delTable: "删除表格",
  uploadFile: "上传文件",
  imageUrlTips: "图片地址",
  uploadImageTips: "上传图片",
  uploadImage: "提交上传",
  networkImage: "网络图片",
  localImage: "本地图片",
  videoUrlTips: "视频地址",
  uploadVideoTips: "上传视频",
  uploadVideo: "提交上传",
  networkVideo: "网络视频",
  localVideo: "本地视频",
  leftFloat: "左浮动",
  rightFloat: "右浮动",
  inline: "内联",
  smallSize: "小尺寸",
  mediumSize: "中尺寸",
  fullSize: "全尺寸",
  delete: "删除",
  displayVideo: "显示控制",
  loopPlay: "循环播放",
  soundOff: "静音",
  editing: "编辑",
  preview: "预览",
  tocHeadTips: "在此页面",
  tocEndTips: "回到顶部",
  placeholderCommand: "输入 '/' 唤起更多",
  wordCount: "字数"
}, p9 = "en-US", eE = n9({
  locale: p9,
  fallbackLocale: "en-US",
  allowComposition: !0,
  messages: {
    "en-US": f9,
    "zh-CN": h9
  }
}), me = eE.global.t;
function g9(t) {
  eE.global.locale = t;
}
function m9(t) {
  t.use(eE);
}
const v9 = { key: 0 }, b9 = /* @__PURE__ */ ae({
  __name: "BlockQuote",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(JR.configure(e.options)), (r, i) => C(n) ? (J(), be("div", v9, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleBlockquote().run(),
          icon: C(AD),
          "is-active": () => C(n).isActive("blockquote"),
          title: C(me)("quote")
        }, null, 8, ["action", "icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
});
function xpe(t) {
  return JR.configure(t);
}
const y9 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, w9 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, _9 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, E9 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, sI = mr.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Va({
        find: y9,
        type: this.type
      }),
      Va({
        find: _9,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      No({
        find: w9,
        type: this.type
      }),
      No({
        find: E9,
        type: this.type
      })
    ];
  }
}), S9 = { key: 0 }, oI = /* @__PURE__ */ ae({
  __name: "Bold",
  props: {
    options: {
      type: Object,
      required: !1
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(sI.configure(e.options)), (r, i) => C(n) ? (J(), be("div", S9, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleBold().run(),
          icon: C(eG),
          "is-active": () => C(n).isActive("bold"),
          mini: t.mini,
          title: C(me)("bold")
        }, null, 8, ["action", "icon", "is-active", "mini", "title"])
      ])
    ])) : He("", !0);
  }
});
function kpe(t) {
  return sI.configure(t);
}
const x9 = "listItem", WC = "textStyle", GC = /^\s*([-+*])\s$/, aI = an.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(x9, this.editor.getAttributes(WC)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = Ec({
      find: GC,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Ec({
      find: GC,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(WC),
      editor: this.editor
    })), [
      t
    ];
  }
}), k9 = { key: 0 }, C9 = /* @__PURE__ */ ae({
  __name: "BulletList",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(aI.configure(e.options)), (r, i) => C(n) ? (J(), be("div", k9, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleBulletList().run(),
          icon: C(TD),
          "is-active": () => C(n).isActive("bulletList"),
          title: C(me)("bulletList")
        }, null, 8, ["action", "icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
});
function Cpe(t) {
  return aI.configure(t);
}
const lI = Et.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc;
      if (((t == null ? void 0 : t.mode) || this.options.mode) === "textSize") {
        const r = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("characterCount"),
        filterTransaction: (t, e) => {
          const n = this.options.limit;
          if (!t.docChanged || n === 0 || n === null || n === void 0)
            return !0;
          const r = this.storage.characters({ node: e.doc }), i = this.storage.characters({ node: t.doc });
          if (i <= n || r > n && i > n && i <= r)
            return !0;
          if (r > n && i > n && i > r || !t.getMeta("paste"))
            return !1;
          const o = t.selection.$head.pos, a = i - n, l = o - a, c = o;
          return t.deleteRange(l, c), !(this.storage.characters({ node: t.doc }) > n);
        }
      })
    ];
  }
}), T9 = /* @__PURE__ */ ae({
  __name: "CharacterCount",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t;
    return nt(lI.configure(e.options)), (n, r) => null;
  }
});
function Tpe(t) {
  return lI.configure(t);
}
const O9 = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/, M9 = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g, cI = mr.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Va({
        find: O9,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      No({
        find: M9,
        type: this.type
      })
    ];
  }
}), A9 = { key: 0 }, N9 = /* @__PURE__ */ ae({
  __name: "Code",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(cI.configure(e.options)), (r, i) => C(n) ? (J(), be("div", A9, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleCode().run(),
          icon: C(ED),
          "is-active": () => C(n).isActive("code"),
          title: C(me)("code")
        }, null, 8, ["action", "icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
});
function Ope(t) {
  return cI.configure(t);
}
const R9 = /^```([a-z]+)?[\s\n]$/, D9 = /^~~~([a-z]+)?[\s\n]$/, I9 = an.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, s = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((o) => o.startsWith(n)).map((o) => o.replace(n, ""))[0];
          return s || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      _t(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const s = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`);
        return !s || !o ? !1 : t.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: r } = e, { $from: i, empty: s } = n;
        if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? t.commands.command(({ tr: c }) => (c.setSelection($e.near(r.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      Fy({
        find: R9,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      Fy({
        find: D9,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new ut({
        key: new ft("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, s = i == null ? void 0 : i.mode;
            if (!n || !s)
              return !1;
            const { tr: o, schema: a } = t.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return o.replaceSelectionWith(this.type.create({ language: s }, l)), o.selection.$from.parent.type !== this.type && o.setSelection(Te.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", !0), t.dispatch(o), !0;
          }
        }
      })
    ];
  }
});
function P9(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function uI(t) {
  return t instanceof Map ? t.clear = t.delete = t.set = function() {
    throw new Error("map is read-only");
  } : t instanceof Set && (t.add = t.clear = t.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach((e) => {
    const n = t[e], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && uI(n);
  }), t;
}
let jC = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
};
function dI(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function mo(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in t)
    n[r] = t[r];
  return e.forEach(function(r) {
    for (const i in r)
      n[i] = r[i];
  }), /** @type {T} */
  n;
}
const L9 = "</span>", qC = (t) => !!t.scope, $9 = (t, { prefix: e }) => {
  if (t.startsWith("language:"))
    return t.replace("language:", "language-");
  if (t.includes(".")) {
    const n = t.split(".");
    return [
      `${e}${n.shift()}`,
      ...n.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${e}${t}`;
};
let B9 = class {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += dI(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!qC(e))
      return;
    const n = $9(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    qC(e) && (this.buffer += L9);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
};
const KC = (t = {}) => {
  const e = { children: [] };
  return Object.assign(e, t), e;
};
let F9 = class fI {
  constructor() {
    this.rootNode = KC(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const n = KC({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      fI._collapse(n);
    }));
  }
}, z9 = class extends F9 {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const r = e.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new B9(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
};
function qd(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function hI(t) {
  return fl("(?=", t, ")");
}
function H9(t) {
  return fl("(?:", t, ")*");
}
function U9(t) {
  return fl("(?:", t, ")?");
}
function fl(...t) {
  return t.map((n) => qd(n)).join("");
}
function V9(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function tE(...t) {
  return "(" + (V9(t).capture ? "" : "?:") + t.map((r) => qd(r)).join("|") + ")";
}
function pI(t) {
  return new RegExp(t.toString() + "|").exec("").length - 1;
}
function W9(t, e) {
  const n = t && t.exec(e);
  return n && n.index === 0;
}
const G9 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function nE(t, { joinWith: e }) {
  let n = 0;
  return t.map((r) => {
    n += 1;
    const i = n;
    let s = qd(r), o = "";
    for (; s.length > 0; ) {
      const a = G9.exec(s);
      if (!a) {
        o += s;
        break;
      }
      o += s.substring(0, a.index), s = s.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? o += "\\" + String(Number(a[1]) + i) : (o += a[0], a[0] === "(" && n++);
    }
    return o;
  }).map((r) => `(${r})`).join(e);
}
const j9 = /\b\B/, gI = "[a-zA-Z]\\w*", rE = "[a-zA-Z_]\\w*", mI = "\\b\\d+(\\.\\d+)?", vI = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", bI = "\\b(0b[01]+)", q9 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", K9 = (t = {}) => {
  const e = /^#![ ]*\//;
  return t.binary && (t.begin = fl(
    e,
    /.*\b/,
    t.binary,
    /\b.*/
  )), mo({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, t);
}, Kd = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, Y9 = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Kd]
}, X9 = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Kd]
}, J9 = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, jv = function(t, e, n = {}) {
  const r = mo(
    {
      scope: "comment",
      begin: t,
      end: e,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = tE(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: fl(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, Z9 = jv("//", "$"), Q9 = jv("/\\*", "\\*/"), e7 = jv("#", "$"), t7 = {
  scope: "number",
  begin: mI,
  relevance: 0
}, n7 = {
  scope: "number",
  begin: vI,
  relevance: 0
}, r7 = {
  scope: "number",
  begin: bI,
  relevance: 0
}, i7 = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    Kd,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [Kd]
    }
  ]
}, s7 = {
  scope: "title",
  begin: gI,
  relevance: 0
}, o7 = {
  scope: "title",
  begin: rE,
  relevance: 0
}, a7 = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + rE,
  relevance: 0
}, l7 = function(t) {
  return Object.assign(
    t,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, n) => {
        n.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch();
      }
    }
  );
};
var Sh = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: Y9,
  BACKSLASH_ESCAPE: Kd,
  BINARY_NUMBER_MODE: r7,
  BINARY_NUMBER_RE: bI,
  COMMENT: jv,
  C_BLOCK_COMMENT_MODE: Q9,
  C_LINE_COMMENT_MODE: Z9,
  C_NUMBER_MODE: n7,
  C_NUMBER_RE: vI,
  END_SAME_AS_BEGIN: l7,
  HASH_COMMENT_MODE: e7,
  IDENT_RE: gI,
  MATCH_NOTHING_RE: j9,
  METHOD_GUARD: a7,
  NUMBER_MODE: t7,
  NUMBER_RE: mI,
  PHRASAL_WORDS_MODE: J9,
  QUOTE_STRING_MODE: X9,
  REGEXP_MODE: i7,
  RE_STARTERS_RE: q9,
  SHEBANG: K9,
  TITLE_MODE: s7,
  UNDERSCORE_IDENT_RE: rE,
  UNDERSCORE_TITLE_MODE: o7
});
function c7(t, e) {
  t.input[t.index - 1] === "." && e.ignoreMatch();
}
function u7(t, e) {
  t.className !== void 0 && (t.scope = t.className, delete t.className);
}
function d7(t, e) {
  e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = c7, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0));
}
function f7(t, e) {
  Array.isArray(t.illegal) && (t.illegal = tE(...t.illegal));
}
function h7(t, e) {
  if (t.match) {
    if (t.begin || t.end)
      throw new Error("begin & end are not supported with match");
    t.begin = t.match, delete t.match;
  }
}
function p7(t, e) {
  t.relevance === void 0 && (t.relevance = 1);
}
const g7 = (t, e) => {
  if (!t.beforeMatch)
    return;
  if (t.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t);
  Object.keys(t).forEach((r) => {
    delete t[r];
  }), t.keywords = n.keywords, t.begin = fl(n.beforeMatch, hI(n.begin)), t.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, t.relevance = 0, delete n.beforeMatch;
}, m7 = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], v7 = "keyword";
function yI(t, e, n = v7) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof t == "string" ? i(n, t.split(" ")) : Array.isArray(t) ? i(n, t) : Object.keys(t).forEach(function(s) {
    Object.assign(
      r,
      yI(t[s], e, s)
    );
  }), r;
  function i(s, o) {
    e && (o = o.map((a) => a.toLowerCase())), o.forEach(function(a) {
      const l = a.split("|");
      r[l[0]] = [s, b7(l[0], l[1])];
    });
  }
}
function b7(t, e) {
  return e ? Number(e) : y7(t) ? 0 : 1;
}
function y7(t) {
  return m7.includes(t.toLowerCase());
}
const YC = {}, Aa = (t) => {
  console.error(t);
}, XC = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e);
}, xl = (t, e) => {
  YC[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), YC[`${t}/${e}`] = !0);
}, Og = new Error();
function wI(t, e, { key: n }) {
  let r = 0;
  const i = t[n], s = {}, o = {};
  for (let a = 1; a <= e.length; a++)
    o[a + r] = i[a], s[a + r] = !0, r += pI(e[a - 1]);
  t[n] = o, t[n]._emit = s, t[n]._multi = !0;
}
function w7(t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin)
      throw Aa("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Og;
    if (typeof t.beginScope != "object" || t.beginScope === null)
      throw Aa("beginScope must be object"), Og;
    wI(t, t.begin, { key: "beginScope" }), t.begin = nE(t.begin, { joinWith: "" });
  }
}
function _7(t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd)
      throw Aa("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Og;
    if (typeof t.endScope != "object" || t.endScope === null)
      throw Aa("endScope must be object"), Og;
    wI(t, t.end, { key: "endScope" }), t.end = nE(t.end, { joinWith: "" });
  }
}
function E7(t) {
  t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
}
function S7(t) {
  E7(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), w7(t), _7(t);
}
function x7(t) {
  function e(o, a) {
    return new RegExp(
      qd(o),
      "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += pI(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = e(nE(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const c = l.findIndex((d, f) => f > 0 && d !== void 0), u = this.matchIndexes[c];
      return l.splice(0, c), Object.assign(l, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a])
        return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([c, u]) => l.addRule(c, u)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let c = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, c = u.exec(a);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function i(o) {
    const a = new r();
    return o.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && a.addRule(o.terminatorEnd, { type: "end" }), o.illegal && a.addRule(o.illegal, { type: "illegal" }), a;
  }
  function s(o, a) {
    const l = (
      /** @type CompiledMode */
      o
    );
    if (o.isCompiled)
      return l;
    [
      u7,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      h7,
      S7,
      g7
    ].forEach((u) => u(o, a)), t.compilerExtensions.forEach((u) => u(o, a)), o.__beforeBegin = null, [
      d7,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      f7,
      // default to 1 relevance if not specified
      p7
    ].forEach((u) => u(o, a)), o.isCompiled = !0;
    let c = null;
    return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), c = o.keywords.$pattern, delete o.keywords.$pattern), c = c || /\w+/, o.keywords && (o.keywords = yI(o.keywords, t.case_insensitive)), l.keywordPatternRe = e(c, !0), a && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = qd(l.end) || "", o.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + a.terminatorEnd)), o.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      o.illegal
    )), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function(u) {
      return k7(u === "self" ? o : u);
    })), o.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        l
      );
    }), o.starts && s(o.starts, a), l.matcher = i(l), l;
  }
  if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t.classNameAliases = mo(t.classNameAliases || {}), s(
    /** @type Mode */
    t
  );
}
function _I(t) {
  return t ? t.endsWithParent || _I(t.starts) : !1;
}
function k7(t) {
  return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function(e) {
    return mo(t, { variants: null }, e);
  })), t.cachedVariants ? t.cachedVariants : _I(t) ? mo(t, { starts: t.starts ? mo(t.starts) : null }) : Object.isFrozen(t) ? mo(t) : t;
}
var C7 = "11.10.0";
let T7 = class extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
};
const fb = dI, JC = mo, ZC = Symbol("nomatch"), O7 = 7, EI = function(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: z9
  };
  function l(M) {
    return a.noHighlightRe.test(M);
  }
  function c(M) {
    let A = M.className + " ";
    A += M.parentNode ? M.parentNode.className : "";
    const z = a.languageDetectRe.exec(A);
    if (z) {
      const V = k(z[1]);
      return V || (XC(s.replace("{}", z[1])), XC("Falling back to no-highlight mode for this block.", M)), V ? z[1] : "no-highlight";
    }
    return A.split(/\s+/).find((V) => l(V) || k(V));
  }
  function u(M, A, z) {
    let V = "", U = "";
    typeof A == "object" ? (V = M, z = A.ignoreIllegals, U = A.language) : (xl("10.7.0", "highlight(lang, code, ...args) has been deprecated."), xl("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), U = M, V = A), z === void 0 && (z = !0);
    const Y = {
      code: V,
      language: U
    };
    B("before:highlight", Y);
    const ne = Y.result ? Y.result : d(Y.language, Y.code, z);
    return ne.code = Y.code, B("after:highlight", ne), ne;
  }
  function d(M, A, z, V) {
    const U = /* @__PURE__ */ Object.create(null);
    function Y(H, K) {
      return H.keywords[K];
    }
    function ne() {
      if (!O.keywords) {
        ee.addText(ce);
        return;
      }
      let H = 0;
      O.keywordPatternRe.lastIndex = 0;
      let K = O.keywordPatternRe.exec(ce), de = "";
      for (; K; ) {
        de += ce.substring(H, K.index);
        const Oe = _e.case_insensitive ? K[0].toLowerCase() : K[0], Xe = Y(O, Oe);
        if (Xe) {
          const [pt, hi] = Xe;
          if (ee.addText(de), de = "", U[Oe] = (U[Oe] || 0) + 1, U[Oe] <= O7 && (Pe += hi), pt.startsWith("_"))
            de += K[0];
          else {
            const D = _e.classNameAliases[pt] || pt;
            Q(K[0], D);
          }
        } else
          de += K[0];
        H = O.keywordPatternRe.lastIndex, K = O.keywordPatternRe.exec(ce);
      }
      de += ce.substring(H), ee.addText(de);
    }
    function ie() {
      if (ce === "")
        return;
      let H = null;
      if (typeof O.subLanguage == "string") {
        if (!e[O.subLanguage]) {
          ee.addText(ce);
          return;
        }
        H = d(O.subLanguage, ce, !0, q[O.subLanguage]), q[O.subLanguage] = /** @type {CompiledMode} */
        H._top;
      } else
        H = h(ce, O.subLanguage.length ? O.subLanguage : null);
      O.relevance > 0 && (Pe += H.relevance), ee.__addSublanguage(H._emitter, H.language);
    }
    function Z() {
      O.subLanguage != null ? ie() : ne(), ce = "";
    }
    function Q(H, K) {
      H !== "" && (ee.startScope(K), ee.addText(H), ee.endScope());
    }
    function fe(H, K) {
      let de = 1;
      const Oe = K.length - 1;
      for (; de <= Oe; ) {
        if (!H._emit[de]) {
          de++;
          continue;
        }
        const Xe = _e.classNameAliases[H[de]] || H[de], pt = K[de];
        Xe ? Q(pt, Xe) : (ce = pt, ne(), ce = ""), de++;
      }
    }
    function ge(H, K) {
      return H.scope && typeof H.scope == "string" && ee.openNode(_e.classNameAliases[H.scope] || H.scope), H.beginScope && (H.beginScope._wrap ? (Q(ce, _e.classNameAliases[H.beginScope._wrap] || H.beginScope._wrap), ce = "") : H.beginScope._multi && (fe(H.beginScope, K), ce = "")), O = Object.create(H, { parent: { value: O } }), O;
    }
    function Re(H, K, de) {
      let Oe = W9(H.endRe, de);
      if (Oe) {
        if (H["on:end"]) {
          const Xe = new jC(H);
          H["on:end"](K, Xe), Xe.isMatchIgnored && (Oe = !1);
        }
        if (Oe) {
          for (; H.endsParent && H.parent; )
            H = H.parent;
          return H;
        }
      }
      if (H.endsWithParent)
        return Re(H.parent, K, de);
    }
    function Be(H) {
      return O.matcher.regexIndex === 0 ? (ce += H[0], 1) : (re = !0, 0);
    }
    function le(H) {
      const K = H[0], de = H.rule, Oe = new jC(de), Xe = [de.__beforeBegin, de["on:begin"]];
      for (const pt of Xe)
        if (pt && (pt(H, Oe), Oe.isMatchIgnored))
          return Be(K);
      return de.skip ? ce += K : (de.excludeBegin && (ce += K), Z(), !de.returnBegin && !de.excludeBegin && (ce = K)), ge(de, H), de.returnBegin ? 0 : K.length;
    }
    function Ee(H) {
      const K = H[0], de = A.substring(H.index), Oe = Re(O, H, de);
      if (!Oe)
        return ZC;
      const Xe = O;
      O.endScope && O.endScope._wrap ? (Z(), Q(K, O.endScope._wrap)) : O.endScope && O.endScope._multi ? (Z(), fe(O.endScope, H)) : Xe.skip ? ce += K : (Xe.returnEnd || Xe.excludeEnd || (ce += K), Z(), Xe.excludeEnd && (ce = K));
      do
        O.scope && ee.closeNode(), !O.skip && !O.subLanguage && (Pe += O.relevance), O = O.parent;
      while (O !== Oe.parent);
      return Oe.starts && ge(Oe.starts, H), Xe.returnEnd ? 0 : K.length;
    }
    function Se() {
      const H = [];
      for (let K = O; K !== _e; K = K.parent)
        K.scope && H.unshift(K.scope);
      H.forEach((K) => ee.openNode(K));
    }
    let xe = {};
    function Ce(H, K) {
      const de = K && K[0];
      if (ce += H, de == null)
        return Z(), 0;
      if (xe.type === "begin" && K.type === "end" && xe.index === K.index && de === "") {
        if (ce += A.slice(K.index, K.index + 1), !i) {
          const Oe = new Error(`0 width match regex (${M})`);
          throw Oe.languageName = M, Oe.badRule = xe.rule, Oe;
        }
        return 1;
      }
      if (xe = K, K.type === "begin")
        return le(K);
      if (K.type === "illegal" && !z) {
        const Oe = new Error('Illegal lexeme "' + de + '" for mode "' + (O.scope || "<unnamed>") + '"');
        throw Oe.mode = O, Oe;
      } else if (K.type === "end") {
        const Oe = Ee(K);
        if (Oe !== ZC)
          return Oe;
      }
      if (K.type === "illegal" && de === "")
        return 1;
      if (j > 1e5 && j > K.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return ce += de, de.length;
    }
    const _e = k(M);
    if (!_e)
      throw Aa(s.replace("{}", M)), new Error('Unknown language: "' + M + '"');
    const Je = x7(_e);
    let P = "", O = V || Je;
    const q = {}, ee = new a.__emitter(a);
    Se();
    let ce = "", Pe = 0, ye = 0, j = 0, re = !1;
    try {
      if (_e.__emitTokens)
        _e.__emitTokens(A, ee);
      else {
        for (O.matcher.considerAll(); ; ) {
          j++, re ? re = !1 : O.matcher.considerAll(), O.matcher.lastIndex = ye;
          const H = O.matcher.exec(A);
          if (!H)
            break;
          const K = A.substring(ye, H.index), de = Ce(K, H);
          ye = H.index + de;
        }
        Ce(A.substring(ye));
      }
      return ee.finalize(), P = ee.toHTML(), {
        language: M,
        value: P,
        relevance: Pe,
        illegal: !1,
        _emitter: ee,
        _top: O
      };
    } catch (H) {
      if (H.message && H.message.includes("Illegal"))
        return {
          language: M,
          value: fb(A),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: H.message,
            index: ye,
            context: A.slice(ye - 100, ye + 100),
            mode: H.mode,
            resultSoFar: P
          },
          _emitter: ee
        };
      if (i)
        return {
          language: M,
          value: fb(A),
          illegal: !1,
          relevance: 0,
          errorRaised: H,
          _emitter: ee,
          _top: O
        };
      throw H;
    }
  }
  function f(M) {
    const A = {
      value: fb(M),
      illegal: !1,
      relevance: 0,
      _top: o,
      _emitter: new a.__emitter(a)
    };
    return A._emitter.addText(M), A;
  }
  function h(M, A) {
    A = A || a.languages || Object.keys(e);
    const z = f(M), V = A.filter(k).filter(I).map(
      (Z) => d(Z, M, !1)
    );
    V.unshift(z);
    const U = V.sort((Z, Q) => {
      if (Z.relevance !== Q.relevance)
        return Q.relevance - Z.relevance;
      if (Z.language && Q.language) {
        if (k(Z.language).supersetOf === Q.language)
          return 1;
        if (k(Q.language).supersetOf === Z.language)
          return -1;
      }
      return 0;
    }), [Y, ne] = U, ie = Y;
    return ie.secondBest = ne, ie;
  }
  function p(M, A, z) {
    const V = A && n[A] || z;
    M.classList.add("hljs"), M.classList.add(`language-${V}`);
  }
  function g(M) {
    let A = null;
    const z = c(M);
    if (l(z))
      return;
    if (B(
      "before:highlightElement",
      { el: M, language: z }
    ), M.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", M);
      return;
    }
    if (M.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(M)), a.throwUnescapedHTML))
      throw new T7(
        "One of your code blocks includes unescaped HTML.",
        M.innerHTML
      );
    A = M;
    const V = A.textContent, U = z ? u(V, { language: z, ignoreIllegals: !0 }) : h(V);
    M.innerHTML = U.value, M.dataset.highlighted = "yes", p(M, z, U.language), M.result = {
      language: U.language,
      // TODO: remove with version 11.0
      re: U.relevance,
      relevance: U.relevance
    }, U.secondBest && (M.secondBest = {
      language: U.secondBest.language,
      relevance: U.secondBest.relevance
    }), B("after:highlightElement", { el: M, result: U, text: V });
  }
  function m(M) {
    a = JC(a, M);
  }
  const v = () => {
    b(), xl("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function y() {
    b(), xl("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let E = !1;
  function b() {
    if (document.readyState === "loading") {
      E = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(g);
  }
  function _() {
    E && b();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", _, !1);
  function w(M, A) {
    let z = null;
    try {
      z = A(t);
    } catch (V) {
      if (Aa("Language definition for '{}' could not be registered.".replace("{}", M)), i)
        Aa(V);
      else
        throw V;
      z = o;
    }
    z.name || (z.name = M), e[M] = z, z.rawDefinition = A.bind(null, t), z.aliases && T(z.aliases, { languageName: M });
  }
  function S(M) {
    delete e[M];
    for (const A of Object.keys(n))
      n[A] === M && delete n[A];
  }
  function x() {
    return Object.keys(e);
  }
  function k(M) {
    return M = (M || "").toLowerCase(), e[M] || e[n[M]];
  }
  function T(M, { languageName: A }) {
    typeof M == "string" && (M = [M]), M.forEach((z) => {
      n[z.toLowerCase()] = A;
    });
  }
  function I(M) {
    const A = k(M);
    return A && !A.disableAutodetect;
  }
  function R(M) {
    M["before:highlightBlock"] && !M["before:highlightElement"] && (M["before:highlightElement"] = (A) => {
      M["before:highlightBlock"](
        Object.assign({ block: A.el }, A)
      );
    }), M["after:highlightBlock"] && !M["after:highlightElement"] && (M["after:highlightElement"] = (A) => {
      M["after:highlightBlock"](
        Object.assign({ block: A.el }, A)
      );
    });
  }
  function N(M) {
    R(M), r.push(M);
  }
  function $(M) {
    const A = r.indexOf(M);
    A !== -1 && r.splice(A, 1);
  }
  function B(M, A) {
    const z = M;
    r.forEach(function(V) {
      V[z] && V[z](A);
    });
  }
  function G(M) {
    return xl("10.7.0", "highlightBlock will be removed entirely in v12.0"), xl("10.7.0", "Please use highlightElement now."), g(M);
  }
  Object.assign(t, {
    highlight: u,
    highlightAuto: h,
    highlightAll: b,
    highlightElement: g,
    // TODO: Remove with v12 API
    highlightBlock: G,
    configure: m,
    initHighlighting: v,
    initHighlightingOnLoad: y,
    registerLanguage: w,
    unregisterLanguage: S,
    listLanguages: x,
    getLanguage: k,
    registerAliases: T,
    autoDetection: I,
    inherit: JC,
    addPlugin: N,
    removePlugin: $
  }), t.debugMode = function() {
    i = !1;
  }, t.safeMode = function() {
    i = !0;
  }, t.versionString = C7, t.regex = {
    concat: fl,
    lookahead: hI,
    either: tE,
    optional: U9,
    anyNumberOfTimes: H9
  };
  for (const M in Sh)
    typeof Sh[M] == "object" && uI(Sh[M]);
  return Object.assign(t, Sh), t;
}, Lc = EI({});
Lc.newInstance = () => EI({});
var M7 = Lc;
Lc.HighlightJS = Lc;
Lc.default = Lc;
var A7 = /* @__PURE__ */ P9(M7);
function SI(t, e = []) {
  return t.map((n) => {
    const r = [...e, ...n.properties ? n.properties.className : []];
    return n.children ? SI(n.children, r) : {
      text: n.value,
      classes: r
    };
  }).flat();
}
function QC(t) {
  return t.value || t.children || [];
}
function N7(t) {
  return !!A7.getLanguage(t);
}
function eT({ doc: t, name: e, lowlight: n, defaultLanguage: r }) {
  const i = [];
  return Ly(t, (s) => s.type.name === e).forEach((s) => {
    var o;
    let a = s.pos + 1;
    const l = s.node.attrs.language || r, c = n.listLanguages(), u = l && (c.includes(l) || N7(l) || !((o = n.registered) === null || o === void 0) && o.call(n, l)) ? QC(n.highlight(l, s.node.textContent)) : QC(n.highlightAuto(s.node.textContent));
    SI(u).forEach((d) => {
      const f = a + d.text.length;
      if (d.classes.length) {
        const h = xn.inline(a, f, {
          class: d.classes.join(" ")
        });
        i.push(h);
      }
      a = f;
    });
  }), Ht.create(t, i);
}
function R7(t) {
  return typeof t == "function";
}
function D7({ name: t, lowlight: e, defaultLanguage: n }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((i) => R7(e[i])))
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  const r = new ut({
    key: new ft("lowlight"),
    state: {
      init: (i, { doc: s }) => eT({
        doc: s,
        name: t,
        lowlight: e,
        defaultLanguage: n
      }),
      apply: (i, s, o, a) => {
        const l = o.selection.$head.parent.type.name, c = a.selection.$head.parent.type.name, u = Ly(o.doc, (f) => f.type.name === t), d = Ly(a.doc, (f) => f.type.name === t);
        return i.docChanged && ([l, c].includes(t) || d.length !== u.length || i.steps.some((f) => (
          // @ts-ignore
          f.from !== void 0 && f.to !== void 0 && u.some((h) => (
            // @ts-ignore
            h.pos >= f.from && h.pos + h.node.nodeSize <= f.to
          ))
        ))) ? eT({
          doc: i.doc,
          name: t,
          lowlight: e,
          defaultLanguage: n
        }) : s.map(i.mapping, i.doc);
      }
    },
    props: {
      decorations(i) {
        return r.getState(i);
      }
    }
  });
  return r;
}
const I7 = I9.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) === null || t === void 0 ? void 0 : t.call(this),
      lowlight: {}
    };
  },
  addProseMirrorPlugins() {
    var t;
    return [
      ...((t = this.parent) === null || t === void 0 ? void 0 : t.call(this)) || [],
      D7({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ];
  }
});
function xI(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function kI(t) {
  return t instanceof Map ? t.clear = t.delete = t.set = function() {
    throw new Error("map is read-only");
  } : t instanceof Set && (t.add = t.clear = t.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach((e) => {
    const n = t[e], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && kI(n);
  }), t;
}
let tT = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
};
function CI(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function vo(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in t)
    n[r] = t[r];
  return e.forEach(function(r) {
    for (const i in r)
      n[i] = r[i];
  }), /** @type {T} */
  n;
}
const P7 = "</span>", nT = (t) => !!t.scope, L7 = (t, { prefix: e }) => {
  if (t.startsWith("language:"))
    return t.replace("language:", "language-");
  if (t.includes(".")) {
    const n = t.split(".");
    return [
      `${e}${n.shift()}`,
      ...n.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${e}${t}`;
};
class $7 {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += CI(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!nT(e))
      return;
    const n = L7(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    nT(e) && (this.buffer += P7);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const rT = (t = {}) => {
  const e = { children: [] };
  return Object.assign(e, t), e;
};
class iE {
  constructor() {
    this.rootNode = rT(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const n = rT({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      iE._collapse(n);
    }));
  }
}
class B7 extends iE {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const r = e.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new $7(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function Yd(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function TI(t) {
  return hl("(?=", t, ")");
}
function F7(t) {
  return hl("(?:", t, ")*");
}
function z7(t) {
  return hl("(?:", t, ")?");
}
function hl(...t) {
  return t.map((n) => Yd(n)).join("");
}
function H7(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function sE(...t) {
  return "(" + (H7(t).capture ? "" : "?:") + t.map((r) => Yd(r)).join("|") + ")";
}
function OI(t) {
  return new RegExp(t.toString() + "|").exec("").length - 1;
}
function U7(t, e) {
  const n = t && t.exec(e);
  return n && n.index === 0;
}
const V7 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function oE(t, { joinWith: e }) {
  let n = 0;
  return t.map((r) => {
    n += 1;
    const i = n;
    let s = Yd(r), o = "";
    for (; s.length > 0; ) {
      const a = V7.exec(s);
      if (!a) {
        o += s;
        break;
      }
      o += s.substring(0, a.index), s = s.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? o += "\\" + String(Number(a[1]) + i) : (o += a[0], a[0] === "(" && n++);
    }
    return o;
  }).map((r) => `(${r})`).join(e);
}
const W7 = /\b\B/, MI = "[a-zA-Z]\\w*", aE = "[a-zA-Z_]\\w*", AI = "\\b\\d+(\\.\\d+)?", NI = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", RI = "\\b(0b[01]+)", G7 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", j7 = (t = {}) => {
  const e = /^#![ ]*\//;
  return t.binary && (t.begin = hl(
    e,
    /.*\b/,
    t.binary,
    /\b.*/
  )), vo({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, t);
}, Xd = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, q7 = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Xd]
}, K7 = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Xd]
}, Y7 = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, qv = function(t, e, n = {}) {
  const r = vo(
    {
      scope: "comment",
      begin: t,
      end: e,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = sE(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: hl(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, X7 = qv("//", "$"), J7 = qv("/\\*", "\\*/"), Z7 = qv("#", "$"), Q7 = {
  scope: "number",
  begin: AI,
  relevance: 0
}, eK = {
  scope: "number",
  begin: NI,
  relevance: 0
}, tK = {
  scope: "number",
  begin: RI,
  relevance: 0
}, nK = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      Xd,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [Xd]
      }
    ]
  }]
}, rK = {
  scope: "title",
  begin: MI,
  relevance: 0
}, iK = {
  scope: "title",
  begin: aE,
  relevance: 0
}, sK = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + aE,
  relevance: 0
}, oK = function(t) {
  return Object.assign(
    t,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, n) => {
        n.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch();
      }
    }
  );
};
var xh = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE: W7,
  IDENT_RE: MI,
  UNDERSCORE_IDENT_RE: aE,
  NUMBER_RE: AI,
  C_NUMBER_RE: NI,
  BINARY_NUMBER_RE: RI,
  RE_STARTERS_RE: G7,
  SHEBANG: j7,
  BACKSLASH_ESCAPE: Xd,
  APOS_STRING_MODE: q7,
  QUOTE_STRING_MODE: K7,
  PHRASAL_WORDS_MODE: Y7,
  COMMENT: qv,
  C_LINE_COMMENT_MODE: X7,
  C_BLOCK_COMMENT_MODE: J7,
  HASH_COMMENT_MODE: Z7,
  NUMBER_MODE: Q7,
  C_NUMBER_MODE: eK,
  BINARY_NUMBER_MODE: tK,
  REGEXP_MODE: nK,
  TITLE_MODE: rK,
  UNDERSCORE_TITLE_MODE: iK,
  METHOD_GUARD: sK,
  END_SAME_AS_BEGIN: oK
});
function aK(t, e) {
  t.input[t.index - 1] === "." && e.ignoreMatch();
}
function lK(t, e) {
  t.className !== void 0 && (t.scope = t.className, delete t.className);
}
function cK(t, e) {
  e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = aK, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0));
}
function uK(t, e) {
  Array.isArray(t.illegal) && (t.illegal = sE(...t.illegal));
}
function dK(t, e) {
  if (t.match) {
    if (t.begin || t.end)
      throw new Error("begin & end are not supported with match");
    t.begin = t.match, delete t.match;
  }
}
function fK(t, e) {
  t.relevance === void 0 && (t.relevance = 1);
}
const hK = (t, e) => {
  if (!t.beforeMatch)
    return;
  if (t.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t);
  Object.keys(t).forEach((r) => {
    delete t[r];
  }), t.keywords = n.keywords, t.begin = hl(n.beforeMatch, TI(n.begin)), t.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, t.relevance = 0, delete n.beforeMatch;
}, pK = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], gK = "keyword";
function DI(t, e, n = gK) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof t == "string" ? i(n, t.split(" ")) : Array.isArray(t) ? i(n, t) : Object.keys(t).forEach(function(s) {
    Object.assign(
      r,
      DI(t[s], e, s)
    );
  }), r;
  function i(s, o) {
    e && (o = o.map((a) => a.toLowerCase())), o.forEach(function(a) {
      const l = a.split("|");
      r[l[0]] = [s, mK(l[0], l[1])];
    });
  }
}
function mK(t, e) {
  return e ? Number(e) : vK(t) ? 0 : 1;
}
function vK(t) {
  return pK.includes(t.toLowerCase());
}
const iT = {}, Na = (t) => {
  console.error(t);
}, sT = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e);
}, kl = (t, e) => {
  iT[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), iT[`${t}/${e}`] = !0);
}, Mg = new Error();
function II(t, e, { key: n }) {
  let r = 0;
  const i = t[n], s = {}, o = {};
  for (let a = 1; a <= e.length; a++)
    o[a + r] = i[a], s[a + r] = !0, r += OI(e[a - 1]);
  t[n] = o, t[n]._emit = s, t[n]._multi = !0;
}
function bK(t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin)
      throw Na("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Mg;
    if (typeof t.beginScope != "object" || t.beginScope === null)
      throw Na("beginScope must be object"), Mg;
    II(t, t.begin, { key: "beginScope" }), t.begin = oE(t.begin, { joinWith: "" });
  }
}
function yK(t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd)
      throw Na("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Mg;
    if (typeof t.endScope != "object" || t.endScope === null)
      throw Na("endScope must be object"), Mg;
    II(t, t.end, { key: "endScope" }), t.end = oE(t.end, { joinWith: "" });
  }
}
function wK(t) {
  t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
}
function _K(t) {
  wK(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), bK(t), yK(t);
}
function EK(t) {
  function e(o, a) {
    return new RegExp(
      Yd(o),
      "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += OI(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = e(oE(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const c = l.findIndex((d, f) => f > 0 && d !== void 0), u = this.matchIndexes[c];
      return l.splice(0, c), Object.assign(l, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a])
        return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([c, u]) => l.addRule(c, u)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let c = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, c = u.exec(a);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function i(o) {
    const a = new r();
    return o.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && a.addRule(o.terminatorEnd, { type: "end" }), o.illegal && a.addRule(o.illegal, { type: "illegal" }), a;
  }
  function s(o, a) {
    const l = (
      /** @type CompiledMode */
      o
    );
    if (o.isCompiled)
      return l;
    [
      lK,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      dK,
      _K,
      hK
    ].forEach((u) => u(o, a)), t.compilerExtensions.forEach((u) => u(o, a)), o.__beforeBegin = null, [
      cK,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      uK,
      // default to 1 relevance if not specified
      fK
    ].forEach((u) => u(o, a)), o.isCompiled = !0;
    let c = null;
    return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), c = o.keywords.$pattern, delete o.keywords.$pattern), c = c || /\w+/, o.keywords && (o.keywords = DI(o.keywords, t.case_insensitive)), l.keywordPatternRe = e(c, !0), a && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = Yd(l.end) || "", o.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + a.terminatorEnd)), o.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      o.illegal
    )), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function(u) {
      return SK(u === "self" ? o : u);
    })), o.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        l
      );
    }), o.starts && s(o.starts, a), l.matcher = i(l), l;
  }
  if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t.classNameAliases = vo(t.classNameAliases || {}), s(
    /** @type Mode */
    t
  );
}
function PI(t) {
  return t ? t.endsWithParent || PI(t.starts) : !1;
}
function SK(t) {
  return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function(e) {
    return vo(t, { variants: null }, e);
  })), t.cachedVariants ? t.cachedVariants : PI(t) ? vo(t, { starts: t.starts ? vo(t.starts) : null }) : Object.isFrozen(t) ? vo(t) : t;
}
var xK = "11.8.0";
class kK extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
}
const hb = CI, oT = vo, aT = Symbol("nomatch"), CK = 7, LI = function(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: B7
  };
  function l(M) {
    return a.noHighlightRe.test(M);
  }
  function c(M) {
    let A = M.className + " ";
    A += M.parentNode ? M.parentNode.className : "";
    const z = a.languageDetectRe.exec(A);
    if (z) {
      const V = k(z[1]);
      return V || (sT(s.replace("{}", z[1])), sT("Falling back to no-highlight mode for this block.", M)), V ? z[1] : "no-highlight";
    }
    return A.split(/\s+/).find((V) => l(V) || k(V));
  }
  function u(M, A, z) {
    let V = "", U = "";
    typeof A == "object" ? (V = M, z = A.ignoreIllegals, U = A.language) : (kl("10.7.0", "highlight(lang, code, ...args) has been deprecated."), kl("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), U = M, V = A), z === void 0 && (z = !0);
    const Y = {
      code: V,
      language: U
    };
    B("before:highlight", Y);
    const ne = Y.result ? Y.result : d(Y.language, Y.code, z);
    return ne.code = Y.code, B("after:highlight", ne), ne;
  }
  function d(M, A, z, V) {
    const U = /* @__PURE__ */ Object.create(null);
    function Y(H, K) {
      return H.keywords[K];
    }
    function ne() {
      if (!O.keywords) {
        ee.addText(ce);
        return;
      }
      let H = 0;
      O.keywordPatternRe.lastIndex = 0;
      let K = O.keywordPatternRe.exec(ce), de = "";
      for (; K; ) {
        de += ce.substring(H, K.index);
        const Oe = _e.case_insensitive ? K[0].toLowerCase() : K[0], Xe = Y(O, Oe);
        if (Xe) {
          const [pt, hi] = Xe;
          if (ee.addText(de), de = "", U[Oe] = (U[Oe] || 0) + 1, U[Oe] <= CK && (Pe += hi), pt.startsWith("_"))
            de += K[0];
          else {
            const D = _e.classNameAliases[pt] || pt;
            Q(K[0], D);
          }
        } else
          de += K[0];
        H = O.keywordPatternRe.lastIndex, K = O.keywordPatternRe.exec(ce);
      }
      de += ce.substring(H), ee.addText(de);
    }
    function ie() {
      if (ce === "")
        return;
      let H = null;
      if (typeof O.subLanguage == "string") {
        if (!e[O.subLanguage]) {
          ee.addText(ce);
          return;
        }
        H = d(O.subLanguage, ce, !0, q[O.subLanguage]), q[O.subLanguage] = /** @type {CompiledMode} */
        H._top;
      } else
        H = h(ce, O.subLanguage.length ? O.subLanguage : null);
      O.relevance > 0 && (Pe += H.relevance), ee.__addSublanguage(H._emitter, H.language);
    }
    function Z() {
      O.subLanguage != null ? ie() : ne(), ce = "";
    }
    function Q(H, K) {
      H !== "" && (ee.startScope(K), ee.addText(H), ee.endScope());
    }
    function fe(H, K) {
      let de = 1;
      const Oe = K.length - 1;
      for (; de <= Oe; ) {
        if (!H._emit[de]) {
          de++;
          continue;
        }
        const Xe = _e.classNameAliases[H[de]] || H[de], pt = K[de];
        Xe ? Q(pt, Xe) : (ce = pt, ne(), ce = ""), de++;
      }
    }
    function ge(H, K) {
      return H.scope && typeof H.scope == "string" && ee.openNode(_e.classNameAliases[H.scope] || H.scope), H.beginScope && (H.beginScope._wrap ? (Q(ce, _e.classNameAliases[H.beginScope._wrap] || H.beginScope._wrap), ce = "") : H.beginScope._multi && (fe(H.beginScope, K), ce = "")), O = Object.create(H, { parent: { value: O } }), O;
    }
    function Re(H, K, de) {
      let Oe = U7(H.endRe, de);
      if (Oe) {
        if (H["on:end"]) {
          const Xe = new tT(H);
          H["on:end"](K, Xe), Xe.isMatchIgnored && (Oe = !1);
        }
        if (Oe) {
          for (; H.endsParent && H.parent; )
            H = H.parent;
          return H;
        }
      }
      if (H.endsWithParent)
        return Re(H.parent, K, de);
    }
    function Be(H) {
      return O.matcher.regexIndex === 0 ? (ce += H[0], 1) : (re = !0, 0);
    }
    function le(H) {
      const K = H[0], de = H.rule, Oe = new tT(de), Xe = [de.__beforeBegin, de["on:begin"]];
      for (const pt of Xe)
        if (pt && (pt(H, Oe), Oe.isMatchIgnored))
          return Be(K);
      return de.skip ? ce += K : (de.excludeBegin && (ce += K), Z(), !de.returnBegin && !de.excludeBegin && (ce = K)), ge(de, H), de.returnBegin ? 0 : K.length;
    }
    function Ee(H) {
      const K = H[0], de = A.substring(H.index), Oe = Re(O, H, de);
      if (!Oe)
        return aT;
      const Xe = O;
      O.endScope && O.endScope._wrap ? (Z(), Q(K, O.endScope._wrap)) : O.endScope && O.endScope._multi ? (Z(), fe(O.endScope, H)) : Xe.skip ? ce += K : (Xe.returnEnd || Xe.excludeEnd || (ce += K), Z(), Xe.excludeEnd && (ce = K));
      do
        O.scope && ee.closeNode(), !O.skip && !O.subLanguage && (Pe += O.relevance), O = O.parent;
      while (O !== Oe.parent);
      return Oe.starts && ge(Oe.starts, H), Xe.returnEnd ? 0 : K.length;
    }
    function Se() {
      const H = [];
      for (let K = O; K !== _e; K = K.parent)
        K.scope && H.unshift(K.scope);
      H.forEach((K) => ee.openNode(K));
    }
    let xe = {};
    function Ce(H, K) {
      const de = K && K[0];
      if (ce += H, de == null)
        return Z(), 0;
      if (xe.type === "begin" && K.type === "end" && xe.index === K.index && de === "") {
        if (ce += A.slice(K.index, K.index + 1), !i) {
          const Oe = new Error(`0 width match regex (${M})`);
          throw Oe.languageName = M, Oe.badRule = xe.rule, Oe;
        }
        return 1;
      }
      if (xe = K, K.type === "begin")
        return le(K);
      if (K.type === "illegal" && !z) {
        const Oe = new Error('Illegal lexeme "' + de + '" for mode "' + (O.scope || "<unnamed>") + '"');
        throw Oe.mode = O, Oe;
      } else if (K.type === "end") {
        const Oe = Ee(K);
        if (Oe !== aT)
          return Oe;
      }
      if (K.type === "illegal" && de === "")
        return 1;
      if (j > 1e5 && j > K.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return ce += de, de.length;
    }
    const _e = k(M);
    if (!_e)
      throw Na(s.replace("{}", M)), new Error('Unknown language: "' + M + '"');
    const Je = EK(_e);
    let P = "", O = V || Je;
    const q = {}, ee = new a.__emitter(a);
    Se();
    let ce = "", Pe = 0, ye = 0, j = 0, re = !1;
    try {
      if (_e.__emitTokens)
        _e.__emitTokens(A, ee);
      else {
        for (O.matcher.considerAll(); ; ) {
          j++, re ? re = !1 : O.matcher.considerAll(), O.matcher.lastIndex = ye;
          const H = O.matcher.exec(A);
          if (!H)
            break;
          const K = A.substring(ye, H.index), de = Ce(K, H);
          ye = H.index + de;
        }
        Ce(A.substring(ye));
      }
      return ee.finalize(), P = ee.toHTML(), {
        language: M,
        value: P,
        relevance: Pe,
        illegal: !1,
        _emitter: ee,
        _top: O
      };
    } catch (H) {
      if (H.message && H.message.includes("Illegal"))
        return {
          language: M,
          value: hb(A),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: H.message,
            index: ye,
            context: A.slice(ye - 100, ye + 100),
            mode: H.mode,
            resultSoFar: P
          },
          _emitter: ee
        };
      if (i)
        return {
          language: M,
          value: hb(A),
          illegal: !1,
          relevance: 0,
          errorRaised: H,
          _emitter: ee,
          _top: O
        };
      throw H;
    }
  }
  function f(M) {
    const A = {
      value: hb(M),
      illegal: !1,
      relevance: 0,
      _top: o,
      _emitter: new a.__emitter(a)
    };
    return A._emitter.addText(M), A;
  }
  function h(M, A) {
    A = A || a.languages || Object.keys(e);
    const z = f(M), V = A.filter(k).filter(I).map(
      (Z) => d(Z, M, !1)
    );
    V.unshift(z);
    const U = V.sort((Z, Q) => {
      if (Z.relevance !== Q.relevance)
        return Q.relevance - Z.relevance;
      if (Z.language && Q.language) {
        if (k(Z.language).supersetOf === Q.language)
          return 1;
        if (k(Q.language).supersetOf === Z.language)
          return -1;
      }
      return 0;
    }), [Y, ne] = U, ie = Y;
    return ie.secondBest = ne, ie;
  }
  function p(M, A, z) {
    const V = A && n[A] || z;
    M.classList.add("hljs"), M.classList.add(`language-${V}`);
  }
  function g(M) {
    let A = null;
    const z = c(M);
    if (l(z))
      return;
    if (B(
      "before:highlightElement",
      { el: M, language: z }
    ), M.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(M)), a.throwUnescapedHTML))
      throw new kK(
        "One of your code blocks includes unescaped HTML.",
        M.innerHTML
      );
    A = M;
    const V = A.textContent, U = z ? u(V, { language: z, ignoreIllegals: !0 }) : h(V);
    M.innerHTML = U.value, p(M, z, U.language), M.result = {
      language: U.language,
      // TODO: remove with version 11.0
      re: U.relevance,
      relevance: U.relevance
    }, U.secondBest && (M.secondBest = {
      language: U.secondBest.language,
      relevance: U.secondBest.relevance
    }), B("after:highlightElement", { el: M, result: U, text: V });
  }
  function m(M) {
    a = oT(a, M);
  }
  const v = () => {
    b(), kl("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function y() {
    b(), kl("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let E = !1;
  function b() {
    if (document.readyState === "loading") {
      E = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(g);
  }
  function _() {
    E && b();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", _, !1);
  function w(M, A) {
    let z = null;
    try {
      z = A(t);
    } catch (V) {
      if (Na("Language definition for '{}' could not be registered.".replace("{}", M)), i)
        Na(V);
      else
        throw V;
      z = o;
    }
    z.name || (z.name = M), e[M] = z, z.rawDefinition = A.bind(null, t), z.aliases && T(z.aliases, { languageName: M });
  }
  function S(M) {
    delete e[M];
    for (const A of Object.keys(n))
      n[A] === M && delete n[A];
  }
  function x() {
    return Object.keys(e);
  }
  function k(M) {
    return M = (M || "").toLowerCase(), e[M] || e[n[M]];
  }
  function T(M, { languageName: A }) {
    typeof M == "string" && (M = [M]), M.forEach((z) => {
      n[z.toLowerCase()] = A;
    });
  }
  function I(M) {
    const A = k(M);
    return A && !A.disableAutodetect;
  }
  function R(M) {
    M["before:highlightBlock"] && !M["before:highlightElement"] && (M["before:highlightElement"] = (A) => {
      M["before:highlightBlock"](
        Object.assign({ block: A.el }, A)
      );
    }), M["after:highlightBlock"] && !M["after:highlightElement"] && (M["after:highlightElement"] = (A) => {
      M["after:highlightBlock"](
        Object.assign({ block: A.el }, A)
      );
    });
  }
  function N(M) {
    R(M), r.push(M);
  }
  function $(M) {
    const A = r.indexOf(M);
    A !== -1 && r.splice(A, 1);
  }
  function B(M, A) {
    const z = M;
    r.forEach(function(V) {
      V[z] && V[z](A);
    });
  }
  function G(M) {
    return kl("10.7.0", "highlightBlock will be removed entirely in v12.0"), kl("10.7.0", "Please use highlightElement now."), g(M);
  }
  Object.assign(t, {
    highlight: u,
    highlightAuto: h,
    highlightAll: b,
    highlightElement: g,
    // TODO: Remove with v12 API
    highlightBlock: G,
    configure: m,
    initHighlighting: v,
    initHighlightingOnLoad: y,
    registerLanguage: w,
    unregisterLanguage: S,
    listLanguages: x,
    getLanguage: k,
    registerAliases: T,
    autoDetection: I,
    inherit: oT,
    addPlugin: N,
    removePlugin: $
  }), t.debugMode = function() {
    i = !1;
  }, t.safeMode = function() {
    i = !0;
  }, t.versionString = xK, t.regex = {
    concat: hl,
    lookahead: TI,
    either: sE,
    optional: z7,
    anyNumberOfTimes: F7
  };
  for (const M in xh)
    typeof xh[M] == "object" && kI(xh[M]);
  return Object.assign(t, xh), t;
}, $c = LI({});
$c.newInstance = () => LI({});
var TK = $c;
$c.HighlightJS = $c;
$c.default = $c;
const Ei = /* @__PURE__ */ xI(TK);
var $I = { exports: {} };
(function(t) {
  (function() {
    var e;
    e = t.exports = i, e.format = i, e.vsprintf = r, typeof console < "u" && typeof console.log == "function" && (e.printf = n);
    function n() {
      console.log(i.apply(null, arguments));
    }
    function r(s, o) {
      return i.apply(null, [s].concat(o));
    }
    function i(s) {
      for (var o = 1, a = [].slice.call(arguments), l = 0, c = s.length, u = "", d, f = !1, h, p, g = !1, m, v = function() {
        return a[o++];
      }, y = function() {
        for (var E = ""; /\d/.test(s[l]); )
          E += s[l++], d = s[l];
        return E.length > 0 ? parseInt(E) : null;
      }; l < c; ++l)
        if (d = s[l], f)
          switch (f = !1, d == "." ? (g = !1, d = s[++l]) : d == "0" && s[l + 1] == "." ? (g = !0, l += 2, d = s[l]) : g = !0, m = y(), d) {
            case "b":
              u += parseInt(v(), 10).toString(2);
              break;
            case "c":
              h = v(), typeof h == "string" || h instanceof String ? u += h : u += String.fromCharCode(parseInt(h, 10));
              break;
            case "d":
              u += parseInt(v(), 10);
              break;
            case "f":
              p = String(parseFloat(v()).toFixed(m || 6)), u += g ? p : p.replace(/^0/, "");
              break;
            case "j":
              u += JSON.stringify(v());
              break;
            case "o":
              u += "0" + parseInt(v(), 10).toString(8);
              break;
            case "s":
              u += v();
              break;
            case "x":
              u += "0x" + parseInt(v(), 10).toString(16);
              break;
            case "X":
              u += "0x" + parseInt(v(), 10).toString(16).toUpperCase();
              break;
            default:
              u += d;
              break;
          }
        else
          d === "%" ? f = !0 : u += d;
      return u;
    }
  })();
})($I);
var OK = $I.exports;
const MK = /* @__PURE__ */ xI(OK), xp = Object.assign(Xo(Error), {
  eval: Xo(EvalError),
  range: Xo(RangeError),
  reference: Xo(ReferenceError),
  syntax: Xo(SyntaxError),
  type: Xo(TypeError),
  uri: Xo(URIError)
});
function Xo(t) {
  return e.displayName = t.displayName || t.name, e;
  function e(n, ...r) {
    const i = n && MK(n, ...r);
    return new t(i);
  }
}
const AK = {}.hasOwnProperty, NK = "hljs-";
function BI(t, e, n = {}) {
  let r = n.prefix;
  if (typeof t != "string")
    throw xp("Expected `string` for name, got `%s`", t);
  if (!Ei.getLanguage(t))
    throw xp("Unknown language: `%s` is not registered", t);
  if (typeof e != "string")
    throw xp("Expected `string` for value, got `%s`", e);
  r == null && (r = NK), Ei.configure({ __emitter: $K, classPrefix: r });
  const i = (
    /** @type {HighlightResult & {_emitter: HastEmitter}} */
    Ei.highlight(e, { language: t, ignoreIllegals: !0 })
  );
  if (Ei.configure({}), i.errorRaised)
    throw i.errorRaised;
  return i._emitter.root.data.language = i.language, i._emitter.root.data.relevance = i.relevance, i._emitter.root;
}
function RK(t, e = {}) {
  const n = e.subset || Ei.listLanguages();
  e.prefix;
  let r = -1, i = {
    type: "root",
    data: { language: null, relevance: 0 },
    children: []
  };
  if (typeof t != "string")
    throw xp("Expected `string` for value, got `%s`", t);
  for (; ++r < n.length; ) {
    const s = n[r];
    if (!Ei.getLanguage(s))
      continue;
    const o = BI(s, t, e);
    o.data.relevance > i.data.relevance && (i = o);
  }
  return i;
}
function DK(t, e) {
  Ei.registerLanguage(t, e);
}
const IK = (
  /**
   * @type {(
   *   ((language: string, alias: string|Array<string>) => void) &
   *   ((aliases: Record<string, string|Array<string>>) => void)
   * )}
   */
  /**
   * @param {string|Record<string, string|Array<string>>} language
   * @param {string|Array<string>} [alias]
   * @returns {void}
   */
  function(t, e) {
    if (typeof t == "string")
      Ei.registerAliases(e, { languageName: t });
    else {
      let n;
      for (n in t)
        AK.call(t, n) && Ei.registerAliases(t[n], { languageName: n });
    }
  }
);
function PK(t) {
  return !!Ei.getLanguage(t);
}
function LK() {
  return Ei.listLanguages();
}
class $K {
  /**
   * @param {HighlightOptions} options
   */
  constructor(e) {
    this.options = e, this.root = {
      type: "root",
      data: { language: null, relevance: 0 },
      children: []
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   */
  addText(e) {
    if (e === "")
      return;
    const n = this.stack[this.stack.length - 1], r = n.children[n.children.length - 1];
    r && r.type === "text" ? r.value += e : n.children.push({ type: "text", value: e });
  }
  /**
   *
   * @param {unknown} rawName
   */
  startScope(e) {
    this.openNode(String(e));
  }
  /**
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const r = this.stack[this.stack.length - 1], i = e.root.children;
    n ? r.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [n] },
      children: i
    }) : r.children.push(...i);
  }
  /**
   * @param {string} name
   */
  openNode(e) {
    const n = e.split(".").map((s, o) => o ? s + "_".repeat(o) : this.options.classPrefix + s), r = this.stack[this.stack.length - 1], i = {
      type: "element",
      tagName: "span",
      properties: { className: n },
      children: []
    };
    r.children.push(i), this.stack.push(i);
  }
  /**
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   */
  finalize() {
  }
  /**
   */
  toHTML() {
    return "";
  }
}
const At = {
  highlight: BI,
  highlightAuto: RK,
  registerLanguage: DK,
  registered: PK,
  listLanguages: LK,
  registerAlias: IK
};
function BK(t) {
  const e = t.regex, n = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [n]
      }
      // default values
    ]
  };
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const i = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [t.BACKSLASH_ESCAPE]
  }, s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      t.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, o = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      n,
      i
    ]
  };
  i.contains.push(o);
  const a = {
    match: /\\"/
  }, l = {
    className: "string",
    begin: /'/,
    end: /'/
  }, c = {
    match: /\\'/
  }, u = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      t.NUMBER_MODE,
      n
    ]
  }, d = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], f = t.SHEBANG({
    binary: `(${d.join("|")})`,
    relevance: 10
  }), h = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [t.inherit(t.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, p = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], g = [
    "true",
    "false"
  ], m = { match: /(\/[a-z._-]+)+/ }, v = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], y = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], E = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], b = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: p,
      literal: g,
      built_in: [
        ...v,
        ...y,
        // Shell modifiers
        "set",
        "shopt",
        ...E,
        ...b
      ]
    },
    contains: [
      f,
      // to catch known shells and boost relevancy
      t.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h,
      u,
      t.HASH_COMMENT_MODE,
      s,
      m,
      o,
      a,
      l,
      c,
      n
    ]
  };
}
function FK(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "<[^<>]+>", o = "(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional(s) + ")", a = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, l = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)", c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + l + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(i) + t.IDENT_RE,
    relevance: 0
  }, h = e.optional(i) + t.IDENT_RE + "\\s*\\(", m = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal128",
      // modifiers
      "const",
      "static",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, v = [
    d,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], y = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: m,
    contains: v.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: m,
        contains: v.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, E = {
    begin: "(" + o + "[\\*&\\s]+)+" + h,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: m,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: m,
        relevance: 0
      },
      {
        begin: h,
        returnBegin: !0,
        contains: [t.inherit(f, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: m,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          u,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: m,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              u,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: m,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      y,
      E,
      v,
      [
        d,
        {
          begin: t.IDENT_RE + "::",
          keywords: m
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            t.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: d,
      strings: c,
      keywords: m
    }
  };
}
const zK = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), HK = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], UK = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], VK = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], WK = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], GK = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function jK(t) {
  const e = t.regex, n = zK(t), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", s = /@-?\w[\w]*(-\w+)*/, o = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      n.BLOCK_COMMENT,
      r,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      n.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + o,
        relevance: 0
      },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + VK.join("|") + ")" },
          { begin: ":(:)?(" + WK.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      n.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + GK.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...a,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...a,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: e.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: s
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: UK.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...a,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + HK.join("|") + ")\\b"
      }
    ]
  };
}
function qK(t) {
  const e = t.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: e.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: e.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function KK(t) {
  const s = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: s,
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            begin: t.C_NUMBER_RE + "[i]",
            relevance: 1
          },
          t.C_NUMBER_MODE
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          t.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: s,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function YK(t) {
  const e = t.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      t.HASH_COMMENT_MODE,
      t.QUOTE_STRING_MODE,
      t.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: e.concat(n, e.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function XK(t) {
  const e = t.regex, n = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: t.NUMBER_RE }
    ]
  }, r = t.COMMENT();
  r.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const i = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, s = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, o = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, a = {
    begin: /\[/,
    end: /\]/,
    contains: [
      r,
      s,
      i,
      o,
      n,
      "self"
    ],
    relevance: 0
  }, l = /[A-Za-z0-9_-]+/, c = /"(\\"|[^"])*"/, u = /'[^']*'/, d = e.either(
    l,
    c,
    u
  ), f = e.concat(
    d,
    "(\\s*\\.\\s*",
    d,
    ")*",
    e.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: f,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            r,
            a,
            s,
            i,
            o,
            n
          ]
        }
      }
    ]
  };
}
var Bl = "[0-9](_*[0-9])*", kh = `\\.(${Bl})`, Ch = "[0-9a-fA-F](_*[0-9a-fA-F])*", lT = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${Bl})((${kh})|\\.)?|(${kh}))[eE][+-]?(${Bl})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${Bl})((${kh})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${kh})[fFdD]?\\b` },
    { begin: `\\b(${Bl})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Ch})\\.?|(${Ch})?\\.(${Ch}))[pP][+-]?(${Bl})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Ch})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function FI(t, e, n) {
  return n === -1 ? "" : t.replace(e, (r) => FI(t, e, n - 1));
}
function JK(t) {
  const e = t.regex, n = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*", r = n + FI("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, c = {
    className: "meta",
    begin: "@" + n,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, u = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: l,
    relevance: 0,
    contains: [t.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [t.BACKSLASH_ESCAPE]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          e.concat(/(?!else)/, n),
          /\s+/,
          n,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          u,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + r + "\\s+)",
          t.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              c,
              t.APOS_STRING_MODE,
              t.QUOTE_STRING_MODE,
              lT,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      lT,
      c
    ]
  };
}
const cT = "[A-Za-z$_][0-9A-Za-z$_]*", ZK = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], QK = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], zI = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], HI = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], UI = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], eY = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], tY = [].concat(
  UI,
  zI,
  HI
);
function nY(t) {
  const e = t.regex, n = (A, { after: z }) => {
    const V = "</" + A[0].slice(1);
    return A.input.indexOf(V, z) !== -1;
  }, r = cT, i = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (A, z) => {
      const V = A[0].length + A.index, U = A.input[V];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        z.ignoreMatch();
        return;
      }
      U === ">" && (n(A, { after: V }) || z.ignoreMatch());
      let Y;
      const ne = A.input.substring(V);
      if (Y = ne.match(/^\s*=/)) {
        z.ignoreMatch();
        return;
      }
      if ((Y = ne.match(/^\s+extends\s+/)) && Y.index === 0) {
        z.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: cT,
    keyword: ZK,
    literal: QK,
    built_in: tY,
    "variable.language": eY
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, p = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, m = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      f
    ]
  }, y = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, E = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    h,
    p,
    g,
    m,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = E.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(E)
  });
  const b = [].concat(y, f.contains), _ = b.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(b)
    }
  ]), w = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: _
  }, S = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, x = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...zI,
        ...HI
      ]
    }
  }, k = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, T = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [w],
    illegal: /%/
  }, I = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function R(A) {
    return e.concat("(?!", A.join("|"), ")");
  }
  const N = {
    match: e.concat(
      /\b/,
      R([
        ...UI,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, $ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, B = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      w
    ]
  }, G = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", M = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(G)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      w
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: _, CLASS_REFERENCE: x },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      k,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      h,
      p,
      g,
      m,
      y,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      x,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      M,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          y,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: G,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: _
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: s },
              {
                begin: o.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": o.isTrulyOpeningTag,
                end: o.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: o.begin,
                end: o.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      T,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          w,
          t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      $,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [w]
      },
      N,
      I,
      S,
      B,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function rY(t) {
  const e = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, n = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, r = [
    "true",
    "false",
    "null"
  ], i = {
    scope: "literal",
    beginKeywords: r.join(" ")
  };
  return {
    name: "JSON",
    keywords: {
      literal: r
    },
    contains: [
      e,
      n,
      t.QUOTE_STRING_MODE,
      i,
      t.C_NUMBER_MODE,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var Fl = "[0-9](_*[0-9])*", Th = `\\.(${Fl})`, Oh = "[0-9a-fA-F](_*[0-9a-fA-F])*", iY = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${Fl})((${Th})|\\.)?|(${Th}))[eE][+-]?(${Fl})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${Fl})((${Th})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Th})[fFdD]?\\b` },
    { begin: `\\b(${Fl})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Oh})\\.?|(${Oh})?\\.(${Oh}))[pP][+-]?(${Fl})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Oh})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function sY(t) {
  const e = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, n = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, r = {
    className: "symbol",
    begin: t.UNDERSCORE_IDENT_RE + "@"
  }, i = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [t.C_NUMBER_MODE]
  }, s = {
    className: "variable",
    begin: "\\$" + t.UNDERSCORE_IDENT_RE
  }, o = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          s,
          i
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          t.BACKSLASH_ESCAPE,
          s,
          i
        ]
      }
    ]
  };
  i.contains.push(o);
  const a = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + t.UNDERSCORE_IDENT_RE + ")?"
  }, l = {
    className: "meta",
    begin: "@" + t.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          t.inherit(o, { className: "string" }),
          "self"
        ]
      }
    ]
  }, c = iY, u = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [t.C_BLOCK_COMMENT_MODE] }
  ), d = { variants: [
    {
      className: "type",
      begin: t.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, f = d;
  return f.variants[1].contains = [d], d.variants[1].contains = [f], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: e,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      t.C_LINE_COMMENT_MODE,
      u,
      n,
      r,
      a,
      l,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: e,
        relevance: 5,
        contains: [
          {
            begin: t.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [t.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: e,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  d,
                  t.C_LINE_COMMENT_MODE,
                  u
                ],
                relevance: 0
              },
              t.C_LINE_COMMENT_MODE,
              u,
              a,
              l,
              o,
              t.C_NUMBER_MODE
            ]
          },
          u
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          t.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          a,
          l
        ]
      },
      o,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      c
    ]
  };
}
const oY = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), aY = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], lY = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], VI = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], WI = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], cY = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse(), uY = VI.concat(WI);
function dY(t) {
  const e = oY(t), n = uY, r = "and or not only", i = "[\\w-]+", s = "(" + i + "|@\\{" + i + "\\})", o = [], a = [], l = function(E) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + E + ".*?" + E
    };
  }, c = function(E, b, _) {
    return {
      className: E,
      begin: b,
      relevance: _
    };
  }, u = {
    $pattern: /[a-z-]+/,
    keyword: r,
    attribute: lY.join(" ")
  }, d = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: a,
    keywords: u,
    relevance: 0
  };
  a.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    e.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    e.HEXCOLOR,
    d,
    c("variable", "@@?" + i, 10),
    c("variable", "@\\{" + i + "\\}"),
    c("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: i + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    e.IMPORTANT,
    { beginKeywords: "and not" },
    e.FUNCTION_DISPATCH
  );
  const f = a.concat({
    begin: /\{/,
    end: /\}/,
    contains: o
  }), h = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(a)
    // using this form to override VALUE’s 'function' match
  }, p = {
    begin: s + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + cY.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: a
        }
      }
    ]
  }, g = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: u,
      returnEnd: !0,
      contains: a,
      relevance: 0
    }
  }, m = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (we’ll still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + i + "\\s*:",
        relevance: 15
      },
      { begin: "@" + i }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: f
    }
  }, v = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: s,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      h,
      c("keyword", "all\\b"),
      c("variable", "@\\{" + i + "\\}"),
      // otherwise it’s identified as tag
      {
        begin: "\\b(" + aY.join("|") + ")\\b",
        className: "selector-tag"
      },
      e.CSS_NUMBER_MODE,
      c("selector-tag", s, 0),
      c("selector-id", "#" + s),
      c("selector-class", "\\." + s, 0),
      c("selector-tag", "&", 0),
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + VI.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + WI.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: f
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      e.FUNCTION_DISPATCH
    ]
  }, y = {
    begin: i + `:(:)?(${n.join("|")})`,
    returnBegin: !0,
    contains: [v]
  };
  return o.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    g,
    m,
    y,
    p,
    v,
    h,
    e.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: o
  };
}
function fY(t) {
  const e = "\\[=*\\[", n = "\\]=*\\]", r = {
    begin: e,
    end: n,
    contains: ["self"]
  }, i = [
    t.COMMENT("--(?!" + e + ")", "$"),
    t.COMMENT(
      "--" + e,
      n,
      {
        contains: [r],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    keywords: {
      $pattern: t.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: i.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          t.inherit(t.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: i
          }
        ].concat(i)
      },
      t.C_NUMBER_MODE,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: e,
        end: n,
        contains: [r],
        relevance: 5
      }
    ])
  };
}
function hY(t) {
  const e = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + t.UNDERSCORE_IDENT_RE + "\\)",
        contains: [t.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, n = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      e
    ]
  }, r = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [e]
  }, i = { begin: "^" + t.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, s = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, o = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [e]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      t.HASH_COMMENT_MODE,
      e,
      n,
      r,
      i,
      s,
      o
    ]
  };
}
function pY(t) {
  const e = t.regex, n = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, r = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, i = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, s = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, o = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, c = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, u = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, d = t.inherit(c, { contains: [] }), f = t.inherit(u, { contains: [] });
  c.contains.push(f), u.contains.push(d);
  let h = [
    n,
    l
  ];
  return [
    c,
    u,
    d,
    f
  ].forEach((m) => {
    m.contains = m.contains.concat(h);
  }), h = h.concat(c, u), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: h
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: h
              }
            ]
          }
        ]
      },
      n,
      s,
      c,
      u,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: h,
        end: "$"
      },
      i,
      r,
      l,
      o
    ]
  };
}
function gY(t) {
  const e = t.regex, n = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], r = /[dualxmsipngr]{0,12}/, i = {
    $pattern: /[\w.]+/,
    keyword: n.join(" ")
  }, s = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: i
  }, o = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, a = { variants: [
    { begin: /\$\d/ },
    { begin: e.concat(
      /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
      // negative look-ahead tries to avoid matching patterns that are not
      // Perl at all like $ident$, @ident@, etc.
      "(?![A-Za-z])(?![@$%])"
    ) },
    {
      begin: /[$%@][^\s\w{]/,
      relevance: 0
    }
  ] }, l = [
    t.BACKSLASH_ESCAPE,
    s,
    a
  ], c = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], u = (h, p, g = "\\1") => {
    const m = g === "\\1" ? g : e.concat(g, p);
    return e.concat(
      e.concat("(?:", h, ")"),
      p,
      /(?:\\.|[^\\\/])*?/,
      m,
      /(?:\\.|[^\\\/])*?/,
      g,
      r
    );
  }, d = (h, p, g) => e.concat(
    e.concat("(?:", h, ")"),
    p,
    /(?:\\.|[^\\\/])*?/,
    g,
    r
  ), f = [
    a,
    t.HASH_COMMENT_MODE,
    t.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    o,
    {
      className: "string",
      contains: l,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    {
      className: "number",
      begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",
      relevance: 0
    },
    {
      // regexp container
      begin: "(\\/\\/|" + t.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        t.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: u("s|tr|y", e.either(...c, { capture: !0 })) },
            // and then paired delmis
            { begin: u("s|tr|y", "\\(", "\\)") },
            { begin: u("s|tr|y", "\\[", "\\]") },
            { begin: u("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: d("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: d("m|qr", e.either(...c, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: d("m|qr", /\(/, /\)/) },
            { begin: d("m|qr", /\[/, /\]/) },
            { begin: d("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [t.TITLE_MODE]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return s.contains = f, o.contains = f, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: i,
    contains: f
  };
}
function mY(t) {
  const e = t.regex, n = /(?![A-Za-z0-9])(?![$])/, r = e.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    n
  ), i = e.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  ), s = {
    scope: "variable",
    match: "\\$+" + r
  }, o = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, a = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, l = t.inherit(t.APOS_STRING_MODE, { illegal: null }), c = t.inherit(t.QUOTE_STRING_MODE, {
    illegal: null,
    contains: t.QUOTE_STRING_MODE.contains.concat(a)
  }), u = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: t.QUOTE_STRING_MODE.contains.concat(a),
    "on:begin": (N, $) => {
      $.data._beginMatch = N[1] || N[2];
    },
    "on:end": (N, $) => {
      $.data._beginMatch !== N[1] && $.ignoreMatch();
    }
  }, d = t.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), f = `[ 	
]`, h = {
    scope: "string",
    variants: [
      c,
      l,
      u,
      d
    ]
  }, p = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, g = [
    "false",
    "null",
    "true"
  ], m = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], v = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], E = {
    keyword: m,
    literal: ((N) => {
      const $ = [];
      return N.forEach((B) => {
        $.push(B), B.toLowerCase() === B ? $.push(B.toUpperCase()) : $.push(B.toLowerCase());
      }), $;
    })(g),
    built_in: v
  }, b = (N) => N.map(($) => $.replace(/\|\d+$/, "")), _ = { variants: [
    {
      match: [
        /new/,
        e.concat(f, "+"),
        // to prevent built ins from being confused as the class constructor call
        e.concat("(?!", b(v).join("\\b|"), "\\b)"),
        i
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, w = e.concat(r, "\\b(?!\\()"), S = { variants: [
    {
      match: [
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        w
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        i,
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        w
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        i,
        e.concat(
          "::",
          e.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        i,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, x = {
    scope: "attr",
    match: e.concat(r, e.lookahead(":"), e.lookahead(/(?!::)/))
  }, k = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: E,
    contains: [
      x,
      s,
      S,
      t.C_BLOCK_COMMENT_MODE,
      h,
      p,
      _
    ]
  }, T = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      e.concat("(?!fn\\b|function\\b|", b(m).join("\\b|"), "|", b(v).join("\\b|"), "\\b)"),
      r,
      e.concat(f, "*"),
      e.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [k]
  };
  k.contains.push(T);
  const I = [
    x,
    S,
    t.C_BLOCK_COMMENT_MODE,
    h,
    p,
    _
  ], R = {
    begin: e.concat(/#\[\s*/, i),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: g,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: g,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...I
        ]
      },
      ...I,
      {
        scope: "meta",
        match: i
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: E,
    contains: [
      R,
      t.HASH_COMMENT_MODE,
      t.COMMENT("//", "$"),
      t.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: t.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      o,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      s,
      T,
      S,
      {
        match: [
          /const/,
          /\s/,
          r
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      _,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          t.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: E,
            contains: [
              "self",
              s,
              S,
              t.C_BLOCK_COMMENT_MODE,
              h,
              p
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [t.inherit(t.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      h,
      p
    ]
  };
}
function vY(t) {
  const e = t.regex, n = /[\p{XID_Start}_]\p{XID_Continue}*/u, r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], a = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, l = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, c = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: a,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          t.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          t.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", h = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, p = `\\b|${r.join("|")}`, g = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${h}))[eE][+-]?(${f})[jJ]?(?=${p})`
      },
      {
        begin: `(${h})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${p})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${p})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${p})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${p})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${p})`
      }
    ]
  }, m = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: a,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, v = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: a,
        contains: [
          "self",
          l,
          g,
          d,
          t.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return c.contains = [
    d,
    g,
    l
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: a,
    illegal: /(<\/|\?)|=>/,
    contains: [
      l,
      g,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      d,
      m,
      t.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          n
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [v]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              n,
              /\s*/,
              /\(\s*/,
              n,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              n
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          g,
          v,
          d
        ]
      }
    ]
  };
}
function bY(t) {
  const e = t.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = e.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), i = e.concat(r, /(::\w+)*/), o = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, a = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, l = {
    begin: "#<",
    end: ">"
  }, c = [
    t.COMMENT(
      "#",
      "$",
      { contains: [a] }
    ),
    t.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [a],
        relevance: 10
      }
    ),
    t.COMMENT("^__END__", t.MATCH_NOTHING_RE)
  ], u = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: o
  }, d = {
    className: "string",
    contains: [
      t.BACKSLASH_ESCAPE,
      u
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: e.concat(
          /<<[-~]?'?/,
          e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          t.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              t.BACKSLASH_ESCAPE,
              u
            ]
          })
        ]
      }
    ]
  }, f = "[1-9](_?[0-9])*|0", h = "[0-9](_?[0-9])*", p = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${f})(\\.(${h}))?([eE][+-]?(${h})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, g = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: o
      }
    ]
  }, w = [
    d,
    {
      variants: [
        {
          match: [
            /class\s+/,
            i,
            /\s+<\s+/,
            i
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            i
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: o
    },
    {
      match: [
        /(include|extend)\s+/,
        i
      ],
      scope: {
        2: "title.class"
      },
      keywords: o
    },
    {
      relevance: 0,
      match: [
        i,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: r,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        n
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        g
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: t.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: t.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        d,
        { begin: n }
      ],
      relevance: 0
    },
    p,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: o
    },
    {
      // regexp container
      begin: "(" + t.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            t.BACKSLASH_ESCAPE,
            u
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(l, c),
      relevance: 0
    }
  ].concat(l, c);
  u.contains = w, g.contains = w;
  const S = "[>?]>", x = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]", k = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>", T = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: w
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + S + "|" + x + "|" + k + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: o,
        contains: w
      }
    }
  ];
  return c.unshift(l), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: o,
    illegal: /\/\*/,
    contains: [t.SHEBANG({ binary: "ruby" })].concat(T).concat(c).concat(w)
  };
}
function yY(t) {
  const e = t.regex, n = {
    className: "title.function.invoke",
    relevance: 0,
    begin: e.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      t.IDENT_RE,
      e.lookahead(/\s*\(/)
    )
  }, r = "([ui](8|16|32|64|128|size)|f(32|64))?", i = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], s = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], o = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], a = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: t.IDENT_RE + "!?",
      type: a,
      keyword: i,
      literal: s,
      built_in: o
    },
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      t.inherit(t.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }
        ]
      },
      {
        className: "symbol",
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + r },
          { begin: "\\b0o([0-7_]+)" + r },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + r },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + r }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: t.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: o,
          type: a
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      n
    ]
  };
}
const wY = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), _Y = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], EY = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], SY = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], xY = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], kY = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function CY(t) {
  const e = wY(t), n = xY, r = SY, i = "@[a-z-]+", s = "and or not only", a = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      e.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + _Y.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + r.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + n.join("|") + ")"
      },
      a,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [e.CSS_NUMBER_MODE]
      },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + kY.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          e.BLOCK_COMMENT,
          a,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.IMPORTANT,
          e.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: i,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: s,
          attribute: EY.join(" ")
        },
        contains: [
          {
            begin: i,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          a,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE
        ]
      },
      e.FUNCTION_DISPATCH
    ]
  };
}
function TY(t) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function OY(t) {
  const e = t.regex, n = t.COMMENT("--", "$"), r = {
    className: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ begin: /''/ }]
      }
    ]
  }, i = {
    begin: /"/,
    end: /"/,
    contains: [{ begin: /""/ }]
  }, s = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], o = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], a = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], l = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], c = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], u = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], d = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], f = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], h = u, p = [
    ...c,
    ...l
  ].filter((E) => !u.includes(E)), g = {
    className: "variable",
    begin: /@[a-z0-9][a-z0-9_]*/
  }, m = {
    className: "operator",
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, v = {
    begin: e.concat(/\b/, e.either(...h), /\s*\(/),
    relevance: 0,
    keywords: { built_in: h }
  };
  function y(E, {
    exceptions: b,
    when: _
  } = {}) {
    const w = _;
    return b = b || [], E.map((S) => S.match(/\|\d+$/) || b.includes(S) ? S : w(S) ? `${S}|0` : S);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: y(p, { when: (E) => E.length < 3 }),
      literal: s,
      type: a,
      built_in: d
    },
    contains: [
      {
        begin: e.either(...f),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: p.concat(f),
          literal: s,
          type: a
        }
      },
      {
        className: "type",
        begin: e.either(...o)
      },
      v,
      g,
      r,
      i,
      t.C_NUMBER_MODE,
      t.C_BLOCK_COMMENT_MODE,
      n,
      m
    ]
  };
}
function GI(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function Mh(t) {
  return Tt("(?=", t, ")");
}
function Tt(...t) {
  return t.map((n) => GI(n)).join("");
}
function MY(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function sr(...t) {
  return "(" + (MY(t).capture ? "" : "?:") + t.map((r) => GI(r)).join("|") + ")";
}
const lE = (t) => Tt(
  /\b/,
  t,
  /\w$/.test(t) ? /\b/ : /\B/
), AY = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(lE), uT = [
  "init",
  "self"
].map(lE), NY = [
  "Any",
  "Self"
], pb = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], dT = [
  "false",
  "nil",
  "true"
], RY = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], DY = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], fT = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], jI = sr(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), qI = sr(
  jI,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), gb = Tt(jI, qI, "*"), KI = sr(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), Ag = sr(
  KI,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), xs = Tt(KI, Ag, "*"), mb = Tt(/[A-Z]/, Ag, "*"), IY = [
  "attached",
  "autoclosure",
  Tt(/convention\(/, sr("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  Tt(/objc\(/, xs, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], PY = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function LY(t) {
  const e = {
    match: /\s+/,
    relevance: 0
  }, n = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), r = [
    t.C_LINE_COMMENT_MODE,
    n
  ], i = {
    match: [
      /\./,
      sr(...AY, ...uT)
    ],
    className: { 2: "keyword" }
  }, s = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: Tt(/\./, sr(...pb)),
    relevance: 0
  }, o = pb.filter((Se) => typeof Se == "string").concat(["_|0"]), a = pb.filter((Se) => typeof Se != "string").concat(NY).map(lE), l = { variants: [
    {
      className: "keyword",
      match: sr(...a, ...uT)
    }
  ] }, c = {
    $pattern: sr(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: o.concat(DY),
    literal: dT
  }, u = [
    i,
    s,
    l
  ], d = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: Tt(/\./, sr(...fT)),
    relevance: 0
  }, f = {
    className: "built_in",
    match: Tt(/\b/, sr(...fT), /(?=\()/)
  }, h = [
    d,
    f
  ], p = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, g = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: gb },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${qI})+`
      }
    ]
  }, m = [
    p,
    g
  ], v = "([0-9]_*)+", y = "([0-9a-fA-F]_*)+", E = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${v})(\\.(${v}))?([eE][+-]?(${v}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${y})(\\.(${y}))?([pP][+-]?(${v}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, b = (Se = "") => ({
    className: "subst",
    variants: [
      { match: Tt(/\\/, Se, /[0\\tnr"']/) },
      { match: Tt(/\\/, Se, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), _ = (Se = "") => ({
    className: "subst",
    match: Tt(/\\/, Se, /[\t ]*(?:[\r\n]|\r\n)/)
  }), w = (Se = "") => ({
    className: "subst",
    label: "interpol",
    begin: Tt(/\\/, Se, /\(/),
    end: /\)/
  }), S = (Se = "") => ({
    begin: Tt(Se, /"""/),
    end: Tt(/"""/, Se),
    contains: [
      b(Se),
      _(Se),
      w(Se)
    ]
  }), x = (Se = "") => ({
    begin: Tt(Se, /"/),
    end: Tt(/"/, Se),
    contains: [
      b(Se),
      w(Se)
    ]
  }), k = {
    className: "string",
    variants: [
      S(),
      S("#"),
      S("##"),
      S("###"),
      x(),
      x("#"),
      x("##"),
      x("###")
    ]
  }, T = [
    t.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [t.BACKSLASH_ESCAPE]
    }
  ], I = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: T
  }, R = (Se) => {
    const xe = Tt(Se, /\//), Ce = Tt(/\//, Se);
    return {
      begin: xe,
      end: Ce,
      contains: [
        ...T,
        {
          scope: "comment",
          begin: `#(?!.*${Ce})`,
          end: /$/
        }
      ]
    };
  }, N = {
    scope: "regexp",
    variants: [
      R("###"),
      R("##"),
      R("#"),
      I
    ]
  }, $ = { match: Tt(/`/, xs, /`/) }, B = {
    className: "variable",
    match: /\$\d+/
  }, G = {
    className: "variable",
    match: `\\$${Ag}+`
  }, M = [
    $,
    B,
    G
  ], A = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: PY,
        contains: [
          ...m,
          E,
          k
        ]
      }
    ] }
  }, z = {
    scope: "keyword",
    match: Tt(/@/, sr(...IY))
  }, V = {
    scope: "meta",
    match: Tt(/@/, xs)
  }, U = [
    A,
    z,
    V
  ], Y = {
    match: Mh(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: Tt(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Ag, "+")
      },
      {
        // Type identifier
        className: "type",
        match: mb,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: Tt(/\s+&\s+/, Mh(mb)),
        relevance: 0
      }
    ]
  }, ne = {
    begin: /</,
    end: />/,
    keywords: c,
    contains: [
      ...r,
      ...u,
      ...U,
      p,
      Y
    ]
  };
  Y.contains.push(ne);
  const ie = {
    match: Tt(xs, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, Z = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: c,
    contains: [
      "self",
      ie,
      ...r,
      N,
      ...u,
      ...h,
      ...m,
      E,
      k,
      ...M,
      ...U,
      Y
    ]
  }, Q = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...r,
      Y
    ]
  }, fe = {
    begin: sr(
      Mh(Tt(xs, /\s*:/)),
      Mh(Tt(xs, /\s+/, xs, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: xs
      }
    ]
  }, ge = {
    begin: /\(/,
    end: /\)/,
    keywords: c,
    contains: [
      fe,
      ...r,
      ...u,
      ...m,
      E,
      k,
      ...U,
      Y,
      Z
    ],
    endsParent: !0,
    illegal: /["']/
  }, Re = {
    match: [
      /(func|macro)/,
      /\s+/,
      sr($.match, xs, gb)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      Q,
      ge,
      e
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, Be = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      Q,
      ge,
      e
    ],
    illegal: /\[|%/
  }, le = {
    match: [
      /operator/,
      /\s+/,
      gb
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, Ee = {
    begin: [
      /precedencegroup/,
      /\s+/,
      mb
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [Y],
    keywords: [
      ...RY,
      ...dT
    ],
    end: /}/
  };
  for (const Se of k.variants) {
    const xe = Se.contains.find((_e) => _e.label === "interpol");
    xe.keywords = c;
    const Ce = [
      ...u,
      ...h,
      ...m,
      E,
      k,
      ...M
    ];
    xe.contains = [
      ...Ce,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...Ce
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: c,
    contains: [
      ...r,
      Re,
      Be,
      {
        beginKeywords: "struct protocol class extension enum actor",
        end: "\\{",
        excludeEnd: !0,
        keywords: c,
        contains: [
          t.inherit(t.TITLE_MODE, {
            className: "title.class",
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }),
          ...u
        ]
      },
      le,
      Ee,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      N,
      ...u,
      ...h,
      ...m,
      E,
      k,
      ...M,
      ...U,
      Y,
      Z
    ]
  };
}
const Ng = "[A-Za-z$_][0-9A-Za-z$_]*", YI = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], XI = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], JI = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], ZI = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], QI = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], e2 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], t2 = [].concat(
  QI,
  JI,
  ZI
);
function $Y(t) {
  const e = t.regex, n = (A, { after: z }) => {
    const V = "</" + A[0].slice(1);
    return A.input.indexOf(V, z) !== -1;
  }, r = Ng, i = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (A, z) => {
      const V = A[0].length + A.index, U = A.input[V];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        z.ignoreMatch();
        return;
      }
      U === ">" && (n(A, { after: V }) || z.ignoreMatch());
      let Y;
      const ne = A.input.substring(V);
      if (Y = ne.match(/^\s*=/)) {
        z.ignoreMatch();
        return;
      }
      if ((Y = ne.match(/^\s+extends\s+/)) && Y.index === 0) {
        z.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: Ng,
    keyword: YI,
    literal: XI,
    built_in: t2,
    "variable.language": e2
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, p = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, m = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      f
    ]
  }, y = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, E = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    h,
    p,
    g,
    m,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = E.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(E)
  });
  const b = [].concat(y, f.contains), _ = b.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(b)
    }
  ]), w = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: _
  }, S = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, x = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...JI,
        ...ZI
      ]
    }
  }, k = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, T = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [w],
    illegal: /%/
  }, I = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function R(A) {
    return e.concat("(?!", A.join("|"), ")");
  }
  const N = {
    match: e.concat(
      /\b/,
      R([
        ...QI,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, $ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, B = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      w
    ]
  }, G = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", M = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(G)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      w
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: _, CLASS_REFERENCE: x },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      k,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      h,
      p,
      g,
      m,
      y,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      x,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      M,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          y,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: G,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: _
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: s },
              {
                begin: o.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": o.isTrulyOpeningTag,
                end: o.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: o.begin,
                end: o.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      T,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          w,
          t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      $,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [w]
      },
      N,
      I,
      S,
      B,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function BY(t) {
  const e = $Y(t), n = Ng, r = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], i = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: !0,
    contains: [e.exports.CLASS_REFERENCE]
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: r
    },
    contains: [e.exports.CLASS_REFERENCE]
  }, o = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, a = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], l = {
    $pattern: Ng,
    keyword: YI.concat(a),
    literal: XI,
    built_in: t2.concat(r),
    "variable.language": e2
  }, c = {
    className: "meta",
    begin: "@" + n
  }, u = (f, h, p) => {
    const g = f.contains.findIndex((m) => m.label === h);
    if (g === -1)
      throw new Error("can not find mode to replace");
    f.contains.splice(g, 1, p);
  };
  Object.assign(e.keywords, l), e.exports.PARAMS_CONTAINS.push(c), e.contains = e.contains.concat([
    c,
    i,
    s
  ]), u(e, "shebang", t.SHEBANG()), u(e, "use_strict", o);
  const d = e.contains.find((f) => f.label === "func.def");
  return d.relevance = 0, Object.assign(e, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), e;
}
function FY(t) {
  const e = t.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, o = t.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), a = t.inherit(t.APOS_STRING_MODE, { className: "string" }), l = t.inherit(t.QUOTE_STRING_MODE, { className: "string" }), c = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [i]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [i]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          l,
          a,
          o,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  o,
                  l,
                  a
                ]
              }
            ]
          }
        ]
      },
      t.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      i,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: c
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function zY(t) {
  const e = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
    className: "attr",
    variants: [
      { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
      {
        // double quoted keys
        begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
      },
      {
        // single quoted keys
        begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
      }
    ]
  }, i = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, s = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      t.BACKSLASH_ESCAPE,
      i
    ]
  }, o = t.inherit(s, { variants: [
    {
      begin: /'/,
      end: /'/
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), a = "[0-9]{4}(-[0-9][0-9]){0,2}", l = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?", c = "(\\.[0-9]*)?", u = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?", d = {
    className: "number",
    begin: "\\b" + a + l + c + u + "\\b"
  }, f = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: e,
    relevance: 0
  }, h = {
    begin: /\{/,
    end: /\}/,
    contains: [f],
    illegal: "\\n",
    relevance: 0
  }, p = {
    begin: "\\[",
    end: "\\]",
    contains: [f],
    illegal: "\\n",
    relevance: 0
  }, g = [
    r,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + n
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + n + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + n
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + n
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    t.HASH_COMMENT_MODE,
    {
      beginKeywords: e,
      keywords: { literal: e }
    },
    d,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: t.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    h,
    p,
    s
  ], m = [...g];
  return m.pop(), m.push(o), f.contains = m, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: g
  };
}
const wr = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, HY = {
  __name: "MathView",
  props: A_,
  setup(t) {
    const e = t, n = X(null);
    function r() {
      e.node.attrs.tex !== void 0 && yA.render(e.node.attrs.tex, n.value, {
        throwOnError: !1
      });
    }
    return Bt(
      () => e.node.attrs.tex,
      () => {
        r();
      }
    ), Zt(() => {
      r();
    }), (i, s) => (J(), Ze(C(M_), { class: "math-block" }, {
      default: Ue(() => [
        se("p", {
          ref_key: "box",
          ref: n,
          class: It({ "math-selected": e.selected })
        }, null, 2)
      ]),
      _: 1
    }));
  }
}, n2 = /* @__PURE__ */ wr(HY, [["__scopeId", "data-v-72dc3c01"]]);
At.registerLanguage("bash", BK);
At.registerLanguage("c", FK);
At.registerLanguage("css", jK);
At.registerLanguage("diff", qK);
At.registerLanguage("go", KK);
At.registerLanguage("graphql", YK);
At.registerLanguage("ini", XK);
At.registerLanguage("java", JK);
At.registerLanguage("javascript", nY);
At.registerLanguage("json", rY);
At.registerLanguage("kotlin", sY);
At.registerLanguage("less", dY);
At.registerLanguage("lua", fY);
At.registerLanguage("makefile", hY);
At.registerLanguage("markdown", pY);
At.registerLanguage("perl", gY);
At.registerLanguage("php", mY);
At.registerLanguage("python", vY);
At.registerLanguage("ruby", bY);
At.registerLanguage("rust", yY);
At.registerLanguage("scss", CY);
At.registerLanguage("shell", TY);
At.registerLanguage("sql", OY);
At.registerLanguage("swift", LY);
At.registerLanguage("typescript", BY);
At.registerLanguage("xml", FY);
At.registerLanguage("yaml", zY);
function UY(t) {
  return t || (t = { lowlight: At }), I7.extend({
    addNodeView() {
      return Lv(n2);
    }
  }).configure(t);
}
const VY = { key: 0 }, WY = /* @__PURE__ */ ae({
  __name: "CodeBlock",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(UY(e.options)), (r, i) => C(n) ? (J(), be("div", VY, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleCodeBlock().run(),
          icon: C(RD),
          "is-active": () => C(n).isActive("hb-code"),
          title: C(me)("codeBlock")
        }, null, 8, ["action", "icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
}), r2 = mr.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = v_(t, this.type);
        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), i2 = Et.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), GY = {
  gray: [
    {
      scale: 50,
      hex: "#f9fafb",
      rgb: "rgb(249,250,251)",
      hsl: "hsl(210,20%,98%)"
    },
    {
      scale: 100,
      hex: "#f3f4f6",
      rgb: "rgb(243,244,246)",
      hsl: "hsl(220,14.3%,95.9%)"
    },
    {
      scale: 200,
      hex: "#e5e7eb",
      rgb: "rgb(229,231,235)",
      hsl: "hsl(220,13%,91%)"
    },
    {
      scale: 300,
      hex: "#d1d5db",
      rgb: "rgb(209,213,219)",
      hsl: "hsl(216,12.2%,83.9%)"
    },
    {
      scale: 400,
      hex: "#9ca3af",
      rgb: "rgb(156,163,175)",
      hsl: "hsl(217.9,10.6%,64.9%)"
    },
    {
      scale: 500,
      hex: "#6b7280",
      rgb: "rgb(107,114,128)",
      hsl: "hsl(220,8.9%,46.1%)"
    },
    {
      scale: 600,
      hex: "#4b5563",
      rgb: "rgb(75,85,99)",
      hsl: "hsl(215,13.8%,34.1%)"
    },
    {
      scale: 700,
      hex: "#374151",
      rgb: "rgb(55,65,81)",
      hsl: "hsl(216.9,19.1%,26.7%)"
    },
    {
      scale: 800,
      hex: "#1f2937",
      rgb: "rgb(31,41,55)",
      hsl: "hsl(215,27.9%,16.9%)"
    },
    {
      scale: 900,
      hex: "#111827",
      rgb: "rgb(17,24,39)",
      hsl: "hsl(220.9,39.3%,11%)"
    },
    {
      scale: 950,
      hex: "#030712",
      rgb: "rgb(3,7,18)",
      hsl: "hsl(224,71.4%,4.1%)"
    }
  ],
  red: [
    {
      scale: 50,
      hex: "#fef2f2",
      rgb: "rgb(254,242,242)",
      hsl: "hsl(0,85.7%,97.3%)"
    },
    {
      scale: 100,
      hex: "#fee2e2",
      rgb: "rgb(254,226,226)",
      hsl: "hsl(0,93.3%,94.1%)"
    },
    {
      scale: 200,
      hex: "#fecaca",
      rgb: "rgb(254,202,202)",
      hsl: "hsl(0,96.3%,89.4%)"
    },
    {
      scale: 300,
      hex: "#fca5a5",
      rgb: "rgb(252,165,165)",
      hsl: "hsl(0,93.5%,81.8%)"
    },
    {
      scale: 400,
      hex: "#f87171",
      rgb: "rgb(248,113,113)",
      hsl: "hsl(0,90.6%,70.8%)"
    },
    {
      scale: 500,
      hex: "#ef4444",
      rgb: "rgb(239,68,68)",
      hsl: "hsl(0,84.2%,60.2%)"
    },
    {
      scale: 600,
      hex: "#dc2626",
      rgb: "rgb(220,38,38)",
      hsl: "hsl(0,72.2%,50.6%)"
    },
    {
      scale: 700,
      hex: "#b91c1c",
      rgb: "rgb(185,28,28)",
      hsl: "hsl(0,73.7%,41.8%)"
    },
    {
      scale: 800,
      hex: "#991b1b",
      rgb: "rgb(153,27,27)",
      hsl: "hsl(0,70%,35.3%)"
    },
    {
      scale: 900,
      hex: "#7f1d1d",
      rgb: "rgb(127,29,29)",
      hsl: "hsl(0,62.8%,30.6%)"
    },
    {
      scale: 950,
      hex: "#450a0a",
      rgb: "rgb(69,10,10)",
      hsl: "hsl(0,74.7%,15.5%)"
    }
  ],
  amber: [
    {
      scale: 50,
      hex: "#fffbeb",
      rgb: "rgb(255,251,235)",
      hsl: "hsl(48,100%,96.1%)"
    },
    {
      scale: 100,
      hex: "#fef3c7",
      rgb: "rgb(254,243,199)",
      hsl: "hsl(48,96.5%,88.8%)"
    },
    {
      scale: 200,
      hex: "#fde68a",
      rgb: "rgb(253,230,138)",
      hsl: "hsl(48,96.6%,76.7%)"
    },
    {
      scale: 300,
      hex: "#fcd34d",
      rgb: "rgb(252,211,77)",
      hsl: "hsl(45.9,96.7%,64.5%)"
    },
    {
      scale: 400,
      hex: "#fbbf24",
      rgb: "rgb(251,191,36)",
      hsl: "hsl(43.3,96.4%,56.3%)"
    },
    {
      scale: 500,
      hex: "#f59e0b",
      rgb: "rgb(245,158,11)",
      hsl: "hsl(37.7,92.1%,50.2%)"
    },
    {
      scale: 600,
      hex: "#d97706",
      rgb: "rgb(217,119,6)",
      hsl: "hsl(32.1,94.6%,43.7%)"
    },
    {
      scale: 700,
      hex: "#b45309",
      rgb: "rgb(180,83,9)",
      hsl: "hsl(26,90.5%,37.1%)"
    },
    {
      scale: 800,
      hex: "#92400e",
      rgb: "rgb(146,64,14)",
      hsl: "hsl(22.7,82.5%,31.4%)"
    },
    {
      scale: 900,
      hex: "#78350f",
      rgb: "rgb(120,53,15)",
      hsl: "hsl(21.7,77.8%,26.5%)"
    },
    {
      scale: 950,
      hex: "#451a03",
      rgb: "rgb(69,26,3)",
      hsl: "hsl(20.9,91.7%,14.1%)"
    }
  ],
  green: [
    {
      scale: 50,
      hex: "#f0fdf4",
      rgb: "rgb(240,253,244)",
      hsl: "hsl(138.5,76.5%,96.7%)"
    },
    {
      scale: 100,
      hex: "#dcfce7",
      rgb: "rgb(220,252,231)",
      hsl: "hsl(140.6,84.2%,92.5%)"
    },
    {
      scale: 200,
      hex: "#bbf7d0",
      rgb: "rgb(187,247,208)",
      hsl: "hsl(141,78.9%,85.1%)"
    },
    {
      scale: 300,
      hex: "#86efac",
      rgb: "rgb(134,239,172)",
      hsl: "hsl(141.7,76.6%,73.1%)"
    },
    {
      scale: 400,
      hex: "#4ade80",
      rgb: "rgb(74,222,128)",
      hsl: "hsl(141.9,69.2%,58%)"
    },
    {
      scale: 500,
      hex: "#22c55e",
      rgb: "rgb(34,197,94)",
      hsl: "hsl(142.1,70.6%,45.3%)"
    },
    {
      scale: 600,
      hex: "#16a34a",
      rgb: "rgb(22,163,74)",
      hsl: "hsl(142.1,76.2%,36.3%)"
    },
    {
      scale: 700,
      hex: "#15803d",
      rgb: "rgb(21,128,61)",
      hsl: "hsl(142.4,71.8%,29.2%)"
    },
    {
      scale: 800,
      hex: "#166534",
      rgb: "rgb(22,101,52)",
      hsl: "hsl(142.8,64.2%,24.1%)"
    },
    {
      scale: 900,
      hex: "#14532d",
      rgb: "rgb(20,83,45)",
      hsl: "hsl(143.8,61.2%,20.2%)"
    },
    {
      scale: 950,
      hex: "#052e16",
      rgb: "rgb(5,46,22)",
      hsl: "hsl(144.9,80.4%,10%)"
    }
  ],
  sky: [
    {
      scale: 50,
      hex: "#f0f9ff",
      rgb: "rgb(240,249,255)",
      hsl: "hsl(204,100%,97.1%)"
    },
    {
      scale: 100,
      hex: "#e0f2fe",
      rgb: "rgb(224,242,254)",
      hsl: "hsl(204,93.8%,93.7%)"
    },
    {
      scale: 200,
      hex: "#bae6fd",
      rgb: "rgb(186,230,253)",
      hsl: "hsl(200.6,94.4%,86.1%)"
    },
    {
      scale: 300,
      hex: "#7dd3fc",
      rgb: "rgb(125,211,252)",
      hsl: "hsl(199.4,95.5%,73.9%)"
    },
    {
      scale: 400,
      hex: "#38bdf8",
      rgb: "rgb(56,189,248)",
      hsl: "hsl(198.4,93.2%,59.6%)"
    },
    {
      scale: 500,
      hex: "#0ea5e9",
      rgb: "rgb(14,165,233)",
      hsl: "hsl(198.6,88.7%,48.4%)"
    },
    {
      scale: 600,
      hex: "#0284c7",
      rgb: "rgb(2,132,199)",
      hsl: "hsl(200.4,98%,39.4%)"
    },
    {
      scale: 700,
      hex: "#0369a1",
      rgb: "rgb(3,105,161)",
      hsl: "hsl(201.3,96.3%,32.2%)"
    },
    {
      scale: 800,
      hex: "#075985",
      rgb: "rgb(7,89,133)",
      hsl: "hsl(201,90%,27.5%)"
    },
    {
      scale: 900,
      hex: "#0c4a6e",
      rgb: "rgb(12,74,110)",
      hsl: "hsl(202,80.3%,23.9%)"
    },
    {
      scale: 950,
      hex: "#082f49",
      rgb: "rgb(8,47,73)",
      hsl: "hsl(204,80.2%,15.9%)"
    }
  ],
  indigo: [
    {
      scale: 50,
      hex: "#eef2ff",
      rgb: "rgb(238,242,255)",
      hsl: "hsl(225.9,100%,96.7%)"
    },
    {
      scale: 100,
      hex: "#e0e7ff",
      rgb: "rgb(224,231,255)",
      hsl: "hsl(226.5,100%,93.9%)"
    },
    {
      scale: 200,
      hex: "#c7d2fe",
      rgb: "rgb(199,210,254)",
      hsl: "hsl(228,96.5%,88.8%)"
    },
    {
      scale: 300,
      hex: "#a5b4fc",
      rgb: "rgb(165,180,252)",
      hsl: "hsl(229.7,93.5%,81.8%)"
    },
    {
      scale: 400,
      hex: "#818cf8",
      rgb: "rgb(129,140,248)",
      hsl: "hsl(234.5,89.5%,73.9%)"
    },
    {
      scale: 500,
      hex: "#6366f1",
      rgb: "rgb(99,102,241)",
      hsl: "hsl(238.7,83.5%,66.7%)"
    },
    {
      scale: 600,
      hex: "#4f46e5",
      rgb: "rgb(79,70,229)",
      hsl: "hsl(243.4,75.4%,58.6%)"
    },
    {
      scale: 700,
      hex: "#4338ca",
      rgb: "rgb(67,56,202)",
      hsl: "hsl(244.5,57.9%,50.6%)"
    },
    {
      scale: 800,
      hex: "#3730a3",
      rgb: "rgb(55,48,163)",
      hsl: "hsl(243.7,54.5%,41.4%)"
    },
    {
      scale: 900,
      hex: "#312e81",
      rgb: "rgb(49,46,129)",
      hsl: "hsl(242.2,47.4%,34.3%)"
    },
    {
      scale: 950,
      hex: "#1e1b4b",
      rgb: "rgb(30,27,75)",
      hsl: "hsl(243.8,47.1%,20%)"
    }
  ],
  purple: [
    {
      scale: 50,
      hex: "#faf5ff",
      rgb: "rgb(250,245,255)",
      hsl: "hsl(270,100%,98%)"
    },
    {
      scale: 100,
      hex: "#f3e8ff",
      rgb: "rgb(243,232,255)",
      hsl: "hsl(268.7,100%,95.5%)"
    },
    {
      scale: 200,
      hex: "#e9d5ff",
      rgb: "rgb(233,213,255)",
      hsl: "hsl(268.6,100%,91.8%)"
    },
    {
      scale: 300,
      hex: "#d8b4fe",
      rgb: "rgb(216,180,254)",
      hsl: "hsl(269.2,97.4%,85.1%)"
    },
    {
      scale: 400,
      hex: "#c084fc",
      rgb: "rgb(192,132,252)",
      hsl: "hsl(270,95.2%,75.3%)"
    },
    {
      scale: 500,
      hex: "#a855f7",
      rgb: "rgb(168,85,247)",
      hsl: "hsl(270.7,91%,65.1%)"
    },
    {
      scale: 600,
      hex: "#9333ea",
      rgb: "rgb(147,51,234)",
      hsl: "hsl(271.5,81.3%,55.9%)"
    },
    {
      scale: 700,
      hex: "#7e22ce",
      rgb: "rgb(126,34,206)",
      hsl: "hsl(272.1,71.7%,47.1%)"
    },
    {
      scale: 800,
      hex: "#6b21a8",
      rgb: "rgb(107,33,168)",
      hsl: "hsl(272.9,67.2%,39.4%)"
    },
    {
      scale: 900,
      hex: "#581c87",
      rgb: "rgb(88,28,135)",
      hsl: "hsl(273.6,65.6%,32%)"
    },
    {
      scale: 950,
      hex: "#3b0764",
      rgb: "rgb(59,7,100)",
      hsl: "hsl(273.5,86.9%,21%)"
    }
  ],
  pink: [
    {
      scale: 50,
      hex: "#fdf2f8",
      rgb: "rgb(253,242,248)",
      hsl: "hsl(327.3,73.3%,97.1%)"
    },
    {
      scale: 100,
      hex: "#fce7f3",
      rgb: "rgb(252,231,243)",
      hsl: "hsl(325.7,77.8%,94.7%)"
    },
    {
      scale: 200,
      hex: "#fbcfe8",
      rgb: "rgb(251,207,232)",
      hsl: "hsl(325.9,84.6%,89.8%)"
    },
    {
      scale: 300,
      hex: "#f9a8d4",
      rgb: "rgb(249,168,212)",
      hsl: "hsl(327.4,87.1%,81.8%)"
    },
    {
      scale: 400,
      hex: "#f472b6",
      rgb: "rgb(244,114,182)",
      hsl: "hsl(328.6,85.5%,70.2%)"
    },
    {
      scale: 500,
      hex: "#ec4899",
      rgb: "rgb(236,72,153)",
      hsl: "hsl(330.4,81.2%,60.4%)"
    },
    {
      scale: 600,
      hex: "#db2777",
      rgb: "rgb(219,39,119)",
      hsl: "hsl(333.3,71.4%,50.6%)"
    },
    {
      scale: 700,
      hex: "#be185d",
      rgb: "rgb(190,24,93)",
      hsl: "hsl(335.1,77.6%,42%)"
    },
    {
      scale: 800,
      hex: "#9d174d",
      rgb: "rgb(157,23,77)",
      hsl: "hsl(335.8,74.4%,35.3%)"
    },
    {
      scale: 900,
      hex: "#831843",
      rgb: "rgb(131,24,67)",
      hsl: "hsl(335.9,69%,30.4%)"
    },
    {
      scale: 950,
      hex: "#500724",
      rgb: "rgb(80,7,36)",
      hsl: "hsl(336.2,83.9%,17.1%)"
    }
  ]
}, jY = { class: "flex items-center w-full gap-1 flex-1 relative langeditor-border rounded-md" }, qY = ["placeholder"], cE = /* @__PURE__ */ ae({
  __name: "LangInput",
  props: {
    isSmall: {
      type: Boolean,
      require: !1,
      default: !1
    },
    loading: {
      type: Boolean,
      require: !1,
      default: !1
    },
    input: {
      type: String,
      require: !0,
      default: ""
    },
    placeholder: {
      type: String,
      require: !0,
      default: ""
    },
    icon: {
      type: Function,
      require: !1,
      default: void 0
    }
  },
  emits: ["ok"],
  setup(t, { emit: e }) {
    const n = t, r = e, i = X("");
    return Zt(() => {
      i.value = n.input;
    }), (s, o) => (J(), be("div", jY, [
      (J(), Ze(ii(t.icon), {
        class: It([t.icon === void 0 ? "" : "pr-8", "absolute left-3 w-3 h-3"])
      }, null, 8, ["class"])),
      Yr(se("input", {
        "onUpdate:modelValue": o[0] || (o[0] = (a) => i.value = a),
        class: It([t.isSmall ? "px-2 py-1" : "px-3 py-2", "flex w-full langeditor-text langeditor-bg rounded-md text-sm"]),
        placeholder: t.placeholder,
        onInput: o[1] || (o[1] = (a) => r("ok", i.value))
      }, null, 42, qY), [
        [vc, i.value]
      ])
    ]));
  }
}), KY = { class: "flex flex-col p-2 gap-2 w-full" }, YY = { class: "flex flex-wrap items-center justify-between gap-0.5" }, XY = ["onClick"], JY = { class: "flex items-center gap-3" }, ZY = /* @__PURE__ */ se("div", null, "HEXA", -1), s2 = /* @__PURE__ */ ae({
  __name: "LangColorPicker",
  props: {
    color: {
      type: String,
      default: "#000"
    },
    defaultColor: {
      type: String,
      default: "#000"
    }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = e;
    function r(i) {
      n("change", i);
    }
    return (i, s) => (J(), be("div", KY, [
      se("button", {
        class: "langeditor-border langeditor-hover rounded py-0.5",
        onClick: s[0] || (s[0] = (o) => r(t.defaultColor))
      }, " Default color "),
      (J(!0), be(Vt, null, $n(C(GY), (o, a) => (J(), be("div", { key: a }, [
        se("div", YY, [
          (J(!0), be(Vt, null, $n(o, (l) => (J(), be("div", {
            key: l.hex,
            class: It([t.color === l.hex ? "langeditor-border" : "", "cursor-pointer px-1 w-5 h-5"]),
            style: Rr({ background: l.hex }),
            onClick: (c) => r(l.hex)
          }, null, 14, XY))), 128))
        ])
      ]))), 128)),
      se("div", JY, [
        ZY,
        W(cE, {
          input: t.color,
          "is-small": !0,
          onOk: s[1] || (s[1] = (o) => r(o))
        }, null, 8, ["input"])
      ])
    ]));
  }
});
function QY(t) {
  typeof queueMicrotask == "function" ? queueMicrotask(t) : Promise.resolve().then(t).catch((e) => setTimeout(() => {
    throw e;
  }));
}
var hT;
let eX = Symbol("headlessui.useid"), tX = 0;
const ko = (hT = lx.useId) != null ? hT : function() {
  return lx.inject(eX, () => `${++tX}`)();
};
function Ie(t) {
  var e;
  if (t == null || t.value == null)
    return null;
  let n = (e = t.value.$el) != null ? e : t.value;
  return n instanceof Node ? n : null;
}
function Pr(t, e, ...n) {
  if (t in e) {
    let i = e[t];
    return typeof i == "function" ? i(...n) : i;
  }
  let r = new Error(`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map((i) => `"${i}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(r, Pr), r;
}
var nX = Object.defineProperty, rX = (t, e, n) => e in t ? nX(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, pT = (t, e, n) => (rX(t, typeof e != "symbol" ? e + "" : e, n), n);
let iX = class {
  constructor() {
    pT(this, "current", this.detect()), pT(this, "currentId", 0);
  }
  set(e) {
    this.current !== e && (this.currentId = 0, this.current = e);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}, Kv = new iX();
function Ks(t) {
  if (Kv.isServer)
    return null;
  if (t instanceof Node)
    return t.ownerDocument;
  if (t != null && t.hasOwnProperty("value")) {
    let e = Ie(t);
    if (e)
      return e.ownerDocument;
  }
  return document;
}
let u1 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((t) => `${t}:not([tabindex='-1'])`).join(",");
var cn = ((t) => (t[t.First = 1] = "First", t[t.Previous = 2] = "Previous", t[t.Next = 4] = "Next", t[t.Last = 8] = "Last", t[t.WrapAround = 16] = "WrapAround", t[t.NoScroll = 32] = "NoScroll", t))(cn || {}), bo = ((t) => (t[t.Error = 0] = "Error", t[t.Overflow = 1] = "Overflow", t[t.Success = 2] = "Success", t[t.Underflow = 3] = "Underflow", t))(bo || {}), sX = ((t) => (t[t.Previous = -1] = "Previous", t[t.Next = 1] = "Next", t))(sX || {});
function Yv(t = document.body) {
  return t == null ? [] : Array.from(t.querySelectorAll(u1)).sort((e, n) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (n.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var uE = ((t) => (t[t.Strict = 0] = "Strict", t[t.Loose = 1] = "Loose", t))(uE || {});
function o2(t, e = 0) {
  var n;
  return t === ((n = Ks(t)) == null ? void 0 : n.body) ? !1 : Pr(e, { 0() {
    return t.matches(u1);
  }, 1() {
    let r = t;
    for (; r !== null; ) {
      if (r.matches(u1))
        return !0;
      r = r.parentElement;
    }
    return !1;
  } });
}
var oX = ((t) => (t[t.Keyboard = 0] = "Keyboard", t[t.Mouse = 1] = "Mouse", t))(oX || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (t) => {
  t.metaKey || t.altKey || t.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (t) => {
  t.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : t.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
let aX = ["textarea", "input"].join(",");
function lX(t) {
  var e, n;
  return (n = (e = t == null ? void 0 : t.matches) == null ? void 0 : e.call(t, aX)) != null ? n : !1;
}
function zl(t, e = (n) => n) {
  return t.slice().sort((n, r) => {
    let i = e(n), s = e(r);
    if (i === null || s === null)
      return 0;
    let o = i.compareDocumentPosition(s);
    return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function Or(t, e, { sorted: n = !0, relativeTo: r = null, skipElements: i = [] } = {}) {
  var s;
  let o = (s = Array.isArray(t) ? t.length > 0 ? t[0].ownerDocument : document : t == null ? void 0 : t.ownerDocument) != null ? s : document, a = Array.isArray(t) ? n ? zl(t) : t : Yv(t);
  i.length > 0 && a.length > 1 && (a = a.filter((p) => !i.includes(p))), r = r ?? o.activeElement;
  let l = (() => {
    if (e & 5)
      return 1;
    if (e & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), c = (() => {
    if (e & 1)
      return 0;
    if (e & 2)
      return Math.max(0, a.indexOf(r)) - 1;
    if (e & 4)
      return Math.max(0, a.indexOf(r)) + 1;
    if (e & 8)
      return a.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), u = e & 32 ? { preventScroll: !0 } : {}, d = 0, f = a.length, h;
  do {
    if (d >= f || d + f <= 0)
      return 0;
    let p = c + d;
    if (e & 16)
      p = (p + f) % f;
    else {
      if (p < 0)
        return 3;
      if (p >= f)
        return 1;
    }
    h = a[p], h == null || h.focus(u), d += l;
  } while (h !== o.activeElement);
  return e & 6 && lX(h) && h.select(), 2;
}
function cX() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function uX() {
  return /Android/gi.test(window.navigator.userAgent);
}
function dX() {
  return cX() || uX();
}
function Ah(t, e, n) {
  Kv.isServer || ps((r) => {
    document.addEventListener(t, e, n), r(() => document.removeEventListener(t, e, n));
  });
}
function a2(t, e, n) {
  Kv.isServer || ps((r) => {
    window.addEventListener(t, e, n), r(() => window.removeEventListener(t, e, n));
  });
}
function fX(t, e, n = rt(() => !0)) {
  function r(s, o) {
    if (!n.value || s.defaultPrevented)
      return;
    let a = o(s);
    if (a === null || !a.getRootNode().contains(a))
      return;
    let l = function c(u) {
      return typeof u == "function" ? c(u()) : Array.isArray(u) || u instanceof Set ? u : [u];
    }(t);
    for (let c of l) {
      if (c === null)
        continue;
      let u = c instanceof HTMLElement ? c : Ie(c);
      if (u != null && u.contains(a) || s.composed && s.composedPath().includes(u))
        return;
    }
    return !o2(a, uE.Loose) && a.tabIndex !== -1 && s.preventDefault(), e(s, a);
  }
  let i = X(null);
  Ah("pointerdown", (s) => {
    var o, a;
    n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target);
  }, !0), Ah("mousedown", (s) => {
    var o, a;
    n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target);
  }, !0), Ah("click", (s) => {
    dX() || i.value && (r(s, () => i.value), i.value = null);
  }, !0), Ah("touchend", (s) => r(s, () => s.target instanceof HTMLElement ? s.target : null), !0), a2("blur", (s) => r(s, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function gT(t, e) {
  if (t)
    return t;
  let n = e ?? "button";
  if (typeof n == "string" && n.toLowerCase() === "button")
    return "button";
}
function l2(t, e) {
  let n = X(gT(t.value.type, t.value.as));
  return Zt(() => {
    n.value = gT(t.value.type, t.value.as);
  }), ps(() => {
    var r;
    n.value || Ie(e) && Ie(e) instanceof HTMLButtonElement && !((r = Ie(e)) != null && r.hasAttribute("type")) && (n.value = "button");
  }), n;
}
var Ya = ((t) => (t[t.None = 0] = "None", t[t.RenderStrategy = 1] = "RenderStrategy", t[t.Static = 2] = "Static", t))(Ya || {}), hX = ((t) => (t[t.Unmount = 0] = "Unmount", t[t.Hidden = 1] = "Hidden", t))(hX || {});
function _r({ visible: t = !0, features: e = 0, ourProps: n, theirProps: r, ...i }) {
  var s;
  let o = u2(r, n), a = Object.assign(i, { props: o });
  if (t || e & 2 && o.static)
    return vb(a);
  if (e & 1) {
    let l = (s = o.unmount) == null || s ? 0 : 1;
    return Pr(l, { 0() {
      return null;
    }, 1() {
      return vb({ ...i, props: { ...o, hidden: !0, style: { display: "none" } } });
    } });
  }
  return vb(a);
}
function vb({ props: t, attrs: e, slots: n, slot: r, name: i }) {
  var s, o;
  let { as: a, ...l } = d2(t, ["unmount", "static"]), c = (s = n.default) == null ? void 0 : s.call(n, r), u = {};
  if (r) {
    let d = !1, f = [];
    for (let [h, p] of Object.entries(r))
      typeof p == "boolean" && (d = !0), p === !0 && f.push(h);
    d && (u["data-headlessui-state"] = f.join(" "));
  }
  if (a === "template") {
    if (c = c2(c ?? []), Object.keys(l).length > 0 || Object.keys(e).length > 0) {
      let [d, ...f] = c ?? [];
      if (!pX(d) || f.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${i} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l).concat(Object.keys(e)).map((g) => g.trim()).filter((g, m, v) => v.indexOf(g) === m).sort((g, m) => g.localeCompare(m)).map((g) => `  - ${g}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((g) => `  - ${g}`).join(`
`)].join(`
`));
      let h = u2((o = d.props) != null ? o : {}, l, u), p = p3(d, h, !0);
      for (let g in h)
        g.startsWith("on") && (p.props || (p.props = {}), p.props[g] = h[g]);
      return p;
    }
    return Array.isArray(c) && c.length === 1 ? c[0] : c;
  }
  return mt(a, Object.assign({}, l, u), { default: () => c });
}
function c2(t) {
  return t.flatMap((e) => e.type === Vt ? c2(e.children) : [e]);
}
function u2(...t) {
  if (t.length === 0)
    return {};
  if (t.length === 1)
    return t[0];
  let e = {}, n = {};
  for (let r of t)
    for (let i in r)
      i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : e[i] = r[i];
  if (e.disabled || e["aria-disabled"])
    return Object.assign(e, Object.fromEntries(Object.keys(n).map((r) => [r, void 0])));
  for (let r in n)
    Object.assign(e, { [r](i, ...s) {
      let o = n[r];
      for (let a of o) {
        if (i instanceof Event && i.defaultPrevented)
          return;
        a(i, ...s);
      }
    } });
  return e;
}
function d2(t, e = []) {
  let n = Object.assign({}, t);
  for (let r of e)
    r in n && delete n[r];
  return n;
}
function pX(t) {
  return t == null ? !1 : typeof t.type == "string" || typeof t.type == "object" || typeof t.type == "function";
}
var Xa = ((t) => (t[t.None = 1] = "None", t[t.Focusable = 2] = "Focusable", t[t.Hidden = 4] = "Hidden", t))(Xa || {});
let Ja = ae({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(t, { slots: e, attrs: n }) {
  return () => {
    var r;
    let { features: i, ...s } = t, o = { "aria-hidden": (i & 2) === 2 ? !0 : (r = s["aria-hidden"]) != null ? r : void 0, hidden: (i & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(i & 4) === 4 && (i & 2) !== 2 && { display: "none" } } };
    return _r({ ourProps: o, theirProps: s, slot: {}, attrs: n, slots: e, name: "Hidden" });
  };
} }), f2 = Symbol("Context");
var Za = ((t) => (t[t.Open = 1] = "Open", t[t.Closed = 2] = "Closed", t[t.Closing = 4] = "Closing", t[t.Opening = 8] = "Opening", t))(Za || {});
function h2() {
  return Ln(f2, null);
}
function gX(t) {
  cr(f2, t);
}
var wn = ((t) => (t.Space = " ", t.Enter = "Enter", t.Escape = "Escape", t.Backspace = "Backspace", t.Delete = "Delete", t.ArrowLeft = "ArrowLeft", t.ArrowUp = "ArrowUp", t.ArrowRight = "ArrowRight", t.ArrowDown = "ArrowDown", t.Home = "Home", t.End = "End", t.PageUp = "PageUp", t.PageDown = "PageDown", t.Tab = "Tab", t))(wn || {});
function mX(t, e, n, r) {
  Kv.isServer || ps((i) => {
    t = t ?? window, t.addEventListener(e, n, r), i(() => t.removeEventListener(e, n, r));
  });
}
var Ps = ((t) => (t[t.Forwards = 0] = "Forwards", t[t.Backwards = 1] = "Backwards", t))(Ps || {});
function p2() {
  let t = X(0);
  return a2("keydown", (e) => {
    e.key === "Tab" && (t.value = e.shiftKey ? 1 : 0);
  }), t;
}
function vX({ defaultContainers: t = [], portals: e, mainTreeNodeRef: n } = {}) {
  let r = X(null), i = Ks(r);
  function s() {
    var o, a, l;
    let c = [];
    for (let u of t)
      u !== null && (u instanceof HTMLElement ? c.push(u) : "value" in u && u.value instanceof HTMLElement && c.push(u.value));
    if (e != null && e.value)
      for (let u of e.value)
        c.push(u);
    for (let u of (o = i == null ? void 0 : i.querySelectorAll("html > *, body > *")) != null ? o : [])
      u !== document.body && u !== document.head && u instanceof HTMLElement && u.id !== "headlessui-portal-root" && (u.contains(Ie(r)) || u.contains((l = (a = Ie(r)) == null ? void 0 : a.getRootNode()) == null ? void 0 : l.host) || c.some((d) => u.contains(d)) || c.push(u));
    return c;
  }
  return { resolveContainers: s, contains(o) {
    return s().some((a) => a.contains(o));
  }, mainTreeNodeRef: r, MainTreeNode() {
    return n != null ? null : mt(Ja, { features: Xa.Hidden, ref: r });
  } };
}
function bX() {
  let t = X(null);
  return { mainTreeNodeRef: t, MainTreeNode() {
    return mt(Ja, { features: Xa.Hidden, ref: t });
  } };
}
let g2 = Symbol("ForcePortalRootContext");
function yX() {
  return Ln(g2, !1);
}
ae({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(t, { slots: e, attrs: n }) {
  return cr(g2, t.force), () => {
    let { force: r, ...i } = t;
    return _r({ theirProps: i, ourProps: {}, slot: {}, slots: e, attrs: n, name: "ForcePortalRoot" });
  };
} });
function wX(t) {
  let e = Ks(t);
  if (!e) {
    if (t === null)
      return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${t}`);
  }
  let n = e.getElementById("headlessui-portal-root");
  if (n)
    return n;
  let r = e.createElement("div");
  return r.setAttribute("id", "headlessui-portal-root"), e.body.appendChild(r);
}
const d1 = /* @__PURE__ */ new WeakMap();
function _X(t) {
  var e;
  return (e = d1.get(t)) != null ? e : 0;
}
function mT(t, e) {
  let n = e(_X(t));
  return n <= 0 ? d1.delete(t) : d1.set(t, n), n;
}
ae({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(t, { slots: e, attrs: n }) {
  let r = X(null), i = rt(() => Ks(r)), s = yX(), o = Ln(m2, null), a = X(s === !0 || o == null ? wX(r.value) : o.resolveTarget());
  a.value && mT(a.value, (f) => f + 1);
  let l = X(!1);
  Zt(() => {
    l.value = !0;
  }), ps(() => {
    s || o != null && (a.value = o.resolveTarget());
  });
  let c = Ln(f1, null), u = !1, d = Oo();
  return Bt(r, () => {
    if (u || !c)
      return;
    let f = Ie(r);
    f && (Mo(c.register(f), d), u = !0);
  }), Mo(() => {
    var f, h;
    let p = (f = i.value) == null ? void 0 : f.getElementById("headlessui-portal-root");
    !p || a.value !== p || mT(a.value, (g) => g - 1) || a.value.children.length > 0 || (h = a.value.parentElement) == null || h.removeChild(a.value);
  }), () => {
    if (!l.value || a.value === null)
      return null;
    let f = { ref: r, "data-headlessui-portal": "" };
    return mt(g3, { to: a.value }, _r({ ourProps: f, theirProps: t, slot: {}, attrs: n, slots: e, name: "Portal" }));
  };
} });
let f1 = Symbol("PortalParentContext");
function EX() {
  let t = Ln(f1, null), e = X([]);
  function n(s) {
    return e.value.push(s), t && t.register(s), () => r(s);
  }
  function r(s) {
    let o = e.value.indexOf(s);
    o !== -1 && e.value.splice(o, 1), t && t.unregister(s);
  }
  let i = { register: n, unregister: r, portals: e };
  return [e, ae({ name: "PortalWrapper", setup(s, { slots: o }) {
    return cr(f1, i), () => {
      var a;
      return (a = o.default) == null ? void 0 : a.call(o);
    };
  } })];
}
let m2 = Symbol("PortalGroupContext");
ae({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(t, { attrs: e, slots: n }) {
  let r = Gw({ resolveTarget() {
    return t.target;
  } });
  return cr(m2, r), () => {
    let { target: i, ...s } = t;
    return _r({ theirProps: s, ourProps: {}, slot: {}, attrs: e, slots: n, name: "PortalGroup" });
  };
} });
var SX = ((t) => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(SX || {});
let v2 = Symbol("PopoverContext");
function Xv(t) {
  let e = Ln(v2, null);
  if (e === null) {
    let n = new Error(`<${t} /> is missing a parent <${_2.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n, Xv), n;
  }
  return e;
}
let b2 = Symbol("PopoverGroupContext");
function y2() {
  return Ln(b2, null);
}
let w2 = Symbol("PopoverPanelContext");
function xX() {
  return Ln(w2, null);
}
let _2 = ae({ name: "Popover", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" } }, setup(t, { slots: e, attrs: n, expose: r }) {
  var i;
  let s = X(null);
  r({ el: s, $el: s });
  let o = X(1), a = X(null), l = X(null), c = X(null), u = X(null), d = rt(() => Ks(s)), f = rt(() => {
    var _, w;
    if (!Ie(a) || !Ie(u))
      return !1;
    for (let N of document.querySelectorAll("body > *"))
      if (Number(N == null ? void 0 : N.contains(Ie(a))) ^ Number(N == null ? void 0 : N.contains(Ie(u))))
        return !0;
    let S = Yv(), x = S.indexOf(Ie(a)), k = (x + S.length - 1) % S.length, T = (x + 1) % S.length, I = S[k], R = S[T];
    return !((_ = Ie(u)) != null && _.contains(I)) && !((w = Ie(u)) != null && w.contains(R));
  }), h = { popoverState: o, buttonId: X(null), panelId: X(null), panel: u, button: a, isPortalled: f, beforePanelSentinel: l, afterPanelSentinel: c, togglePopover() {
    o.value = Pr(o.value, { 0: 1, 1: 0 });
  }, closePopover() {
    o.value !== 1 && (o.value = 1);
  }, close(_) {
    h.closePopover();
    let w = (() => _ ? _ instanceof HTMLElement ? _ : _.value instanceof HTMLElement ? Ie(_) : Ie(h.button) : Ie(h.button))();
    w == null || w.focus();
  } };
  cr(v2, h), gX(rt(() => Pr(o.value, { 0: Za.Open, 1: Za.Closed })));
  let p = { buttonId: h.buttonId, panelId: h.panelId, close() {
    h.closePopover();
  } }, g = y2(), m = g == null ? void 0 : g.registerPopover, [v, y] = EX(), E = vX({ mainTreeNodeRef: g == null ? void 0 : g.mainTreeNodeRef, portals: v, defaultContainers: [a, u] });
  function b() {
    var _, w, S, x;
    return (x = g == null ? void 0 : g.isFocusWithinPopoverGroup()) != null ? x : ((_ = d.value) == null ? void 0 : _.activeElement) && (((w = Ie(a)) == null ? void 0 : w.contains(d.value.activeElement)) || ((S = Ie(u)) == null ? void 0 : S.contains(d.value.activeElement)));
  }
  return ps(() => m == null ? void 0 : m(p)), mX((i = d.value) == null ? void 0 : i.defaultView, "focus", (_) => {
    var w, S;
    _.target !== window && _.target instanceof HTMLElement && o.value === 0 && (b() || a && u && (E.contains(_.target) || (w = Ie(h.beforePanelSentinel)) != null && w.contains(_.target) || (S = Ie(h.afterPanelSentinel)) != null && S.contains(_.target) || h.closePopover()));
  }, !0), fX(E.resolveContainers, (_, w) => {
    var S;
    h.closePopover(), o2(w, uE.Loose) || (_.preventDefault(), (S = Ie(a)) == null || S.focus());
  }, rt(() => o.value === 0)), () => {
    let _ = { open: o.value === 0, close: h.close };
    return mt(Vt, [mt(y, {}, () => _r({ theirProps: { ...t, ...n }, ourProps: { ref: s }, slot: _, slots: e, attrs: n, name: "Popover" })), mt(E.MainTreeNode)]);
  };
} }), kX = ae({ name: "PopoverButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, inheritAttrs: !1, setup(t, { attrs: e, slots: n, expose: r }) {
  var i;
  let s = (i = t.id) != null ? i : `headlessui-popover-button-${ko()}`, o = Xv("PopoverButton"), a = rt(() => Ks(o.button));
  r({ el: o.button, $el: o.button }), Zt(() => {
    o.buttonId.value = s;
  }), Mo(() => {
    o.buttonId.value = null;
  });
  let l = y2(), c = l == null ? void 0 : l.closeOthers, u = xX(), d = rt(() => u === null ? !1 : u.value === o.panelId.value), f = X(null), h = `headlessui-focus-sentinel-${ko()}`;
  d.value || ps(() => {
    o.button.value = Ie(f);
  });
  let p = l2(rt(() => ({ as: t.as, type: e.type })), f);
  function g(_) {
    var w, S, x, k, T;
    if (d.value) {
      if (o.popoverState.value === 1)
        return;
      switch (_.key) {
        case wn.Space:
        case wn.Enter:
          _.preventDefault(), (S = (w = _.target).click) == null || S.call(w), o.closePopover(), (x = Ie(o.button)) == null || x.focus();
          break;
      }
    } else
      switch (_.key) {
        case wn.Space:
        case wn.Enter:
          _.preventDefault(), _.stopPropagation(), o.popoverState.value === 1 && (c == null || c(o.buttonId.value)), o.togglePopover();
          break;
        case wn.Escape:
          if (o.popoverState.value !== 0)
            return c == null ? void 0 : c(o.buttonId.value);
          if (!Ie(o.button) || (k = a.value) != null && k.activeElement && !((T = Ie(o.button)) != null && T.contains(a.value.activeElement)))
            return;
          _.preventDefault(), _.stopPropagation(), o.closePopover();
          break;
      }
  }
  function m(_) {
    d.value || _.key === wn.Space && _.preventDefault();
  }
  function v(_) {
    var w, S;
    t.disabled || (d.value ? (o.closePopover(), (w = Ie(o.button)) == null || w.focus()) : (_.preventDefault(), _.stopPropagation(), o.popoverState.value === 1 && (c == null || c(o.buttonId.value)), o.togglePopover(), (S = Ie(o.button)) == null || S.focus()));
  }
  function y(_) {
    _.preventDefault(), _.stopPropagation();
  }
  let E = p2();
  function b() {
    let _ = Ie(o.panel);
    if (!_)
      return;
    function w() {
      Pr(E.value, { [Ps.Forwards]: () => Or(_, cn.First), [Ps.Backwards]: () => Or(_, cn.Last) }) === bo.Error && Or(Yv().filter((S) => S.dataset.headlessuiFocusGuard !== "true"), Pr(E.value, { [Ps.Forwards]: cn.Next, [Ps.Backwards]: cn.Previous }), { relativeTo: Ie(o.button) });
    }
    w();
  }
  return () => {
    let _ = o.popoverState.value === 0, w = { open: _ }, { ...S } = t, x = d.value ? { ref: f, type: p.value, onKeydown: g, onClick: v } : { ref: f, id: s, type: p.value, "aria-expanded": o.popoverState.value === 0, "aria-controls": Ie(o.panel) ? o.panelId.value : void 0, disabled: t.disabled ? !0 : void 0, onKeydown: g, onKeyup: m, onClick: v, onMousedown: y };
    return mt(Vt, [_r({ ourProps: x, theirProps: { ...e, ...S }, slot: w, attrs: e, slots: n, name: "PopoverButton" }), _ && !d.value && o.isPortalled.value && mt(Ja, { id: h, features: Xa.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: b })]);
  };
} });
ae({ name: "PopoverOverlay", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 } }, setup(t, { attrs: e, slots: n }) {
  let r = Xv("PopoverOverlay"), i = `headlessui-popover-overlay-${ko()}`, s = h2(), o = rt(() => s !== null ? (s.value & Za.Open) === Za.Open : r.popoverState.value === 0);
  function a() {
    r.closePopover();
  }
  return () => {
    let l = { open: r.popoverState.value === 0 };
    return _r({ ourProps: { id: i, "aria-hidden": !0, onClick: a }, theirProps: t, slot: l, attrs: e, slots: n, features: Ya.RenderStrategy | Ya.Static, visible: o.value, name: "PopoverOverlay" });
  };
} });
let CX = ae({ name: "PopoverPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, focus: { type: Boolean, default: !1 }, id: { type: String, default: null } }, inheritAttrs: !1, setup(t, { attrs: e, slots: n, expose: r }) {
  var i;
  let s = (i = t.id) != null ? i : `headlessui-popover-panel-${ko()}`, { focus: o } = t, a = Xv("PopoverPanel"), l = rt(() => Ks(a.panel)), c = `headlessui-focus-sentinel-before-${ko()}`, u = `headlessui-focus-sentinel-after-${ko()}`;
  r({ el: a.panel, $el: a.panel }), Zt(() => {
    a.panelId.value = s;
  }), Mo(() => {
    a.panelId.value = null;
  }), cr(w2, a.panelId), ps(() => {
    var y, E;
    if (!o || a.popoverState.value !== 0 || !a.panel)
      return;
    let b = (y = l.value) == null ? void 0 : y.activeElement;
    (E = Ie(a.panel)) != null && E.contains(b) || Or(Ie(a.panel), cn.First);
  });
  let d = h2(), f = rt(() => d !== null ? (d.value & Za.Open) === Za.Open : a.popoverState.value === 0);
  function h(y) {
    var E, b;
    switch (y.key) {
      case wn.Escape:
        if (a.popoverState.value !== 0 || !Ie(a.panel) || l.value && !((E = Ie(a.panel)) != null && E.contains(l.value.activeElement)))
          return;
        y.preventDefault(), y.stopPropagation(), a.closePopover(), (b = Ie(a.button)) == null || b.focus();
        break;
    }
  }
  function p(y) {
    var E, b, _, w, S;
    let x = y.relatedTarget;
    x && Ie(a.panel) && ((E = Ie(a.panel)) != null && E.contains(x) || (a.closePopover(), ((_ = (b = Ie(a.beforePanelSentinel)) == null ? void 0 : b.contains) != null && _.call(b, x) || (S = (w = Ie(a.afterPanelSentinel)) == null ? void 0 : w.contains) != null && S.call(w, x)) && x.focus({ preventScroll: !0 })));
  }
  let g = p2();
  function m() {
    let y = Ie(a.panel);
    if (!y)
      return;
    function E() {
      Pr(g.value, { [Ps.Forwards]: () => {
        var b;
        Or(y, cn.First) === bo.Error && ((b = Ie(a.afterPanelSentinel)) == null || b.focus());
      }, [Ps.Backwards]: () => {
        var b;
        (b = Ie(a.button)) == null || b.focus({ preventScroll: !0 });
      } });
    }
    E();
  }
  function v() {
    let y = Ie(a.panel);
    if (!y)
      return;
    function E() {
      Pr(g.value, { [Ps.Forwards]: () => {
        let b = Ie(a.button), _ = Ie(a.panel);
        if (!b)
          return;
        let w = Yv(), S = w.indexOf(b), x = w.slice(0, S + 1), k = [...w.slice(S + 1), ...x];
        for (let T of k.slice())
          if (T.dataset.headlessuiFocusGuard === "true" || _ != null && _.contains(T)) {
            let I = k.indexOf(T);
            I !== -1 && k.splice(I, 1);
          }
        Or(k, cn.First, { sorted: !1 });
      }, [Ps.Backwards]: () => {
        var b;
        Or(y, cn.Previous) === bo.Error && ((b = Ie(a.button)) == null || b.focus());
      } });
    }
    E();
  }
  return () => {
    let y = { open: a.popoverState.value === 0, close: a.close }, { focus: E, ...b } = t, _ = { ref: a.panel, id: s, onKeydown: h, onFocusout: o && a.popoverState.value === 0 ? p : void 0, tabIndex: -1 };
    return _r({ ourProps: _, theirProps: { ...e, ...b }, attrs: e, slot: y, slots: { ...n, default: (...w) => {
      var S;
      return [mt(Vt, [f.value && a.isPortalled.value && mt(Ja, { id: c, ref: a.beforePanelSentinel, features: Xa.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: m }), (S = n.default) == null ? void 0 : S.call(n, ...w), f.value && a.isPortalled.value && mt(Ja, { id: u, ref: a.afterPanelSentinel, features: Xa.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: v })])];
    } }, features: Ya.RenderStrategy | Ya.Static, visible: f.value, name: "PopoverPanel" });
  };
} });
ae({ name: "PopoverGroup", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" } }, setup(t, { attrs: e, slots: n, expose: r }) {
  let i = X(null), s = mv([]), o = rt(() => Ks(i)), a = bX();
  r({ el: i, $el: i });
  function l(f) {
    let h = s.value.indexOf(f);
    h !== -1 && s.value.splice(h, 1);
  }
  function c(f) {
    return s.value.push(f), () => {
      l(f);
    };
  }
  function u() {
    var f;
    let h = o.value;
    if (!h)
      return !1;
    let p = h.activeElement;
    return (f = Ie(i)) != null && f.contains(p) ? !0 : s.value.some((g) => {
      var m, v;
      return ((m = h.getElementById(g.buttonId.value)) == null ? void 0 : m.contains(p)) || ((v = h.getElementById(g.panelId.value)) == null ? void 0 : v.contains(p));
    });
  }
  function d(f) {
    for (let h of s.value)
      h.buttonId.value !== f && h.close();
  }
  return cr(b2, { registerPopover: c, unregisterPopover: l, isFocusWithinPopoverGroup: u, closeOthers: d, mainTreeNodeRef: a.mainTreeNodeRef }), () => mt(Vt, [_r({ ourProps: { ref: i }, theirProps: { ...t, ...e }, slot: {}, attrs: e, slots: n, name: "PopoverGroup" }), mt(a.MainTreeNode)]);
} });
let TX = ae({ props: { onFocus: { type: Function, required: !0 } }, setup(t) {
  let e = X(!0);
  return () => e.value ? mt(Ja, { as: "button", type: "button", features: Xa.Focusable, onFocus(n) {
    n.preventDefault();
    let r, i = 50;
    function s() {
      var o;
      if (i-- <= 0) {
        r && cancelAnimationFrame(r);
        return;
      }
      if ((o = t.onFocus) != null && o.call(t)) {
        e.value = !1, cancelAnimationFrame(r);
        return;
      }
      r = requestAnimationFrame(s);
    }
    r = requestAnimationFrame(s);
  } }) : null;
} });
var OX = ((t) => (t[t.Forwards = 0] = "Forwards", t[t.Backwards = 1] = "Backwards", t))(OX || {}), MX = ((t) => (t[t.Less = -1] = "Less", t[t.Equal = 0] = "Equal", t[t.Greater = 1] = "Greater", t))(MX || {});
let E2 = Symbol("TabsContext");
function Hf(t) {
  let e = Ln(E2, null);
  if (e === null) {
    let n = new Error(`<${t} /> is missing a parent <TabGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n, Hf), n;
  }
  return e;
}
let dE = Symbol("TabsSSRContext"), S2 = ae({ name: "TabGroup", emits: { change: (t) => !0 }, props: { as: { type: [Object, String], default: "template" }, selectedIndex: { type: [Number], default: null }, defaultIndex: { type: [Number], default: 0 }, vertical: { type: [Boolean], default: !1 }, manual: { type: [Boolean], default: !1 } }, inheritAttrs: !1, setup(t, { slots: e, attrs: n, emit: r }) {
  var i;
  let s = X((i = t.selectedIndex) != null ? i : t.defaultIndex), o = X([]), a = X([]), l = rt(() => t.selectedIndex !== null), c = rt(() => l.value ? t.selectedIndex : s.value);
  function u(g) {
    var m;
    let v = zl(d.tabs.value, Ie), y = zl(d.panels.value, Ie), E = v.filter((b) => {
      var _;
      return !((_ = Ie(b)) != null && _.hasAttribute("disabled"));
    });
    if (g < 0 || g > v.length - 1) {
      let b = Pr(s.value === null ? 0 : Math.sign(g - s.value), { [-1]: () => 1, 0: () => Pr(Math.sign(g), { [-1]: () => 0, 0: () => 0, 1: () => 1 }), 1: () => 0 }), _ = Pr(b, { 0: () => v.indexOf(E[0]), 1: () => v.indexOf(E[E.length - 1]) });
      _ !== -1 && (s.value = _), d.tabs.value = v, d.panels.value = y;
    } else {
      let b = v.slice(0, g), _ = [...v.slice(g), ...b].find((S) => E.includes(S));
      if (!_)
        return;
      let w = (m = v.indexOf(_)) != null ? m : d.selectedIndex.value;
      w === -1 && (w = d.selectedIndex.value), s.value = w, d.tabs.value = v, d.panels.value = y;
    }
  }
  let d = { selectedIndex: rt(() => {
    var g, m;
    return (m = (g = s.value) != null ? g : t.defaultIndex) != null ? m : null;
  }), orientation: rt(() => t.vertical ? "vertical" : "horizontal"), activation: rt(() => t.manual ? "manual" : "auto"), tabs: o, panels: a, setSelectedIndex(g) {
    c.value !== g && r("change", g), l.value || u(g);
  }, registerTab(g) {
    var m;
    if (o.value.includes(g))
      return;
    let v = o.value[s.value];
    if (o.value.push(g), o.value = zl(o.value, Ie), !l.value) {
      let y = (m = o.value.indexOf(v)) != null ? m : s.value;
      y !== -1 && (s.value = y);
    }
  }, unregisterTab(g) {
    let m = o.value.indexOf(g);
    m !== -1 && o.value.splice(m, 1);
  }, registerPanel(g) {
    a.value.includes(g) || (a.value.push(g), a.value = zl(a.value, Ie));
  }, unregisterPanel(g) {
    let m = a.value.indexOf(g);
    m !== -1 && a.value.splice(m, 1);
  } };
  cr(E2, d);
  let f = X({ tabs: [], panels: [] }), h = X(!1);
  Zt(() => {
    h.value = !0;
  }), cr(dE, rt(() => h.value ? null : f.value));
  let p = rt(() => t.selectedIndex);
  return Zt(() => {
    Bt([p], () => {
      var g;
      return u((g = t.selectedIndex) != null ? g : t.defaultIndex);
    }, { immediate: !0 });
  }), ps(() => {
    if (!l.value || c.value == null || d.tabs.value.length <= 0)
      return;
    let g = zl(d.tabs.value, Ie);
    g.some((m, v) => Ie(d.tabs.value[v]) !== Ie(m)) && d.setSelectedIndex(g.findIndex((m) => Ie(m) === Ie(d.tabs.value[c.value])));
  }), () => {
    let g = { selectedIndex: s.value };
    return mt(Vt, [o.value.length <= 0 && mt(TX, { onFocus: () => {
      for (let m of o.value) {
        let v = Ie(m);
        if ((v == null ? void 0 : v.tabIndex) === 0)
          return v.focus(), !0;
      }
      return !1;
    } }), _r({ theirProps: { ...n, ...d2(t, ["selectedIndex", "defaultIndex", "manual", "vertical", "onChange"]) }, ourProps: {}, slot: g, slots: e, attrs: n, name: "TabGroup" })]);
  };
} }), x2 = ae({ name: "TabList", props: { as: { type: [Object, String], default: "div" } }, setup(t, { attrs: e, slots: n }) {
  let r = Hf("TabList");
  return () => {
    let i = { selectedIndex: r.selectedIndex.value }, s = { role: "tablist", "aria-orientation": r.orientation.value };
    return _r({ ourProps: s, theirProps: t, slot: i, attrs: e, slots: n, name: "TabList" });
  };
} }), k2 = ae({ name: "Tab", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n, expose: r }) {
  var i;
  let s = (i = t.id) != null ? i : `headlessui-tabs-tab-${ko()}`, o = Hf("Tab"), a = X(null);
  r({ el: a, $el: a }), Zt(() => o.registerTab(a)), Mo(() => o.unregisterTab(a));
  let l = Ln(dE), c = rt(() => {
    if (l.value) {
      let y = l.value.tabs.indexOf(s);
      return y === -1 ? l.value.tabs.push(s) - 1 : y;
    }
    return -1;
  }), u = rt(() => {
    let y = o.tabs.value.indexOf(a);
    return y === -1 ? c.value : y;
  }), d = rt(() => u.value === o.selectedIndex.value);
  function f(y) {
    var E;
    let b = y();
    if (b === bo.Success && o.activation.value === "auto") {
      let _ = (E = Ks(a)) == null ? void 0 : E.activeElement, w = o.tabs.value.findIndex((S) => Ie(S) === _);
      w !== -1 && o.setSelectedIndex(w);
    }
    return b;
  }
  function h(y) {
    let E = o.tabs.value.map((b) => Ie(b)).filter(Boolean);
    if (y.key === wn.Space || y.key === wn.Enter) {
      y.preventDefault(), y.stopPropagation(), o.setSelectedIndex(u.value);
      return;
    }
    switch (y.key) {
      case wn.Home:
      case wn.PageUp:
        return y.preventDefault(), y.stopPropagation(), f(() => Or(E, cn.First));
      case wn.End:
      case wn.PageDown:
        return y.preventDefault(), y.stopPropagation(), f(() => Or(E, cn.Last));
    }
    if (f(() => Pr(o.orientation.value, { vertical() {
      return y.key === wn.ArrowUp ? Or(E, cn.Previous | cn.WrapAround) : y.key === wn.ArrowDown ? Or(E, cn.Next | cn.WrapAround) : bo.Error;
    }, horizontal() {
      return y.key === wn.ArrowLeft ? Or(E, cn.Previous | cn.WrapAround) : y.key === wn.ArrowRight ? Or(E, cn.Next | cn.WrapAround) : bo.Error;
    } })) === bo.Success)
      return y.preventDefault();
  }
  let p = X(!1);
  function g() {
    var y;
    p.value || (p.value = !0, !t.disabled && ((y = Ie(a)) == null || y.focus({ preventScroll: !0 }), o.setSelectedIndex(u.value), QY(() => {
      p.value = !1;
    })));
  }
  function m(y) {
    y.preventDefault();
  }
  let v = l2(rt(() => ({ as: t.as, type: e.type })), a);
  return () => {
    var y, E;
    let b = { selected: d.value, disabled: (y = t.disabled) != null ? y : !1 }, { ..._ } = t, w = { ref: a, onKeydown: h, onMousedown: m, onClick: g, id: s, role: "tab", type: v.value, "aria-controls": (E = Ie(o.panels.value[u.value])) == null ? void 0 : E.id, "aria-selected": d.value, tabIndex: d.value ? 0 : -1, disabled: t.disabled ? !0 : void 0 };
    return _r({ ourProps: w, theirProps: _, slot: b, attrs: e, slots: n, name: "Tab" });
  };
} }), C2 = ae({ name: "TabPanels", props: { as: { type: [Object, String], default: "div" } }, setup(t, { slots: e, attrs: n }) {
  let r = Hf("TabPanels");
  return () => {
    let i = { selectedIndex: r.selectedIndex.value };
    return _r({ theirProps: t, ourProps: {}, slot: i, attrs: n, slots: e, name: "TabPanels" });
  };
} }), Rg = ae({ name: "TabPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: null }, tabIndex: { type: Number, default: 0 } }, setup(t, { attrs: e, slots: n, expose: r }) {
  var i;
  let s = (i = t.id) != null ? i : `headlessui-tabs-panel-${ko()}`, o = Hf("TabPanel"), a = X(null);
  r({ el: a, $el: a }), Zt(() => o.registerPanel(a)), Mo(() => o.unregisterPanel(a));
  let l = Ln(dE), c = rt(() => {
    if (l.value) {
      let f = l.value.panels.indexOf(s);
      return f === -1 ? l.value.panels.push(s) - 1 : f;
    }
    return -1;
  }), u = rt(() => {
    let f = o.panels.value.indexOf(a);
    return f === -1 ? c.value : f;
  }), d = rt(() => u.value === o.selectedIndex.value);
  return () => {
    var f;
    let h = { selected: d.value }, { tabIndex: p, ...g } = t, m = { ref: a, id: s, role: "tabpanel", "aria-labelledby": (f = Ie(o.tabs.value[u.value])) == null ? void 0 : f.id, tabIndex: d.value ? p : -1 };
    return !d.value && t.unmount && !t.static ? mt(Ja, { as: "span", "aria-hidden": !0, ...m }) : _r({ ourProps: m, theirProps: g, slot: h, attrs: e, slots: n, features: Ya.Static | Ya.RenderStrategy, visible: d.value, name: "TabPanel" });
  };
} });
const fi = /* @__PURE__ */ ae({
  __name: "LangPopover",
  props: {
    contentClass: {
      type: String,
      required: !1,
      default: ""
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["open"],
  setup(t, { emit: e }) {
    const n = e, r = X(!1);
    function i() {
      r.value = !r.value, n("open");
    }
    return (s, o) => (J(), Ze(C(_2), { class: "transition-all" }, {
      default: Ue(({ open: a }) => [
        W(C(kX), {
          class: It(a ? "langeditor-popover-open" : "langeditor-popover-close"),
          as: "div",
          onClick: i
        }, {
          default: Ue(() => [
            Lt(s.$slots, "button")
          ]),
          _: 2
        }, 1032, ["class"]),
        W(C(CX), {
          class: It([[t.contentClass, { "!p-1": t.mini }], "z-[20] absolute w-max p-2 langeditor-bg langeditor-text langeditor-border transition-all shadow rounded max-h-[400px] overflow-hidden overflow-y-auto"]),
          align: "end"
        }, {
          default: Ue(({ close: l }) => [
            Lt(s.$slots, "content")
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }));
  }
});
const AX = { key: 0 }, NX = /* @__PURE__ */ ae({
  __name: "Color",
  props: {
    options: {
      type: Object,
      required: !1
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    nt(i2.configure(e.options));
    const r = X("hsl(var(--foreground))");
    function i() {
      n.value.chain().focus().setColor(r.value).run();
    }
    function s(o) {
      r.value = o, i();
    }
    return (o, a) => C(n) ? (J(), be("div", AX, [
      W(fi, null, {
        button: Ue(() => [
          W(Ve, {
            "is-active": () => C(n).isActive("font-color"),
            mini: t.mini,
            title: C(me)("textColor")
          }, {
            text: Ue(() => [
              W(C(Q6), {
                style: Rr({ color: r.value === "transparent" ? "hsl(var(--foreground))" : r.value }),
                class: "w-4 h-4"
              }, null, 8, ["style"])
            ]),
            _: 1
          }, 8, ["is-active", "mini", "title"])
        ]),
        content: Ue(() => [
          W(s2, {
            color: r.value,
            "default-color": "#000",
            onChange: s
          }, null, 8, ["color"])
        ]),
        _: 1
      })
    ])) : He("", !0);
  }
});
const T2 = /* @__PURE__ */ wr(NX, [["__scopeId", "data-v-fce13d0b"]]);
function Ppe(t) {
  return i2.configure(t);
}
const RX = {}, DX = { class: "langeditor-divider" };
function IX(t, e) {
  return J(), be("div", DX);
}
const Jo = /* @__PURE__ */ wr(RX, [["render", IX], ["__scopeId", "data-v-61e47d54"]]), O2 = an.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), PX = {
  __name: "Document",
  setup(t) {
    return nt(O2), (e, n) => null;
  }
};
function Lpe() {
  return O2;
}
function LX(t = {}) {
  return new ut({
    view(e) {
      return new $X(e, t);
    }
  });
}
class $X {
  constructor(e, n) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let s = (o) => {
        this[i](o);
      };
      return e.dom.addEventListener(i, s), { name: i, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r;
    if (n) {
      let a = e.nodeBefore, l = e.nodeAfter;
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (c) {
          let u = c.getBoundingClientRect(), d = a ? u.bottom : u.top;
          a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
        }
      }
    }
    if (!r) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      r = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let i = this.editorView.dom.offsetParent;
    this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let s, o;
    if (!i || i == document.body && getComputedStyle(i).position == "static")
      s = -pageXOffset, o = -pageYOffset;
    else {
      let a = i.getBoundingClientRect();
      s = a.left - i.scrollLeft, o = a.top - i.scrollTop;
    }
    this.element.style.left = r.left - s + "px", this.element.style.top = r.top - o + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, n, e) : i;
    if (n && !s) {
      let o = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = vN(this.editorView.state.doc, o, this.editorView.dragging.slice);
        a != null && (o = a);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const M2 = Et.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      LX(this.options)
    ];
  }
}), BX = /* @__PURE__ */ ae({
  __name: "Dropcursor",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t;
    return nt(M2.configure(e.options)), (n, r) => null;
  }
});
function $pe(t) {
  return M2.configure(t);
}
class Yt extends $e {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return Yt.valid(r) ? new Yt(r) : $e.near(r);
  }
  content() {
    return De.empty;
  }
  eq(e) {
    return e instanceof Yt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Yt(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new fE(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !FX(e) || !zX(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e:
      for (; ; ) {
        if (!r && Yt.valid(e))
          return e;
        let i = e.pos, s = null;
        for (let o = e.depth; ; o--) {
          let a = e.node(o);
          if (n > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
            s = a.child(n > 0 ? e.indexAfter(o) : e.index(o) - 1);
            break;
          } else if (o == 0)
            return null;
          i += n;
          let l = e.doc.resolve(i);
          if (Yt.valid(l))
            return l;
        }
        for (; ; ) {
          let o = n > 0 ? s.firstChild : s.lastChild;
          if (!o) {
            if (s.isAtom && !s.isText && !ve.isSelectable(s)) {
              e = e.doc.resolve(i + s.nodeSize * n), r = !1;
              continue e;
            }
            break;
          }
          s = o, i += n;
          let a = e.doc.resolve(i);
          if (Yt.valid(a))
            return a;
        }
        return null;
      }
  }
}
Yt.prototype.visible = !1;
Yt.findFrom = Yt.findGapCursorFrom;
$e.jsonID("gapcursor", Yt);
class fE {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new fE(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Yt.valid(n) ? new Yt(n) : $e.near(n);
  }
}
function FX(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function zX(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function HX() {
  return new ut({
    props: {
      decorations: GX,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Yt.valid(n) ? new Yt(n) : null;
      },
      handleClick: VX,
      handleKeyDown: UX,
      handleDOMEvents: { beforeinput: WX }
    }
  });
}
const UX = kv({
  ArrowLeft: Nh("horiz", -1),
  ArrowRight: Nh("horiz", 1),
  ArrowUp: Nh("vert", -1),
  ArrowDown: Nh("vert", 1)
});
function Nh(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, a = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof Te) {
      if (!s.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = r.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = Yt.findGapCursorFrom(a, e, l);
    return c ? (i && i(r.tr.setSelection(new Yt(c))), !0) : !1;
  };
}
function VX(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!Yt.valid(r))
    return !1;
  let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && ve.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Yt(r))), !0);
}
function WX(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Yt))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = pe.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = pe.from(r[o].createAndFill(null, i));
  let s = t.state.tr.replace(n.pos, n.pos, new De(i, 0, 0));
  return s.setSelection(Te.near(s.doc.resolve(n.pos + 1))), t.dispatch(s), !1;
}
function GX(t) {
  if (!(t.selection instanceof Yt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Ht.create(t.doc, [xn.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const A2 = Et.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      HX()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = lt(Le(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), jX = /* @__PURE__ */ ae({
  __name: "Gapcursor",
  setup(t) {
    return nt(A2), (e, n) => null;
  }
});
function Bpe() {
  return A2;
}
const qX = { key: 0 }, KX = /* @__PURE__ */ ae({
  __name: "FormatClear",
  setup(t) {
    const e = et();
    return (n, r) => C(e) ? (J(), be("div", qX, [
      Lt(n.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(e).chain().focus().clearNodes().unsetAllMarks().run(),
          icon: C(iG),
          title: C(me)("formatClear")
        }, null, 8, ["action", "icon", "title"])
      ])
    ])) : He("", !0);
  }
}), YX = { key: 0 }, XX = /* @__PURE__ */ ae({
  __name: "Fullscreen",
  setup(t) {
    const e = et();
    function n() {
      e.value.storage.fullscreen.value = !e.value.storage.fullscreen.value;
    }
    return (r, i) => C(e) ? (J(), be("div", YX, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: n,
          icon: C(e).storage.fullscreen.value ? C(mG) : C(gG),
          title: C(me)("fullscreen")
        }, null, 8, ["icon", "title"])
      ])
    ])) : He("", !0);
  }
}), JX = { key: 0 }, Jv = {
  __name: "LangSimpleItem",
  props: {
    title: {
      type: String,
      required: !1
    },
    text: {
      type: String,
      required: !1,
      default: void 0
    },
    showIcon: {
      type: Boolean,
      required: !1,
      default: !0
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    return (e, n) => (J(), Ze(kg, null, {
      content: Ue(() => [
        vv(Ut(t.title), 1)
      ]),
      button: Ue(() => [
        se("button", {
          class: It([t.mini ? "text-sm !p-1.5 !h-auto" : "", "p-2 h-[32px] text-sm flex-nowrap text-nowrap rounded flex items-center cursor-pointer gap-1 transition-all langeditor-hover langeditor-text font-medium"]),
          type: "button"
        }, [
          t.text !== void 0 ? (J(), be("span", JX, Ut(t.text), 1)) : He("", !0),
          Lt(e.$slots, "default"),
          t.showIcon ? (J(), Ze(C(nG), {
            key: 1,
            class: "w-4 h-4"
          })) : He("", !0)
        ], 2)
      ]),
      _: 3
    }));
  }
}, ZX = { key: 0 }, QX = /* @__PURE__ */ ae({
  __name: "Print",
  setup(t) {
    const e = et();
    return nt(nJ()), (n, r) => C(e) ? (J(), be("div", ZX, [
      W(Ve, {
        action: () => C(e).chain().print(),
        icon: C(xG),
        "is-active": () => C(e).isActive("print"),
        title: C(me)("print")
      }, null, 8, ["action", "icon", "is-active", "title"])
    ])) : He("", !0);
  }
});
function eJ(t) {
  const n = Array.from(document.querySelectorAll("style, link")).reduce(
    (o, a) => o + a.outerHTML,
    ""
  ) + t.outerHTML, r = document.createElement("iframe");
  r.id = "langeditor-iframe", r.setAttribute("style", "position: absolute; width: 0; height: 0; top: -10px; left: -10px;"), document.body.appendChild(r);
  const i = r.contentWindow, s = r.contentDocument || r.contentWindow && r.contentWindow.document;
  s && (s.open(), s.write(n), s.close()), i && (r.onload = function() {
    try {
      setTimeout(() => {
        i.focus();
        try {
          i.document.execCommand("print", !1) || i.print();
        } catch {
          i.print();
        }
        i.close();
      }, 10);
    } catch (o) {
      console.error(o);
    }
    setTimeout(function() {
      document.body.removeChild(r);
    }, 100);
  });
}
function tJ(t) {
  const e = t.dom.closest(".markdown-body");
  return e ? (eJ(e), !0) : !1;
}
function nJ() {
  return Et.create({
    name: "print",
    addCommands() {
      return {
        print: () => ({ view: t }) => tJ(t)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-p": () => this.editor.commands.print()
      };
    }
  });
}
const N2 = an.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", _t(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: i, storedMarks: s } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: o } = this.options, { splittableMarks: a } = r.extensionManager, l = s || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && l && o) {
              const d = l.filter((f) => a.includes(f.type.name));
              c.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), rJ = /* @__PURE__ */ ae({
  __name: "HardBreak",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t;
    return nt(N2.configure(e.options)), (n, r) => null;
  }
});
function Fpe(t) {
  return N2.configure(t);
}
const R2 = an.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, _t(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => Fy({
      find: new RegExp(`^(#{1,${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
}), iJ = { key: 0 }, sJ = ["onClick"], oJ = { class: "flex items-center space-x-2" }, aJ = /* @__PURE__ */ ae({
  __name: "Heading",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    nt(R2.configure(e.options));
    const r = [
      {
        name: "Paragraph",
        size: "16px",
        icon: SG,
        command: () => n.value.chain().focus().toggleHeading({ level: 1 }).run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("heading", { level: 1 });
        }
      },
      {
        name: "Heading 1",
        size: "32px",
        icon: SD,
        command: () => n.value.chain().focus().toggleHeading({ level: 1 }).run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("heading", { level: 1 });
        }
      },
      {
        name: "Heading 2",
        size: "24px",
        icon: xD,
        command: () => n.value.chain().focus().toggleHeading({ level: 2 }).run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("heading", { level: 2 });
        }
      },
      {
        name: "Heading 3",
        size: "20.8px",
        icon: kD,
        command: () => n.value.chain().focus().toggleHeading({ level: 3 }).run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("heading", { level: 3 });
        }
      },
      {
        name: "Heading 4",
        size: "16px",
        icon: lG,
        command: () => n.value.chain().focus().toggleHeading({ level: 4 }).run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("heading", { level: 4 });
        }
      },
      {
        name: "Heading 5",
        size: "13.28px",
        icon: cG,
        command: () => n.value.chain().focus().toggleHeading({ level: 5 }).run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("heading", { level: 5 });
        }
      },
      {
        name: "Heading 6",
        size: "10.72px",
        icon: uG,
        command: () => n.value.chain().focus().toggleHeading({ level: 6 }).run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("heading", { level: 6 });
        }
      }
    ], i = rt(
      () => r.filter((s) => s == null ? void 0 : s.isActive()).pop() ?? {
        name: "Paragraph"
      }
    );
    return (s, o) => C(n) ? (J(), be("div", iJ, [
      W(fi, null, {
        button: Ue(() => [
          W(Jv, {
            text: i.value.name,
            title: C(me)("textColor")
          }, null, 8, ["text", "title"])
        ]),
        content: Ue(() => [
          (J(), be(Vt, null, $n(r, (a, l) => se("div", {
            key: l,
            class: "flex items-center gap-1.5 cursor-pointer px-2 py-1.5 text-sm rounded-sm langeditor-text langeditor-hover",
            type: "button",
            onClick: () => a.command()
          }, [
            (J(), Ze(ii(a.icon), {
              size: 14,
              class: "text-sm"
            })),
            se("div", oJ, Ut(a.name), 1),
            i.value.name === a.name ? (J(), Ze(C(Fv), {
              key: 0,
              class: "w-4 h-4"
            })) : He("", !0)
          ], 8, sJ)), 64))
        ]),
        _: 1
      })
    ])) : He("", !0);
  }
});
function zpe(t) {
  return R2.configure(t);
}
const lJ = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, cJ = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, uJ = mr.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      Va({
        find: lJ,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      No({
        find: cJ,
        type: this.type
      })
    ];
  }
});
function dJ(t) {
  return uJ.configure(t).extend({
    addOptions() {
      var e;
      return {
        ...(e = this.parent) == null ? void 0 : e.call(this),
        ...t
      };
    },
    renderHTML: function({ HTMLAttributes: e }) {
      const n = _t(this.options.HTMLAttributes, e);
      return n.color && (n.style = `background-color: ${n.color}`), ["mark", n, 0];
    },
    addAttributes: function() {
      var e;
      return {
        ...(e = this.parent) == null ? void 0 : e.call(this),
        // 添加新的属性
        color: {
          default: "none",
          parseHTML: (n) => n.getAttribute("data-color"),
          renderHTML: (n) => ({
            "data-color": n.color,
            style: `background-color: ${n.color}`
          })
        }
      };
    }
  });
}
const fJ = { key: 0 }, D2 = /* @__PURE__ */ ae({
  __name: "HighlightExt",
  props: {
    options: {
      type: Object,
      required: !1,
      default: () => ({ multicolor: !0 })
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    nt(dJ(e.options));
    const r = X("hsl(var(--foreground))");
    function i(s) {
      r.value = s, n.value.chain().focus().setHighlight({ color: r.value }).run();
    }
    return (s, o) => C(n) ? (J(), be("div", fJ, [
      W(fi, null, {
        button: Ue(() => [
          W(Ve, {
            "is-active": () => C(n).isActive("font-color"),
            mini: t.mini,
            title: C(me)("textLight")
          }, {
            text: Ue(() => [
              W(C(tG), {
                style: Rr({ color: r.value === "transparent" ? "#000" : r.value }),
                class: "w-4 h-4"
              }, null, 8, ["style"])
            ]),
            _: 1
          }, 8, ["is-active", "mini", "title"])
        ]),
        content: Ue(() => [
          W(s2, {
            color: r.value,
            "default-color": "transparent",
            onChange: i
          }, null, 8, ["color"])
        ]),
        _: 1
      })
    ])) : He("", !0);
  }
});
var Dg = 200, En = function() {
};
En.prototype.append = function(e) {
  return e.length ? (e = En.from(e), !this.length && e || e.length < Dg && this.leafAppend(e) || this.length < Dg && e.leafPrepend(this) || this.appendInner(e)) : this;
};
En.prototype.prepend = function(e) {
  return e.length ? En.from(e).append(this) : this;
};
En.prototype.appendInner = function(e) {
  return new hJ(this, e);
};
En.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? En.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
En.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
En.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
En.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, n, r), i;
};
En.from = function(e) {
  return e instanceof En ? e : e && e.length ? new I2(e) : En.empty;
};
var I2 = /* @__PURE__ */ function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, a) {
    for (var l = s; l < o; l++)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, a) {
    for (var l = s - 1; l >= o; l--)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Dg)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Dg)
      return new e(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(En);
En.empty = new I2([]);
var hJ = /* @__PURE__ */ function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === !1 || s > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === !1 || s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(En);
const pJ = 500;
class wi {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    n && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, a, l, c = [], u = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        i || (i = this.remapping(r, f + 1), s = i.maps.length), s--, u.push(d);
        return;
      }
      if (i) {
        u.push(new Qs(d.map));
        let h = d.step.map(i.slice(s)), p;
        h && o.maybeStep(h).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new Qs(p, void 0, void 0, c.length + u.length))), s--, p && i.appendMap(p, s);
      } else
        o.maybeStep(d.step);
      if (d.selection)
        return a = i ? d.selection.map(i.slice(s)) : d.selection, l = new wi(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: o, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, i) {
    let s = [], o = this.eventCount, a = this.items, l = !i && a.length ? a.get(a.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), f = new Qs(e.mapping.maps[u], d, n), h;
      (h = l && l.merge(f)) && (f = h, u ? s.pop() : a = a.slice(0, a.length - 1)), s.push(f), n && (o++, n = void 0), i || (l = f);
    }
    let c = o - r.depth;
    return c > mJ && (a = gJ(a, c), o -= c), new wi(a.append(s), o);
  }
  remapping(e, n) {
    let r = new ic();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new wi(this.items.append(e.map((n) => new Qs(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), s = e.mapping, o = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, i);
    let l = n;
    this.items.forEach((f) => {
      let h = s.getMirror(--l);
      if (h == null)
        return;
      o = Math.min(o, h);
      let p = s.maps[h];
      if (f.step) {
        let g = e.steps[h].invert(e.docs[h]), m = f.selection && f.selection.map(s.slice(l + 1, h));
        m && a++, r.push(new Qs(p, g, m));
      } else
        r.push(new Qs(p));
    }, i);
    let c = [];
    for (let f = n; f < o; f++)
      c.push(new Qs(s.maps[f]));
    let u = this.items.slice(0, i).append(c).append(r), d = new wi(u, a);
    return d.emptyItemCount() > pJ && (d = d.compress(this.items.length - r.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, i = [], s = 0;
    return this.items.forEach((o, a) => {
      if (a >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let l = o.step.map(n.slice(r)), c = l && l.getMap();
        if (r--, c && n.appendMap(c, r), l) {
          let u = o.selection && o.selection.map(n.slice(r));
          u && s++;
          let d = new Qs(c.invert(), l, u), f, h = i.length - 1;
          (f = i.length && i[h].merge(d)) ? i[h] = f : i.push(d);
        }
      } else
        o.map && r--;
    }, this.items.length, 0), new wi(En.from(i.reverse()), s);
  }
}
wi.empty = new wi(En.empty, 0);
function gJ(t, e) {
  let n;
  return t.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return n = i, !1;
  }), t.slice(n);
}
let Qs = class P2 {
  constructor(e, n, r, i) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new P2(n.getMap().invert(), n, this.selection);
    }
  }
};
class oo {
  constructor(e, n, r, i, s) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = s;
  }
}
const mJ = 20;
function vJ(t, e, n, r) {
  let i = n.getMeta(Ra), s;
  if (i)
    return i.historyState;
  n.getMeta(wJ) && (t = new oo(t.done, t.undone, null, 0, -1));
  let o = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (o && o.getMeta(Ra))
    return o.getMeta(Ra).redo ? new oo(t.done.addTransform(n, void 0, r, kp(e)), t.undone, vT(n.mapping.maps), t.prevTime, t.prevComposition) : new oo(t.done, t.undone.addTransform(n, void 0, r, kp(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = t.prevTime == 0 || !o && t.prevComposition != a && (t.prevTime < (n.time || 0) - r.newGroupDelay || !bJ(n, t.prevRanges)), c = o ? bb(t.prevRanges, n.mapping) : vT(n.mapping.maps);
    return new oo(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, kp(e)), wi.empty, c, n.time, a ?? t.prevComposition);
  } else
    return (s = n.getMeta("rebased")) ? new oo(t.done.rebased(n, s), t.undone.rebased(n, s), bb(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new oo(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), bb(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function bJ(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (n = !0);
  }), n;
}
function vT(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, i, s, o) => e.push(s, o));
  return e;
}
function bb(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let i = e.map(t[r], 1), s = e.map(t[r + 1], -1);
    i <= s && n.push(i, s);
  }
  return n;
}
function yJ(t, e, n) {
  let r = kp(e), i = Ra.get(e).spec.config, s = (n ? t.undone : t.done).popEvent(e, r);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), a = (n ? t.done : t.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), l = new oo(n ? a : s.remaining, n ? s.remaining : a, null, 0, -1);
  return s.transform.setSelection(o).setMeta(Ra, { redo: n, historyState: l });
}
let yb = !1, bT = null;
function kp(t) {
  let e = t.plugins;
  if (bT != e) {
    yb = !1, bT = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        yb = !0;
        break;
      }
  }
  return yb;
}
const Ra = new ft("history"), wJ = new ft("closeHistory");
function _J(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new ut({
    key: Ra,
    state: {
      init() {
        return new oo(wi.empty, wi.empty, null, 0, -1);
      },
      apply(e, n, r) {
        return vJ(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, i = r == "historyUndo" ? $2 : r == "historyRedo" ? B2 : null;
          return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function L2(t, e) {
  return (n, r) => {
    let i = Ra.getState(n);
    if (!i || (t ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let s = yJ(i, n, t);
      s && r(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const $2 = L2(!1, !0), B2 = L2(!0, !0), F2 = Et.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => $2(t, e),
      redo: () => ({ state: t, dispatch: e }) => B2(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      _J(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), EJ = /* @__PURE__ */ ae({
  __name: "History",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t;
    return nt(F2.configure(e.options)), (n, r) => null;
  }
});
function Hpe(t) {
  return F2.configure(t);
}
const z2 = an.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", _t(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        const { selection: n } = e, { $from: r, $to: i } = n, s = t();
        return r.parentOffset === 0 ? s.insertContentAt({
          from: Math.max(r.pos - 1, 0),
          to: i.pos
        }, {
          type: this.name
        }) : ER(n) ? s.insertContentAt(i.pos, {
          type: this.name
        }) : s.insertContent({ type: this.name }), s.command(({ tr: o, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: c } = o.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? o.setSelection(Te.create(o.doc, c.pos + 1)) : c.nodeAfter.isBlock ? o.setSelection(ve.create(o.doc, c.pos)) : o.setSelection(Te.create(o.doc, c.pos));
            else {
              const d = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              d && (o.insert(u, d), o.setSelection(Te.create(o.doc, u + 1)));
            }
            o.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      kR({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), SJ = { key: 0 }, xJ = /* @__PURE__ */ ae({
  __name: "HorizontalRule",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(z2.configure(e.options)), (r, i) => C(n) ? (J(), be("div", SJ, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().setHorizontalRule().run(),
          icon: C(vG),
          title: C(me)("separator")
        }, null, 8, ["action", "icon", "title"])
      ])
    ])) : He("", !0);
  }
});
function Upe(t) {
  return z2.configure(t);
}
const kJ = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, CJ = an.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", _t(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      kR({
        find: kJ,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, r] = t;
          return { src: n, alt: e, title: r };
        }
      })
    ];
  }
});
function TJ(t) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e[n - 1] = arguments[n];
  return e.map(function(r) {
    return r.split(" ").map(function(i) {
      return i ? "" + t + i : "";
    }).join(" ");
  }).join(" ");
}
function OJ(t, e) {
  return e.replace(/([^}{]*){/gm, function(n, r) {
    return r.replace(/\.([^{,\s\d.]+)/g, "." + t + "$1") + "{";
  });
}
function $s(t, e) {
  return function(n) {
    n && (t[e] = n);
  };
}
function H2(t, e, n) {
  return function(r) {
    r && (t[e][n] = r);
  };
}
function yT(t, e) {
  return function(n) {
    var r = n.prototype;
    t.forEach(function(i) {
      e(r, i);
    });
  };
}
function MJ(t, e) {
  return e === void 0 && (e = {}), function(n, r) {
    t.forEach(function(i) {
      var s = e[i] || i;
      s in n || (n[s] = function() {
        for (var o, a = [], l = 0; l < arguments.length; l++)
          a[l] = arguments[l];
        var c = (o = this[r])[i].apply(o, a);
        return c === this[r] ? this : c;
      });
    });
  };
}
var AJ = "function", NJ = "object", RJ = "string", DJ = "number", hE = "undefined", U2 = typeof window !== hE, IJ = typeof document !== hE && document, PJ = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], tn = 1e-7, Rh = {
  cm: function(t) {
    return t * 96 / 2.54;
  },
  mm: function(t) {
    return t * 96 / 254;
  },
  in: function(t) {
    return t * 96;
  },
  pt: function(t) {
    return t * 96 / 72;
  },
  pc: function(t) {
    return t * 96 / 6;
  },
  "%": function(t, e) {
    return t * e / 100;
  },
  vw: function(t, e) {
    return e === void 0 && (e = window.innerWidth), t / 100 * e;
  },
  vh: function(t, e) {
    return e === void 0 && (e = window.innerHeight), t / 100 * e;
  },
  vmax: function(t, e) {
    return e === void 0 && (e = Math.max(window.innerWidth, window.innerHeight)), t / 100 * e;
  },
  vmin: function(t, e) {
    return e === void 0 && (e = Math.min(window.innerWidth, window.innerHeight)), t / 100 * e;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function LJ() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), i = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      r[i] = s[o];
  return r;
}
function Ig(t, e, n, r) {
  return (t * r + e * n) / (n + r);
}
function Uf(t) {
  return typeof t === hE;
}
function Ni(t) {
  return t && typeof t === NJ;
}
function rn(t) {
  return Array.isArray(t);
}
function vr(t) {
  return typeof t === RJ;
}
function Bc(t) {
  return typeof t === DJ;
}
function pE(t) {
  return typeof t === AJ;
}
function $J(t, e) {
  var n = t === "" || t == " ", r = e === "" || e == " ";
  return r && n || t === e;
}
function V2(t, e, n, r, i) {
  var s = gE(t, e, n);
  return s ? n : BJ(t, e, n + 1, r, i);
}
function gE(t, e, n) {
  if (!t.ignore)
    return null;
  var r = e.slice(Math.max(n - 3, 0), n + 3).join("");
  return new RegExp(t.ignore).exec(r);
}
function BJ(t, e, n, r, i) {
  for (var s = function(c) {
    var u = e[c].trim();
    if (u === t.close && !gE(t, e, c))
      return {
        value: c
      };
    var d = c, f = br(i, function(h) {
      var p = h.open;
      return p === u;
    });
    if (f && (d = V2(f, e, c, r, i)), d === -1)
      return o = c, "break";
    c = d, o = c;
  }, o, a = n; a < r; ++a) {
    var l = s(a);
    if (a = o, typeof l == "object")
      return l.value;
    if (l === "break")
      break;
  }
  return -1;
}
function mE(t, e) {
  var n = vr(e) ? {
    separator: e
  } : e, r = n.separator, i = r === void 0 ? "," : r, s = n.isSeparateFirst, o = n.isSeparateOnlyOpenClose, a = n.isSeparateOpenClose, l = a === void 0 ? o : a, c = n.openCloseCharacters, u = c === void 0 ? PJ : c, d = u.map(function(S) {
    var x = S.open, k = S.close;
    return x === k ? x : x + "|" + k;
  }).join("|"), f = "(\\s*" + i + "\\s*|" + d + "|\\s+)", h = new RegExp(f, "g"), p = t.split(h).filter(function(S) {
    return S && S !== "undefined";
  }), g = p.length, m = [], v = [];
  function y() {
    return v.length ? (m.push(v.join("")), v = [], !0) : !1;
  }
  for (var E = function(S) {
    var x = p[S].trim(), k = S, T = br(u, function(N) {
      var $ = N.open;
      return $ === x;
    }), I = br(u, function(N) {
      var $ = N.close;
      return $ === x;
    });
    if (T) {
      if (k = V2(T, p, S, g, u), k !== -1 && l)
        return y() && s || (m.push(p.slice(S, k + 1).join("")), S = k, s) ? (b = S, "break") : (b = S, "continue");
    } else if (I && !gE(I, p, S)) {
      var R = LJ(u);
      return R.splice(u.indexOf(I), 1), {
        value: mE(t, {
          separator: i,
          isSeparateFirst: s,
          isSeparateOnlyOpenClose: o,
          isSeparateOpenClose: l,
          openCloseCharacters: R
        })
      };
    } else if ($J(x, i) && !o)
      return y(), s ? (b = S, "break") : (b = S, "continue");
    k === -1 && (k = g - 1), v.push(p.slice(S, k + 1).join("")), S = k, b = S;
  }, b, _ = 0; _ < g; ++_) {
    var w = E(_);
    if (_ = b, typeof w == "object")
      return w.value;
    if (w === "break")
      break;
  }
  return v.length && m.push(v.join("")), m;
}
function Do(t) {
  return mE(t, "");
}
function ga(t) {
  return mE(t, ",");
}
function W2(t) {
  var e = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(t);
  return !e || e.length < 4 ? {} : {
    prefix: e[1],
    value: e[2],
    suffix: e[3]
  };
}
function Vf(t) {
  var e = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(t);
  if (!e)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var n = e[1], r = e[2], i = e[3];
  return {
    prefix: n,
    unit: i,
    value: parseFloat(r)
  };
}
function FJ(t) {
  return t.replace(/[\s-_]+([^\s-_])/g, function(e, n) {
    return n.toUpperCase();
  });
}
function Cp(t, e) {
  return e === void 0 && (e = "-"), t.replace(/([a-z])([A-Z])/g, function(n, r, i) {
    return "" + r + e + i.toLowerCase();
  });
}
function Jd() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
}
function Ws(t, e, n) {
  n === void 0 && (n = -1);
  for (var r = t.length, i = 0; i < r; ++i)
    if (e(t[i], i, t))
      return i;
  return n;
}
function br(t, e, n) {
  var r = Ws(t, e);
  return r > -1 ? t[r] : n;
}
var G2 = /* @__PURE__ */ function() {
  var t = Jd(), e = U2 && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return e ? e.bind(window) : function(n) {
    var r = Jd(), i = setTimeout(function() {
      n(r - t);
    }, 1e3 / 60);
    return i;
  };
}(), zJ = /* @__PURE__ */ function() {
  var t = U2 && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return t ? t.bind(window) : function(e) {
    clearTimeout(e);
  };
}();
function Gs(t) {
  return Object.keys(t);
}
function HJ(t) {
  var e = Gs(t);
  return e.map(function(n) {
    return t[n];
  });
}
function Ot(t, e) {
  var n = Vf(t), r = n.value, i = n.unit;
  if (Ni(e)) {
    var s = e[i];
    if (s) {
      if (pE(s))
        return s(r);
      if (Rh[i])
        return Rh[i](r, s);
    }
  } else if (i === "%")
    return r * e / 100;
  return Rh[i] ? Rh[i](r) : r;
}
function h1(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
function wT(t, e, n, r) {
  return r === void 0 && (r = t[0] / t[1]), [[tt(e[0], tn), tt(e[0] / r, tn)], [tt(e[1] * r, tn), tt(e[1], tn)]].filter(function(i) {
    return i.every(function(s, o) {
      var a = e[o], l = tt(a, tn);
      return n ? s <= a || s <= l : s >= a || s >= l;
    });
  })[0] || t;
}
function j2(t, e, n, r) {
  if (!r)
    return t.map(function(h, p) {
      return h1(h, e[p], n[p]);
    });
  var i = t[0], s = t[1], o = r === !0 ? i / s : r, a = wT(t, e, !1, o), l = a[0], c = a[1], u = wT(t, n, !0, o), d = u[0], f = u[1];
  return i < l || s < c ? (i = l, s = c) : (i > d || s > f) && (i = d, s = f), [i, s];
}
function UJ(t) {
  for (var e = t.length, n = 0, r = e - 1; r >= 0; --r)
    n += t[r];
  return n;
}
function p1(t) {
  for (var e = t.length, n = 0, r = e - 1; r >= 0; --r)
    n += t[r];
  return e ? n / e : 0;
}
function Qt(t, e) {
  var n = e[0] - t[0], r = e[1] - t[1], i = Math.atan2(r, n);
  return i >= 0 ? i : i + Math.PI * 2;
}
function VJ(t) {
  return [0, 1].map(function(e) {
    return p1(t.map(function(n) {
      return n[e];
    }));
  });
}
function _T(t) {
  var e = VJ(t), n = Qt(e, t[0]), r = Qt(e, t[1]);
  return n < r && r - n < Math.PI || n > r && r - n < -Math.PI ? 1 : -1;
}
function Bs(t, e) {
  return Math.sqrt(Math.pow((e ? e[0] : 0) - t[0], 2) + Math.pow((e ? e[1] : 0) - t[1], 2));
}
function tt(t, e) {
  if (!e)
    return t;
  var n = 1 / e;
  return Math.round(t / e) / n;
}
function ET(t, e) {
  return t.forEach(function(n, r) {
    t[r] = tt(t[r], e);
  }), t;
}
function WJ(t) {
  for (var e = [], n = 0; n < t; ++n)
    e.push(n);
  return e;
}
function q2(t) {
  return t.reduce(function(e, n) {
    return e.concat(n);
  }, []);
}
function K2(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function fn(t, e) {
  return t.classList ? t.classList.contains(e) : !!t.className.match(new RegExp("(\\s|^)" + e + "(\\s|$)"));
}
function Y2(t, e) {
  t.classList ? t.classList.add(e) : t.className += " " + e;
}
function X2(t, e) {
  if (t.classList)
    t.classList.remove(e);
  else {
    var n = new RegExp("(\\s|^)" + e + "(\\s|$)");
    t.className = t.className.replace(n, " ");
  }
}
function kn(t, e, n, r) {
  t.addEventListener(e, n, r);
}
function ln(t, e, n, r) {
  t.removeEventListener(e, n, r);
}
function tu(t) {
  return (t == null ? void 0 : t.ownerDocument) || IJ;
}
function vE(t) {
  return tu(t).documentElement;
}
function qo(t) {
  return tu(t).body;
}
function Co(t) {
  var e;
  return ((e = t == null ? void 0 : t.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || window;
}
function J2(t) {
  return t && "postMessage" in t && "blur" in t && "self" in t;
}
function nu(t) {
  return Ni(t) && t.nodeName && t.nodeType && "ownerDocument" in t;
}
var GJ = /* @__PURE__ */ function() {
  function t() {
    this.keys = [], this.values = [];
  }
  var e = t.prototype;
  return e.get = function(n) {
    return this.values[this.keys.indexOf(n)];
  }, e.set = function(n, r) {
    var i = this.keys, s = this.values, o = i.indexOf(n), a = o === -1 ? i.length : o;
    i[a] = n, s[a] = r;
  }, t;
}(), jJ = /* @__PURE__ */ function() {
  function t() {
    this.object = {};
  }
  var e = t.prototype;
  return e.get = function(n) {
    return this.object[n];
  }, e.set = function(n, r) {
    this.object[n] = r;
  }, t;
}(), qJ = typeof Map == "function", KJ = /* @__PURE__ */ function() {
  function t() {
  }
  var e = t.prototype;
  return e.connect = function(n, r) {
    this.prev = n, this.next = r, n && (n.next = this), r && (r.prev = this);
  }, e.disconnect = function() {
    var n = this.prev, r = this.next;
    n && (n.next = r), r && (r.prev = n);
  }, e.getIndex = function() {
    for (var n = this, r = -1; n; )
      n = n.prev, ++r;
    return r;
  }, t;
}();
function YJ(t, e) {
  var n = [], r = [];
  return t.forEach(function(i) {
    var s = i[0], o = i[1], a = new KJ();
    n[s] = a, r[o] = a;
  }), n.forEach(function(i, s) {
    i.connect(n[s - 1]);
  }), t.filter(function(i, s) {
    return !e[s];
  }).map(function(i, s) {
    var o = i[0], a = i[1];
    if (o === a)
      return [0, 0];
    var l = n[o], c = r[a - 1], u = l.getIndex();
    l.disconnect(), c ? l.connect(c, c.next) : l.connect(void 0, n[0]);
    var d = l.getIndex();
    return [u, d];
  });
}
var XJ = /* @__PURE__ */ function() {
  function t(n, r, i, s, o, a, l, c) {
    this.prevList = n, this.list = r, this.added = i, this.removed = s, this.changed = o, this.maintained = a, this.changedBeforeAdded = l, this.fixed = c;
  }
  var e = t.prototype;
  return Object.defineProperty(e, "ordered", {
    get: function() {
      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e, "pureChanged", {
    get: function() {
      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;
    },
    enumerable: !0,
    configurable: !0
  }), e.caculateOrdered = function() {
    var n = YJ(this.changedBeforeAdded, this.fixed), r = this.changed, i = [];
    this.cacheOrdered = n.filter(function(s, o) {
      var a = s[0], l = s[1], c = r[o], u = c[0], d = c[1];
      if (a !== l)
        return i.push([u, d]), !0;
    }), this.cachePureChanged = i;
  }, t;
}();
function Wf(t, e, n) {
  var r = qJ ? Map : n ? jJ : GJ, i = n || function(y) {
    return y;
  }, s = [], o = [], a = [], l = t.map(i), c = e.map(i), u = new r(), d = new r(), f = [], h = [], p = {}, g = [], m = 0, v = 0;
  return l.forEach(function(y, E) {
    u.set(y, E);
  }), c.forEach(function(y, E) {
    d.set(y, E);
  }), l.forEach(function(y, E) {
    var b = d.get(y);
    typeof b > "u" ? (++v, o.push(E)) : p[b] = v;
  }), c.forEach(function(y, E) {
    var b = u.get(y);
    typeof b > "u" ? (s.push(E), ++m) : (a.push([b, E]), v = p[E] || 0, f.push([b - v, E - m]), h.push(E === b), b !== E && g.push([b, E]));
  }), o.reverse(), new XJ(t, e, s, o, g, a, f, h);
}
var JJ = /* @__PURE__ */ function() {
  function t(n, r) {
    n === void 0 && (n = []), this.findKeyCallback = r, this.list = [].slice.call(n);
  }
  var e = t.prototype;
  return e.update = function(n) {
    var r = [].slice.call(n), i = Wf(this.list, r, this.findKeyCallback);
    return this.list = r, i;
  }, t;
}(), g1 = function(t, e) {
  return g1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, g1(t, e);
};
function Gf(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  g1(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Xi = function() {
  return Xi = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Xi.apply(this, arguments);
};
function Z2(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function ST(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
function xT(t) {
  var e = 0;
  return t.map(function(n) {
    return n == null ? "$compat".concat(++e) : "".concat(n);
  });
}
function Q2(t) {
  var e = [];
  return t.forEach(function(n) {
    e = e.concat(rn(n) ? Q2(n) : n);
  }), e;
}
function wb(t, e) {
  if (!e)
    return t;
  for (var n in e)
    Uf(t[n]) && (t[n] = e[n]);
  return t;
}
function Pg(t, e) {
  if (t === e)
    return !1;
  for (var n in t)
    if (!(n in e))
      return !0;
  for (var n in e)
    if (t[n] !== e[n])
      return !0;
  return !1;
}
function kT(t) {
  var e = t.className, n = Z2(t, ["className"]);
  return e != null && (n.class = e), delete n.style, delete n.children, n;
}
function CT(t) {
  var e = {}, n = {};
  for (var r in t)
    r.indexOf("on") === 0 ? n[r] = t[r] : e[r] = t[r];
  return [e, n];
}
function Zv(t) {
  if (!t)
    return null;
  var e = t.b;
  return nu(e) ? e : Zv(t.c);
}
function eP(t) {
  var e = t.parentNode;
  e && e.removeChild(t);
}
function tP(t) {
  t.forEach(function(e) {
    e();
  });
}
function ZJ() {
  return this.constructor(this.props, this.context);
}
var bE = 0, Qv = /* @__PURE__ */ function() {
  function t(n, r, i, s, o, a, l) {
    l === void 0 && (l = {}), this.t = n, this.d = r, this.k = i, this.i = s, this.c = o, this.ref = a, this.ps = l, this.typ = "prov", this._ps = [], this._cs = {}, this._hyd = null, this._sel = !1;
  }
  var e = t.prototype;
  return e.s = function() {
    return !0;
  }, e.u = function(n, r, i, s, o) {
    var a = this, l = a.d, c = HJ(r).filter(function(p) {
      return p.$_req;
    }), u = Q2(c.map(function(p) {
      return p.$_subs;
    })), d = br(u, function(p) {
      return p.d === l;
    });
    if (a.b && !vr(i) && !o && !a.s(i.props, s) && !d) {
      var f = u.reduce(function(p, g) {
        var m = g.d;
        return p[0] ? p[0].d === m && p.push(g) : m > l && p.push(g), p;
      }, []);
      return f.forEach(function(p) {
        jf(p, p._ps, [p.o], n, r, !0);
      }), !1;
    }
    a.o = i, a.ss(s);
    var h = a.ps;
    return vr(i) || (a.ps = i.props, a.ref = i.ref), yE(this), a.r(n, r, a.b ? h : {}, s), !0;
  }, e.md = function() {
    this.rr();
  }, e.ss = function() {
  }, e.ud = function() {
    this.rr();
  }, e.rr = function() {
    var n = this, r = n.ref, i = n.fr;
    r && r(i ? i.current : n.b);
  }, t;
}();
function nP() {
  return Object.__CROACT_CURRENT_INSTNACE__;
}
function QJ() {
  return bE;
}
function eZ(t) {
  bE = t;
}
function yE(t) {
  return Object.__CROACT_CURRENT_INSTNACE__ = t, bE = 0, t;
}
var wE = /* @__PURE__ */ function() {
  function t(n, r) {
    n === void 0 && (n = {}), this.props = n, this.context = r, this.state = {}, this.$_timer = 0, this.$_state = {}, this.$_subs = [], this.$_cs = {};
  }
  var e = t.prototype;
  return e.render = function() {
    return null;
  }, e.shouldComponentUpdate = function(n, r) {
    return this.props !== n || this.state !== r;
  }, e.setState = function(n, r, i) {
    var s = this;
    s.$_timer || (s.$_state = {}), clearTimeout(s.$_timer), s.$_timer = 0, s.$_state = Xi(Xi({}, s.$_state), n), i ? s.$_setState(r, i) : s.$_timer = window.setTimeout(function() {
      s.$_timer = 0, s.$_setState(r, i);
    });
  }, e.forceUpdate = function(n) {
    this.setState({}, n, !0);
  }, e.componentDidMount = function() {
  }, e.componentDidUpdate = function(n, r) {
  }, e.componentWillUnmount = function() {
  }, e.$_setState = function(n, r) {
    var i = [], s = this.$_p, o = jf(s.c, [s], [s.o], i, s._cs, Xi(Xi({}, this.state), this.$_state), r);
    o && (n && i.push(n), tP(i), yE(null));
  }, t;
}(), rP = /* @__PURE__ */ function(t) {
  Gf(e, t);
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  var n = e.prototype;
  return n.shouldComponentUpdate = function(r, i) {
    return Pg(this.props, r) || Pg(this.state, i);
  }, e;
}(wE);
function iP(t) {
  var e = function(n) {
    e.current = n;
  };
  return e.current = t, e;
}
function tZ(t) {
  return t._fr = !0, t;
}
function nZ(t, e, n, r) {
  var i, s;
  return !((i = t == null ? void 0 : t.prototype) === null || i === void 0) && i.render ? s = new t(e, n) : (s = new wE(e, n), s.constructor = t, t._fr ? (r.fr = iP(), s.render = function() {
    return this.constructor(this.props, r.fr);
  }) : s.render = ZJ), s.$_p = r, s;
}
var rZ = /* @__PURE__ */ function(t) {
  Gf(e, t);
  function e(r, i, s, o, a, l, c) {
    c === void 0 && (c = {});
    var u = t.call(this, r, i, s, o, a, l, wb(c, r.defaultProps)) || this;
    return u.typ = "comp", u._usefs = [], u._uefs = [], u._defs = [], u;
  }
  var n = e.prototype;
  return n.s = function(r, i) {
    var s = this.b;
    return s.shouldComponentUpdate(wb(r, this.t.defaultProps), i || s.state) !== !1;
  }, n.r = function(r, i, s) {
    var o, a, l = this, c = l.t;
    l.ps = wb(l.ps, l.t.defaultProps);
    var u = l.ps, d = !l.b, f = c.contextType, h = l.b, p = f == null ? void 0 : f.get(l);
    l._cs = i, d ? (h = nZ(c, u, p, l), l.b = h) : (h.props = u, h.context = p);
    var g = h.state;
    l._usefs = [], l._uefs = [];
    var m = h.render();
    ((a = (o = m == null ? void 0 : m.props) === null || o === void 0 ? void 0 : o.children) === null || a === void 0 ? void 0 : a.length) === 0 && (m.props.children = l.ps.children);
    var v = Xi(Xi({}, i), h.$_cs);
    jf(l, l._ps, m ? [m] : [], r, v), d ? l._uefs.push(function() {
      f == null || f.register(l), h.componentDidMount();
    }) : l._uefs.push(function() {
      h.componentDidUpdate(s, g);
    }), r.push(function() {
      l._usefs.forEach(function(y) {
        y();
      }), d ? l.md() : l.ud(), l._defs = l._uefs.map(function(y) {
        return y();
      });
    });
  }, n.ss = function(r) {
    var i = this.b;
    !i || !r || (i.state = r);
  }, n.un = function() {
    var r, i = this;
    i._ps.forEach(function(o) {
      o.un();
    });
    var s = i.t;
    (r = s.contextType) === null || r === void 0 || r.unregister(i), clearTimeout(i.b.$_timer), i._defs.forEach(function(o) {
      o && o();
    }), i.b.componentWillUnmount();
  }, e;
}(Qv);
function iZ(t, e, n) {
  var r = _E(kT(t), kT(e)), i = r.added, s = r.removed, o = r.changed;
  for (var a in i)
    n.setAttribute(a, i[a]);
  for (var l in o)
    n.setAttribute(l, o[l][1]);
  for (var c in s)
    n.removeAttribute(c);
}
function sZ(t, e, n) {
  var r = _E(t, e), i = r.added, s = r.removed;
  for (var o in s)
    n.e(o, !0);
  for (var a in i)
    n.e(a);
}
function _E(t, e) {
  var n = Gs(t), r = Gs(e), i = Wf(n, r, function(l) {
    return l;
  }), s = {}, o = {}, a = {};
  return i.added.forEach(function(l) {
    var c = r[l];
    s[c] = e[c];
  }), i.removed.forEach(function(l) {
    var c = n[l];
    o[c] = t[c];
  }), i.maintained.forEach(function(l) {
    var c = l[0], u = n[c], d = [t[u], e[u]];
    t[u] !== e[u] && (a[u] = d);
  }), {
    added: s,
    removed: o,
    changed: a
  };
}
function oZ(t, e, n) {
  var r = n.style, i = _E(t, e), s = i.added, o = i.removed, a = i.changed;
  for (var l in s) {
    var c = Cp(l, "-");
    r.setProperty(c, s[l]);
  }
  for (var l in a) {
    var u = Cp(l, "-");
    r.setProperty(u, a[l][1]);
  }
  for (var l in o) {
    var d = Cp(l, "-");
    r.removeProperty(d);
  }
}
function aZ(t) {
  return t.replace(/^on/g, "").toLowerCase();
}
var lZ = /* @__PURE__ */ function(t) {
  Gf(e, t);
  function e() {
    var r = t !== null && t.apply(this, arguments) || this;
    return r.typ = "elem", r._es = {}, r._svg = !1, r;
  }
  var n = e.prototype;
  return n.e = function(r, i) {
    var s = this, o = s._es, a = s.b, l = aZ(r);
    i ? (ln(a, l, o[r]), delete o[r]) : (o[r] = function(c) {
      var u, d;
      (d = (u = s.ps)[r]) === null || d === void 0 || d.call(u, c);
    }, kn(a, l, o[r]));
  }, n.s = function(r) {
    return Pg(this.ps, r);
  }, n.r = function(r, i, s) {
    var o, a = this, l = !a.b, c = a.ps;
    if (l) {
      var u = Zv(a.c), d = !1;
      a._svg || a.t === "svg" ? d = !0 : d = u && u.ownerSVGElement, a._svg = d;
      var f = (o = a._hyd) === null || o === void 0 ? void 0 : o.splice(0, 1)[0], h = a.t;
      if (f)
        a._hyd = [].slice.call(f.children || []);
      else {
        var p = tu(u);
        d ? f = p.createElementNS("http://www.w3.org/2000/svg", h) : f = p.createElement(h);
      }
      a.b = f;
    }
    jf(a, a._ps, c.children, r, i);
    var g = a.b, m = CT(s), v = m[0], y = m[1], E = CT(c), b = E[0], _ = E[1];
    return iZ(v, b, g), sZ(y, _, a), oZ(s.style || {}, c.style || {}, g), r.push(function() {
      l ? a.md() : a.ud();
    }), !0;
  }, n.un = function() {
    var r = this, i = r._es, s = r.b;
    for (var o in i)
      ln(s, o, i[o]);
    r._ps.forEach(function(a) {
      a.un();
    }), r._es = {}, r._sel || eP(s);
  }, e;
}(Qv);
function Zd(t) {
  if (!t || nu(t))
    return t;
  var e = t.$_p._ps;
  return e.length ? Zd(e[0].b) : null;
}
function sP(t) {
  if (t) {
    if (t.b && nu(t.b))
      return t;
    var e = t._ps;
    return e.length ? sP(e[0]) : null;
  }
}
function ki(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  var i = e || {}, s = i.key, o = i.ref, a = Z2(i, ["key", "ref"]);
  return {
    type: t,
    key: s,
    ref: o,
    props: Xi(Xi({}, a), {
      children: q2(n).filter(function(l) {
        return l != null && l !== !1;
      })
    })
  };
}
var oP = /* @__PURE__ */ function(t) {
  Gf(e, t);
  function e(r, i) {
    i === void 0 && (i = 0);
    var s = t.call(this, "container", i, "container", 0, null) || this;
    return s.typ = "container", s.b = r, s;
  }
  var n = e.prototype;
  return n.r = function() {
    return !0;
  }, n.un = function() {
  }, e;
}(Qv), cZ = /* @__PURE__ */ function(t) {
  Gf(e, t);
  function e() {
    var r = t !== null && t.apply(this, arguments) || this;
    return r.typ = "text", r;
  }
  var n = e.prototype;
  return n.r = function(r) {
    var i, s = this, o = !s.b;
    if (o) {
      var a = Zv(s.c), l = (i = s._hyd) === null || i === void 0 ? void 0 : i.splice(0, 1)[0];
      s.b = l || tu(a).createTextNode(s.t.replace("text_", ""));
    }
    return r.push(function() {
      o ? s.md() : s.ud();
    }), !0;
  }, n.un = function() {
    eP(this.b);
  }, e;
}(Qv);
function uZ(t, e, n) {
  var r = n.map(function(l) {
    return vr(l) ? null : l.key;
  }), i = xT(e.map(function(l) {
    return l.k;
  })), s = xT(r), o = Wf(i, s, function(l) {
    return l;
  });
  o.removed.forEach(function(l) {
    e.splice(l, 1)[0].un();
  }), o.ordered.forEach(function(l) {
    var c = l[0], u = l[1], d = e.splice(c, 1)[0];
    e.splice(u, 0, d);
    var f = Zd(d.b), h = Zd(e[u + 1] && e[u + 1].b);
    f && f.parentNode.insertBefore(f, h);
  }), o.added.forEach(function(l) {
    e.splice(l, 0, TT(n[l], r[l], l, t));
  });
  var a = o.maintained.filter(function(l) {
    l[0];
    var c = l[1], u = n[c], d = e[c], f = vr(u) ? "text_".concat(u) : u.type;
    return f !== d.t ? (d.un(), e.splice(c, 1, TT(u, r[c], c, t)), !0) : (d.i = c, !1);
  });
  return ST(ST([], o.added, !0), a.map(function(l) {
    l[0];
    var c = l[1];
    return c;
  }), !0);
}
function dZ(t, e) {
  for (var n = t._ps, r = n.length, i = e.i + 1; i < r; ++i) {
    var s = Zd(n[i].b);
    if (s)
      return s;
  }
  return null;
}
function TT(t, e, n, r) {
  var i = r.d + 1;
  if (vr(t) || Bc(t))
    return new cZ("text_".concat(t), i, e, n, r, null, {});
  var s = t.type, o = typeof s == "string" ? lZ : rZ;
  return new o(s, i, e, n, r, t.ref, t.props);
}
function jf(t, e, n, r, i, s, o) {
  var a = uZ(t, e, n), l = t._hyd, c = e.filter(function(d, f) {
    return d._hyd = l, d.u(r, i, n[f], s, o);
  });
  t.typ === "container" && t._sel && e.forEach(function(d) {
    var f = sP(d);
    f && (f._sel = !0);
  }), t._hyd = null;
  var u = Zv(t);
  return u && a.reverse().forEach(function(d) {
    var f = e[d], h = Zd(f.b);
    if (h && u !== h && !h.parentNode) {
      var p = dZ(t, f);
      u.insertBefore(h, p);
    }
  }), c.length > 0;
}
function fZ(t, e, n, r) {
  n === void 0 && (n = e.__CROACT__), r === void 0 && (r = {});
  var i = !!n;
  n || (n = new oP(e));
  var s = [];
  return jf(n, n._ps, t ? [t] : [], s, r, void 0, void 0), tP(s), yE(null), i || (e.__CROACT__ = n), n;
}
function OT(t, e, n) {
  return !n && t && (n = new oP(e.parentElement), n._hyd = [e], n._sel = !0), fZ(t, e, n), n;
}
function aP(t) {
  var e = nP(), n = e._hs || (e._hs = []), r = QJ(), i = n[r];
  if (eZ(r + 1), i) {
    if (!Pg(i.deps, t.deps))
      return i.updated = !1, i;
    n[r] = t;
  } else
    n.push(t);
  return t.value = t.func(), t.updated = !0, t;
}
function hZ(t, e) {
  var n = aP({
    func: t,
    deps: e
  });
  return n.value;
}
function pZ(t) {
  return hZ(function() {
    return iP(t);
  }, []);
}
function lP(t, e, n) {
  var r = nP(), i = aP({
    func: function() {
      return t;
    },
    deps: e
  }), s = n ? r._usefs : r._uefs;
  i.updated ? s.push(function() {
    return i.effect && i.effect(), i.effect = t(), i.effect;
  }) : s.push(function() {
    return i.effect;
  });
}
function gZ(t, e, n) {
  lP(function() {
    t == null || t(e());
  }, n, !0);
}
function EE(t, e) {
  for (var n = t.length, r = 0; r < n; ++r)
    if (e(t[r], r))
      return !0;
  return !1;
}
function cP(t, e) {
  for (var n = t.length, r = 0; r < n; ++r)
    if (e(t[r], r))
      return t[r];
  return null;
}
function uP(t) {
  var e = t;
  if (typeof e > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    e = navigator.userAgent || "";
  }
  return e.toLowerCase();
}
function SE(t, e) {
  try {
    return new RegExp(t, "g").exec(e);
  } catch {
    return null;
  }
}
function mZ() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var t = navigator.userAgentData, e = t.brands || t.uaList;
  return !!(e && e.length);
}
function vZ(t, e) {
  var n = SE("(" + t + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", e);
  return n ? n[3] : "";
}
function m1(t) {
  return t.replace(/_/g, ".");
}
function Iu(t, e) {
  var n = null, r = "-1";
  return EE(t, function(i) {
    var s = SE("(" + i.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", e);
    return !s || i.brand ? !1 : (n = i, r = s[3] || "-1", i.versionAlias ? r = i.versionAlias : i.versionTest && (r = vZ(i.versionTest.toLowerCase(), e) || r), r = m1(r), !0);
  }), {
    preset: n,
    version: r
  };
}
function bu(t, e) {
  var n = {
    brand: "",
    version: "-1"
  };
  return EE(t, function(r) {
    var i = dP(e, r);
    return i ? (n.brand = r.id, n.version = r.versionAlias || i.version, n.version !== "-1") : !1;
  }), n;
}
function dP(t, e) {
  return cP(t, function(n) {
    var r = n.brand;
    return SE("" + e.test, r.toLowerCase());
  });
}
var v1 = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], fP = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], b1 = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], hP = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}], pP = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function gP(t) {
  return !!Iu(hP, t).preset;
}
function bZ(t) {
  var e = uP(t), n = !!/mobi/g.exec(e), r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: gP(e),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, i = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, s = Iu(v1, e), o = s.preset, a = s.version, l = Iu(pP, e), c = l.preset, u = l.version, d = Iu(fP, e);
  if (r.chromium = !!d.preset, r.chromiumVersion = d.version, !r.chromium) {
    var f = Iu(b1, e);
    r.webkit = !!f.preset, r.webkitVersion = f.version;
  }
  return c && (i.name = c.id, i.version = u, i.majorVersion = parseInt(u, 10)), o && (r.name = o.id, r.version = a, r.webview && i.name === "ios" && r.name !== "safari" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
    browser: r,
    os: i,
    isMobile: n,
    isHints: !1
  };
}
function yZ(t) {
  var e = navigator.userAgentData, n = (e.uaList || e.brands).slice(), r = t && t.fullVersionList, i = e.mobile || !1, s = n[0], o = (t && t.platform || e.platform || navigator.platform).toLowerCase(), a = {
    name: s.brand,
    version: s.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!bu(hP, n).brand || gP(uP())
  }, l = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  a.webkit = !a.chromium && EE(b1, function(p) {
    return dP(n, p);
  });
  var c = bu(fP, n);
  if (a.chromium = !!c.brand, a.chromiumVersion = c.version, !a.chromium) {
    var u = bu(b1, n);
    a.webkit = !!u.brand, a.webkitVersion = u.version;
  }
  var d = cP(pP, function(p) {
    return new RegExp("" + p.test, "g").exec(o);
  });
  if (l.name = d ? d.id : "", t && (l.version = t.platformVersion), r && r.length) {
    var f = bu(v1, r);
    a.name = f.brand || a.name, a.version = f.version || a.version;
  } else {
    var h = bu(v1, n);
    a.name = h.brand || a.name, a.version = h.brand && t ? t.uaFullVersion : h.version;
  }
  return a.webkit && (l.name = i ? "ios" : "mac"), l.name === "ios" && a.webview && (a.version = "-1"), l.version = m1(l.version), a.version = m1(a.version), l.majorVersion = parseInt(l.version, 10), a.majorVersion = parseInt(a.version, 10), {
    browser: a,
    os: l,
    isMobile: i,
    isHints: !0
  };
}
function wZ(t) {
  return typeof t > "u" && mZ() ? yZ() : bZ(t);
}
function _Z(t, e, n, r, i, s) {
  for (var o = 0; o < i; ++o) {
    var a = n + o * i, l = r + o * i;
    t[a] += t[l] * s, e[a] += e[l] * s;
  }
}
function EZ(t, e, n, r, i) {
  for (var s = 0; s < i; ++s) {
    var o = n + s * i, a = r + s * i, l = t[o], c = e[o];
    t[o] = t[a], t[a] = l, e[o] = e[a], e[a] = c;
  }
}
function SZ(t, e, n, r, i) {
  for (var s = 0; s < r; ++s) {
    var o = n + s * r;
    t[o] /= i, e[o] /= i;
  }
}
function mP(t, e, n) {
  n === void 0 && (n = Math.sqrt(t.length));
  for (var r = t.slice(), i = 0; i < n; ++i)
    r[i * n + e - 1] = 0, r[(e - 1) * n + i] = 0;
  return r[(e - 1) * (n + 1)] = 1, r;
}
function us(t, e) {
  e === void 0 && (e = Math.sqrt(t.length));
  for (var n = t.slice(), r = $t(e), i = 0; i < e; ++i) {
    var s = e * i + i;
    if (!tt(n[s], tn)) {
      for (var o = i + 1; o < e; ++o)
        if (n[e * i + o]) {
          EZ(n, r, i, o, e);
          break;
        }
    }
    if (!tt(n[s], tn))
      return [];
    SZ(n, r, i, e, n[s]);
    for (var o = 0; o < e; ++o) {
      var a = o, l = o + i * e, c = n[l];
      !tt(c, tn) || i === o || _Z(n, r, a, i, e, -c);
    }
  }
  return r;
}
function xZ(t, e) {
  e === void 0 && (e = Math.sqrt(t.length));
  for (var n = [], r = 0; r < e; ++r)
    for (var i = 0; i < e; ++i)
      n[i * e + r] = t[e * r + i];
  return n;
}
function vP(t, e) {
  e === void 0 && (e = Math.sqrt(t.length));
  for (var n = [], r = t[e * e - 1], i = 0; i < e - 1; ++i)
    n[i] = t[e * (e - 1) + i] / r;
  return n[e - 1] = 0, n;
}
function kZ(t, e) {
  for (var n = $t(e), r = 0; r < e - 1; ++r)
    n[e * (e - 1) + r] = t[r] || 0;
  return n;
}
function Qa(t, e) {
  for (var n = t.slice(), r = t.length; r < e - 1; ++r)
    n[r] = 0;
  return n[e - 1] = 1, n;
}
function Ri(t, e, n) {
  if (e === void 0 && (e = Math.sqrt(t.length)), e === n)
    return t;
  for (var r = $t(n), i = Math.min(e, n), s = 0; s < i - 1; ++s) {
    for (var o = 0; o < i - 1; ++o)
      r[s * n + o] = t[s * e + o];
    r[(s + 1) * n - 1] = t[(s + 1) * e - 1], r[(n - 1) * n + s] = t[(e - 1) * e + s];
  }
  return r[n * n - 1] = t[e * e - 1], r;
}
function Lg(t) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e[n - 1] = arguments[n];
  var r = $t(t);
  return e.forEach(function(i) {
    r = Mt(r, i, t);
  }), r;
}
function Mt(t, e, n) {
  n === void 0 && (n = Math.sqrt(t.length));
  var r = [], i = t.length / n, s = e.length / i;
  if (i) {
    if (!s)
      return t;
  } else
    return e;
  for (var o = 0; o < n; ++o)
    for (var a = 0; a < s; ++a) {
      r[a * n + o] = 0;
      for (var l = 0; l < i; ++l)
        r[a * n + o] += t[l * n + o] * e[a * i + l];
    }
  return r;
}
function wt(t, e) {
  for (var n = Math.min(t.length, e.length), r = t.slice(), i = 0; i < n; ++i)
    r[i] = r[i] + e[i];
  return r;
}
function Ke(t, e) {
  for (var n = Math.min(t.length, e.length), r = t.slice(), i = 0; i < n; ++i)
    r[i] = r[i] - e[i];
  return r;
}
function CZ(t, e) {
  return e === void 0 && (e = t.length === 6), e ? [t[0], t[1], 0, t[2], t[3], 0, t[4], t[5], 1] : t;
}
function bP(t, e) {
  return e === void 0 && (e = t.length === 9), e ? [t[0], t[1], t[3], t[4], t[6], t[7]] : t;
}
function Bn(t, e, n) {
  n === void 0 && (n = e.length);
  var r = Mt(t, e, n), i = r[n - 1];
  return r.map(function(s) {
    return s / i;
  });
}
function TZ(t, e) {
  return Mt(t, [1, 0, 0, 0, 0, Math.cos(e), Math.sin(e), 0, 0, -Math.sin(e), Math.cos(e), 0, 0, 0, 0, 1], 4);
}
function OZ(t, e) {
  return Mt(t, [Math.cos(e), 0, -Math.sin(e), 0, 0, 1, 0, 0, Math.sin(e), 0, Math.cos(e), 0, 0, 0, 0, 1], 4);
}
function MZ(t, e) {
  return Mt(t, Kf(e, 4));
}
function Dh(t, e) {
  var n = e[0], r = n === void 0 ? 1 : n, i = e[1], s = i === void 0 ? 1 : i, o = e[2], a = o === void 0 ? 1 : o;
  return Mt(t, [r, 0, 0, 0, 0, s, 0, 0, 0, 0, a, 0, 0, 0, 0, 1], 4);
}
function qf(t, e) {
  return Bn(Kf(e, 3), Qa(t, 3));
}
function _b(t, e) {
  var n = e[0], r = n === void 0 ? 0 : n, i = e[1], s = i === void 0 ? 0 : i, o = e[2], a = o === void 0 ? 0 : o;
  return Mt(t, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, s, a, 1], 4);
}
function MT(t, e) {
  return Mt(t, e, 4);
}
function Kf(t, e) {
  var n = Math.cos(t), r = Math.sin(t), i = $t(e);
  return i[0] = n, i[1] = r, i[e] = -r, i[e + 1] = n, i;
}
function $t(t) {
  for (var e = t * t, n = [], r = 0; r < e; ++r)
    n[r] = r % (t + 1) ? 0 : 1;
  return n;
}
function xE(t, e) {
  for (var n = $t(e), r = Math.min(t.length, e - 1), i = 0; i < r; ++i)
    n[(e + 1) * i] = t[i];
  return n;
}
function el(t, e) {
  for (var n = $t(e), r = Math.min(t.length, e - 1), i = 0; i < r; ++i)
    n[e * (e - 1) + i] = t[i];
  return n;
}
function kE(t, e, n, r, i, s, o, a) {
  var l = t[0], c = t[1], u = e[0], d = e[1], f = n[0], h = n[1], p = r[0], g = r[1], m = i[0], v = i[1], y = s[0], E = s[1], b = o[0], _ = o[1], w = a[0], S = a[1], x = [l, 0, u, 0, f, 0, p, 0, c, 0, d, 0, h, 0, g, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, l, 0, u, 0, f, 0, p, 0, c, 0, d, 0, h, 0, g, 0, 1, 0, 1, 0, 1, 0, 1, -m * l, -v * l, -y * u, -E * u, -b * f, -_ * f, -w * p, -S * p, -m * c, -v * c, -y * d, -E * d, -b * h, -_ * h, -w * g, -S * g], k = us(x, 8);
  if (!k.length)
    return [];
  var T = Mt(k, [m, v, y, E, b, _, w, S], 8);
  return T[8] = 1, Ri(xZ(T), 3, 4);
}
var od = function() {
  return od = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, od.apply(this, arguments);
};
function AZ() {
  return [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
}
function Qd(t, e) {
  return e === void 0 && (e = 0), Hl(Fc(t, e));
}
function NZ(t, e) {
  var n = Bn(t, [e[0], e[1] || 0, e[2] || 0, 1], 4), r = n[3] || 1;
  return [
    n[0] / r,
    n[1] / r,
    n[2] / r
  ];
}
function Hl(t) {
  var e = AZ();
  return t.forEach(function(n) {
    var r = n.matrixFunction, i = n.functionValue;
    r && (e = r(e, i));
  }), e;
}
function Fc(t, e) {
  e === void 0 && (e = 0);
  var n = rn(t) ? t : Do(t);
  return n.map(function(r) {
    var i = W2(r), s = i.prefix, o = i.value, a = null, l = s, c = "";
    if (s === "translate" || s === "translateX" || s === "translate3d") {
      var u = Ni(e) ? od(od({}, e), { "o%": e["%"] }) : {
        "%": e,
        "o%": e
      }, d = ga(o).map(function(N, $) {
        return $ === 0 && "x%" in u ? u["%"] = e["x%"] : $ === 1 && "y%" in u ? u["%"] = e["y%"] : u["%"] = e["o%"], Ot(N, u);
      }), f = d[0], h = d[1], p = h === void 0 ? 0 : h, g = d[2], m = g === void 0 ? 0 : g;
      a = _b, c = [f, p, m];
    } else if (s === "translateY") {
      var v = Ni(e) ? od({ "%": e["y%"] }, e) : {
        "%": e
      }, p = Ot(o, v);
      a = _b, c = [0, p, 0];
    } else if (s === "translateZ") {
      var m = parseFloat(o);
      a = _b, c = [0, 0, m];
    } else if (s === "scale" || s === "scale3d") {
      var y = ga(o).map(function(N) {
        return parseFloat(N);
      }), E = y[0], b = y[1], _ = b === void 0 ? E : b, w = y[2], S = w === void 0 ? 1 : w;
      a = Dh, c = [E, _, S];
    } else if (s === "scaleX") {
      var E = parseFloat(o);
      a = Dh, c = [E, 1, 1];
    } else if (s === "scaleY") {
      var _ = parseFloat(o);
      a = Dh, c = [1, _, 1];
    } else if (s === "scaleZ") {
      var S = parseFloat(o);
      a = Dh, c = [1, 1, S];
    } else if (s === "rotate" || s === "rotateZ" || s === "rotateX" || s === "rotateY") {
      var x = Vf(o), k = x.unit, T = x.value, I = k === "rad" ? T : T * Math.PI / 180;
      s === "rotate" || s === "rotateZ" ? (l = "rotateZ", a = MZ) : s === "rotateX" ? a = TZ : s === "rotateY" && (a = OZ), c = I;
    } else if (s === "matrix3d")
      a = MT, c = ga(o).map(function(N) {
        return parseFloat(N);
      });
    else if (s === "matrix") {
      var R = ga(o).map(function(N) {
        return parseFloat(N);
      });
      a = MT, c = [
        R[0],
        R[1],
        0,
        0,
        R[2],
        R[3],
        0,
        0,
        0,
        0,
        1,
        0,
        R[4],
        R[5],
        0,
        1
      ];
    } else
      l = "";
    return {
      name: s,
      functionName: l,
      value: o,
      matrixFunction: a,
      functionValue: c
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var y1 = function(t, e) {
  return y1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      r.hasOwnProperty(i) && (n[i] = r[i]);
  }, y1(t, e);
};
function RZ(t, e) {
  y1(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var yP = typeof Map == "function" ? void 0 : function() {
  var t = 0;
  return function(e) {
    return e.__DIFF_KEY__ || (e.__DIFF_KEY__ = ++t);
  };
}(), wP = /* @__PURE__ */ function(t) {
  RZ(e, t);
  function e(n) {
    return n === void 0 && (n = []), t.call(this, n, yP) || this;
  }
  return e;
}(JJ);
function DZ(t, e) {
  return Wf(t, e, yP);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var w1 = function() {
  return w1 = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, w1.apply(this, arguments);
};
function IZ() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), i = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      r[i] = s[o];
  return r;
}
var PZ = /* @__PURE__ */ function() {
  function t() {
    this._events = {};
  }
  var e = t.prototype;
  return e.on = function(n, r) {
    if (Ni(n))
      for (var i in n)
        this.on(i, n[i]);
    else
      this._addEvent(n, r, {});
    return this;
  }, e.off = function(n, r) {
    if (!n)
      this._events = {};
    else if (Ni(n))
      for (var i in n)
        this.off(i);
    else if (!r)
      this._events[n] = [];
    else {
      var s = this._events[n];
      if (s) {
        var o = Ws(s, function(a) {
          return a.listener === r;
        });
        o > -1 && s.splice(o, 1);
      }
    }
    return this;
  }, e.once = function(n, r) {
    var i = this;
    return r && this._addEvent(n, r, {
      once: !0
    }), new Promise(function(s) {
      i._addEvent(n, s, {
        once: !0
      });
    });
  }, e.emit = function(n, r) {
    var i = this;
    r === void 0 && (r = {});
    var s = this._events[n];
    if (!n || !s)
      return !0;
    var o = !1;
    return r.eventType = n, r.stop = function() {
      o = !0;
    }, r.currentTarget = this, IZ(s).forEach(function(a) {
      a.listener(r), a.once && i.off(n, a.listener);
    }), !o;
  }, e.trigger = function(n, r) {
    return r === void 0 && (r = {}), this.emit(n, r);
  }, e._addEvent = function(n, r, i) {
    var s = this._events;
    s[n] = s[n] || [];
    var o = s[n];
    o.push(w1({
      listener: r
    }, i));
  }, t;
}();
const e0 = PZ;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var _1 = function(t, e) {
  return _1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      r.hasOwnProperty(i) && (n[i] = r[i]);
  }, _1(t, e);
};
function LZ(t, e) {
  _1(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Xl = function() {
  return Xl = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Xl.apply(this, arguments);
};
function $Z(t) {
  var e = t.container;
  return e === document.body ? [e.scrollLeft || document.documentElement.scrollLeft, e.scrollTop || document.documentElement.scrollTop] : [e.scrollLeft, e.scrollTop];
}
function AT(t, e) {
  return t.addEventListener("scroll", e), function() {
    t.removeEventListener("scroll", e);
  };
}
function Ih(t) {
  if (t) {
    if (vr(t))
      return document.querySelector(t);
  } else
    return null;
  if (pE(t))
    return t();
  if (t instanceof Element)
    return t;
  if ("current" in t)
    return t.current;
  if ("value" in t)
    return t.value;
}
var BZ = /* @__PURE__ */ function(t) {
  LZ(e, t);
  function e() {
    var r = t !== null && t.apply(this, arguments) || this;
    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r._currentOptions = null, r._lock = !1, r._unregister = null, r._onScroll = function() {
      var i = r._currentOptions;
      r._lock || !i || r.emit("scrollDrag", {
        next: function(s) {
          r.checkScroll({
            container: i.container,
            inputEvent: s
          });
        }
      });
    }, r;
  }
  var n = e.prototype;
  return n.dragStart = function(r, i) {
    var s = Ih(i.container);
    if (!s) {
      this._flag = !1;
      return;
    }
    var o = 0, a = 0, l = 0, c = 0;
    if (s === document.body)
      l = window.innerWidth, c = window.innerHeight;
    else {
      var u = s.getBoundingClientRect();
      o = u.top, a = u.left, l = u.width, c = u.height;
    }
    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {
      top: o,
      left: a,
      width: l,
      height: c
    }, this._prevScrollPos = this._getScrollPosition([0, 0], i), this._currentOptions = i, this._registerScrollEvent(i);
  }, n.drag = function(r, i) {
    if (clearTimeout(this._timer), !!this._flag) {
      var s = r.clientX, o = r.clientY, a = i.threshold, l = a === void 0 ? 0 : a, c = this, u = c._startRect, d = c._startPos;
      this._currentOptions = i;
      var f = [0, 0];
      return u.top > o - l ? (d[1] > u.top || o < d[1]) && (f[1] = -1) : u.top + u.height < o + l && (d[1] < u.top + u.height || o > d[1]) && (f[1] = 1), u.left > s - l ? (d[0] > u.left || s < d[0]) && (f[0] = -1) : u.left + u.width < s + l && (d[0] < u.left + u.width || s > d[0]) && (f[0] = 1), !f[0] && !f[1] ? !1 : this._continueDrag(Xl(Xl({}, i), {
        direction: f,
        inputEvent: r,
        isDrag: !0
      }));
    }
  }, n.checkScroll = function(r) {
    var i = this;
    if (this._isWait)
      return !1;
    var s = r.prevScrollPos, o = s === void 0 ? this._prevScrollPos : s, a = r.direction, l = r.throttleTime, c = l === void 0 ? 0 : l, u = r.inputEvent, d = r.isDrag, f = this._getScrollPosition(a || [0, 0], r), h = f[0] - o[0], p = f[1] - o[1], g = a || [h ? Math.abs(h) / h : 0, p ? Math.abs(p) / p : 0];
    return this._prevScrollPos = f, this._lock = !1, !h && !p ? !1 : (this.emit("move", {
      offsetX: g[0] ? h : 0,
      offsetY: g[1] ? p : 0,
      inputEvent: u
    }), c && d && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {
      i._continueDrag(r);
    }, c)), !0);
  }, n.dragEnd = function() {
    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();
  }, n._getScrollPosition = function(r, i) {
    var s = i.container, o = i.getScrollPosition, a = o === void 0 ? $Z : o;
    return a({
      container: Ih(s),
      direction: r
    });
  }, n._continueDrag = function(r) {
    var i = this, s, o = r.container, a = r.direction, l = r.throttleTime, c = r.useScroll, u = r.isDrag, d = r.inputEvent;
    if (!(!this._flag || u && this._isWait)) {
      var f = Jd(), h = Math.max(l + this._prevTime - f, 0);
      if (h > 0)
        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {
          i._continueDrag(r);
        }, h), !1;
      this._prevTime = f;
      var p = this._getScrollPosition(a, r);
      this._prevScrollPos = p, u && (this._isWait = !0), c || (this._lock = !0);
      var g = {
        container: Ih(o),
        direction: a,
        inputEvent: d
      };
      return (s = r.requestScroll) === null || s === void 0 || s.call(r, g), this.emit("scroll", g), this._isWait = !1, c || this.checkScroll(Xl(Xl({}, r), {
        prevScrollPos: p,
        direction: a,
        inputEvent: d
      }));
    }
  }, n._registerScrollEvent = function(r) {
    this._unregisterScrollEvent();
    var i = r.checkScrollEvent;
    if (i) {
      var s = i === !0 ? AT : i, o = Ih(r.container);
      i === !0 && (o === document.body || o === document.documentElement) ? this._unregister = AT(window, this._onScroll) : this._unregister = s(o, this._onScroll);
    }
  }, n._unregisterScrollEvent = function() {
    var r;
    (r = this._unregister) === null || r === void 0 || r.call(this), this._unregister = null;
  }, e;
}(e0);
const FZ = BZ;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function zZ() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), i = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      r[i] = s[o];
  return r;
}
function ir(t) {
  return tt(t, tn);
}
function HZ(t, e) {
  return t.every(function(n, r) {
    return ir(n - e[r]) === 0;
  });
}
function UZ(t, e) {
  return !ir(t[0] - e[0]) && !ir(t[1] - e[1]);
}
function _P(t) {
  return t.length < 3 ? 0 : Math.abs(UJ(t.map(function(e, n) {
    var r = t[n + 1] || t[0];
    return e[0] * r[1] - r[0] * e[1];
  }))) / 2;
}
function NT(t, e) {
  var n = e.width, r = e.height, i = e.left, s = e.top, o = tl(t), a = o.minX, l = o.minY, c = o.maxX, u = o.maxY, d = n / (c - a), f = r / (u - l);
  return t.map(function(h) {
    return [i + (h[0] - a) * d, s + (h[1] - l) * f];
  });
}
function tl(t) {
  var e = t.map(function(r) {
    return r[0];
  }), n = t.map(function(r) {
    return r[1];
  });
  return {
    minX: Math.min.apply(Math, e),
    minY: Math.min.apply(Math, n),
    maxX: Math.max.apply(Math, e),
    maxY: Math.max.apply(Math, n)
  };
}
function E1(t, e, n) {
  var r = t[0], i = t[1], s = tl(e), o = s.minX, a = s.maxX, l = [[o, i], [a, i]], c = $g(l[0], l[1]), u = S1(e), d = [];
  if (u.forEach(function(p) {
    var g = $g(p[0], p[1]), m = p[0];
    if (HZ(c, g))
      d.push({
        pos: t,
        line: p,
        type: "line"
      });
    else {
      var v = EP(CE(c, g), [l, p]);
      v.forEach(function(y) {
        p.some(function(E) {
          return UZ(E, y);
        }) ? d.push({
          pos: y,
          line: p,
          type: "point"
        }) : ir(m[1] - i) !== 0 && d.push({
          pos: y,
          line: p,
          type: "intersection"
        });
      });
    }
  }), !n && br(d, function(p) {
    return p[0] === r;
  }))
    return !0;
  var f = 0, h = {};
  return d.forEach(function(p) {
    var g = p.pos, m = p.type, v = p.line;
    if (!(g[0] > r))
      if (m === "intersection")
        ++f;
      else {
        if (m === "line")
          return;
        if (m === "point") {
          var y = br(v, function(_) {
            return _[1] !== i;
          }), E = h[g[0]], b = y[1] > i ? 1 : -1;
          E ? E !== b && ++f : h[g[0]] = b;
        }
      }
  }), f % 2 === 1;
}
function $g(t, e) {
  var n = t[0], r = t[1], i = e[0], s = e[1], o = i - n, a = s - r;
  Math.abs(o) < tn && (o = 0), Math.abs(a) < tn && (a = 0);
  var l = 0, c = 0, u = 0;
  return o ? a ? (l = -a / o, c = 1, u = -l * n - r) : (c = 1, u = -r) : a && (l = -1, u = n), [l, c, u];
}
function CE(t, e) {
  var n = t[0], r = t[1], i = t[2], s = e[0], o = e[1], a = e[2], l = n === 0 && s === 0, c = r === 0 && o === 0, u = [];
  if (l && c)
    return [];
  if (l) {
    var d = -i / r, f = -a / o;
    return d !== f ? [] : [[-1 / 0, d], [1 / 0, d]];
  } else if (c) {
    var h = -i / n, p = -a / s;
    return h !== p ? [] : [[h, -1 / 0], [h, 1 / 0]];
  } else if (n === 0) {
    var g = -i / r, m = -(o * g + a) / s;
    u = [[m, g]];
  } else if (s === 0) {
    var g = -a / o, m = -(r * g + i) / n;
    u = [[m, g]];
  } else if (r === 0) {
    var m = -i / n, g = -(s * m + a) / o;
    u = [[m, g]];
  } else if (o === 0) {
    var m = -a / s, g = -(n * m + i) / r;
    u = [[m, g]];
  } else {
    var m = (r * a - o * i) / (o * n - r * s), g = -(n * m + i) / r;
    u = [[m, g]];
  }
  return u.map(function(v) {
    return [v[0], v[1]];
  });
}
function EP(t, e) {
  var n = e.map(function(d) {
    return [0, 1].map(function(f) {
      return [Math.min(d[0][f], d[1][f]), Math.max(d[0][f], d[1][f])];
    });
  }), r = [];
  if (t.length === 2) {
    var i = t[0], s = i[0], o = i[1];
    if (ir(s - t[1][0])) {
      if (!ir(o - t[1][1])) {
        var c = Math.max.apply(Math, n.map(function(d) {
          return d[0][0];
        })), u = Math.min.apply(Math, n.map(function(d) {
          return d[0][1];
        }));
        if (ir(c - u) > 0)
          return [];
        r = [[c, o], [u, o]];
      }
    } else {
      var a = Math.max.apply(Math, n.map(function(d) {
        return d[1][0];
      })), l = Math.min.apply(Math, n.map(function(d) {
        return d[1][1];
      }));
      if (ir(a - l) > 0)
        return [];
      r = [[s, a], [s, l]];
    }
  }
  return r.length || (r = t.filter(function(d) {
    var f = d[0], h = d[1];
    return n.every(function(p) {
      return 0 <= ir(f - p[0][0]) && 0 <= ir(p[0][1] - f) && 0 <= ir(h - p[1][0]) && 0 <= ir(p[1][1] - h);
    });
  })), r.map(function(d) {
    return [ir(d[0]), ir(d[1])];
  });
}
function S1(t) {
  return zZ(t.slice(1), [t[0]]).map(function(e, n) {
    return [t[n], e];
  });
}
function VZ(t, e) {
  var n = t.slice(), r = e.slice();
  _T(n) === -1 && n.reverse(), _T(r) === -1 && r.reverse();
  var i = S1(n), s = S1(r), o = i.map(function(u) {
    return $g(u[0], u[1]);
  }), a = s.map(function(u) {
    return $g(u[0], u[1]);
  }), l = [];
  o.forEach(function(u, d) {
    var f = i[d], h = [];
    a.forEach(function(p, g) {
      var m = CE(u, p), v = EP(m, [f, s[g]]);
      h.push.apply(h, v.map(function(y) {
        return {
          index1: d,
          index2: g,
          pos: y,
          type: "intersection"
        };
      }));
    }), h.sort(function(p, g) {
      return Bs(f[0], p.pos) - Bs(f[0], g.pos);
    }), l.push.apply(l, h), E1(f[1], r) && l.push({
      index1: d,
      index2: -1,
      pos: f[1],
      type: "inside"
    });
  }), s.forEach(function(u, d) {
    if (E1(u[1], n)) {
      var f = !1, h = Ws(l, function(p) {
        var g = p.index2;
        return g === d ? (f = !0, !1) : !!f;
      });
      h === -1 && (f = !1, h = Ws(l, function(p) {
        var g = p.index1, m = p.index2;
        return g === -1 && m + 1 === d ? (f = !0, !1) : !!f;
      })), h === -1 ? l.push({
        index1: -1,
        index2: d,
        pos: u[1],
        type: "inside"
      }) : l.splice(h, 0, {
        index1: -1,
        index2: d,
        pos: u[1],
        type: "inside"
      });
    }
  });
  var c = {};
  return l.filter(function(u) {
    var d = u.pos, f = d[0] + "x" + d[1];
    return c[f] ? !1 : (c[f] = !0, !0);
  });
}
function WZ(t, e) {
  var n = VZ(t, e);
  return n.map(function(r) {
    var i = r.pos;
    return i;
  });
}
function GZ(t, e) {
  var n = WZ(t, e);
  return _P(n);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var x1 = function(t, e) {
  return x1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      r.hasOwnProperty(i) && (n[i] = r[i]);
  }, x1(t, e);
};
function jZ(t, e) {
  x1(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var en = function() {
  return en = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, en.apply(this, arguments);
};
function qZ(t, e) {
  var n = e[0] - t[0], r = e[1] - t[1], i = Math.atan2(r, n);
  return i >= 0 ? i : i + Math.PI * 2;
}
function Eb(t) {
  return qZ([
    t[0].clientX,
    t[0].clientY
  ], [
    t[1].clientX,
    t[1].clientY
  ]) / Math.PI * 180;
}
function KZ(t) {
  return t.touches && t.touches.length >= 2;
}
function Ph(t) {
  return t ? t.touches ? XZ(t.touches) : [SP(t)] : [];
}
function YZ(t) {
  return t && (t.type.indexOf("mouse") > -1 || "button" in t);
}
function RT(t, e, n) {
  var r = n.length, i = ad(t, r), s = i.clientX, o = i.clientY, a = i.originalClientX, l = i.originalClientY, c = ad(e, r), u = c.clientX, d = c.clientY, f = ad(n, r), h = f.clientX, p = f.clientY, g = s - u, m = o - d, v = s - h, y = o - p;
  return {
    clientX: a,
    clientY: l,
    deltaX: g,
    deltaY: m,
    distX: v,
    distY: y
  };
}
function Sb(t) {
  return Math.sqrt(Math.pow(t[0].clientX - t[1].clientX, 2) + Math.pow(t[0].clientY - t[1].clientY, 2));
}
function XZ(t) {
  for (var e = Math.min(t.length, 2), n = [], r = 0; r < e; ++r)
    n.push(SP(t[r]));
  return n;
}
function SP(t) {
  return {
    clientX: t.clientX,
    clientY: t.clientY
  };
}
function ad(t, e) {
  e === void 0 && (e = t.length);
  for (var n = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, r = Math.min(t.length, e), i = 0; i < r; ++i) {
    var s = t[i];
    n.originalClientX += "originalClientX" in s ? s.originalClientX : s.clientX, n.originalClientY += "originalClientY" in s ? s.originalClientY : s.clientY, n.clientX += s.clientX, n.clientY += s.clientY;
  }
  return e ? {
    clientX: n.clientX / e,
    clientY: n.clientY / e,
    originalClientX: n.originalClientX / e,
    originalClientY: n.originalClientY / e
  } : n;
}
var xb = /* @__PURE__ */ function() {
  function t(e) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;
  }
  return t.prototype.getAngle = function(e) {
    return e === void 0 && (e = this.prevClients), Eb(e);
  }, t.prototype.getRotation = function(e) {
    return e === void 0 && (e = this.prevClients), Eb(e) - Eb(this.startClients);
  }, t.prototype.getPosition = function(e, n) {
    e === void 0 && (e = this.prevClients);
    var r = RT(e || this.prevClients, this.prevClients, this.startClients), i = r.deltaX, s = r.deltaY;
    return this.movement += Math.sqrt(i * i + s * s), this.prevClients = e, r;
  }, t.prototype.getPositions = function(e) {
    e === void 0 && (e = this.prevClients);
    for (var n = this.prevClients, r = this.startClients, i = Math.min(this.length, n.length), s = [], o = 0; o < i; ++o)
      s[o] = RT([e[o]], [n[o]], [r[o]]);
    return s;
  }, t.prototype.getMovement = function(e) {
    var n = this.movement;
    if (!e)
      return n;
    var r = ad(e, this.length), i = ad(this.prevClients, this.length), s = r.clientX - i.clientX, o = r.clientY - i.clientY;
    return Math.sqrt(s * s + o * o) + n;
  }, t.prototype.getDistance = function(e) {
    return e === void 0 && (e = this.prevClients), Sb(e);
  }, t.prototype.getScale = function(e) {
    return e === void 0 && (e = this.prevClients), Sb(e) / Sb(this.startClients);
  }, t.prototype.move = function(e, n) {
    this.startClients.forEach(function(r) {
      r.clientX -= e, r.clientY -= n;
    }), this.prevClients.forEach(function(r) {
      r.clientX -= e, r.clientY -= n;
    });
  }, t;
}(), DT = ["textarea", "input"], JZ = /* @__PURE__ */ function(t) {
  jZ(e, t);
  function e(n, r) {
    r === void 0 && (r = {});
    var i = t.call(this) || this;
    i.options = {}, i.flag = !1, i.pinchFlag = !1, i.data = {}, i.isDrag = !1, i.isPinch = !1, i.clientStores = [], i.targets = [], i.prevTime = 0, i.doubleFlag = !1, i._useMouse = !1, i._useTouch = !1, i._useDrag = !1, i._dragFlag = !1, i._isTrusted = !1, i._isMouseEvent = !1, i._isSecondaryButton = !1, i._preventMouseEvent = !1, i._prevInputEvent = null, i._isDragAPI = !1, i._isIdle = !0, i._preventMouseEventId = 0, i._window = window, i.onDragStart = function(f, h) {
      if (h === void 0 && (h = !0), !(!i.flag && f.cancelable === !1)) {
        var p = f.type.indexOf("drag") >= -1;
        if (!(i.flag && p)) {
          i._isDragAPI = !0;
          var g = i.options, m = g.container, v = g.pinchOutside, y = g.preventWheelClick, E = g.preventRightClick, b = g.preventDefault, _ = g.checkInput, w = g.dragFocusedInput, S = g.preventClickEventOnDragStart, x = g.preventClickEventOnDrag, k = g.preventClickEventByCondition, T = i._useTouch, I = !i.flag;
          if (i._isSecondaryButton = f.which === 3 || f.button === 2, y && (f.which === 2 || f.button === 1) || E && (f.which === 3 || f.button === 2))
            return i.stop(), !1;
          if (I) {
            var R = i._window.document.activeElement, N = f.target;
            if (N) {
              var $ = N.tagName.toLowerCase(), B = DT.indexOf($) > -1, G = N.isContentEditable;
              if (B || G) {
                if (_ || !w && R === N)
                  return !1;
                if (R && (R === N || G && R.isContentEditable && R.contains(N)))
                  if (w)
                    N.blur();
                  else
                    return !1;
              } else if ((b || f.type === "touchstart") && R) {
                var M = R.tagName.toLowerCase();
                (R.isContentEditable || DT.indexOf(M) > -1) && R.blur();
              }
              (S || x || k) && kn(i._window, "click", i._onClick, !0);
            }
            i.clientStores = [new xb(Ph(f))], i._isIdle = !1, i.flag = !0, i.isDrag = !1, i._isTrusted = h, i._dragFlag = !0, i._prevInputEvent = f, i.data = {}, i.doubleFlag = Jd() - i.prevTime < 200, i._isMouseEvent = YZ(f), !i._isMouseEvent && i._preventMouseEvent && i._allowMouseEvent();
            var A = i._preventMouseEvent || i.emit("dragStart", en(en({ data: i.data, datas: i.data, inputEvent: f, isMouseEvent: i._isMouseEvent, isSecondaryButton: i._isSecondaryButton, isTrusted: h, isDouble: i.doubleFlag }, i.getCurrentStore().getPosition()), { preventDefault: function() {
              f.preventDefault();
            }, preventDrag: function() {
              i._dragFlag = !1;
            } }));
            A === !1 && i.stop(), i._isMouseEvent && i.flag && b && f.preventDefault();
          }
          if (!i.flag)
            return !1;
          var z = 0;
          if (I ? (i._attchDragEvent(), T && v && (z = setTimeout(function() {
            kn(m, "touchstart", i.onDragStart, {
              passive: !1
            });
          }))) : T && v && ln(m, "touchstart", i.onDragStart), i.flag && KZ(f)) {
            if (clearTimeout(z), I && f.touches.length !== f.changedTouches.length)
              return;
            i.pinchFlag || i.onPinchStart(f);
          }
        }
      }
    }, i.onDrag = function(f, h) {
      if (i.flag) {
        var p = i.options.preventDefault;
        !i._isMouseEvent && p && f.preventDefault(), i._prevInputEvent = f;
        var g = Ph(f), m = i.moveClients(g, f, !1);
        if (i._dragFlag) {
          if (i.pinchFlag || m.deltaX || m.deltaY) {
            var v = i._preventMouseEvent || i.emit("drag", en(en({}, m), { isScroll: !!h, inputEvent: f }));
            if (v === !1) {
              i.stop();
              return;
            }
          }
          i.pinchFlag && i.onPinch(f, g);
        }
        i.getCurrentStore().getPosition(g, !0);
      }
    }, i.onDragEnd = function(f) {
      if (i.flag) {
        var h = i.options, p = h.pinchOutside, g = h.container, m = h.preventClickEventOnDrag, v = h.preventClickEventOnDragStart, y = h.preventClickEventByCondition, E = i.isDrag;
        (m || v || y) && requestAnimationFrame(function() {
          i._allowClickEvent();
        }), !y && !v && m && !E && i._allowClickEvent(), i._useTouch && p && ln(g, "touchstart", i.onDragStart), i.pinchFlag && i.onPinchEnd(f);
        var b = f != null && f.touches ? Ph(f) : [], _ = b.length;
        _ === 0 || !i.options.keepDragging ? i.flag = !1 : i._addStore(new xb(b));
        var w = i._getPosition(), S = Jd(), x = !E && i.doubleFlag;
        i._prevInputEvent = null, i.prevTime = E || x ? 0 : S, i.flag || (i._dettachDragEvent(), i._preventMouseEvent || i.emit("dragEnd", en({ data: i.data, datas: i.data, isDouble: x, isDrag: E, isClick: !E, isMouseEvent: i._isMouseEvent, isSecondaryButton: i._isSecondaryButton, inputEvent: f, isTrusted: i._isTrusted }, w)), i.clientStores = [], i._isMouseEvent || (i._preventMouseEvent = !0, clearTimeout(i._preventMouseEventId), i._preventMouseEventId = setTimeout(function() {
          i._preventMouseEvent = !1;
        }, 200)), i._isIdle = !0);
      }
    }, i.onBlur = function() {
      i.onDragEnd();
    }, i._allowClickEvent = function() {
      ln(i._window, "click", i._onClick, !0);
    }, i._onClick = function(f) {
      i._allowClickEvent(), i._allowMouseEvent();
      var h = i.options.preventClickEventByCondition;
      h != null && h(f) || (f.stopPropagation(), f.preventDefault());
    }, i._onContextMenu = function(f) {
      var h = i.options;
      h.preventRightClick ? i.onDragEnd(f) : f.preventDefault();
    }, i._passCallback = function() {
    };
    var s = [].concat(n), o = s[0];
    i._window = J2(o) ? o : Co(o), i.options = en({ checkInput: !1, container: o && !("document" in o) ? Co(o) : o, preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, r);
    var a = i.options, l = a.container, c = a.events, u = a.checkWindowBlur;
    if (i._useDrag = c.indexOf("drag") > -1, i._useTouch = c.indexOf("touch") > -1, i._useMouse = c.indexOf("mouse") > -1, i.targets = s, i._useDrag && s.forEach(function(f) {
      kn(f, "dragstart", i.onDragStart);
    }), i._useMouse && (s.forEach(function(f) {
      kn(f, "mousedown", i.onDragStart), kn(f, "mousemove", i._passCallback);
    }), kn(l, "contextmenu", i._onContextMenu)), u && kn(Co(), "blur", i.onBlur), i._useTouch) {
      var d = {
        passive: !1
      };
      s.forEach(function(f) {
        kn(f, "touchstart", i.onDragStart, d), kn(f, "touchmove", i._passCallback, d);
      });
    }
    return i;
  }
  return e.prototype.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._isIdle = !0, this._allowClickEvent(), this._dettachDragEvent(), this._isDragAPI = !1;
  }, e.prototype.getMovement = function(n) {
    return this.getCurrentStore().getMovement(n) + this.clientStores.slice(1).reduce(function(r, i) {
      return r + i.movement;
    }, 0);
  }, e.prototype.isDragging = function() {
    return this.isDrag;
  }, e.prototype.isIdle = function() {
    return this._isIdle;
  }, e.prototype.isFlag = function() {
    return this.flag;
  }, e.prototype.isPinchFlag = function() {
    return this.pinchFlag;
  }, e.prototype.isDoubleFlag = function() {
    return this.doubleFlag;
  }, e.prototype.isPinching = function() {
    return this.isPinch;
  }, e.prototype.scrollBy = function(n, r, i, s) {
    s === void 0 && (s = !0), this.flag && (this.clientStores[0].move(n, r), s && this.onDrag(i, !0));
  }, e.prototype.move = function(n, r) {
    var i = n[0], s = n[1], o = this.getCurrentStore(), a = o.prevClients;
    return this.moveClients(a.map(function(l) {
      var c = l.clientX, u = l.clientY;
      return {
        clientX: c + i,
        clientY: u + s,
        originalClientX: c,
        originalClientY: u
      };
    }), r, !0);
  }, e.prototype.triggerDragStart = function(n) {
    this.onDragStart(n, !1);
  }, e.prototype.setEventData = function(n) {
    var r = this.data;
    for (var i in n)
      r[i] = n[i];
    return this;
  }, e.prototype.setEventDatas = function(n) {
    return this.setEventData(n);
  }, e.prototype.getCurrentEvent = function(n) {
    return n === void 0 && (n = this._prevInputEvent), en(en({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: n });
  }, e.prototype.getEventData = function() {
    return this.data;
  }, e.prototype.getEventDatas = function() {
    return this.data;
  }, e.prototype.unset = function() {
    var n = this, r = this.targets, i = this.options.container;
    this.off(), ln(this._window, "blur", this.onBlur), this._useDrag && r.forEach(function(s) {
      ln(s, "dragstart", n.onDragStart);
    }), this._useMouse && (r.forEach(function(s) {
      ln(s, "mousedown", n.onDragStart);
    }), ln(i, "contextmenu", this._onContextMenu)), this._useTouch && (r.forEach(function(s) {
      ln(s, "touchstart", n.onDragStart);
    }), ln(i, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();
  }, e.prototype.onPinchStart = function(n) {
    var r = this, i = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > i)) {
      var s = new xb(Ph(n));
      this.pinchFlag = !0, this._addStore(s);
      var o = this.emit("pinchStart", en(en({ data: this.data, datas: this.data, angle: s.getAngle(), touches: this.getCurrentStore().getPositions() }, s.getPosition()), { inputEvent: n, isTrusted: this._isTrusted, preventDefault: function() {
        n.preventDefault();
      }, preventDrag: function() {
        r._dragFlag = !1;
      } }));
      o === !1 && (this.pinchFlag = !1);
    }
  }, e.prototype.onPinch = function(n, r) {
    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {
      var i = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", en(en({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: i.getAngle(r), rotation: i.getRotation(r), touches: i.getPositions(r), scale: i.getScale(r), distance: i.getDistance(r) }, i.getPosition(r)), { inputEvent: n, isTrusted: this._isTrusted }));
    }
  }, e.prototype.onPinchEnd = function(n) {
    if (this.pinchFlag) {
      var r = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var i = this.getCurrentStore();
      this.emit("pinchEnd", en(en({ data: this.data, datas: this.data, isPinch: r, touches: i.getPositions() }, i.getPosition()), { inputEvent: n }));
    }
  }, e.prototype.getCurrentStore = function() {
    return this.clientStores[0];
  }, e.prototype.moveClients = function(n, r, i) {
    var s = this._getPosition(n, i), o = this.isDrag;
    (s.deltaX || s.deltaY) && (this.isDrag = !0);
    var a = !1;
    return !o && this.isDrag && (a = !0), en(en({ data: this.data, datas: this.data }, s), { movement: this.getMovement(n), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: a });
  }, e.prototype._addStore = function(n) {
    this.clientStores.splice(0, 0, n);
  }, e.prototype._getPosition = function(n, r) {
    var i = this.getCurrentStore(), s = i.getPosition(n, r), o = this.clientStores.slice(1).reduce(function(c, u) {
      var d = u.getPosition();
      return c.distX += d.distX, c.distY += d.distY, c;
    }, s), a = o.distX, l = o.distY;
    return en(en({}, s), { distX: a, distY: l });
  }, e.prototype._attchDragEvent = function() {
    var n = this._window, r = this.options.container, i = {
      passive: !1
    };
    this._isDragAPI && (kn(r, "dragover", this.onDrag, i), kn(n, "dragend", this.onDragEnd)), this._useMouse && (kn(r, "mousemove", this.onDrag), kn(n, "mouseup", this.onDragEnd)), this._useTouch && (kn(r, "touchmove", this.onDrag, i), kn(n, "touchend", this.onDragEnd, i), kn(n, "touchcancel", this.onDragEnd, i));
  }, e.prototype._dettachDragEvent = function() {
    var n = this._window, r = this.options.container;
    this._isDragAPI && (ln(r, "dragover", this.onDrag), ln(n, "dragend", this.onDragEnd)), this._useMouse && (ln(r, "mousemove", this.onDrag), ln(n, "mouseup", this.onDragEnd)), this._useTouch && (ln(r, "touchstart", this.onDragStart), ln(r, "touchmove", this.onDrag), ln(n, "touchend", this.onDragEnd), ln(n, "touchcancel", this.onDragEnd));
  }, e.prototype._allowMouseEvent = function() {
    this._preventMouseEvent = !1, clearTimeout(this._preventMouseEventId);
  }, e;
}(e0);
function ZZ(t) {
  for (var e = 5381, n = t.length; n; )
    e = e * 33 ^ t.charCodeAt(--n);
  return e >>> 0;
}
var QZ = ZZ;
function eQ(t) {
  return QZ(t).toString(36);
}
function tQ(t) {
  if (t && t.getRootNode) {
    var e = t.getRootNode();
    if (e.nodeType === 11)
      return e;
  }
}
function nQ(t, e, n) {
  return n.original ? e : e.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(r, i) {
    var s = i.trim();
    return (s ? ga(s) : [""]).map(function(o) {
      var a = o.trim();
      return a.indexOf("@") === 0 ? a : a.indexOf(":global") > -1 ? a.replace(/\:global/g, "") : a.indexOf(":host") > -1 ? "".concat(a.replace(/\:host/g, ".".concat(t))) : a ? ".".concat(t, " ").concat(a) : ".".concat(t);
    }).join(", ") + " {";
  });
}
function rQ(t, e, n, r, i) {
  var s = tu(r), o = s.createElement("style");
  return o.setAttribute("type", "text/css"), o.setAttribute("data-styled-id", t), o.setAttribute("data-styled-count", "1"), n.nonce && o.setAttribute("nonce", n.nonce), o.innerHTML = nQ(t, e, n), (i || s.head || s.body).appendChild(o), o;
}
function iQ(t) {
  var e = "rCS" + eQ(t);
  return {
    className: e,
    inject: function(n, r) {
      r === void 0 && (r = {});
      var i = tQ(n), s = (i || n.ownerDocument || document).querySelector('style[data-styled-id="'.concat(e, '"]'));
      if (!s)
        s = rQ(e, t, r, n, i);
      else {
        var o = parseFloat(s.getAttribute("data-styled-count")) || 0;
        s.setAttribute("data-styled-count", "".concat(o + 1));
      }
      return {
        destroy: function() {
          var a, l = parseFloat(s.getAttribute("data-styled-count")) || 0;
          l <= 1 ? (s.remove ? s.remove() : (a = s.parentNode) === null || a === void 0 || a.removeChild(s), s = null) : s.setAttribute("data-styled-count", "".concat(l - 1));
        }
      };
    }
  };
}
var k1 = function() {
  return k1 = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, k1.apply(this, arguments);
};
function sQ(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function xP(t, e) {
  var n = iQ(e), r = n.className;
  return tZ(function(i, s) {
    var o = i.className, a = o === void 0 ? "" : o;
    i.cspNonce;
    var l = sQ(i, ["className", "cspNonce"]), c = pZ();
    return gZ(s, function() {
      return c.current;
    }, []), lP(function() {
      var u = n.inject(c.current, {
        nonce: i.cspNonce
      });
      return function() {
        u.destroy();
      };
    }, []), ki(t, k1({
      ref: c,
      "data-styled-id": r,
      className: "".concat(a, " ").concat(r)
    }, l));
  });
}
var C1 = function(t, e) {
  return C1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, C1(t, e);
};
function Yf(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  C1(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var L = function() {
  return L = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, L.apply(this, arguments);
};
function oQ(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function aQ(t, e, n, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var a = t.length - 1; a >= 0; a--)
      (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
  return i > 3 && s && Object.defineProperty(e, n, s), s;
}
function lQ(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function F(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
      s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function he(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
function Xf(t, e) {
  return L({ events: [], props: [], name: t }, e);
}
var cQ = ["n", "w", "s", "e"], TE = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
function uQ(t, e) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(32 * t, 'px" height="').concat(32 * t, 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(').concat(e, 'deg);transform-origin: 16px 16px"></path></svg>');
}
function dQ(t) {
  var e = uQ(1, t), n = Math.round(t / 45) * 45 % 180, r = "ns-resize";
  return n === 135 ? r = "nwse-resize" : n === 45 ? r = "nesw-resize" : n === 90 && (r = "ew-resize"), "cursor:".concat(r, ";cursor: url('").concat(e, "') 16 16, ").concat(r, ";");
}
var ru = wZ(), kP = ru.browser.webkit, CP = kP && function() {
  var t = typeof window > "u" ? { userAgent: "" } : window.navigator, e = /applewebkit\/([^\s]+)/g.exec(t.userAgent.toLowerCase());
  return e ? parseFloat(e[1]) < 605 : !1;
}(), TP = ru.browser.name, OP = parseInt(ru.browser.version, 10), fQ = TP === "chrome", hQ = ru.browser.chromium, pQ = parseInt(ru.browser.chromiumVersion, 10) || 0, gQ = fQ && OP >= 109 || hQ && pQ >= 109, mQ = TP === "firefox", vQ = parseInt(ru.browser.webkitVersion, 10) >= 612 || OP >= 15, OE = "moveable-", bQ = TE.map(function(t) {
  var e = "", n = "", r = "center", i = "center", s = "calc(var(--moveable-control-padding, 20) * -1px)";
  return t.indexOf("n") > -1 && (e = "top: ".concat(s, ";"), i = "bottom"), t.indexOf("s") > -1 && (e = "top: 0px;", i = "top"), t.indexOf("w") > -1 && (n = "left: ".concat(s, ";"), r = "right"), t.indexOf("e") > -1 && (n = "left: 0px;", r = "left"), '.around-control[data-direction*="'.concat(t, `"] {
        `).concat(n).concat(e, `
        transform-origin: `).concat(r, " ").concat(i, `;
    }`);
}).join(`
`), yQ = `
{
position: absolute;
width: 1px;
height: 1px;
left: 0;
top: 0;
z-index: 3000;
--moveable-color: #4af;
--zoom: 1;
--zoompx: 1px;
--moveable-line-padding: 0;
--moveable-control-padding: 0;
will-change: transform;
outline: 1px solid transparent;
}
.control-box {
z-index: 0;
}
.line, .control {
position: absolute;
left: 0;
top: 0;
will-change: transform;
}
.control {
width: 14px;
height: 14px;
border-radius: 50%;
border: 2px solid #fff;
box-sizing: border-box;
background: #4af;
background: var(--moveable-color);
margin-top: -7px;
margin-left: -7px;
border: 2px solid #fff;
z-index: 10;
}
.around-control {
position: absolute;
will-change: transform;
width: calc(var(--moveable-control-padding, 20) * 1px);
height: calc(var(--moveable-control-padding, 20) * 1px);
left: calc(var(--moveable-control-padding, 20) * -0.5px);
top: calc(var(--moveable-control-padding, 20) * -0.5px);
box-sizing: border-box;
background: transparent;
z-index: 8;
cursor: alias;
transform-origin: center center;
}
`.concat(bQ, `
.padding {
position: absolute;
top: 0px;
left: 0px;
width: 100px;
height: 100px;
transform-origin: 0 0;
}
.line {
width: 1px;
height: 1px;
background: #4af;
background: var(--moveable-color);
transform-origin: 0px 50%;
}
.line.edge {
z-index: 1;
background: transparent;
}
.line.dashed {
box-sizing: border-box;
background: transparent;
}
.line.dashed.horizontal {
border-top: 1px dashed #4af;
border-top-color: #4af;
border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
border-left: 1px dashed #4af;
border-left-color: #4af;
border-left-color: var(--moveable-color);
}
.line.vertical {
transform: translateX(-50%);
}
.line.horizontal {
transform: translateY(-50%);
}
.line.vertical.bold {
width: 2px;
}
.line.horizontal.bold {
height: 2px;
}

.control.origin {
border-color: #f55;
background: #fff;
width: 12px;
height: 12px;
margin-top: -6px;
margin-left: -6px;
pointer-events: none;
}
`).concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(t) {
  return `
.direction[data-rotation="`.concat(t, '"], :global .view-control-rotation').concat(t, ` {
`).concat(dQ(t), `
}
`);
}).join(`
`), `

.line.direction:before {
content: "";
position: absolute;
width: 100%;
height: calc(var(--moveable-line-padding, 0) * 1px);
bottom: 0;
left: 0;
}
.group {
z-index: -1;
}
.area {
position: absolute;
}
.area-pieces {
position: absolute;
top: 0;
left: 0;
display: none;
}
.area.avoid, .area.pass {
pointer-events: none;
}
.area.avoid+.area-pieces {
display: block;
}
.area-piece {
position: absolute;
}

`).concat(CP ? `:global svg *:before {
content:"";
transform-origin: inherit;
}` : "", `
`), wQ = [
  [0, 1, 2],
  [1, 0, 3],
  [2, 0, 3],
  [3, 1, 2]
], T1 = 1e-4, rr = 1e-7, Lh = 1e-9, O1 = Math.pow(10, 10), IT = -O1, _Q = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, ME = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, MP = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, AP = [
  "isMoveableElement",
  "updateRect",
  "updateTarget",
  "destroy",
  "dragStart",
  "isInside",
  "hitTest",
  "setState",
  "getRect",
  "request",
  "isDragging",
  "getManager",
  "forceUpdate",
  "waitToChangeTarget",
  "updateSelectors",
  "getTargets",
  "stopDrag",
  "getControlBoxElement",
  "getMoveables",
  "getDragElement"
];
function Jf(t, e, n, r, i, s) {
  var o, a;
  s === void 0 && (s = "draggable");
  var l = (a = (o = e.gestos[s]) === null || o === void 0 ? void 0 : o.move(n, t.inputEvent)) !== null && a !== void 0 ? a : {}, c = l.originalDatas || l.datas, u = c[s] || (c[s] = {});
  return L(L({}, i ? bL(e, l) : l), { isPinch: !!r, parentEvent: !0, datas: u, originalDatas: t.originalDatas });
}
var zc = /* @__PURE__ */ function() {
  function t(e) {
    var n;
    e === void 0 && (e = "draggable"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {
      draggable: {}
    }, this.datas = (n = {}, n[e] = {}, n);
  }
  return t.prototype.dragStart = function(e, n) {
    this.isDrag = !1, this.isFlag = !1;
    var r = n.originalDatas;
    return this.datas = r, r[this.ableName] || (r[this.ableName] = {}), L(L({}, this.move(e, n.inputEvent)), { type: "dragstart" });
  }, t.prototype.drag = function(e, n) {
    return this.move([
      e[0] - this.prevX,
      e[1] - this.prevY
    ], n);
  }, t.prototype.move = function(e, n) {
    var r, i, s = !1;
    if (!this.isFlag)
      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], r = e[0], i = e[1], this.isFlag = !0;
    else {
      var o = this.isDrag;
      r = this.prevX + e[0], i = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !o && this.isDrag && (s = !0);
    }
    return this.prevX = r, this.prevY = i, {
      type: "drag",
      clientX: r,
      clientY: i,
      inputEvent: n,
      isFirstDrag: s,
      isDrag: this.isDrag,
      distX: r - this.startX,
      distY: i - this.startY,
      deltaX: e[0],
      deltaY: e[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }, t;
}();
function ac(t, e, n, r) {
  var i = t.length === 16, s = i ? 4 : 3, o = gl(t, n, r, s), a = F(o, 4), l = F(a[0], 2), c = l[0], u = l[1], d = F(a[1], 2), f = d[0], h = d[1], p = F(a[2], 2), g = p[0], m = p[1], v = F(a[3], 2), y = v[0], E = v[1], b = F(qt(t, e, s), 2), _ = b[0], w = b[1], S = Math.min(c, f, g, y), x = Math.min(u, h, m, E), k = Math.max(c, f, g, y), T = Math.max(u, h, m, E);
  c = c - S || 0, f = f - S || 0, g = g - S || 0, y = y - S || 0, u = u - x || 0, h = h - x || 0, m = m - x || 0, E = E - x || 0, _ = _ - S || 0, w = w - x || 0;
  var I = t[0], R = t[s + 1], N = Kn(I * R);
  return {
    left: S,
    top: x,
    right: k,
    bottom: T,
    origin: [_, w],
    pos1: [c, u],
    pos2: [f, h],
    pos3: [g, m],
    pos4: [y, E],
    direction: N
  };
}
function NP(t, e) {
  var n = e.clientX, r = e.clientY, i = e.datas, s = t.state, o = s.moveableClientRect, a = s.rootMatrix, l = s.is3d, c = s.pos1, u = o.left, d = o.top, f = l ? 4 : 3, h = F(Ke(Vc(a, [n - u, r - d], f), c), 2), p = h[0], g = h[1], m = F(ms({ datas: i, distX: p, distY: g }), 2), v = m[0], y = m[1];
  return [v, y];
}
function pl(t, e) {
  var n = e.datas, r = t.state, i = r.allMatrix, s = r.beforeMatrix, o = r.is3d, a = r.left, l = r.top, c = r.origin, u = r.offsetMatrix, d = r.targetMatrix, f = r.transformOrigin, h = o ? 4 : 3;
  n.is3d = o, n.matrix = i, n.targetMatrix = d, n.beforeMatrix = s, n.offsetMatrix = u, n.transformOrigin = f, n.inverseMatrix = us(i, h), n.inverseBeforeMatrix = us(s, h), n.absoluteOrigin = Qa(wt([a, l], c), h), n.startDragBeforeDist = Bn(n.inverseBeforeMatrix, n.absoluteOrigin, h), n.startDragDist = Bn(n.inverseMatrix, n.absoluteOrigin, h);
}
function EQ(t) {
  return ac(t.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function t0(t, e, n) {
  var r = e.datas, i = e.originalDatas.beforeRenderable, s = r.transformIndex, o = i.nextTransforms, a = o.length, l = i.nextTransformAppendedIndexes, c = -1;
  s === -1 ? (n === "translate" ? c = 0 : n === "rotate" && (c = Ws(o, function(h) {
    return h.match(/scale\(/g);
  })), c === -1 && (c = o.length), r.transformIndex = c) : br(l, function(h) {
    return h.index === s && h.functionName === n;
  }) ? c = s : c = s + l.filter(function(h) {
    return h.index < s;
  }).length;
  var u = qee(o, t.state, c), d = u.targetFunction, f = n === "rotate" ? "rotateZ" : n;
  r.beforeFunctionTexts = u.beforeFunctionTexts, r.afterFunctionTexts = u.afterFunctionTexts, r.beforeTransform = u.beforeFunctionMatrix, r.beforeTransform2 = u.beforeFunctionMatrix2, r.targetTansform = u.targetFunctionMatrix, r.afterTransform = u.afterFunctionMatrix, r.afterTransform2 = u.afterFunctionMatrix2, r.targetAllTransform = u.allFunctionMatrix, d.functionName === f ? (r.afterFunctionTexts.splice(0, 1), r.isAppendTransform = !1) : a > c && (r.isAppendTransform = !0, i.nextTransformAppendedIndexes = he(he([], F(l), !1), [{
    functionName: n,
    index: c,
    isAppend: !0
  }], !1));
}
function n0(t, e, n) {
  return "".concat(t.beforeFunctionTexts.join(" "), " ").concat(t.isAppendTransform ? n : e, " ").concat(t.afterFunctionTexts.join(" "));
}
function SQ(t) {
  var e = t.datas, n = t.distX, r = t.distY, i = F(DP({ datas: e, distX: n, distY: r }), 2), s = i[0], o = i[1], a = RP(e, kZ([s, o], 4));
  return Bn(a, Qa([0, 0, 0], 4), 4);
}
function RP(t, e, n) {
  var r = t.beforeTransform, i = t.afterTransform, s = t.beforeTransform2, o = t.afterTransform2, a = t.targetAllTransform, l = n ? Mt(a, e, 4) : Mt(e, a, 4), c = Mt(us(n ? s : r, 4), l, 4), u = Mt(c, us(n ? o : i, 4), 4);
  return u;
}
function DP(t) {
  var e = t.datas, n = t.distX, r = t.distY, i = e.inverseBeforeMatrix, s = e.is3d, o = e.startDragBeforeDist, a = e.absoluteOrigin, l = s ? 4 : 3;
  return Ke(Bn(i, wt(a, [n, r]), l), o);
}
function ms(t, e) {
  var n = t.datas, r = t.distX, i = t.distY, s = n.inverseBeforeMatrix, o = n.inverseMatrix, a = n.is3d, l = n.startDragBeforeDist, c = n.startDragDist, u = n.absoluteOrigin, d = a ? 4 : 3;
  return Ke(Bn(e ? s : o, wt(u, [r, i]), d), e ? l : c);
}
function xQ(t, e) {
  var n = t.datas, r = t.distX, i = t.distY, s = n.beforeMatrix, o = n.matrix, a = n.is3d, l = n.startDragBeforeDist, c = n.startDragDist, u = n.absoluteOrigin, d = a ? 4 : 3;
  return Ke(Bn(e ? s : o, wt(e ? l : c, [r, i]), d), u);
}
function kQ(t, e, n, r, i, s) {
  return r === void 0 && (r = e), i === void 0 && (i = n), s === void 0 && (s = [0, 0]), t ? t.map(function(o, a) {
    var l = Vf(o), c = l.value, u = l.unit, d = a ? i : r, f = a ? n : e;
    if (o === "%" || isNaN(c)) {
      var h = d ? s[a] / d : 0;
      return f * h;
    } else if (u !== "%")
      return c;
    return f * c / 100;
  }) : s;
}
function IP(t) {
  var e = [];
  return t[1] >= 0 && (t[0] >= 0 && e.push(3), t[0] <= 0 && e.push(2)), t[1] <= 0 && (t[0] >= 0 && e.push(1), t[0] <= 0 && e.push(0)), e;
}
function CQ(t, e) {
  return IP(e).map(function(n) {
    return t[n];
  });
}
function kb(t, e) {
  var n = (e + 1) / 2;
  return [
    Ig(t[0][0], t[1][0], n, 1 - n),
    Ig(t[0][1], t[1][1], n, 1 - n)
  ];
}
function hn(t, e) {
  var n = kb([t[0], t[1]], e[0]), r = kb([t[2], t[3]], e[0]);
  return kb([n, r], e[1]);
}
function TQ(t, e, n, r, i, s) {
  var o = gl(e, n, r, i), a = hn(o, s), l = t[0] - a[0], c = t[1] - a[1];
  return [l, c];
}
function Zf(t, e, n, r) {
  return Mt(t, cd(e, r, n), r);
}
function OQ(t, e, n, r) {
  var i = t.transformOrigin, s = t.offsetMatrix, o = t.is3d, a = o ? 4 : 3, l;
  if (vr(n)) {
    var c = e.beforeTransform, u = e.afterTransform;
    r ? l = Ri(Qd(n), 4, a) : l = Ri(Mt(Mt(c, Qd([n]), 4), u, 4), 4, a);
  } else
    l = n;
  return Zf(s, l, i, a);
}
function MQ(t, e) {
  var n = t.transformOrigin, r = t.offsetMatrix, i = t.is3d, s = t.targetMatrix, o = t.targetAllTransform, a = i ? 4 : 3;
  return Zf(r, Mt(o || s, xE(e, a), a), n, a);
}
function r0(t, e) {
  var n = iu(e);
  return {
    setTransform: function(r, i) {
      i === void 0 && (i = -1), n.startTransforms = rn(r) ? r : Do(r), M1(t, e, i);
    },
    setTransformIndex: function(r) {
      M1(t, e, r);
    }
  };
}
function i0(t, e, n) {
  var r = iu(e), i = r.startTransforms;
  M1(t, e, Ws(i, function(s) {
    return s.indexOf("".concat(n, "(")) === 0;
  }));
}
function M1(t, e, n) {
  var r = iu(e), i = e.datas;
  if (i.transformIndex = n, n !== -1) {
    var s = r.startTransforms[n];
    if (s) {
      var o = t.state, a = Fc([s], {
        "x%": function(l) {
          return l / 100 * o.offsetWidth;
        },
        "y%": function(l) {
          return l / 100 * o.offsetHeight;
        }
      });
      i.startValue = a[0].functionValue;
    }
  }
}
function AE(t, e) {
  var n = iu(t);
  n.nextTransforms = Do(e);
}
function iu(t) {
  return t.originalDatas.beforeRenderable;
}
function Bg(t) {
  var e = t.originalDatas.beforeRenderable;
  return e.nextTransforms;
}
function $h(t) {
  return (Bg(t) || []).join(" ");
}
function Bh(t) {
  return iu(t).nextStyle;
}
function PP(t, e, n, r, i) {
  AE(i, e);
  var s = qn.drag(t, Jf(i, t.state, n, r, !1)), o = s ? s.transform : e;
  return L(L({ transform: e, drag: s }, Jn({
    transform: o
  }, i)), { afterTransform: o });
}
function NE(t, e, n, r, i, s) {
  var o = OQ(t.state, i, e, s), a = RQ(t, n, r, o);
  return a;
}
function LP(t, e, n, r, i, s, o) {
  var a = NE(t, e, n, i, s, o), l = t.state, c = l.left, u = l.top, d = t.props.groupable, f = d ? c : 0, h = d ? u : 0, p = Ke(r, a);
  return Ke(p, [f, h]);
}
function AQ(t, e, n, r, i, s, o) {
  var a = LP(t, e, n, r, i, s, o);
  return a;
}
function NQ(t, e, n) {
  return [
    e ? -1 + t[0] / (e / 2) : 0,
    n ? -1 + t[1] / (n / 2) : 0
  ];
}
function RQ(t, e, n, r) {
  r === void 0 && (r = t.state.allMatrix);
  var i = t.state, s = i.width, o = i.height, a = i.is3d, l = a ? 4 : 3, c = [
    s / 2 * (1 + e[0]) + n[0],
    o / 2 * (1 + e[1]) + n[1]
  ];
  return qt(r, c, l);
}
function DQ(t, e, n) {
  var r = n.fixedDirection, i = n.fixedPosition, s = n.fixedOffset;
  return LP(t, "rotate(".concat(e, "deg)"), r, i, s, n);
}
function IQ(t, e, n, r, i, s) {
  var o = t.props.groupable, a = t.state, l = a.transformOrigin, c = a.offsetMatrix, u = a.is3d, d = a.width, f = a.height, h = a.left, p = a.top, g = s.fixedDirection, m = s.nextTargetMatrix || a.targetMatrix, v = u ? 4 : 3, y = kQ(i, e, n, d, f, l), E = o ? h : 0, b = o ? p : 0, _ = Zf(c, m, y, v), w = TQ(r, _, e, n, v, g);
  return Ke(w, [E, b]);
}
function PQ(t, e) {
  return hn(ui(t.state), e);
}
function LQ(t, e) {
  var n = t.targetGesto, r = t.controlGesto, i;
  return n != null && n.isFlag() && (i = n.getEventData()[e]), !i && (r != null && r.isFlag()) && (i = r.getEventData()[e]), i || {};
}
function $Q(t) {
  if (t && t.getRootNode) {
    var e = t.getRootNode();
    if (e.nodeType === 11)
      return e;
  }
}
function BQ(t) {
  var e = t("scale"), n = t("rotate"), r = t("translate"), i = [];
  return r && r !== "0px" && r !== "none" && i.push("translate(".concat(r.split(/\s+/).join(","), ")")), n && n !== "1" && n !== "none" && i.push("rotate(".concat(n, ")")), e && e !== "1" && e !== "none" && i.push("scale(".concat(e.split(/\s+/).join(","), ")")), i;
}
function $P(t, e, n) {
  for (var r = t, i = [], s = vE(t) || qo(t), o = !n && t === e || t === s, a = o, l = !1, c = 3, u, d, f, h = !1, p = tf(e, e, !0).offsetParent, g = 1; r && !a; ) {
    a = o;
    var m = yr(r), v = m("position"), y = aL(r), E = v === "fixed", b = BQ(m), _ = CZ(Pee(y)), w = void 0, S = !1, x = !1, k = 0, T = 0, I = 0, R = 0, N = {
      hasTransform: !1,
      fixedContainer: null
    };
    E && (h = !0, N = zee(r), p = N.fixedContainer);
    var $ = _.length;
    !l && ($ === 16 || b.length) && (l = !0, c = 4, P1(i), f && (f = Ri(f, 3, 4))), l && $ === 9 && (_ = Ri(_, 3, 4));
    var B = Fee(r, t), G = B.tagName, M = B.hasOffset, A = B.isSVG, z = B.origin, V = B.targetOrigin, U = B.offset, Y = F(U, 2), ne = Y[0], ie = Y[1];
    G === "svg" && !r.ownerSVGElement && f && (i.push({
      type: "target",
      target: r,
      matrix: Hee(r, c)
    }), i.push({
      type: "offset",
      target: r,
      matrix: $t(c)
    }));
    var Z = parseFloat(m("zoom")) || 1;
    if (E)
      w = N.fixedContainer, S = !0;
    else {
      var Q = tf(r, e, !1, !0, m), fe = Q.offsetZoom;
      if (w = Q.offsetParent, S = Q.isEnd, x = Q.isStatic, g *= fe, (Q.isCustomElement || fe !== 1) && x)
        ne -= w.offsetLeft, ie -= w.offsetTop;
      else if (mQ || gQ) {
        var ge = Q.parentSlotElement;
        if (ge) {
          for (var Re = w, Be = 0, le = 0; Re && $Q(Re); )
            Be += Re.offsetLeft, le += Re.offsetTop, Re = Re.offsetParent;
          ne -= Be, ie -= le;
        }
      }
    }
    if (kP && !vQ && M && !A && x && (v === "relative" || v === "static") && (ne -= w.offsetLeft, ie -= w.offsetTop, o = o || S), E)
      M && N.hasTransform && (I = w.clientLeft, R = w.clientTop);
    else if (M && p !== w && (k = w.clientLeft, T = w.clientTop), M && w === s) {
      var Ee = lL(r, !1);
      ne += Ee[0], ie += Ee[1];
    }
    if (i.push({
      type: "target",
      target: r,
      matrix: cd(_, c, z)
    }), b.length && (i.push({
      type: "offset",
      target: r,
      matrix: $t(c)
    }), i.push({
      type: "target",
      target: r,
      matrix: cd(Qd(b), c, z)
    })), M) {
      var Se = r === t, xe = Se ? 0 : r.scrollLeft, Ce = Se ? 0 : r.scrollTop;
      i.push({
        type: "offset",
        target: r,
        matrix: el([
          ne - xe + k - I,
          ie - Ce + T - R
        ], c)
      });
    } else
      i.push({
        type: "offset",
        target: r,
        origin: z
      });
    if (Z !== 1 && i.push({
      type: "zoom",
      target: r,
      matrix: cd(xE([Z, Z], c), c, [0, 0])
    }), f || (f = _), u || (u = z), d || (d = V), a || E)
      break;
    r = w, o = S, (!n || r === s) && (a = o);
  }
  return f || (f = $t(c)), u || (u = [0, 0]), d || (d = [0, 0]), {
    zoom: g,
    offsetContainer: p,
    matrixes: i,
    targetMatrix: f,
    transformOrigin: u,
    targetOrigin: d,
    is3d: l,
    hasFixed: h
  };
}
var sa = null, oa = null, Jl = null;
function Hc(t) {
  t ? (window.Map && (sa = /* @__PURE__ */ new Map(), oa = /* @__PURE__ */ new Map()), Jl = []) : (sa = null, Jl = null, oa = null);
}
function FQ(t) {
  var e = oa == null ? void 0 : oa.get(t);
  if (e)
    return e;
  var n = ud(t, !0);
  return oa && oa.set(t, n), n;
}
function zQ(t, e) {
  if (Jl) {
    var n = br(Jl, function(i) {
      return i[0][0] == t && i[0][1] == e;
    });
    if (n)
      return n[1];
  }
  var r = $P(t, e, !0);
  return Jl && Jl.push([[t, e], r]), r;
}
function yr(t) {
  var e = sa == null ? void 0 : sa.get(t);
  if (!e) {
    var n = Co(t).getComputedStyle(t);
    if (!sa)
      return function(s) {
        return n[s];
      };
    e = {
      style: n,
      cached: {}
    }, sa.set(t, e);
  }
  var r = e.cached, i = e.style;
  return function(s) {
    return s in r || (r[s] = i[s]), r[s];
  };
}
function Ci(t, e, n) {
  var r = n.originalDatas;
  r.groupable = r.groupable || {};
  var i = r.groupable;
  i.childDatas = i.childDatas || [];
  var s = i.childDatas;
  return t.moveables.map(function(o, a) {
    return s[a] = s[a] || {}, s[a][e] = s[a][e] || {}, L(L({}, n), { isRequestChild: !0, datas: s[a][e], originalDatas: s[a] });
  });
}
function Cb(t, e, n, r, i, s, o) {
  var a = !!n.match(/Start$/g), l = !!n.match(/End$/g), c = i.isPinch, u = i.datas, d = Ci(t, e.name, i), f = t.moveables, h = [], p = d.map(function(g, m) {
    var v = f[m], y = v.state, E = y.gestos, b = g;
    if (a)
      b = new zc(o).dragStart(r, g), h.push(b);
    else {
      if (E[o] || (E[o] = u.childGestos[m]), !E[o])
        return;
      b = Jf(g, y, r, c, s, o), h.push(b);
    }
    var _ = e[n](v, L(L({}, b), { parentFlag: !0 }));
    return l && (E[o] = null), _;
  });
  return a && (u.childGestos = f.map(function(g) {
    return g.state.gestos[o];
  })), {
    eventParams: p,
    childEvents: h
  };
}
function Fs(t, e, n, r, i, s) {
  i === void 0 && (i = function(u, d) {
    return d;
  });
  var o = !!n.match(/End$/g), a = Ci(t, e.name, r), l = t.moveables, c = a.map(function(u, d) {
    var f = l[d], h = u;
    h = i(f, u);
    var p = e[n](f, L(L({}, h), { parentFlag: !0 }));
    return p && s && s(f, u, p, d), o && (f.state.gestos = {}), p;
  });
  return c;
}
function Fg(t, e, n, r) {
  var i = n.fixedDirection, s = n.fixedPosition, o = r.datas.startPositions || ui(e.state), a = hn(o, i), l = F(Bn(Kf(-t.rotation / 180 * Math.PI, 3), [a[0] - s[0], a[1] - s[1], 1], 3), 2), c = l[0], u = l[1];
  return r.datas.originalX = c, r.datas.originalY = u, r;
}
function BP(t, e, n, r) {
  var i = t.getState(), s = i.renderPoses, o = i.rotation, a = i.direction, l = nl(t.props, e).zoom, c = ld(o / Math.PI * 180), u = {}, d = t.renderState;
  d.renderDirectionMap || (d.renderDirectionMap = {});
  var f = d.renderDirectionMap;
  n.forEach(function(p) {
    var g = p.dir;
    u[g] = !0;
  });
  var h = Kn(a);
  return n.map(function(p) {
    var g = p.data, m = p.classNames, v = p.dir, y = ME[v];
    if (!y || !u[v])
      return null;
    f[v] = !0;
    var E = (tt(c, 15) + h * MP[v] + 720) % 180, b = {};
    return Gs(g).forEach(function(_) {
      b["data-".concat(_)] = g[_];
    }), r.createElement("div", L({ className: qe.apply(void 0, he(["control", "direction", v, e], F(m), !1)), "data-rotation": E, "data-direction": v }, b, { key: "direction-".concat(v), style: Vg.apply(void 0, he([o, l], F(y.map(function(_) {
      return s[_];
    })), !1)) }));
  });
}
function FP(t, e, n, r) {
  var i = nl(t.props, n), s = i.renderDirections, o = s === void 0 ? e : s, a = i.displayAroundControls;
  if (!o)
    return [];
  var l = o === !0 ? TE : o;
  return he(he([], F(a ? VP(t, r, n, l) : []), !1), F(BP(t, n, l.map(function(c) {
    return {
      data: {},
      classNames: [],
      dir: c
    };
  }), r)), !1);
}
function ef(t, e, n, r, i, s) {
  for (var o = [], a = 6; a < arguments.length; a++)
    o[a - 6] = arguments[a];
  var l = Qt(n, r), c = e ? tt(l / Math.PI * 180, 15) % 180 : -1;
  return t.createElement("div", { key: "line-".concat(s), className: qe.apply(void 0, he(["line", "direction", e ? "edge" : "", e], F(o), !1)), "data-rotation": c, "data-line-key": s, "data-direction": e, style: Lu(n, r, i, l) });
}
function zP(t, e, n, r, i) {
  var s = n === !0 ? cQ : n;
  return s.map(function(o, a) {
    var l = F(ME[o], 2), c = l[0], u = l[1];
    if (u != null)
      return ef(t, o, r[c], r[u], i, "".concat(e, "Edge").concat(a), e);
  }).filter(Boolean);
}
function HP(t) {
  return function(e, n) {
    var r = nl(e.props, t).edge;
    return r && (r === !0 || r.length) ? he(he([], F(zP(n, t, r, e.getState().renderPoses, e.props.zoom)), !1), F(HQ(e, t, n)), !1) : UP(e, t, n);
  };
}
function UP(t, e, n) {
  return FP(t, TE, e, n);
}
function HQ(t, e, n) {
  return FP(t, ["nw", "ne", "sw", "se"], e, n);
}
function VP(t, e, n, r) {
  var i = t.renderState;
  i.renderDirectionMap || (i.renderDirectionMap = {});
  var s = t.getState(), o = s.renderPoses, a = s.rotation, l = s.direction, c = i.renderDirectionMap, u = t.props.zoom, d = Kn(l), f = a / Math.PI * 180;
  return (r || Gs(c)).map(function(h) {
    var p = ME[h];
    if (!p)
      return null;
    var g = (tt(f, 15) + d * MP[h] + 720) % 180, m = ["around-control"];
    return n && m.push("direction", n), e.createElement("div", { className: qe.apply(void 0, he([], F(m), !1)), "data-rotation": g, "data-direction": h, key: "direction-around-".concat(h), style: Vg.apply(void 0, he([a, u], F(p.map(function(v) {
      return o[v];
    })), !1)) });
  });
}
function RE(t, e, n) {
  var r = t || {}, i = r.position, s = i === void 0 ? "client" : i, o = r.left, a = o === void 0 ? -1 / 0 : o, l = r.top, c = l === void 0 ? -1 / 0 : l, u = r.right, d = u === void 0 ? 1 / 0 : u, f = r.bottom, h = f === void 0 ? 1 / 0 : f, p = {
    position: s,
    left: a,
    top: c,
    right: d,
    bottom: h
  };
  return {
    vertical: PT(p, e, !0),
    horizontal: PT(p, n, !1)
  };
}
function s0(t, e) {
  var n = t.state, r = n.containerClientRect, i = r.clientHeight, s = r.clientWidth, o = r.clientLeft, a = r.clientTop, l = n.snapOffset, c = l.left, u = l.top, d = l.right, f = l.bottom, h = e || t.props.bounds || {}, p = h.position || "client", g = p === "css", m = h.left, v = m === void 0 ? -1 / 0 : m, y = h.top, E = y === void 0 ? -1 / 0 : y, b = h.right, _ = b === void 0 ? g ? -1 / 0 : 1 / 0 : b, w = h.bottom, S = w === void 0 ? g ? -1 / 0 : 1 / 0 : w;
  return g && (_ = s + d - c - _, S = i + f - u - S), {
    left: v + c - o,
    right: _ + c - o,
    top: E + u - a,
    bottom: S + u - a
  };
}
function UQ(t, e, n) {
  var r = s0(t), i = r.left, s = r.top, o = r.right, a = r.bottom, l = F(n, 2), c = l[0], u = l[1], d = F(Ke(n, e), 2), f = d[0], h = d[1];
  oe(f) < rr && (f = 0), oe(h) < rr && (h = 0);
  var p = h > 0, g = f > 0, m = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, v = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (f === 0 && h === 0)
    return {
      vertical: m,
      horizontal: v
    };
  if (f === 0)
    p ? a < u && (v.pos = a, v.offset = u - a) : s > u && (v.pos = s, v.offset = u - s);
  else if (h === 0)
    g ? o < c && (m.pos = o, m.offset = c - o) : i > c && (m.pos = i, m.offset = c - i);
  else {
    var y = h / f, E = n[1] - y * c, b = 0, _ = 0, w = !1;
    g && o <= c ? (b = y * o + E, _ = o, w = !0) : !g && c <= i && (b = y * i + E, _ = i, w = !0), w && (b < s || b > a) && (w = !1), w || (p && a <= u ? (b = a, _ = (b - E) / y, w = !0) : !p && u <= s && (b = s, _ = (b - E) / y, w = !0)), w && (m.isBound = !0, m.pos = _, m.offset = c - _, v.isBound = !0, v.pos = b, v.offset = u - b);
  }
  return {
    vertical: m,
    horizontal: v
  };
}
function PT(t, e, n) {
  var r = t[n ? "left" : "top"], i = t[n ? "right" : "bottom"], s = Math.min.apply(Math, he([], F(e), !1)), o = Math.max.apply(Math, he([], F(e), !1)), a = [];
  return r + 1 > s && a.push({
    direction: "start",
    isBound: !0,
    offset: s - r,
    pos: r
  }), i - 1 < o && a.push({
    direction: "end",
    isBound: !0,
    offset: o - i,
    pos: i
  }), a.length || a.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), a.sort(function(l, c) {
    return oe(c.offset) - oe(l.offset);
  });
}
function LT(t, e, n) {
  var r = n ? t.map(function(i) {
    return qf(i, n);
  }) : t;
  return r.some(function(i) {
    return i[0] < e.left && oe(i[0] - e.left) > 0.1 || i[0] > e.right && oe(i[0] - e.right) > 0.1 || i[1] < e.top && oe(i[1] - e.top) > 0.1 || i[1] > e.bottom && oe(i[1] - e.bottom) > 0.1;
  });
}
function VQ(t, e, n) {
  var r = ci(t), i = Math.sqrt(r * r - e * e) || 0;
  return [i, -i].sort(function(s, o) {
    return oe(s - t[n ? 0 : 1]) - oe(o - t[n ? 0 : 1]);
  }).map(function(s) {
    return Qt([0, 0], n ? [s, e] : [e, s]);
  });
}
function WQ(t, e, n, r, i) {
  if (!t.props.bounds)
    return [];
  var s = i * Math.PI / 180, o = s0(t), a = o.left, l = o.top, c = o.right, u = o.bottom, d = a - r[0], f = c - r[0], h = l - r[1], p = u - r[1], g = {
    left: d,
    top: h,
    right: f,
    bottom: p
  };
  if (!LT(n, g, 0))
    return [];
  var m = [];
  return [
    [d, 0],
    [f, 0],
    [h, 1],
    [p, 1]
  ].forEach(function(v) {
    var y = F(v, 2), E = y[0], b = y[1];
    n.forEach(function(_) {
      var w = Qt([0, 0], _);
      m.push.apply(m, he([], F(VQ(_, E, b).map(function(S) {
        return s + S - w;
      }).filter(function(S) {
        return !LT(e, g, S);
      }).map(function(S) {
        return tt(S * 180 / Math.PI, rr);
      })), !1));
    });
  }), m;
}
var GQ = ["left", "right", "center"], jQ = ["top", "bottom", "middle"], $T = {
  left: "start",
  right: "end",
  center: "center",
  top: "start",
  bottom: "end",
  middle: "center"
}, Io = {
  start: "left",
  end: "right",
  center: "center"
}, Po = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function Zl() {
  return {
    left: !1,
    top: !1,
    right: !1,
    bottom: !1
  };
}
function su(t, e) {
  var n = t.props, r = n.snappable, i = n.bounds, s = n.innerBounds, o = n.verticalGuidelines, a = n.horizontalGuidelines, l = n.snapGridWidth, c = n.snapGridHeight, u = t.state, d = u.guidelines, f = u.enableSnap;
  return !r || !f || e && r !== !0 && r.indexOf(e) < 0 ? !1 : !!(l || c || i || s || d && d.length || o && o.length || a && a.length);
}
function DE(t) {
  return t === !1 ? {} : t === !0 || !t ? { left: !0, right: !0, top: !0, bottom: !0 } : t;
}
function qQ(t, e) {
  var n = DE(t), r = {};
  for (var i in n)
    i in e && n[i] && (r[i] = e[i]);
  return r;
}
function IE(t, e) {
  var n = qQ(t, e), r = jQ.filter(function(s) {
    return s in n;
  }), i = GQ.filter(function(s) {
    return s in n;
  });
  return {
    horizontalNames: r,
    verticalNames: i,
    horizontal: r.map(function(s) {
      return n[s];
    }),
    vertical: i.map(function(s) {
      return n[s];
    })
  };
}
function KQ(t, e, n) {
  var r = qt(t, [e.clientLeft, e.clientTop], n);
  return [
    e.left + r[0],
    e.top + r[1]
  ];
}
function YQ(t) {
  var e = F(t, 2), n = e[0], r = e[1], i = r[0] - n[0], s = r[1] - n[1];
  Math.abs(i) < tn && (i = 0), Math.abs(s) < tn && (s = 0);
  var o = 0, a = 0, l = 0;
  return i ? s ? (o = -s / i, a = 1, l = o * n[0] - n[1]) : (a = 1, l = -n[1]) : (o = -1, l = n[0]), [o, a, l].map(function(c) {
    return tt(c, tn);
  });
}
var WP = "snapRotationThreshold", GP = "snapRotationDegrees", jP = "snapHorizontalThreshold", qP = "snapVerticalThreshold";
function o0(t, e, n, r, i, s, o) {
  var a;
  r === void 0 && (r = []), i === void 0 && (i = []);
  var l = t.props, c = ((a = t.state.snapThresholdInfo) === null || a === void 0 ? void 0 : a.multiples) || [1, 1], u = ZT(o, l[jP], 5), d = ZT(s, l[qP], 5);
  return KP(t.state.guidelines, e, n, r, i, u, d, c);
}
function KP(t, e, n, r, i, s, o, a) {
  return {
    vertical: FT(t, "vertical", e, o * a[0], r),
    horizontal: FT(t, "horizontal", n, s * a[1], i)
  };
}
function XQ(t, e, n) {
  var r = F(n, 2), i = r[0], s = r[1], o = F(e, 2), a = o[0], l = o[1], c = F(Ke(n, e), 2), u = c[0], d = c[1], f = d > 0, h = u > 0;
  u = Wg(u), d = Wg(d);
  var p = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, g = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (u === 0 && d === 0)
    return {
      vertical: p,
      horizontal: g
    };
  var m = o0(t, u ? [i] : [], d ? [s] : [], [], [], void 0, void 0), v = m.vertical, y = m.horizontal;
  v.posInfos.filter(function(G) {
    var M = G.pos;
    return h ? M >= a : M <= a;
  }), y.posInfos.filter(function(G) {
    var M = G.pos;
    return f ? M >= l : M <= l;
  }), v.isSnap = v.posInfos.length > 0, y.isSnap = y.posInfos.length > 0;
  var E = A1(v), b = E.isSnap, _ = E.guideline, w = A1(y), S = w.isSnap, x = w.guideline, k = S ? x.pos[1] : 0, T = b ? _.pos[0] : 0;
  if (u === 0)
    S && (g.isSnap = !0, g.pos = x.pos[1], g.offset = s - g.pos);
  else if (d === 0)
    b && (p.isSnap = !0, p.pos = T, p.offset = i - T);
  else {
    var I = d / u, R = n[1] - I * i, N = 0, $ = 0, B = !1;
    b ? ($ = T, N = I * $ + R, B = !0) : S && (N = k, $ = (N - R) / I, B = !0), B && (p.isSnap = !0, p.pos = $, p.offset = i - $, g.isSnap = !0, g.pos = N, g.offset = s - N);
  }
  return {
    vertical: p,
    horizontal: g
  };
}
function yo(t) {
  var e = "";
  return t === -1 || t === "top" || t === "left" ? e = "start" : t === 0 || t === "center" || t === "middle" ? e = "center" : (t === 1 || t === "right" || t === "bottom") && (e = "end"), e;
}
function BT(t, e, n, r) {
  var i = IE(t.props.snapDirections, e), s = o0(t, i.vertical, i.horizontal, i.verticalNames.map(function(l) {
    return yo(l);
  }), i.horizontalNames.map(function(l) {
    return yo(l);
  }), n, r), o = yo(i.horizontalNames[s.horizontal.index]), a = yo(i.verticalNames[s.vertical.index]);
  return {
    vertical: L(L({}, s.vertical), { direction: a }),
    horizontal: L(L({}, s.horizontal), { direction: o })
  };
}
function A1(t) {
  var e = t.isSnap;
  if (!e)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  var n = t.posInfos[0], r = n.guidelineInfos[0], i = r.offset, s = r.dist, o = r.guideline;
  return {
    isSnap: e,
    offset: i,
    dist: s,
    pos: n.pos,
    guideline: o
  };
}
function FT(t, e, n, r, i) {
  var s, o;
  if (i === void 0 && (i = []), !t || !t.length)
    return {
      isSnap: !1,
      index: -1,
      direction: "",
      posInfos: []
    };
  var a = e === "vertical", l = a ? 0 : 1, c = n.map(function(d, f) {
    var h = i[f] || "", p = t.map(function(g) {
      var m = g.pos, v = d - m[l];
      return {
        offset: v,
        dist: oe(v),
        guideline: g,
        direction: h
      };
    }).filter(function(g) {
      var m = g.guideline, v = g.dist, y = m.type;
      return !(y !== e || v > r);
    }).sort(function(g, m) {
      return g.dist - m.dist;
    });
    return {
      pos: d,
      index: f,
      guidelineInfos: p,
      direction: h
    };
  }).filter(function(d) {
    return d.guidelineInfos.length > 0;
  }).sort(function(d, f) {
    return d.guidelineInfos[0].dist - f.guidelineInfos[0].dist;
  }), u = c.length > 0;
  return {
    isSnap: u,
    index: u ? c[0].index : -1,
    direction: (o = (s = c[0]) === null || s === void 0 ? void 0 : s.direction) !== null && o !== void 0 ? o : "",
    posInfos: c
  };
}
function JQ(t, e, n, r, i) {
  var s = [];
  n[0] && n[1] ? s = [
    n,
    [-n[0], n[1]],
    [n[0], -n[1]]
  ] : !n[0] && !n[1] ? [
    [-1, -1],
    [1, -1],
    [1, 1],
    [-1, 1]
  ].forEach(function(f, h, p) {
    var g = p[h + 1] || p[0];
    s.push(f), s.push([
      (f[0] + g[0]) / 2,
      (f[1] + g[1]) / 2
    ]);
  }) : t.props.keepRatio ? s.push([-1, -1], [-1, 1], [1, -1], [1, 1], n) : (s.push.apply(s, he([], F(CQ([
    [-1, -1],
    [1, -1],
    [-1, -1],
    [1, 1]
  ], n)), !1)), s.length > 1 && s.push([
    (s[0][0] + s[1][0]) / 2,
    (s[0][1] + s[1][1]) / 2
  ]));
  var o = s.map(function(f) {
    return hn(e, f);
  }), a = o.map(function(f) {
    return f[0];
  }), l = o.map(function(f) {
    return f[1];
  }), c = o0(t, a, l, s.map(function(f) {
    return yo(f[0]);
  }), s.map(function(f) {
    return yo(f[1]);
  }), r, i), u = yo(s.map(function(f) {
    return f[0];
  })[c.vertical.index]), d = yo(s.map(function(f) {
    return f[1];
  })[c.horizontal.index]);
  return {
    vertical: L(L({}, c.vertical), { direction: u }),
    horizontal: L(L({}, c.horizontal), { direction: d })
  };
}
function YP(t, e) {
  var n = oe(t.offset), r = oe(e.offset);
  return t.isBound && e.isBound ? r - n : t.isBound ? -1 : e.isBound ? 1 : t.isSnap && e.isSnap ? r - n : t.isSnap ? -1 : e.isSnap || n < rr ? 1 : r < rr ? -1 : n - r;
}
function zg(t, e) {
  return t.slice().sort(function(n, r) {
    var i = n.sign[e], s = r.sign[e], o = n.offset[e], a = r.offset[e];
    if (i) {
      if (!s)
        return -1;
    } else
      return 1;
    return YP({ isBound: n.isBound, isSnap: n.isSnap, offset: o }, { isBound: r.isBound, isSnap: r.isSnap, offset: a });
  })[0];
}
function ZQ(t, e, n) {
  var r = [];
  if (n)
    oe(e[0]) !== 1 || oe(e[1]) !== 1 ? r.push([e, [-1, -1]], [e, [-1, 1]], [e, [1, -1]], [e, [1, 1]]) : r.push([e, [t[0], -t[1]]], [e, [-t[0], t[1]]]), r.push([e, t]);
  else if (t[0] && t[1] || !t[0] && !t[1]) {
    var i = t[0] ? t : [1, 1];
    [1, -1].forEach(function(o) {
      [1, -1].forEach(function(a) {
        var l = [o * i[0], a * i[1]];
        e[0] === l[0] && e[1] === l[1] || r.push([e, l]);
      });
    });
  } else if (t[0]) {
    var s = oe(e[0]) === 1 ? [1] : [1, -1];
    s.forEach(function(o) {
      r.push([
        [e[0], -1],
        [o * t[0], -1]
      ], [
        [e[0], 0],
        [o * t[0], 0]
      ], [
        [e[0], 1],
        [o * t[0], 1]
      ]);
    });
  } else if (t[1]) {
    var s = oe(e[1]) === 1 ? [1] : [1, -1];
    s.forEach(function(a) {
      r.push([
        [-1, e[1]],
        [-1, a * t[1]]
      ], [
        [0, e[1]],
        [0, a * t[1]]
      ], [
        [1, e[1]],
        [1, a * t[1]]
      ]);
    });
  }
  return r;
}
function XP(t, e) {
  var n = p1([e[0][0], e[1][0]]), r = p1([e[0][1], e[1][1]]);
  return {
    vertical: n <= t[0],
    horizontal: r <= t[1]
  };
}
function PE(t, e) {
  var n = F(e, 2), r = n[0], i = n[1], s = i[0] - r[0], o = i[1] - r[1];
  oe(s) < rr && (s = 0), oe(o) < rr && (o = 0);
  var a, l;
  if (!s)
    a = r[0], l = t[0];
  else if (!o)
    a = r[1], l = t[1];
  else {
    var c = o / s;
    a = c * (t[0] - r[0]) + r[1], l = t[1];
  }
  return a - l;
}
function JP(t, e, n, r) {
  return r === void 0 && (r = rr), t.every(function(i) {
    var s = PE(i, e), o = s <= 0;
    return o === n || oe(s) <= r;
  });
}
function zT(t, e, n, r, i) {
  return i === void 0 && (i = 0), r && e - i <= t || !r && t <= n + i ? {
    isBound: !0,
    offset: r ? e - t : n - t
  } : {
    isBound: !1,
    offset: 0
  };
}
function QQ(t, e) {
  var n = e.line, r = e.centerSign, i = e.verticalSign, s = e.horizontalSign, o = e.lineConstants, a = t.props.innerBounds;
  if (!a)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var l = a.left, c = a.top, u = a.width, d = a.height, f = [[l, c], [l, c + d]], h = [[l, c], [l + u, c]], p = [[l + u, c], [l + u, c + d]], g = [[l, c + d], [l + u, c + d]];
  if (JP([
    [l, c],
    [l + u, c],
    [l, c + d],
    [l + u, c + d]
  ], n, r))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var m = wo(n, o, h, i), v = wo(n, o, g, i), y = wo(n, o, f, s), E = wo(n, o, p, s), b = m.isBound && v.isBound, _ = m.isBound || v.isBound, w = y.isBound && E.isBound, S = y.isBound || E.isBound, x = Uc(m.offset, v.offset), k = Uc(y.offset, E.offset), T = [0, 0], I = !1, R = !1;
  return oe(k) < oe(x) ? (T = [x, 0], I = _, R = b) : (T = [0, k], I = S, R = w), {
    isAllBound: R,
    isVerticalBound: _,
    isHorizontalBound: S,
    isBound: I,
    offset: T
  };
}
function wo(t, e, n, r, i, s) {
  var o = F(e, 2), a = o[0], l = o[1], c = t[0], u = n[0], d = n[1], f = Wg(d[1] - u[1]), h = Wg(d[0] - u[0]), p = l, g = a, m = -a / l;
  if (h) {
    if (!f) {
      if (s && !p)
        return {
          isBound: !1,
          offset: 0
        };
      if (g) {
        var b = (u[1] - c[1]) / m + c[0];
        return zT(b, u[0], d[0], r, i);
      } else {
        var y = u[1] - c[1], E = oe(y) <= (i || 0);
        return {
          isBound: E,
          offset: E ? y : 0
        };
      }
    }
  } else {
    if (s && !g)
      return {
        isBound: !1,
        offset: 0
      };
    if (p) {
      var v = m * (u[0] - c[0]) + c[1];
      return zT(v, u[1], d[1], r, i);
    } else {
      var y = u[0] - c[0], E = oe(y) <= (i || 0);
      return {
        isBound: E,
        offset: E ? y : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function ZP(t, e, n) {
  return e.map(function(r) {
    var i = QQ(t, r), s = i.isBound, o = i.offset, a = i.isVerticalBound, l = i.isHorizontalBound, c = r.multiple, u = ms({
      datas: n,
      distX: o[0],
      distY: o[1]
    }).map(function(d, f) {
      return d * (c[f] ? 2 / c[f] : 0);
    });
    return {
      sign: c,
      isBound: s,
      isVerticalBound: a,
      isHorizontalBound: l,
      isSnap: !1,
      offset: u
    };
  });
}
function eee(t, e, n) {
  var r, i = LE(t, e, [0, 0], !1).map(function(f) {
    return L(L({}, f), { multiple: f.multiple.map(function(h) {
      return oe(h) * 2;
    }) });
  }), s = ZP(t, i, n), o = zg(s, 0), a = zg(s, 1), l = 0, c = 0, u = o.isVerticalBound || a.isVerticalBound, d = o.isHorizontalBound || a.isHorizontalBound;
  return (u || d) && (r = F(xQ({
    datas: n,
    distX: -o.offset[0],
    distY: -a.offset[1]
  }), 2), l = r[0], c = r[1]), {
    vertical: {
      isBound: u,
      offset: l
    },
    horizontal: {
      isBound: d,
      offset: c
    }
  };
}
function tee(t, e) {
  var n = [], r = t[0], i = t[1];
  return r && i ? n.push([[0, i * 2], t, [-r, i]], [[r * 2, 0], t, [r, -i]]) : r ? (n.push([[r * 2, 0], [r, 1], [r, -1]]), e && n.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : i ? (n.push([[0, i * 2], [1, i], [-1, i]]), e && n.push([[-1, 0], [-1, i], [-1, -i]], [[1, 0], [1, i], [1, -i]])) : n.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), n;
}
function LE(t, e, n, r) {
  var i = t.state, s = i.allMatrix, o = i.is3d, a = gl(s, 100, 100, o ? 4 : 3), l = hn(a, [0, 0]);
  return tee(n, r).map(function(c) {
    var u = F(c, 3), d = u[0], f = u[1], h = u[2], p = [
      hn(a, f),
      hn(a, h)
    ], g = YQ(p), m = XP(l, p), v = m.vertical, y = m.horizontal, E = PE(l, p) <= 0;
    return {
      multiple: d,
      centerSign: E,
      verticalSign: v,
      horizontalSign: y,
      lineConstants: g,
      line: [
        hn(e, f),
        hn(e, h)
      ]
    };
  });
}
function HT(t, e, n, r) {
  var i = r ? t.map(function(s) {
    return qf(s, r);
  }) : t;
  return [
    [i[0], i[1]],
    [i[1], i[3]],
    [i[3], i[2]],
    [i[2], i[0]]
  ].some(function(s) {
    var o = PE(n, s) <= 0;
    return !JP(e, s, o);
  });
}
function nee(t) {
  var e = F(t, 2), n = e[0], r = e[1], i = r[0] - n[0], s = r[1] - n[1];
  if (!i)
    return oe(n[0]);
  if (!s)
    return oe(n[1]);
  var o = s / i;
  return oe((-o * n[0] + n[1]) / Math.sqrt(Math.pow(o, 2) + 1));
}
function ree(t) {
  var e = F(t, 2), n = e[0], r = e[1], i = r[0] - n[0], s = r[1] - n[1];
  if (!i)
    return [n[0], 0];
  if (!s)
    return [0, n[1]];
  var o = s / i, a = -o * n[0] + n[1];
  return [
    -a / (o + 1 / o),
    a / (o * o + 1)
  ];
}
function iee(t, e, n, r, i) {
  var s = t.props.innerBounds, o = i * Math.PI / 180;
  if (!s)
    return [];
  var a = s.left, l = s.top, c = s.width, u = s.height, d = a - r[0], f = a + c - r[0], h = l - r[1], p = l + u - r[1], g = [
    [d, h],
    [f, h],
    [d, p],
    [f, p]
  ], m = hn(n, [0, 0]);
  if (!HT(n, g, m, 0))
    return [];
  var v = [], y = g.map(function(E) {
    return [
      ci(E),
      Qt([0, 0], E)
    ];
  });
  return [
    [n[0], n[1]],
    [n[1], n[3]],
    [n[3], n[2]],
    [n[2], n[0]]
  ].forEach(function(E) {
    var b = Qt([0, 0], ree(E)), _ = nee(E);
    v.push.apply(v, he([], F(y.filter(function(w) {
      var S = F(w, 1), x = S[0];
      return x && _ <= x;
    }).map(function(w) {
      var S = F(w, 2), x = S[0], k = S[1], T = Math.acos(x ? _ / x : 0), I = k + T, R = k - T;
      return [
        o + I - b,
        o + R - b
      ];
    }).reduce(function(w, S) {
      return w.push.apply(w, he([], F(S), !1)), w;
    }, []).filter(function(w) {
      return !HT(e, g, m, w);
    }).map(function(w) {
      return tt(w * 180 / Math.PI, rr);
    })), !1));
  }), v;
}
function see(t) {
  var e = t.props.innerBounds, n = Zl();
  if (!e)
    return {
      boundMap: n,
      vertical: [],
      horizontal: []
    };
  var r = t.getRect(), i = r.pos1, s = r.pos2, o = r.pos3, a = r.pos4, l = [i, s, o, a], c = hn(l, [0, 0]), u = e.left, d = e.top, f = e.width, h = e.height, p = [[u, d], [u, d + h]], g = [[u, d], [u + f, d]], m = [[u + f, d], [u + f, d + h]], v = [[u, d + h], [u + f, d + h]], y = LE(t, l, [0, 0], !1), E = [], b = [];
  return y.forEach(function(_) {
    var w = _.line, S = _.lineConstants, x = XP(c, w), k = x.horizontal, T = x.vertical, I = wo(w, S, g, T, 1, !0), R = wo(w, S, v, T, 1, !0), N = wo(w, S, p, k, 1, !0), $ = wo(w, S, m, k, 1, !0);
    I.isBound && !n.top && (E.push(d), n.top = !0), R.isBound && !n.bottom && (E.push(d + h), n.bottom = !0), N.isBound && !n.left && (b.push(u), n.left = !0), $.isBound && !n.right && (b.push(u + f), n.right = !0);
  }), {
    boundMap: n,
    horizontal: E,
    vertical: b
  };
}
function oee(t, e, n, r) {
  var i = e[0] - t[0], s = e[1] - t[1];
  if (oe(i) < tn && (i = 0), oe(s) < tn && (s = 0), !i)
    return r ? [0, 0] : [0, n];
  if (!s)
    return r ? [n, 0] : [0, 0];
  var o = s / i, a = t[1] - o * t[0];
  if (r) {
    var l = o * (e[0] + n) + a;
    return [n, l - e[1]];
  } else {
    var c = (e[1] + n - a) / o;
    return [c - e[0], n];
  }
}
function N1(t, e, n, r, i) {
  var s = oee(t, e, n, r);
  if (!s)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  var o = Bs(t, e), a = Bs(s, t), l = Bs(s, e), c = a > o || l > o, u = F(ms({
    datas: i,
    distX: s[0],
    distY: s[1]
  }), 2), d = u[0], f = u[1];
  return {
    offset: [d, f],
    isOutside: c
  };
}
function Hg(t, e) {
  return t.isBound ? t.offset : e.isSnap ? A1(e).offset : 0;
}
function aee(t, e, n, r, i) {
  var s = F(e, 2), o = s[0], a = s[1], l = F(n, 2), c = l[0], u = l[1], d = F(r, 2), f = d[0], h = d[1], p = F(i, 2), g = p[0], m = p[1], v = -g, y = -m;
  if (t && o && a) {
    v = 0, y = 0;
    var E = [];
    if (c && u ? E.push([0, m], [g, 0]) : c ? E.push([g, 0]) : u ? E.push([0, m]) : f && h ? E.push([0, m], [g, 0]) : f ? E.push([g, 0]) : h && E.push([0, m]), E.length) {
      E.sort(function(S, x) {
        return ci(Ke([o, a], S)) - ci(Ke([o, a], x));
      });
      var b = E[0];
      if (b[0] && oe(o) > tn)
        v = -b[0], y = a * oe(o + v) / oe(o) - a;
      else if (b[1] && oe(a) > tn) {
        var _ = a;
        y = -b[1], v = o * oe(a + y) / oe(_) - o;
      }
      if (t && u && c)
        if (oe(v) > tn && oe(v) < oe(g)) {
          var w = oe(g) / oe(v);
          v *= w, y *= w;
        } else if (oe(y) > tn && oe(y) < oe(m)) {
          var w = oe(m) / oe(y);
          v *= w, y *= w;
        } else
          v = Uc(-g, v), y = Uc(-m, y);
    }
  } else
    v = o || c ? -g : 0, y = a || u ? -m : 0;
  return [v, y];
}
function lee(t, e, n, r, i, s) {
  if (!su(t, "draggable"))
    return [
      {
        isSnap: !1,
        isBound: !1,
        offset: 0
      },
      {
        isSnap: !1,
        isBound: !1,
        offset: 0
      }
    ];
  var o = FE(s.absolutePoses, [e, n]), a = ni(o), l = a.left, c = a.right, u = a.top, d = a.bottom, f = {
    horizontal: o.map(function($) {
      return $[1];
    }),
    vertical: o.map(function($) {
      return $[0];
    })
  }, h = DE(t.props.snapDirections), p = IE(h, {
    left: l,
    right: c,
    top: u,
    bottom: d,
    center: (l + c) / 2,
    middle: (u + d) / 2
  }), g = a0(t, i, p, f), m = g.vertical, v = g.horizontal, y = eee(t, o, s), E = y.vertical, b = y.horizontal, _ = m.isSnap, w = v.isSnap, S = m.isBound || E.isBound, x = v.isBound || b.isBound, k = Uc(m.offset, E.offset), T = Uc(v.offset, b.offset), I = F(aee(r, [e, n], [S, x], [_, w], [k, T]), 2), R = I[0], N = I[1];
  return [
    {
      isBound: S,
      isSnap: _,
      offset: R
    },
    {
      isBound: x,
      isSnap: w,
      offset: N
    }
  ];
}
function a0(t, e, n, r) {
  r === void 0 && (r = n);
  var i = RE(s0(t), r.vertical, r.horizontal), s = i.horizontal, o = i.vertical, a = e ? {
    horizontal: { isSnap: !1, index: -1 },
    vertical: { isSnap: !1, index: -1 }
  } : o0(t, n.vertical, n.horizontal, void 0, void 0, void 0, void 0), l = a.horizontal, c = a.vertical, u = Hg(s[0], l), d = Hg(o[0], c), f = oe(u), h = oe(d);
  return {
    horizontal: {
      isBound: s[0].isBound,
      isSnap: l.isSnap,
      snapIndex: l.index,
      offset: u,
      dist: f,
      bounds: s,
      snap: l
    },
    vertical: {
      isBound: o[0].isBound,
      isSnap: c.isSnap,
      snapIndex: c.index,
      offset: d,
      dist: h,
      bounds: o,
      snap: c
    }
  };
}
function UT(t, e, n, r, i, s, o) {
  o === void 0 && (o = [1, 1]);
  var a = RE(e, n, r), l = a.horizontal, c = a.vertical, u = KP(t, n, r, [], [], i, s, o), d = u.horizontal, f = u.vertical, h = Hg(l[0], d), p = Hg(c[0], f), g = oe(h), m = oe(p);
  return {
    horizontal: {
      isBound: l[0].isBound,
      isSnap: d.isSnap,
      snapIndex: d.index,
      offset: h,
      dist: g,
      bounds: l,
      snap: d
    },
    vertical: {
      isBound: c[0].isBound,
      isSnap: f.isSnap,
      snapIndex: f.index,
      offset: p,
      dist: m,
      bounds: c,
      snap: f
    }
  };
}
function cee(t, e, n, r) {
  var i = Qt(t, e) / Math.PI * 180, s = n.vertical, o = s.isBound, a = s.isSnap, l = s.dist, c = n.horizontal, u = c.isBound, d = c.isSnap, f = c.dist, h = i % 180, p = h < 3 || h > 177, g = h > 87 && h < 93;
  return f < l && (o || a && !g && (!r || !p)) ? "vertical" : u || d && !p && (!r || !g) ? "horizontal" : "";
}
function uee(t, e, n, r, i, s) {
  return n.map(function(o) {
    var a = F(o, 2), l = a[0], c = a[1], u = hn(e, l), d = hn(e, c), f = r ? dee(t, u, d, i) : a0(t, i, {
      vertical: [d[0]],
      horizontal: [d[1]]
    }), h = f.horizontal, p = h.offset, g = h.isBound, m = h.isSnap, v = f.vertical, y = v.offset, E = v.isBound, b = v.isSnap, _ = Ke(c, l);
    if (!y && !p)
      return {
        isBound: E || g,
        isSnap: b || m,
        sign: _,
        offset: [0, 0]
      };
    var w = cee(u, d, f, r);
    if (!w)
      return {
        sign: _,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    var S = w === "vertical", x = [0, 0];
    return !r && oe(c[0]) === 1 && oe(c[1]) === 1 && l[0] !== c[0] && l[1] !== c[1] ? x = ms({
      datas: s,
      distX: -y,
      distY: -p
    }) : x = N1(u, d, -(S ? y : p), S, s).offset, x = x.map(function(k, T) {
      return k * (_[T] ? 2 / _[T] : 0);
    }), {
      sign: _,
      isBound: S ? E : g,
      isSnap: S ? b : m,
      offset: x
    };
  });
}
function VT(t, e) {
  return t.isBound ? t.offset : e.isSnap ? e.offset : 0;
}
function dee(t, e, n, r) {
  var i = UQ(t, e, n), s = i.horizontal, o = i.vertical, a = r ? {
    horizontal: { isSnap: !1 },
    vertical: { isSnap: !1 }
  } : XQ(t, e, n), l = a.horizontal, c = a.vertical, u = VT(s, l), d = VT(o, c), f = oe(u), h = oe(d);
  return {
    horizontal: {
      isBound: s.isBound,
      isSnap: l.isSnap,
      offset: u,
      dist: f
    },
    vertical: {
      isBound: o.isBound,
      isSnap: c.isSnap,
      offset: d,
      dist: h
    }
  };
}
function fee(t, e, n, r, i) {
  var s = [-n[0], -n[1]], o = t.state, a = o.width, l = o.height, c = t.props.bounds, u = 1 / 0, d = 1 / 0;
  if (c) {
    var f = [
      [n[0], -n[1]],
      [-n[0], n[1]]
    ], h = c.left, p = h === void 0 ? -1 / 0 : h, g = c.top, m = g === void 0 ? -1 / 0 : g, v = c.right, y = v === void 0 ? 1 / 0 : v, E = c.bottom, b = E === void 0 ? 1 / 0 : E;
    f.forEach(function(_) {
      var w = _[0] !== s[0], S = _[1] !== s[1], x = hn(e, _), k = Qt(r, x) * 360 / Math.PI;
      if (S) {
        var T = x.slice();
        (oe(k - 360) < 2 || oe(k - 180) < 2) && (T[1] = r[1]);
        var I = N1(r, T, (r[1] < x[1] ? b : m) - x[1], !1, i), R = F(I.offset, 2), N = R[1], $ = I.isOutside;
        isNaN(N) || (d = l + ($ ? 1 : -1) * oe(N));
      }
      if (w) {
        var T = x.slice();
        (oe(k - 90) < 2 || oe(k - 270) < 2) && (T[0] = r[0]);
        var B = N1(r, T, (r[0] < x[0] ? y : p) - x[0], !0, i), G = F(B.offset, 1), M = G[0], A = B.isOutside;
        isNaN(M) || (u = a + (A ? 1 : -1) * oe(M));
      }
    });
  }
  return {
    maxWidth: u,
    maxHeight: d
  };
}
var qn = {
  name: "draggable",
  props: [
    "draggable",
    "throttleDrag",
    "throttleDragRotate",
    "hideThrottleDragRotateLine",
    "startDragRotate",
    "edgeDraggable"
  ],
  events: [
    "dragStart",
    "drag",
    "dragEnd",
    "dragGroupStart",
    "dragGroup",
    "dragGroupEnd"
  ],
  requestStyle: function() {
    return ["left", "top", "right", "bottom"];
  },
  requestChildStyle: function() {
    return ["left", "top", "right", "bottom"];
  },
  render: function(t, e) {
    var n = t.props, r = n.hideThrottleDragRotateLine, i = n.throttleDragRotate, s = n.zoom, o = t.getState(), a = o.dragInfo, l = o.beforeOrigin;
    if (r || !i || !a)
      return [];
    var c = a.dist;
    if (!c[0] && !c[1])
      return [];
    var u = ci(c), d = Qt(c, [0, 0]);
    return [e.createElement("div", { className: qe("line", "horizontal", "dragline", "dashed"), key: "dragRotateGuideline", style: {
      width: "".concat(u, "px"),
      transform: "translate(".concat(l[0], "px, ").concat(l[1], "px) rotate(").concat(d, "rad) scaleY(").concat(s, ")")
    } })];
  },
  dragStart: function(t, e) {
    var n = e.datas, r = e.parentEvent, i = e.parentGesto, s = t.state, o = s.gestos, a = s.style;
    if (o.draggable)
      return !1;
    o.draggable = i || t.targetGesto, n.datas = {}, n.left = parseFloat(a.left || "") || 0, n.top = parseFloat(a.top || "") || 0, n.bottom = parseFloat(a.bottom || "") || 0, n.right = parseFloat(a.right || "") || 0, n.startValue = [0, 0], pl(t, e), i0(t, e, "translate"), Nee(t, n), n.prevDist = [0, 0], n.prevBeforeDist = [0, 0], n.isDrag = !1, n.deltaOffset = [0, 0];
    var l = st(t, e, L({ set: function(u) {
      n.startValue = u;
    } }, r0(t, e))), c = r || Ne(t, "onDragStart", l);
    return c !== !1 ? (n.isDrag = !0, t.state.dragInfo = {
      startRect: t.getRect(),
      dist: [0, 0]
    }) : (o.draggable = null, n.isPinch = !1), n.isDrag ? l : !1;
  },
  drag: function(t, e) {
    if (e) {
      t0(t, e, "translate");
      var n = e.datas, r = e.parentEvent, i = e.parentFlag, s = e.isPinch, o = e.deltaOffset, a = e.useSnap, l = e.isRequest, c = e.isGroup, u = e.parentThrottleDrag, d = e.distX, f = e.distY, h = n.isDrag, p = n.prevDist, g = n.prevBeforeDist, m = n.startValue;
      if (h) {
        o && (d += o[0], f += o[1]);
        var v = t.props, y = v.parentMoveable, E = c ? 0 : v.throttleDrag || u || 0, b = r ? 0 : v.throttleDragRotate || 0, _ = 0, w = !1, S = !1, x = !1, k = !1;
        if (!r && b > 0 && (d || f)) {
          var T = v.startDragRotate || 0, I = tt(T + Qt([0, 0], [d, f]) * 180 / Math.PI, b) - T, R = f * Math.abs(Math.cos((I - 90) / 180 * Math.PI)), N = d * Math.abs(Math.cos(I / 180 * Math.PI)), $ = ci([N, R]);
          _ = I * Math.PI / 180, d = $ * Math.cos(_), f = $ * Math.sin(_);
        }
        if (!s && !r && !i) {
          var B = F(lee(t, d, f, b, !a && l || o, n), 2), G = B[0], M = B[1];
          w = G.isSnap, S = G.isBound, x = M.isSnap, k = M.isBound;
          var A = G.offset, z = M.offset;
          d += A, f += z;
        }
        var V = wt(DP({ datas: n, distX: d, distY: f }), m), U = wt(SQ({ datas: n, distX: d, distY: f }), m);
        ET(U, rr), ET(V, rr), b || (!w && !S && (U[0] = tt(U[0], E), V[0] = tt(V[0], E)), !x && !k && (U[1] = tt(U[1], E), V[1] = tt(V[1], E)));
        var Y = Ke(V, m), ne = Ke(U, m), ie = Ke(ne, p), Z = Ke(Y, g);
        n.prevDist = ne, n.prevBeforeDist = Y, n.passDelta = ie, n.passDist = ne;
        var Q = n.left + Y[0], fe = n.top + Y[1], ge = n.right - Y[0], Re = n.bottom - Y[1], Be = n0(n, "translate(".concat(U[0], "px, ").concat(U[1], "px)"), "translate(".concat(ne[0], "px, ").concat(ne[1], "px)"));
        if (AE(e, Be), t.state.dragInfo.dist = r ? [0, 0] : ne, !(!r && !y && ie.every(function(Ce) {
          return !Ce;
        }) && Z.some(function(Ce) {
          return !Ce;
        }))) {
          var le = t.state, Ee = le.width, Se = le.height, xe = st(t, e, L({ transform: Be, dist: ne, delta: ie, translate: U, beforeDist: Y, beforeDelta: Z, beforeTranslate: V, left: Q, top: fe, right: ge, bottom: Re, width: Ee, height: Se, isPinch: s }, Jn({
            transform: Be
          }, e)));
          return !r && Ne(t, "onDrag", xe), xe;
        }
      }
    }
  },
  dragAfter: function(t, e) {
    var n = e.datas, r = n.deltaOffset;
    return r[0] || r[1] ? (n.deltaOffset = [0, 0], this.drag(t, L(L({}, e), { deltaOffset: r }))) : !1;
  },
  dragEnd: function(t, e) {
    var n = e.parentEvent, r = e.datas;
    if (t.state.dragInfo = null, !!r.isDrag) {
      r.isDrag = !1;
      var i = zr(t, e, {});
      return !n && Ne(t, "onDragEnd", i), i;
    }
  },
  dragGroupStart: function(t, e) {
    var n, r, i = e.datas, s = e.clientX, o = e.clientY, a = this.dragStart(t, e);
    if (!a)
      return !1;
    var l = Cb(t, this, "dragStart", [
      s || 0,
      o || 0
    ], e, !1, "draggable"), c = l.childEvents, u = l.eventParams, d = L(L({}, a), { targets: t.props.targets, events: u }), f = Ne(t, "onDragGroupStart", d);
    i.isDrag = f !== !1;
    var h = (r = (n = c[0]) === null || n === void 0 ? void 0 : n.datas.startValue) !== null && r !== void 0 ? r : [0, 0];
    return i.throttleOffset = [h[0] % 1, h[1] % 1], i.isDrag ? a : !1;
  },
  dragGroup: function(t, e) {
    var n = e.datas;
    if (n.isDrag) {
      var r = this.drag(t, L(L({}, e), { parentThrottleDrag: t.props.throttleDrag })), i = e.datas.passDelta, s = Cb(t, this, "drag", i, e, !1, "draggable").eventParams;
      if (r) {
        var o = L({ targets: t.props.targets, events: s }, r);
        return Ne(t, "onDragGroup", o), o;
      }
    }
  },
  dragGroupEnd: function(t, e) {
    var n = e.isDrag, r = e.datas;
    if (r.isDrag) {
      this.dragEnd(t, e);
      var i = Cb(t, this, "dragEnd", [0, 0], e, !1, "draggable").eventParams;
      return Ne(t, "onDragGroupEnd", zr(t, e, {
        targets: t.props.targets,
        events: i
      })), n;
    }
  },
  /**
       * @method Moveable.Draggable#request
       * @param {object} [e] - the draggable's request parameter
       * @param {number} [e.x] - x position
       * @param {number} [e.y] - y position
       * @param {number} [e.deltaX] - X number to move
       * @param {number} [e.deltaY] - Y number to move
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("draggable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 });
       * moveable.request("draggable", { x: 220, y: 100 });
       * moveable.request("draggable", { x: 240, y: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request: function(t) {
    var e = {}, n = t.getRect(), r = 0, i = 0, s = !1;
    return {
      isControl: !1,
      requestStart: function(o) {
        return s = o.useSnap, { datas: e, useSnap: s };
      },
      request: function(o) {
        return "x" in o ? r = o.x - n.left : "deltaX" in o && (r += o.deltaX), "y" in o ? i = o.y - n.top : "deltaY" in o && (i += o.deltaY), { datas: e, distX: r, distY: i, useSnap: s };
      },
      requestEnd: function() {
        return { datas: e, isDrag: !0, useSnap: s };
      }
    };
  },
  unset: function(t) {
    t.state.gestos.draggable = null, t.state.dragInfo = null;
  }
};
function QP(t, e) {
  var n = hn(t, e), r = [0, 0];
  return {
    fixedPosition: n,
    fixedDirection: e,
    fixedOffset: r
  };
}
function hee(t, e) {
  var n = t.allMatrix, r = t.is3d, i = t.width, s = t.height, o = r ? 4 : 3, a = [
    i / 2 * (1 + e[0]),
    s / 2 * (1 + e[1])
  ], l = qt(n, a, o), c = [0, 0];
  return {
    fixedPosition: l,
    fixedDirection: e,
    fixedOffset: c
  };
}
function eL(t, e) {
  var n = t.allMatrix, r = t.is3d, i = t.width, s = t.height, o = r ? 4 : 3, a = NQ(e, i, s), l = qt(n, e, o), c = [
    i ? 0 : e[0],
    s ? 0 : e[1]
  ];
  return {
    fixedPosition: l,
    fixedDirection: a,
    fixedOffset: c
  };
}
var WT = UE("resizable"), R1 = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: [
    "resizable",
    "throttleResize",
    "renderDirections",
    "displayAroundControls",
    "keepRatio",
    "resizeFormat",
    "keepRatioFinally",
    "edge",
    "checkResizableError"
  ],
  events: [
    "resizeStart",
    "beforeResize",
    "resize",
    "resizeEnd",
    "resizeGroupStart",
    "beforeResizeGroup",
    "resizeGroup",
    "resizeGroupEnd"
  ],
  render: HP("resizable"),
  dragControlCondition: WT,
  viewClassName: HE("resizable"),
  dragControlStart: function(t, e) {
    var n, r = e.inputEvent, i = e.isPinch, s = e.isGroup, o = e.parentDirection, a = e.parentGesto, l = e.datas, c = e.parentFixedDirection, u = e.parentEvent, d = hL(o, i, r, l), f = t.state, h = f.target, p = f.width, g = f.height, m = f.gestos;
    if (!d || !h || m.resizable)
      return !1;
    m.resizable = a || t.controlGesto, !i && pl(t, e), l.datas = {}, l.direction = d, l.startOffsetWidth = p, l.startOffsetHeight = g, l.prevWidth = 0, l.prevHeight = 0, l.minSize = [0, 0], l.startWidth = f.inlineCSSWidth || f.cssWidth, l.startHeight = f.inlineCSSHeight || f.cssHeight, l.maxSize = [1 / 0, 1 / 0], s || (l.minSize = [
      f.minOffsetWidth,
      f.minOffsetHeight
    ], l.maxSize = [
      f.maxOffsetWidth,
      f.maxOffsetHeight
    ]);
    var v = t.props.transformOrigin || "% %";
    l.transformOrigin = v && vr(v) ? v.split(" ") : v, l.startOffsetMatrix = f.offsetMatrix, l.startTransformOrigin = f.transformOrigin, l.isWidth = (n = e == null ? void 0 : e.parentIsWidth) !== null && n !== void 0 ? n : !d[0] && !d[1] || d[0] || !d[1];
    function y(k) {
      l.ratio = k && isFinite(k) ? k : 0;
    }
    l.startPositions = ui(t.state);
    function E(k) {
      var T = QP(l.startPositions, k);
      l.fixedDirection = T.fixedDirection, l.fixedPosition = T.fixedPosition, l.fixedOffset = T.fixedOffset;
    }
    function b(k) {
      var T = eL(t.state, k);
      l.fixedDirection = T.fixedDirection, l.fixedPosition = T.fixedPosition, l.fixedOffset = T.fixedOffset;
    }
    function _(k) {
      l.minSize = [
        Ot("".concat(k[0]), 0) || 0,
        Ot("".concat(k[1]), 0) || 0
      ];
    }
    function w(k) {
      var T = [
        k[0] || 1 / 0,
        k[1] || 1 / 0
      ];
      (!Bc(T[0]) || isFinite(T[0])) && (T[0] = Ot("".concat(T[0]), 0) || 1 / 0), (!Bc(T[1]) || isFinite(T[1])) && (T[1] = Ot("".concat(T[1]), 0) || 1 / 0), l.maxSize = T;
    }
    y(p / g), E(c || [-d[0], -d[1]]), l.setFixedDirection = E, l.setFixedPosition = b, l.setMin = _, l.setMax = w;
    var S = st(t, e, {
      direction: d,
      startRatio: l.ratio,
      set: function(k) {
        var T = F(k, 2), I = T[0], R = T[1];
        l.startWidth = I, l.startHeight = R;
      },
      setMin: _,
      setMax: w,
      setRatio: y,
      setFixedDirection: E,
      setFixedPosition: b,
      setOrigin: function(k) {
        l.transformOrigin = k;
      },
      dragStart: qn.dragStart(t, new zc().dragStart([0, 0], e))
    }), x = u || Ne(t, "onResizeStart", S);
    return l.startFixedDirection = l.fixedDirection, l.startFixedPosition = l.fixedPosition, x !== !1 && (l.isResize = !0, t.state.snapRenderInfo = {
      request: e.isRequest,
      direction: d
    }), l.isResize ? S : !1;
  },
  dragControl: function(t, e) {
    var n, r = e.datas, i = e.parentFlag, s = e.isPinch, o = e.parentKeepRatio, a = e.dragClient, l = e.parentDist, c = e.useSnap, u = e.isRequest, d = e.isGroup, f = e.parentEvent, h = e.resolveMatrix, p = r.isResize, g = r.transformOrigin, m = r.startWidth, v = r.startHeight, y = r.prevWidth, E = r.prevHeight, b = r.minSize, _ = r.maxSize, w = r.ratio, S = r.startOffsetWidth, x = r.startOffsetHeight, k = r.isWidth;
    if (!p)
      return;
    if (h) {
      var T = t.state.is3d, I = r.startOffsetMatrix, R = r.startTransformOrigin, N = T ? 4 : 3, $ = Qd(Bg(e)), B = Math.sqrt($.length);
      N !== B && ($ = Ri($, B, N));
      var G = Zf(I, $, R, N), M = gl(G, S, x, N);
      r.startPositions = M, r.nextTargetMatrix = $, r.nextAllMatrix = G;
    }
    var A = nl(t.props, "resizable"), z = A.resizeFormat, V = A.throttleResize, U = V === void 0 ? i ? 0 : 1 : V, Y = A.parentMoveable, ne = A.keepRatioFinally, ie = r.direction, Z = ie, Q = 0, fe = 0;
    !ie[0] && !ie[1] && (Z = [1, 1]);
    var ge = w && (o ?? A.keepRatio) || !1;
    function Re() {
      var ye = r.fixedDirection, j = wL(Z, ge, r, e);
      Q = j.distWidth, fe = j.distHeight;
      var re = Z[0] - ye[0] || ge ? Math.max(S + Q, rr) : S, H = Z[1] - ye[1] || ge ? Math.max(x + fe, rr) : x;
      return ge && S && x && (k ? H = re / w : re = H * w), [re, H];
    }
    var Be = F(Re(), 2), le = Be[0], Ee = Be[1];
    f || (r.setFixedDirection(r.fixedDirection), Ne(t, "onBeforeResize", st(t, e, {
      startFixedDirection: r.startFixedDirection,
      startFixedPosition: r.startFixedPosition,
      setFixedDirection: function(ye) {
        var j;
        return r.setFixedDirection(ye), j = F(Re(), 2), le = j[0], Ee = j[1], [le, Ee];
      },
      setFixedPosition: function(ye) {
        var j;
        return r.setFixedPosition(ye), j = F(Re(), 2), le = j[0], Ee = j[1], [le, Ee];
      },
      boundingWidth: le,
      boundingHeight: Ee,
      setSize: function(ye) {
        var j;
        j = F(ye, 2), le = j[0], Ee = j[1];
      }
    }, !0)));
    var Se = a;
    a || (!i && s ? Se = PQ(t, [0, 0]) : Se = r.fixedPosition);
    var xe = [0, 0];
    s || (xe = Mee(t, le, Ee, ie, Se, !c && u, r)), l && (!l[0] && (xe[0] = 0), !l[1] && (xe[1] = 0));
    function Ce() {
      var ye;
      z && (ye = F(z([le, Ee]), 2), le = ye[0], Ee = ye[1]), le = tt(le, U), Ee = tt(Ee, U);
    }
    if (ge) {
      Z[0] && Z[1] && xe[0] && xe[1] && (oe(xe[0]) > oe(xe[1]) ? xe[1] = 0 : xe[0] = 0);
      var _e = !xe[0] && !xe[1];
      _e && Ce(), Z[0] && !Z[1] || xe[0] && !xe[1] || _e && k ? (le += xe[0], Ee = le / w) : (!Z[0] && Z[1] || !xe[0] && xe[1] || _e && !k) && (Ee += xe[1], le = Ee * w);
    } else
      le += xe[0], Ee += xe[1], le = Math.max(0, le), Ee = Math.max(0, Ee);
    n = F(j2([le, Ee], b, _, ge ? w : !1), 2), le = n[0], Ee = n[1], Ce(), ge && (d || ne) && (k ? Ee = le / w : le = Ee * w), Q = le - S, fe = Ee - x;
    var Je = [Q - y, fe - E];
    r.prevWidth = Q, r.prevHeight = fe;
    var P = IQ(t, le, Ee, Se, g, r);
    if (!(!Y && Je.every(function(ye) {
      return !ye;
    }) && P.every(function(ye) {
      return !ye;
    }))) {
      var O = qn.drag(t, Jf(e, t.state, P, !!s, !1, "draggable")), q = O.transform, ee = m + Q, ce = v + fe, Pe = st(t, e, L({ width: ee, height: ce, offsetWidth: Math.round(le), offsetHeight: Math.round(Ee), startRatio: w, boundingWidth: le, boundingHeight: Ee, direction: ie, dist: [Q, fe], delta: Je, isPinch: !!s, drag: O }, gL({
        style: {
          width: "".concat(ee, "px"),
          height: "".concat(ce, "px")
        },
        transform: q
      }, O, e)));
      return !f && Ne(t, "onResize", Pe), Pe;
    }
  },
  dragControlAfter: function(t, e) {
    var n = e.datas, r = n.isResize, i = n.startOffsetWidth, s = n.startOffsetHeight, o = n.prevWidth, a = n.prevHeight;
    if (!(!r || t.props.checkResizableError === !1)) {
      var l = t.state, c = l.width, u = l.height, d = c - (i + o), f = u - (s + a), h = oe(d) > 3, p = oe(f) > 3;
      if (h && (n.startWidth += d, n.startOffsetWidth += d, n.prevWidth += d), p && (n.startHeight += f, n.startOffsetHeight += f, n.prevHeight += f), h || p)
        return this.dragControl(t, e);
    }
  },
  dragControlEnd: function(t, e) {
    var n = e.datas, r = e.parentEvent;
    if (n.isResize) {
      n.isResize = !1;
      var i = zr(t, e, {});
      return !r && Ne(t, "onResizeEnd", i), i;
    }
  },
  dragGroupControlCondition: WT,
  dragGroupControlStart: function(t, e) {
    var n = e.datas, r = this.dragControlStart(t, L(L({}, e), { isGroup: !0 }));
    if (!r)
      return !1;
    var i = Ci(t, "resizable", e), s = n.startOffsetWidth, o = n.startOffsetHeight;
    function a() {
      var h = n.minSize;
      i.forEach(function(p) {
        var g = p.datas, m = g.minSize, v = g.startOffsetWidth, y = g.startOffsetHeight, E = s * (v ? m[0] / v : 0), b = o * (y ? m[1] / y : 0);
        h[0] = Math.max(h[0], E), h[1] = Math.max(h[1], b);
      });
    }
    function l() {
      var h = n.maxSize;
      i.forEach(function(p) {
        var g = p.datas, m = g.maxSize, v = g.startOffsetWidth, y = g.startOffsetHeight, E = s * (v ? m[0] / v : 0), b = o * (y ? m[1] / y : 0);
        h[0] = Math.min(h[0], E), h[1] = Math.min(h[1], b);
      });
    }
    var c = Fs(t, this, "dragControlStart", e, function(h, p) {
      return Fg(t, h, n, p);
    });
    a(), l();
    var u = function(h) {
      r.setFixedDirection(h), c.forEach(function(p, g) {
        p.setFixedDirection(h), Fg(t, p.moveable, n, i[g]);
      });
    };
    n.setFixedDirection = u;
    var d = L(L({}, r), { targets: t.props.targets, events: c.map(function(h) {
      return L(L({}, h), { setMin: function(p) {
        h.setMin(p), a();
      }, setMax: function(p) {
        h.setMax(p), l();
      } });
    }), setFixedDirection: u, setMin: function(h) {
      r.setMin(h), a();
    }, setMax: function(h) {
      r.setMax(h), l();
    } }), f = Ne(t, "onResizeGroupStart", d);
    return n.isResize = f !== !1, n.isResize ? r : !1;
  },
  dragGroupControl: function(t, e) {
    var n = e.datas;
    if (n.isResize) {
      var r = nl(t.props, "resizable");
      c0(t, "onBeforeResize", function(h) {
        Ne(t, "onBeforeResizeGroup", st(t, e, L(L({}, h), { targets: r.targets }), !0));
      });
      var i = this.dragControl(t, L(L({}, e), { isGroup: !0 }));
      if (i) {
        var s = i.boundingWidth, o = i.boundingHeight, a = i.dist, l = r.keepRatio, c = [
          s / (s - a[0]),
          o / (o - a[1])
        ], u = n.fixedPosition, d = Fs(t, this, "dragControl", e, function(h, p) {
          var g = F(Bn(Kf(t.rotation / 180 * Math.PI, 3), [
            p.datas.originalX * c[0],
            p.datas.originalY * c[1],
            1
          ], 3), 2), m = g[0], v = g[1];
          return L(L({}, p), { parentDist: null, parentScale: c, dragClient: wt(u, [m, v]), parentKeepRatio: l });
        }), f = L({ targets: r.targets, events: d }, i);
        return Ne(t, "onResizeGroup", f), f;
      }
    }
  },
  dragGroupControlEnd: function(t, e) {
    var n = e.isDrag, r = e.datas;
    if (r.isResize) {
      this.dragControlEnd(t, e);
      var i = Fs(t, this, "dragControlEnd", e), s = zr(t, e, {
        targets: t.props.targets,
        events: i
      });
      return Ne(t, "onResizeGroupEnd", s), n;
    }
  },
  /**
       * @method Moveable.Resizable#request
       * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("resizable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request: function(t) {
    var e = {}, n = 0, r = 0, i = !1, s = t.getRect();
    return {
      isControl: !0,
      requestStart: function(o) {
        var a;
        return i = o.useSnap, {
          datas: e,
          parentDirection: o.direction || [1, 1],
          parentIsWidth: (a = o == null ? void 0 : o.horizontal) !== null && a !== void 0 ? a : !0,
          useSnap: i
        };
      },
      request: function(o) {
        return "offsetWidth" in o ? n = o.offsetWidth - s.offsetWidth : "deltaWidth" in o && (n += o.deltaWidth), "offsetHeight" in o ? r = o.offsetHeight - s.offsetHeight : "deltaHeight" in o && (r += o.deltaHeight), {
          datas: e,
          parentDist: [n, r],
          parentKeepRatio: o.keepRatio,
          useSnap: i
        };
      },
      requestEnd: function() {
        return { datas: e, isDrag: !0, useSnap: i };
      }
    };
  },
  unset: function(t) {
    t.state.gestos.resizable = null;
  }
};
function Tb(t, e, n, r, i) {
  var s = t.props.groupable, o = t.state, a = o.is3d ? 4 : 3, l = e.origin, c = qt(
    t.state.rootMatrix,
    // TO-DO #710
    Ke([l[0], l[1]], s ? [0, 0] : [o.left, o.top]),
    a
  ), u = wt([i.left, i.top], c);
  e.startAbsoluteOrigin = u, e.prevDeg = Qt(u, [n, r]) / Math.PI * 180, e.defaultDeg = e.prevDeg, e.prevSnapDeg = 0, e.loop = 0, e.startDist = Bs(u, [n, r]);
}
function Tp(t, e, n) {
  var r = n.defaultDeg, i = n.prevDeg, s = i % 360, o = Math.floor(i / 360);
  s < 0 && (s += 360), s > t && s > 270 && t < 90 ? ++o : s < t && s < 90 && t > 270 && --o;
  var a = e * (o * 360 + t - r);
  return n.prevDeg = r + a, a;
}
function Ob(t, e, n, r) {
  return Tp(Qt(r.startAbsoluteOrigin, [t, e]) / Math.PI * 180, n, r);
}
function Mb(t, e, n, r, i, s) {
  var o = t.props.throttleRotate, a = o === void 0 ? 0 : o, l = n.prevSnapDeg, c = 0, u = !1;
  if (s) {
    var d = Oee(t, e, r, i + r);
    u = d.isSnap, c = i + d.dist;
  }
  u || (c = tt(i + r, a));
  var f = c - i;
  return n.prevSnapDeg = f, [f - l, f, c];
}
function tL(t, e, n) {
  var r = F(e, 4), i = r[0], s = r[1], o = r[2], a = r[3];
  if (t === "none")
    return [];
  if (rn(t))
    return t.map(function(m) {
      return tL(m, [i, s, o, a], n)[0];
    });
  var l = F((t || "top").split("-"), 2), c = l[0], u = l[1], d = [i, s];
  c === "left" ? d = [o, i] : c === "right" ? d = [s, a] : c === "bottom" && (d = [a, o]);
  var f = [
    (d[0][0] + d[1][0]) / 2,
    (d[0][1] + d[1][1]) / 2
  ], h = dL(d, n);
  if (u) {
    var p = u === "top" || u === "left", g = c === "bottom" || c === "left";
    f = d[p && !g || !p && g ? 0 : 1];
  }
  return [[f, h]];
}
function D1(t, e) {
  if (e.isRequest)
    return e.requestAble === "rotatable";
  var n = e.inputEvent.target;
  if (fn(n, qe("rotation-control")) || t.props.rotateAroundControls && fn(n, qe("around-control")) || fn(n, qe("control")) && fn(n, qe("rotatable")))
    return !0;
  var r = t.props.rotationTarget;
  return r ? VE(r, !0).some(function(i) {
    return i ? n === i || n.contains(i) : !1;
  }) : !1;
}
var pee = `.rotation {
position: absolute;
height: 40px;
width: 1px;
transform-origin: 50% 100%;
height: calc(40px * var(--zoom));
top: auto;
left: 0;
bottom: 100%;
will-change: transform;
}
.rotation .rotation-line {
display: block;
width: 100%;
height: 100%;
transform-origin: 50% 50%;
}
.rotation .rotation-control {
border-color: #4af;
border-color: var(--moveable-color);
background:#fff;
cursor: alias;
}
:global .view-rotation-dragging, .rotatable.direction.control {
cursor: alias;
}
.rotatable.direction.control.move {
cursor: move;
}
`, gee = {
  name: "rotatable",
  canPinch: !0,
  props: [
    "rotatable",
    "rotationPosition",
    "throttleRotate",
    "renderDirections",
    "rotationTarget",
    "rotateAroundControls",
    "edge",
    "resolveAblesWithRotatable",
    "displayAroundControls"
  ],
  events: [
    "rotateStart",
    "beforeRotate",
    "rotate",
    "rotateEnd",
    "rotateGroupStart",
    "beforeRotateGroup",
    "rotateGroup",
    "rotateGroupEnd"
  ],
  css: [pee],
  viewClassName: function(t) {
    return t.isDragging("rotatable") ? qe("view-rotation-dragging") : "";
  },
  render: function(t, e) {
    var n = nl(t.props, "rotatable"), r = n.rotatable, i = n.rotationPosition, s = n.zoom, o = n.renderDirections, a = n.rotateAroundControls, l = n.resolveAblesWithRotatable, c = t.getState(), u = c.renderPoses, d = c.direction;
    if (!r)
      return null;
    var f = tL(i, u, d), h = [];
    if (f.forEach(function(v, y) {
      var E = F(v, 2), b = E[0], _ = E[1];
      h.push(e.createElement(
        "div",
        { key: "rotation".concat(y), className: qe("rotation"), style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(".concat(b[0], "px, ").concat(b[1], "px) rotate(").concat(_, "rad)")
        } },
        e.createElement("div", { className: qe("line rotation-line"), style: {
          transform: "scaleX(".concat(s, ")")
        } }),
        e.createElement("div", { className: qe("control rotation-control"), style: {
          transform: "translate(0.5px) scale(".concat(s, ")")
        } })
      ));
    }), o) {
      var p = Gs(l || {}), g = {};
      p.forEach(function(v) {
        l[v].forEach(function(y) {
          g[y] = v;
        });
      });
      var m = [];
      rn(o) && (m = o.map(function(v) {
        var y = g[v];
        return {
          data: y ? { resolve: y } : {},
          classNames: y ? ["move"] : [],
          dir: v
        };
      })), h.push.apply(h, he([], F(BP(t, "rotatable", m, e)), !1));
    }
    return a && h.push.apply(h, he([], F(VP(t, e)), !1)), h;
  },
  dragControlCondition: D1,
  dragControlStart: function(t, e) {
    var n, r, i = e.datas, s = e.clientX, o = e.clientY, a = e.parentRotate, l = e.parentFlag, c = e.isPinch, u = e.isRequest, d = t.state, f = d.target, h = d.left, p = d.top, g = d.direction, m = d.beforeDirection, v = d.targetTransform, y = d.moveableClientRect, E = d.offsetMatrix, b = d.targetMatrix, _ = d.allMatrix, w = d.width, S = d.height;
    if (!u && !f)
      return !1;
    var x = t.getRect();
    i.rect = x, i.transform = v, i.left = h, i.top = p;
    var k = function(Z) {
      var Q = eL(t.state, Z);
      i.fixedDirection = Q.fixedDirection, i.fixedOffset = Q.fixedOffset, i.fixedPosition = Q.fixedPosition, U && U.setFixedPosition(Z);
    }, T = function(Z) {
      var Q = hee(t.state, Z);
      i.fixedDirection = Q.fixedDirection, i.fixedOffset = Q.fixedOffset, i.fixedPosition = Q.fixedPosition, U && U.setFixedDirection(Z);
    }, I = s, R = o;
    if (u || c || l) {
      var N = a || 0;
      i.beforeInfo = {
        origin: x.beforeOrigin,
        prevDeg: N,
        defaultDeg: N,
        prevSnapDeg: 0,
        startDist: 0
      }, i.afterInfo = L(L({}, i.beforeInfo), { origin: x.origin }), i.absoluteInfo = L(L({}, i.beforeInfo), { origin: x.origin, startValue: N });
    } else {
      var $ = (r = e.inputEvent) === null || r === void 0 ? void 0 : r.target;
      if ($) {
        var B = $.getAttribute("data-direction") || "", G = _Q[B];
        if (G) {
          i.isControl = !0, i.isAroundControl = fn($, qe("around-control")), i.controlDirection = G;
          var M = $.getAttribute("data-resolve");
          M && (i.resolveAble = M);
          var A = Wee(d.rootMatrix, d.renderPoses, y);
          n = F(hn(A, G), 2), I = n[0], R = n[1];
        }
      }
      i.beforeInfo = { origin: x.beforeOrigin }, i.afterInfo = { origin: x.origin }, i.absoluteInfo = {
        origin: x.origin,
        startValue: x.rotation
      };
      var z = k;
      k = function(Z) {
        var Q = d.is3d ? 4 : 3, fe = F(wt(vP(b, Q), Z), 2), ge = fe[0], Re = fe[1], Be = Bn(E, Qa([ge, Re], Q)), le = Bn(_, Qa([Z[0], Z[1]], Q));
        z(Z);
        var Ee = d.posDelta;
        i.beforeInfo.origin = Ke(Be, Ee), i.afterInfo.origin = Ke(le, Ee), i.absoluteInfo.origin = Ke(le, Ee), Tb(t, i.beforeInfo, I, R, y), Tb(t, i.afterInfo, I, R, y), Tb(t, i.absoluteInfo, I, R, y);
      }, T = function(Z) {
        var Q = hn([
          [0, 0],
          [w, 0],
          [0, S],
          [w, S]
        ], Z);
        k(Q);
      };
    }
    i.startClientX = I, i.startClientY = R, i.direction = g, i.beforeDirection = m, i.startValue = 0, i.datas = {}, i0(t, e, "rotate");
    var V = !1, U = !1;
    if (i.isControl && i.resolveAble) {
      var Y = i.resolveAble;
      Y === "resizable" && (U = R1.dragControlStart(t, L(L({}, new zc("resizable").dragStart([0, 0], e)), { parentPosition: i.controlPosition, parentFixedPosition: i.fixedPosition })));
    }
    U || (V = qn.dragStart(t, new zc().dragStart([0, 0], e))), k(Gee(t));
    var ne = st(t, e, L(L({ set: function(Z) {
      i.startValue = Z * Math.PI / 180;
    }, setFixedDirection: T, setFixedPosition: k }, r0(t, e)), { dragStart: V, resizeStart: U })), ie = Ne(t, "onRotateStart", ne);
    return i.isRotate = ie !== !1, d.snapRenderInfo = {
      request: e.isRequest
    }, i.isRotate ? ne : !1;
  },
  dragControl: function(t, e) {
    var n, r, i, s = e.datas, o = e.clientDistX, a = e.clientDistY, l = e.parentRotate, c = e.parentFlag, u = e.isPinch, d = e.groupDelta, f = e.resolveMatrix, h = s.beforeDirection, p = s.beforeInfo, g = s.afterInfo, m = s.absoluteInfo, v = s.isRotate, y = s.startValue, E = s.rect, b = s.startClientX, _ = s.startClientY;
    if (v) {
      t0(t, e, "rotate");
      var w = EQ(e), S = h * w, x = t.props.parentMoveable, k = 0, T, I, R = 0, N, $, B = 0, G, M, A = 180 / Math.PI * y, z = m.startValue, V = !1, U = b + o, Y = _ + a;
      if (!c && "parentDist" in e) {
        var ne = e.parentDist;
        T = ne, N = ne, G = ne;
      } else
        u || c ? (T = Tp(l, h, p), N = Tp(l, S, g), G = Tp(l, S, m)) : (T = Ob(U, Y, h, p), N = Ob(U, Y, S, g), G = Ob(U, Y, S, m), V = !0);
      if (I = A + T, $ = A + N, M = z + G, Ne(t, "onBeforeRotate", st(t, e, {
        beforeRotation: I,
        rotation: $,
        absoluteRotation: M,
        setRotation: function(Se) {
          N = Se - A, T = N, G = N;
        }
      }, !0)), n = F(Mb(t, E, p, T, A, V), 3), k = n[0], T = n[1], I = n[2], r = F(Mb(t, E, g, N, A, V), 3), R = r[0], N = r[1], $ = r[2], i = F(Mb(t, E, m, G, z, V), 3), B = i[0], G = i[1], M = i[2], !(!B && !R && !k && !x && !f)) {
        var ie = n0(s, "rotate(".concat($, "deg)"), "rotate(".concat(N, "deg)"));
        f && (s.fixedPosition = NE(t, s.targetAllTransform, s.fixedDirection, s.fixedOffset, s));
        var Z = DQ(t, N, s), Q = Ke(wt(d || [0, 0], Z), s.prevInverseDist || [0, 0]);
        s.prevInverseDist = Z, s.requestValue = null;
        var fe = PP(t, ie, Q, u, e), ge = fe, Re = Bs([U, Y], m.startAbsoluteOrigin) - m.startDist, Be = void 0;
        if (s.resolveAble === "resizable") {
          var le = R1.dragControl(t, L(L({}, Jf(e, t.state, [e.deltaX, e.deltaY], !!u, !1, "resizable")), { resolveMatrix: !0, parentDistance: Re }));
          le && (Be = le, ge = gL(ge, le, e));
        }
        var Ee = st(t, e, L(L({ delta: R, dist: N, rotate: $, rotation: $, beforeDist: T, beforeDelta: k, beforeRotate: I, beforeRotation: I, absoluteDist: G, absoluteDelta: B, absoluteRotate: M, absoluteRotation: M, isPinch: !!u, resize: Be }, fe), ge));
        return Ne(t, "onRotate", Ee), Ee;
      }
    }
  },
  dragControlEnd: function(t, e) {
    var n = e.datas;
    if (n.isRotate) {
      n.isRotate = !1;
      var r = zr(t, e, {});
      return Ne(t, "onRotateEnd", r), r;
    }
  },
  dragGroupControlCondition: D1,
  dragGroupControlStart: function(t, e) {
    var n = e.datas, r = t.state, i = r.left, s = r.top, o = r.beforeOrigin, a = this.dragControlStart(t, e);
    if (!a)
      return !1;
    a.set(n.beforeDirection * t.rotation);
    var l = Fs(t, this, "dragControlStart", e, function(d, f) {
      var h = d.state, p = h.left, g = h.top, m = h.beforeOrigin, v = wt(Ke([p, g], [i, s]), Ke(m, o));
      return f.datas.startGroupClient = v, f.datas.groupClient = v, L(L({}, f), { parentRotate: 0 });
    }), c = L(L({}, a), { targets: t.props.targets, events: l }), u = Ne(t, "onRotateGroupStart", c);
    return n.isRotate = u !== !1, n.isRotate ? a : !1;
  },
  dragGroupControl: function(t, e) {
    var n = e.datas;
    if (n.isRotate) {
      c0(t, "onBeforeRotate", function(c) {
        Ne(t, "onBeforeRotateGroup", st(t, e, L(L({}, c), { targets: t.props.targets }), !0));
      });
      var r = this.dragControl(t, e);
      if (r) {
        var i = n.beforeDirection, s = r.beforeDist, o = s / 180 * Math.PI, a = Fs(t, this, "dragControl", e, function(c, u) {
          var d = u.datas.startGroupClient, f = F(u.datas.groupClient, 2), h = f[0], p = f[1], g = F(qf(d, o * i), 2), m = g[0], v = g[1], y = [m - h, v - p];
          return u.datas.groupClient = [m, v], L(L({}, u), { parentRotate: s, groupDelta: y });
        });
        t.rotation = i * r.beforeRotation;
        var l = L({ targets: t.props.targets, events: a, set: function(c) {
          t.rotation = c;
        }, setGroupRotation: function(c) {
          t.rotation = c;
        } }, r);
        return Ne(t, "onRotateGroup", l), l;
      }
    }
  },
  dragGroupControlEnd: function(t, e) {
    var n = e.isDrag, r = e.datas;
    if (r.isRotate) {
      this.dragControlEnd(t, e);
      var i = Fs(t, this, "dragControlEnd", e), s = zr(t, e, {
        targets: t.props.targets,
        events: i
      });
      return Ne(t, "onRotateGroupEnd", s), n;
    }
  },
  /**
       * @method Moveable.Rotatable#request
       * @param {object} [e] - the Resizable's request parameter
       * @param {number} [e.deltaRotate=0] -  delta number of rotation
       * @param {number} [e.rotate=0] - absolute number of moveable's rotation
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("rotatable", { deltaRotate: 10 }, true);
       *
       * * moveable.request("rotatable", { rotate: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("rotatable");
       *
       * // request
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       *
       * requester.request({ rotate: 10 });
       * requester.request({ rotate: 20 });
       * requester.request({ rotate: 30 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request: function(t) {
    var e = {}, n = 0, r = t.getRotation();
    return {
      isControl: !0,
      requestStart: function() {
        return { datas: e };
      },
      request: function(i) {
        return "deltaRotate" in i ? n += i.deltaRotate : "rotate" in i && (n = i.rotate - r), { datas: e, parentDist: n };
      },
      requestEnd: function() {
        return { datas: e, isDrag: !0 };
      }
    };
  }
};
function mee(t, e) {
  var n, r = t.direction, i = t.classNames, s = t.size, o = t.pos, a = t.zoom, l = t.key, c = r === "horizontal", u = c ? "Y" : "X";
  return e.createElement("div", {
    key: l,
    className: i.join(" "),
    style: (n = {}, n[c ? "width" : "height"] = "".concat(s), n.transform = "translate(".concat(o[0], ", ").concat(o[1], ") translate").concat(u, "(-50%) scale").concat(u, "(").concat(a, ")"), n)
  });
}
function $E(t, e) {
  return mee(L(L({}, t), { classNames: he([
    qe("line", "guideline", t.direction)
  ], F(t.classNames), !1).filter(function(n) {
    return n;
  }), size: t.size || "".concat(t.sizeValue, "px"), pos: t.pos || t.posValue.map(function(n) {
    return "".concat(tt(n, 0.1), "px");
  }) }), e);
}
function GT(t, e, n, r, i, s, o, a) {
  var l = t.props.zoom;
  return n.map(function(c, u) {
    var d = c.type, f = c.pos, h = [0, 0];
    return h[o] = r, h[o ? 0 : 1] = -i + f, $E({
      key: "".concat(e, "TargetGuideline").concat(u),
      classNames: [qe("target", "bold", d)],
      posValue: h,
      sizeValue: s,
      zoom: l,
      direction: e
    }, a);
  });
}
function jT(t, e, n, r, i, s) {
  var o = t.props, a = o.zoom, l = o.isDisplayInnerSnapDigit, c = e === "horizontal" ? Io : Po, u = i[c.start], d = i[c.end];
  return n.filter(function(f) {
    var h = f.hide, p = f.elementRect;
    if (h)
      return !1;
    if (l && p) {
      var g = p.rect;
      if (g[c.start] <= u && d <= g[c.end])
        return !1;
    }
    return !0;
  }).map(function(f, h) {
    var p = f.pos, g = f.size, m = f.element, v = f.className, y = [
      -r[0] + p[0],
      -r[1] + p[1]
    ];
    return $E({
      key: "".concat(e, "-default-guideline-").concat(h),
      classNames: m ? [qe("bold"), v] : [qe("normal"), v],
      direction: e,
      posValue: y,
      sizeValue: g,
      zoom: a
    }, s);
  });
}
function Pu(t, e, n, r, i, s, o, a) {
  var l, c = t.props, u = c.snapDigit, d = u === void 0 ? 0 : u, f = c.isDisplaySnapDigit, h = f === void 0 ? !0 : f, p = c.snapDistFormat, g = p === void 0 ? function(_, w) {
    return _;
  } : p, m = c.zoom, v = e === "horizontal" ? "X" : "Y", y = e === "vertical" ? "height" : "width", E = Math.abs(i), b = h ? parseFloat(E.toFixed(d)) : 0;
  return a.createElement(
    "div",
    { key: "".concat(e, "-").concat(n, "-guideline-").concat(r), className: qe("guideline-group", e), style: (l = {
      left: "".concat(s[0], "px"),
      top: "".concat(s[1], "px")
    }, l[y] = "".concat(E, "px"), l) },
    $E({
      direction: e,
      classNames: [qe(n), o],
      size: "100%",
      posValue: [0, 0],
      sizeValue: E,
      zoom: m
    }, a),
    a.createElement("div", { className: qe("size-value", "gap"), style: {
      transform: "translate".concat(v, "(-50%) scale(").concat(m, ")")
    } }, b > 0 ? g(b, e) : "")
  );
}
function vee(t, e, n, r) {
  var i = t === "vertical" ? 0 : 1, s = t === "vertical" ? 1 : 0, o = i ? Io : Po, a = n[o.start], l = n[o.end];
  return mL(e, function(c) {
    return c.pos[i];
  }).map(function(c) {
    var u = [], d = [], f = [];
    return c.forEach(function(h) {
      var p, g, m = h.element, v = h.elementRect.rect;
      if (v[o.end] < a)
        u.push(h);
      else if (l < v[o.start])
        d.push(h);
      else if (v[o.start] <= a && l <= v[o.end] && r) {
        var y = h.pos, E = { element: m, rect: L(L({}, v), (p = {}, p[o.end] = v[o.start], p)) }, b = { element: m, rect: L(L({}, v), (g = {}, g[o.start] = v[o.end], g)) }, _ = [0, 0], w = [0, 0];
        _[i] = y[i], _[s] = y[s], w[i] = y[i], w[s] = y[s] + h.size, u.push({
          type: t,
          pos: _,
          size: 0,
          elementRect: E,
          direction: "",
          elementDirection: "end"
        }), d.push({
          type: t,
          pos: w,
          size: 0,
          elementRect: b,
          direction: "",
          elementDirection: "start"
        });
      }
    }), u.sort(function(h, p) {
      return p.pos[s] - h.pos[s];
    }), d.sort(function(h, p) {
      return h.pos[s] - p.pos[s];
    }), {
      total: c,
      start: u,
      end: d,
      inner: f
    };
  });
}
function bee(t, e, n, r, i) {
  var s = t.props.isDisplayInnerSnapDigit, o = [];
  return ["vertical", "horizontal"].forEach(function(a) {
    var l = e.filter(function(m) {
      return m.type === a;
    }), c = a === "vertical" ? 1 : 0, u = c ? 0 : 1, d = vee(a, l, r, s), f = c ? Po : Io, h = c ? Io : Po, p = r[f.start], g = r[f.end];
    d.forEach(function(m) {
      var v = m.total, y = m.start, E = m.end, b = m.inner, _ = n[u] + v[0].pos[u] - r[h.start], w = r;
      y.forEach(function(S) {
        var x = S.elementRect.rect, k = w[f.start] - x[f.end];
        if (k > 0) {
          var T = [0, 0];
          T[c] = n[c] + w[f.start] - p - k, T[u] = _, o.push(Pu(t, a, "dashed", o.length, k, T, S.className, i));
        }
        w = x;
      }), w = r, E.forEach(function(S) {
        var x = S.elementRect.rect, k = x[f.start] - w[f.end];
        if (k > 0) {
          var T = [0, 0];
          T[c] = n[c] + w[f.end] - p, T[u] = _, o.push(Pu(t, a, "dashed", o.length, k, T, S.className, i));
        }
        w = x;
      }), b.forEach(function(S) {
        var x = S.elementRect.rect, k = p - x[f.start], T = x[f.end] - g, I = [0, 0], R = [0, 0];
        I[c] = n[c] - k, I[u] = _, R[c] = n[c] + g - p, R[u] = _, o.push(Pu(t, a, "dashed", o.length, k, I, S.className, i)), o.push(Pu(t, a, "dashed", o.length, T, R, S.className, i));
      });
    });
  }), o;
}
function yee(t, e, n, r, i) {
  var s = [];
  return ["horizontal", "vertical"].forEach(function(o) {
    var a = e.filter(function(m) {
      return m.type === o;
    }).slice(0, 1), l = o === "vertical" ? 0 : 1, c = l ? 0 : 1, u = l ? Po : Io, d = l ? Io : Po, f = r[u.start], h = r[u.end], p = r[d.start], g = r[d.end];
    a.forEach(function(m) {
      var v = m.gap, y = m.gapRects, E = Math.max.apply(Math, he([p], F(y.map(function(w) {
        var S = w.rect;
        return S[d.start];
      })), !1)), b = Math.min.apply(Math, he([g], F(y.map(function(w) {
        var S = w.rect;
        return S[d.end];
      })), !1)), _ = (E + b) / 2;
      E === b || _ === (p + g) / 2 || y.forEach(function(w) {
        var S = w.rect, x = w.className, k = [n[0], n[1]];
        if (S[u.end] < f)
          k[l] += S[u.end] - f;
        else if (h < S[u.start])
          k[l] += S[u.start] - f - v;
        else
          return;
        k[c] += _ - p, s.push(Pu(t, l ? "vertical" : "horizontal", "gap", s.length, v, k, x, i));
      });
    });
  }), s;
}
function I1(t) {
  var e, n, r = t.state, i = r.containerClientRect, s = r.hasFixed, o = i.overflow, a = i.scrollHeight, l = i.scrollWidth, c = i.clientHeight, u = i.clientWidth, d = i.clientLeft, f = i.clientTop, h = t.props, p = h.snapGap, g = p === void 0 ? !0 : p, m = h.verticalGuidelines, v = h.horizontalGuidelines, y = h.snapThreshold, E = y === void 0 ? 5 : y, b = h.maxSnapElementGuidelineDistance, _ = b === void 0 ? 1 / 0 : b, w = h.isDisplayGridGuidelines, S = ni(ui(t.state)), x = S.top, k = S.left, T = S.bottom, I = S.right, R = { top: x, left: k, bottom: T, right: I, center: (k + I) / 2, middle: (x + T) / 2 }, N = See(t), $ = he([], F(N), !1), B = ((n = (e = r.snapThresholdInfo) === null || e === void 0 ? void 0 : e.multiples) !== null && n !== void 0 ? n : [1, 1]).map(function(z) {
    return z * E;
  });
  g && $.push.apply($, he([], F(wee(t, R, B)), !1));
  var G = L({}, r.snapOffset || {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  });
  if ($.push.apply($, he([], F(Eee(t, o ? l : u, o ? a : c, d, f, G, w)), !1)), s) {
    var M = i.left, A = i.top;
    G.left += M, G.top += A, G.right += M, G.bottom += A;
  }
  return $.push.apply($, he([], F(rL(v || !1, m || !1, o ? l : u, o ? a : c, d, f, G)), !1)), $ = $.filter(function(z) {
    var V = z.element, U = z.elementRect, Y = z.type;
    if (!V || !U)
      return !0;
    var ne = U.rect;
    return nL(R, ne, Y, _);
  }), $;
}
function wee(t, e, n) {
  var r = t.props, i = r.maxSnapElementGuidelineDistance, s = i === void 0 ? 1 / 0 : i, o = r.maxSnapElementGapDistance, a = o === void 0 ? 1 / 0 : o, l = t.state.elementRects, c = [];
  return [
    ["vertical", Io, Po],
    ["horizontal", Po, Io]
  ].forEach(function(u) {
    var d = F(u, 3), f = d[0], h = d[1], p = d[2], g = e[h.start], m = e[h.end], v = e[h.center], y = e[p.start], E = e[p.end], b = {
      left: n[0],
      top: n[1]
    };
    function _(x) {
      var k = x.rect, T = b[h.start];
      return k[h.end] < g + T ? g - k[h.end] : m - T < k[h.start] ? k[h.start] - m : -1;
    }
    var w = l.filter(function(x) {
      var k = x.rect;
      return k[p.start] > E || k[p.end] < y ? !1 : _(x) > 0;
    }).sort(function(x, k) {
      return _(x) - _(k);
    }), S = [];
    w.forEach(function(x) {
      w.forEach(function(k) {
        if (x !== k) {
          var T = x.rect, I = k.rect, R = T[p.start], N = T[p.end], $ = I[p.start], B = I[p.end];
          R > B || $ > N || S.push([x, k]);
        }
      });
    }), S.forEach(function(x) {
      var k = F(x, 2), T = k[0], I = k[1], R = T.rect, N = I.rect, $ = R[h.start], B = R[h.end], G = N[h.start], M = N[h.end], A = b[h.start], z = 0, V = 0, U = !1, Y = !1, ne = !1;
      if (B <= g && m <= G) {
        if (Y = !0, z = (G - B - (m - g)) / 2, V = B + z + (m - g) / 2, oe(V - v) > A)
          return;
      } else if (B < G && M < g + A) {
        if (U = !0, z = G - B, V = M + z, oe(V - g) > A)
          return;
      } else if (B < G && m - A < $) {
        if (ne = !0, z = G - B, V = $ - z, oe(V - m) > A)
          return;
      } else
        return;
      z && nL(e, N, f, s) && (z > a || c.push({
        type: f,
        pos: f === "vertical" ? [V, 0] : [0, V],
        element: I.element,
        size: 0,
        className: I.className,
        isStart: U,
        isCenter: Y,
        isEnd: ne,
        gap: z,
        hide: !0,
        gapRects: [T, I],
        direction: "",
        elementDirection: ""
      }));
    });
  }), c;
}
function _ee(t, e, n, r) {
  var i, s, o = t.props, a = t.state, l = o.snapGridAll, c = o.snapGridWidth, u = c === void 0 ? 0 : c, d = o.snapGridHeight, f = d === void 0 ? 0 : d, h = a.snapRenderInfo, p = h && (((i = h.direction) === null || i === void 0 ? void 0 : i[0]) || ((s = h.direction) === null || s === void 0 ? void 0 : s[1])), g = t.moveables;
  if (l && g && p && (u || f)) {
    if (a.snapThresholdInfo)
      return;
    a.snapThresholdInfo = {
      multiples: [1, 1],
      offset: [0, 0]
    };
    var m = t.getRect(), v = m.children, y = h.direction;
    if (v) {
      var E = y.map(function(_, w) {
        var S = w === 0 ? {
          snapSize: u,
          posName: "left",
          sizeName: "width",
          clientOffset: r.left - e
        } : {
          snapSize: f,
          posName: "top",
          sizeName: "height",
          clientOffset: r.top - n
        }, x = S.snapSize, k = S.posName, T = S.sizeName, I = S.clientOffset;
        if (!x)
          return {
            dir: _,
            multiple: 1,
            snapSize: x,
            snapOffset: 0
          };
        var R = m[T], N = m[k], $ = q2(v.map(function(U) {
          return [
            U[k] - N,
            U[T],
            R - U[T] - U[k] + N
          ];
        })).filter(function(U) {
          return U;
        }).sort(function(U, Y) {
          return U - Y;
        }), B = $[0], G = $.map(function(U) {
          return tt(U / B, 0.1) * x;
        }), M = 1, A = tt(R / B, 0.1);
        for (M = 1; M <= 10 && !G.every(function(U) {
          return U * M % 1 === 0;
        }); ++M)
          ;
        var z = (-_ + 1) / 2, V = Ig(N - I, N - I + R, z, 1 - z);
        return {
          multiple: A * M,
          dir: _,
          snapSize: x,
          snapOffset: Math.round(V / x)
        };
      }), b = E.map(function(_) {
        return _.multiple || 1;
      });
      a.snapThresholdInfo.multiples = b, a.snapThresholdInfo.offset = E.map(function(_) {
        return _.snapOffset;
      }), E.forEach(function(_, w) {
        _.snapSize;
      });
    }
  } else
    a.snapThresholdInfo = null;
}
function Eee(t, e, n, r, i, s, o) {
  r === void 0 && (r = 0), i === void 0 && (i = 0);
  var a = t.props, l = t.state, c = a.snapGridWidth, u = c === void 0 ? 0 : c, d = a.snapGridHeight, f = d === void 0 ? 0 : d, h = [], p = s.left, g = s.top, m = [0, 0];
  _ee(t, r, i, s);
  var v = l.snapThresholdInfo, y = u, E = f;
  if (v && (u *= v.multiples[0] || 1, f *= v.multiples[1] || 1, m = v.offset), f) {
    for (var b = function(w) {
      h.push({
        type: "horizontal",
        pos: [
          p,
          tt(m[1] * E + w - i + g, 0.1)
        ],
        className: qe("grid-guideline"),
        size: e,
        hide: !o,
        direction: "",
        grid: !0
      });
    }, _ = 0; _ <= n * 2; _ += f)
      b(_);
    for (var _ = -f; _ >= -n; _ -= f)
      b(_);
  }
  if (u) {
    for (var b = function(S) {
      h.push({
        type: "vertical",
        pos: [
          tt(m[0] * y + S - r + p, 0.1),
          g
        ],
        className: qe("grid-guideline"),
        size: n,
        hide: !o,
        direction: "",
        grid: !0
      });
    }, _ = 0; _ <= e * 2; _ += u)
      b(_);
    for (var _ = -u; _ >= -e; _ -= u)
      b(_);
  }
  return h;
}
function nL(t, e, n, r) {
  return n === "horizontal" ? oe(t.right - e.left) <= r || oe(t.left - e.right) <= r || t.left <= e.right && e.left <= t.right : n === "vertical" ? oe(t.bottom - e.top) <= r || oe(t.top - e.bottom) <= r || t.top <= e.bottom && e.top <= t.bottom : !0;
}
function See(t) {
  var e = t.state, n = t.props.elementGuidelines, r = n === void 0 ? [] : n;
  if (!r.length)
    return e.elementRects = [], [];
  var i = (e.elementRects || []).filter(function(f) {
    return !f.refresh;
  }), s = r.map(function(f) {
    return Ni(f) && "element" in f ? L(L({}, f), { element: ts(f.element, !0) }) : {
      element: ts(f, !0)
    };
  }).filter(function(f) {
    return f.element;
  }), o = DZ(i.map(function(f) {
    return f.element;
  }), s.map(function(f) {
    return f.element;
  })), a = o.maintained, l = o.added, c = [];
  a.forEach(function(f) {
    var h = F(f, 2), p = h[0], g = h[1];
    c[g] = i[p];
  }), xee(t, l.map(function(f) {
    return s[f];
  })).map(function(f, h) {
    c[l[h]] = f;
  }), e.elementRects = c;
  var u = DE(t.props.elementSnapDirections), d = [];
  return c.forEach(function(f) {
    var h = f.element, p = f.top, g = p === void 0 ? u.top : p, m = f.left, v = m === void 0 ? u.left : m, y = f.right, E = y === void 0 ? u.right : y, b = f.bottom, _ = b === void 0 ? u.bottom : b, w = f.center, S = w === void 0 ? u.center : w, x = f.middle, k = x === void 0 ? u.middle : x, T = f.className, I = f.rect, R = IE({
      top: g,
      right: E,
      left: v,
      bottom: _,
      center: S,
      middle: k
    }, I), N = R.horizontal, $ = R.vertical, B = R.horizontalNames, G = R.verticalNames, M = I.top, A = I.left, z = I.right - A, V = I.bottom - M, U = [z, V];
    $.forEach(function(Y, ne) {
      d.push({
        type: "vertical",
        element: h,
        pos: [
          tt(Y, 0.1),
          M
        ],
        size: V,
        sizes: U,
        className: T,
        elementRect: f,
        elementDirection: $T[G[ne]] || G[ne],
        direction: ""
      });
    }), N.forEach(function(Y, ne) {
      d.push({
        type: "horizontal",
        element: h,
        pos: [
          A,
          tt(Y, 0.1)
        ],
        size: z,
        sizes: U,
        className: T,
        elementRect: f,
        elementDirection: $T[B[ne]] || B[ne],
        direction: ""
      });
    });
  }), d;
}
function qT(t, e) {
  return t ? t.map(function(n) {
    var r = Ni(n) ? n : { pos: n }, i = r.pos;
    return Bc(i) ? r : L(L({}, r), { pos: Ot(i, e) });
  }) : [];
}
function rL(t, e, n, r, i, s, o) {
  i === void 0 && (i = 0), s === void 0 && (s = 0), o === void 0 && (o = { left: 0, top: 0, right: 0, bottom: 0 });
  var a = [], l = o.left, c = o.top, u = o.bottom, d = o.right, f = n + d - l, h = r + u - c;
  return qT(t, h).forEach(function(p) {
    a.push({
      type: "horizontal",
      pos: [
        l,
        tt(p.pos - s + c, 0.1)
      ],
      size: f,
      className: p.className,
      direction: ""
    });
  }), qT(e, f).forEach(function(p) {
    a.push({
      type: "vertical",
      pos: [
        tt(p.pos - i + l, 0.1),
        c
      ],
      size: h,
      className: p.className,
      direction: ""
    });
  }), a;
}
function xee(t, e) {
  if (!e.length)
    return [];
  var n = t.props.groupable, r = t.state, i = r.containerClientRect, s = r.rootMatrix, o = r.is3d, a = r.offsetDelta, l = o ? 4 : 3, c = F(KQ(s, i, l), 2), u = c[0], d = c[1], f = n ? 0 : a[0], h = n ? 0 : a[1];
  return e.map(function(p) {
    var g = p.element.getBoundingClientRect(), m = g.left - u - f, v = g.top - d - h, y = v + g.height, E = m + g.width, b = F(Vc(s, [m, v], l), 2), _ = b[0], w = b[1], S = F(Vc(s, [E, y], l), 2), x = S[0], k = S[1];
    return L(L({}, p), { rect: {
      left: _,
      right: x,
      top: w,
      bottom: k,
      center: (_ + x) / 2,
      middle: (w + k) / 2
    } });
  });
}
function Fh(t) {
  var e = t.state, n = e.container, r = t.props.snapContainer || n;
  if (e.snapContainer === r && e.guidelines && e.guidelines.length)
    return !1;
  var i = e.containerClientRect, s = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (n !== r) {
    var o = ts(r, !0);
    if (o) {
      var a = ud(o), l = QT(e, [
        a.left - i.left,
        a.top - i.top
      ]), c = QT(e, [
        a.right - i.right,
        a.bottom - i.bottom
      ]);
      s.left = tt(l[0], 1e-5), s.top = tt(l[1], 1e-5), s.right = tt(c[0], 1e-5), s.bottom = tt(c[1], 1e-5);
    }
  }
  return e.snapContainer = r, e.snapOffset = s, e.guidelines = I1(t), e.enableSnap = !0, !0;
}
function iL(t, e, n, r, i, s) {
  var o = gl(t, e, n, s ? 4 : 3), a = hn(o, r);
  return FE(o, Ke(i, a));
}
function KT(t) {
  return t ? t / oe(t) : 0;
}
function kee(t, e, n, r, i, s) {
  var o = s.fixedDirection, a = ZQ(n, o, r), l = LE(t, e, n, r), c = he(he([], F(uee(t, e, a, r, i, s)), !1), F(ZP(t, l, s)), !1), u = zg(c, 0), d = zg(c, 1);
  return {
    width: {
      isBound: u.isBound,
      offset: u.offset[0]
    },
    height: {
      isBound: d.isBound,
      offset: d.offset[1]
    }
  };
}
function Cee(t, e, n, r, i, s, o, a, l) {
  var c = hn(e, o), u = a0(t, a, {
    vertical: [c[0]],
    horizontal: [c[1]]
  }), d = u.horizontal.offset, f = u.vertical.offset;
  if (tt(f, T1) || tt(d, T1)) {
    var h = F(ms({
      datas: l,
      distX: -f,
      distY: -d
    }), 2), p = h[0], g = h[1], m = Math.min(i || 1 / 0, n + o[0] * p), v = Math.min(s || 1 / 0, r + o[1] * g);
    return [m - n, v - r];
  }
  return [0, 0];
}
function sL(t, e, n, r, i, s, o, a) {
  for (var l = ui(t.state), c = t.props.keepRatio, u = 0, d = 0, f = 0; f < 2; ++f) {
    var h = e(u, d), p = kee(t, h, i, c, o, a), g = p.width, m = p.height, v = g.isBound, y = m.isBound, E = g.offset, b = m.offset;
    if (f === 1 && (v || (E = 0), y || (b = 0)), f === 0 && o && !v && !y)
      return [0, 0];
    if (c) {
      var _ = oe(E) * (n ? 1 / n : 1), w = oe(b) * (r ? 1 / r : 1), S = v && y ? _ < w : y || !v && _ < w;
      S ? E = n * b / r : b = r * E / n;
    }
    u += E, d += b;
  }
  if (!c && i[0] && i[1]) {
    var x = fee(t, l, i, s, a), k = x.maxWidth, T = x.maxHeight, I = F(Cee(t, e(u, d).map(function($) {
      return $.map(function(B) {
        return tt(B, T1);
      });
    }), n + u, r + d, k, T, i, o, a), 2), E = I[0], b = I[1];
    u += E, d += b;
  }
  return [u, d];
}
function ld(t) {
  return t < 0 && (t = t % 360 + 360), t %= 360, t;
}
function Tee(t, e) {
  e = ld(e);
  var n = Math.floor(t / 360), r = n * 360 + 360 - e, i = n * 360 + e;
  return oe(t - r) < oe(t - i) ? r : i;
}
function Ab(t, e) {
  t = ld(t), e = ld(e);
  var n = ld(t - e);
  return Math.min(n, 360 - n);
}
function Oee(t, e, n, r) {
  var i, s = t.props, o = (i = s[WP]) !== null && i !== void 0 ? i : 5, a = s[GP];
  if (su(t, "rotatable")) {
    var l = e.pos1, c = e.pos2, u = e.pos3, d = e.pos4, f = e.origin, h = n * Math.PI / 180, p = [l, c, u, d].map(function(b) {
      return Ke(b, f);
    }), g = p.map(function(b) {
      return qf(b, h);
    }), m = he(he([], F(WQ(t, p, g, f, n)), !1), F(iee(t, p, g, f, n)), !1);
    m.sort(function(b, _) {
      return oe(b - n) - oe(_ - n);
    });
    var v = m.length > 0;
    if (v)
      return {
        isSnap: v,
        dist: v ? m[0] : n
      };
  }
  if (a != null && a.length && o) {
    var y = a.slice().sort(function(b, _) {
      return Ab(b, r) - Ab(_, r);
    }), E = y[0];
    if (Ab(E, r) <= o)
      return {
        isSnap: !0,
        dist: n + Tee(r, E) - r
      };
  }
  return {
    isSnap: !1,
    dist: n
  };
}
function Mee(t, e, n, r, i, s, o) {
  if (!su(t, "resizable"))
    return [0, 0];
  var a = o.fixedDirection, l = o.nextAllMatrix, c = t.state, u = c.allMatrix, d = c.is3d;
  return sL(t, function(f, h) {
    return iL(l || u, e + f, n + h, a, i, d);
  }, e, n, r, i, s, o);
}
function Aee(t, e, n, r, i) {
  if (!su(t, "scalable"))
    return [0, 0];
  var s = i.startOffsetWidth, o = i.startOffsetHeight, a = i.fixedPosition, l = i.fixedDirection, c = i.is3d, u = sL(t, function(d, f) {
    return iL(MQ(i, wt(e, [d / s, f / o])), s, o, l, a, c);
  }, s, o, n, a, r, i);
  return [u[0] / s, u[1] / o];
}
function Nee(t, e) {
  e.absolutePoses = ui(t.state);
}
function YT(t) {
  var e = [];
  return t.forEach(function(n) {
    n.guidelineInfos.forEach(function(r) {
      var i = r.guideline;
      br(e, function(s) {
        return s.guideline === i;
      }) || (i.direction = "", e.push({ guideline: i, posInfo: n }));
    });
  }), e.map(function(n) {
    var r = n.guideline, i = n.posInfo;
    return L(L({}, r), { direction: i.direction });
  });
}
function XT(t, e, n, r, i, s) {
  var o = RE(s0(t, s), e, n), a = o.vertical, l = o.horizontal, c = Zl();
  a.forEach(function(p) {
    p.isBound && (p.direction === "start" && (c.left = !0), p.direction === "end" && (c.right = !0), r.push({
      type: "bounds",
      pos: p.pos
    }));
  }), l.forEach(function(p) {
    p.isBound && (p.direction === "start" && (c.top = !0), p.direction === "end" && (c.bottom = !0), i.push({
      type: "bounds",
      pos: p.pos
    }));
  });
  var u = see(t), d = u.boundMap, f = u.vertical, h = u.horizontal;
  return f.forEach(function(p) {
    Ws(r, function(g) {
      var m = g.type, v = g.pos;
      return m === "bounds" && v === p;
    }) >= 0 || r.push({
      type: "bounds",
      pos: p
    });
  }), h.forEach(function(p) {
    Ws(i, function(g) {
      var m = g.type, v = g.pos;
      return m === "bounds" && v === p;
    }) >= 0 || i.push({
      type: "bounds",
      pos: p
    });
  }), {
    boundMap: c,
    innerBoundMap: d
  };
}
var Ree = UE("", ["resizable", "scalable"]), Dee = {
  name: "snappable",
  dragRelation: "strong",
  props: [
    "snappable",
    "snapContainer",
    "snapDirections",
    "elementSnapDirections",
    "snapGap",
    "snapGridWidth",
    "snapGridHeight",
    "isDisplaySnapDigit",
    "isDisplayInnerSnapDigit",
    "isDisplayGridGuidelines",
    "snapDigit",
    "snapThreshold",
    "snapRenderThreshold",
    "snapGridAll",
    WP,
    GP,
    jP,
    qP,
    "horizontalGuidelines",
    "verticalGuidelines",
    "elementGuidelines",
    "bounds",
    "innerBounds",
    "snapDistFormat",
    "maxSnapElementGuidelineDistance",
    "maxSnapElementGapDistance"
  ],
  events: ["snap", "bound"],
  css: [
    `:host {
--bounds-color: #d66;
}
.guideline {
pointer-events: none;
z-index: 2;
}
.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}
.guideline-group {
position: absolute;
top: 0;
left: 0;
}
.guideline-group .size-value {
position: absolute;
color: #f55;
font-size: 12px;
font-size: calc(12px * var(--zoom));
font-weight: bold;
}
.guideline-group.horizontal .size-value {
transform-origin: 50% 100%;
transform: translateX(-50%);
left: 50%;
bottom: 5px;
bottom: calc(2px + 3px * var(--zoom));
}
.guideline-group.vertical .size-value {
transform-origin: 0% 50%;
top: 50%;
transform: translateY(-50%);
left: 5px;
left: calc(2px + 3px * var(--zoom));
}
.guideline.gap {
background: #f55;
}
.size-value.gap {
color: #f55;
}
`
  ],
  render: function(t, e) {
    var n = t.state, r = n.top, i = n.left, s = n.pos1, o = n.pos2, a = n.pos3, l = n.pos4, c = n.snapRenderInfo, u = t.props.snapRenderThreshold, d = u === void 0 ? 1 : u;
    if (!c || !c.render || !su(t, ""))
      return ec(t, "boundMap", Zl(), function(ie) {
        return JSON.stringify(ie);
      }), ec(t, "innerBoundMap", Zl(), function(ie) {
        return JSON.stringify(ie);
      }), [];
    n.guidelines = I1(t);
    var f = Math.min(s[0], o[0], a[0], l[0]), h = Math.min(s[1], o[1], a[1], l[1]), p = c.externalPoses || [], g = ui(t.state), m = [], v = [], y = [], E = [], b = [], _ = ni(g), w = _.width, S = _.height, x = _.top, k = _.left, T = _.bottom, I = _.right, R = { left: k, right: I, top: x, bottom: T, center: (k + I) / 2, middle: (x + T) / 2 }, N = p.length > 0, $ = N ? ni(p) : {};
    if (!c.request) {
      if (c.direction && b.push(JQ(t, g, c.direction, d, d)), c.snap) {
        var B = ni(g);
        c.center && (B.middle = (B.top + B.bottom) / 2, B.center = (B.left + B.right) / 2), b.push(BT(t, B, d, d));
      }
      N && (c.center && ($.middle = ($.top + $.bottom) / 2, $.center = ($.left + $.right) / 2), b.push(BT(t, $, d, d))), b.forEach(function(ie) {
        var Z = ie.vertical.posInfos, Q = ie.horizontal.posInfos;
        m.push.apply(m, he([], F(Z.filter(function(fe) {
          var ge = fe.guidelineInfos;
          return ge.some(function(Re) {
            var Be = Re.guideline;
            return !Be.hide;
          });
        }).map(function(fe) {
          return {
            type: "snap",
            pos: fe.pos
          };
        })), !1)), v.push.apply(v, he([], F(Q.filter(function(fe) {
          var ge = fe.guidelineInfos;
          return ge.some(function(Re) {
            var Be = Re.guideline;
            return !Be.hide;
          });
        }).map(function(fe) {
          return {
            type: "snap",
            pos: fe.pos
          };
        })), !1)), y.push.apply(y, he([], F(YT(Z)), !1)), E.push.apply(E, he([], F(YT(Q)), !1));
      });
    }
    var G = XT(t, [k, I], [x, T], m, v), M = G.boundMap, A = G.innerBoundMap;
    N && XT(t, [$.left, $.right], [$.top, $.bottom], m, v, c.externalBounds);
    var z = he(he([], F(y), !1), F(E), !1), V = z.filter(function(ie) {
      return ie.element && !ie.gapRects;
    }), U = z.filter(function(ie) {
      return ie.gapRects;
    }).sort(function(ie, Z) {
      return ie.gap - Z.gap;
    });
    Ne(t, "onSnap", {
      guidelines: z.filter(function(ie) {
        var Z = ie.element;
        return !Z;
      }),
      elements: V,
      gaps: U
    }, !0);
    var Y = ec(t, "boundMap", M, function(ie) {
      return JSON.stringify(ie);
    }, Zl()), ne = ec(t, "innerBoundMap", A, function(ie) {
      return JSON.stringify(ie);
    }, Zl());
    return (M === Y || A === ne) && Ne(t, "onBound", {
      bounds: M,
      innerBounds: A
    }, !0), he(he(he(he(he(he([], F(bee(t, V, [f, h], R, e)), !1), F(yee(t, U, [f, h], R, e)), !1), F(jT(t, "horizontal", E, [i, r], R, e)), !1), F(jT(t, "vertical", y, [i, r], R, e)), !1), F(GT(t, "horizontal", v, f, r, w, 0, e)), !1), F(GT(t, "vertical", m, h, i, S, 1, e)), !1);
  },
  dragStart: function(t, e) {
    t.state.snapRenderInfo = {
      request: e.isRequest,
      snap: !0,
      center: !0
    }, Fh(t);
  },
  drag: function(t) {
    var e = t.state;
    Fh(t) || (e.guidelines = I1(t)), e.snapRenderInfo && (e.snapRenderInfo.render = !0);
  },
  pinchStart: function(t) {
    this.unset(t);
  },
  dragEnd: function(t) {
    this.unset(t);
  },
  dragControlCondition: function(t, e) {
    if (Ree(t, e) || D1(t, e))
      return !0;
    if (!e.isRequest && e.inputEvent)
      return fn(e.inputEvent.target, qe("snap-control"));
  },
  dragControlStart: function(t) {
    t.state.snapRenderInfo = null, Fh(t);
  },
  dragControl: function(t) {
    this.drag(t);
  },
  dragControlEnd: function(t) {
    this.unset(t);
  },
  dragGroupStart: function(t, e) {
    this.dragStart(t, e);
  },
  dragGroup: function(t) {
    this.drag(t);
  },
  dragGroupEnd: function(t) {
    this.unset(t);
  },
  dragGroupControlStart: function(t) {
    t.state.snapRenderInfo = null, Fh(t);
  },
  dragGroupControl: function(t) {
    this.drag(t);
  },
  dragGroupControlEnd: function(t) {
    this.unset(t);
  },
  unset: function(t) {
    var e = t.state;
    e.enableSnap = !1, e.guidelines = [], e.snapRenderInfo = null, e.elementRects = [];
  }
};
function Iee(t, e) {
  return [
    t[0] * e[0],
    t[1] * e[1]
  ];
}
function qe() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return TJ.apply(void 0, he([OE], F(t), !1));
}
function oL(t) {
  t();
}
function Pee(t) {
  return !t || t === "none" ? [1, 0, 0, 1, 0, 0] : Ni(t) ? t : Qd(t);
}
function cd(t, e, n) {
  return Lg(e, el(n, e), t, el(n.map(function(r) {
    return -r;
  }), e));
}
function Lee(t, e, n) {
  if (e === "%") {
    var r = BE(t.ownerSVGElement);
    return r[n ? "width" : "height"] / 100;
  }
  return 1;
}
function $ee(t) {
  var e = Bee(zE(t, ":before"));
  return e.map(function(n, r) {
    var i = Vf(n), s = i.value, o = i.unit;
    return s * Lee(t, o, r === 0);
  });
}
function Ug(t) {
  return t ? t.split(" ") : ["0", "0"];
}
function Bee(t) {
  return Ug(t.transformOrigin);
}
function aL(t) {
  var e = yr(t), n = e("transform");
  if (n && n !== "none")
    return n;
  if ("transform" in t) {
    var r = t.transform, i = r.baseVal;
    if (!i)
      return "";
    var s = i.length;
    if (!s)
      return "";
    for (var o = [], a = function(c) {
      var u = i[c].matrix;
      o.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function(d) {
        return u[d];
      }).join(", "), ")"));
    }, l = 0; l < s; ++l)
      a(l);
    return o.join(" ");
  }
  return "";
}
function tf(t, e, n, r, i) {
  var s, o, a = vE(t) || qo(t), l = !1, c, u;
  if (!t || n)
    c = t;
  else {
    var d = (s = t == null ? void 0 : t.assignedSlot) === null || s === void 0 ? void 0 : s.parentElement, f = t.parentElement;
    d ? (l = !0, u = f, c = d) : c = f;
  }
  for (var h = !1, p = t === e || c === e, g = "relative", m = 1, v = parseFloat(i == null ? void 0 : i("zoom")) || 1, y = i == null ? void 0 : i("position"); c && c !== a; ) {
    e === c && (p = !0);
    var E = yr(c), b = c.tagName.toLowerCase(), _ = aL(c), w = E("willChange"), S = parseFloat(E("zoom")) || 1;
    if (g = E("position"), r && S !== 1) {
      m = S;
      break;
    }
    if (
      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.
      !n && r && v !== 1 && y && y !== "absolute" || b === "svg" || b === "foreignobject" || g !== "static" || _ && _ !== "none" || w === "transform"
    )
      break;
    var x = (o = t == null ? void 0 : t.assignedSlot) === null || o === void 0 ? void 0 : o.parentNode, k = c.parentNode;
    x && (l = !0, u = k);
    var T = k;
    if (T && T.nodeType === 11) {
      c = T.host, h = !0, g = yr(c)("position");
      break;
    }
    c = T, g = "relative";
  }
  return {
    offsetZoom: m,
    hasSlot: l,
    parentSlotElement: u,
    isCustomElement: h,
    isStatic: g === "static",
    isEnd: p || !c || c === a,
    offsetParent: c || a
  };
}
function Fee(t, e) {
  var n, r = t.tagName.toLowerCase(), i = t.offsetLeft, s = t.offsetTop, o = yr(t), a = Uf(i), l = !a, c, u;
  return !l && (r !== "svg" || t.ownerSVGElement) ? (c = CP ? $ee(t) : Ug(o("transformOrigin")).map(function(d) {
    return parseFloat(d);
  }), u = c.slice(), l = !0, r === "svg" ? (i = 0, s = 0) : (n = F(Uee(t, c, t === e && e.tagName.toLowerCase() === "g"), 4), i = n[0], s = n[1], c[0] = n[2], c[1] = n[3])) : (c = Ug(o("transformOrigin")).map(function(d) {
    return parseFloat(d);
  }), u = c.slice()), {
    tagName: r,
    isSVG: a,
    hasOffset: l,
    offset: [i || 0, s || 0],
    origin: c,
    targetOrigin: u
  };
}
function lL(t, e) {
  var n = yr(t), r = yr(qo(t)), i = r("position");
  if (!e && (!i || i === "static"))
    return [0, 0];
  var s = parseInt(r("marginLeft"), 10), o = parseInt(r("marginTop"), 10);
  return n("position") === "absolute" && ((n("top") !== "auto" || n("bottom") !== "auto") && (o = 0), (n("left") !== "auto" || n("right") !== "auto") && (s = 0)), [s, o];
}
function P1(t) {
  t.forEach(function(e) {
    var n = e.matrix;
    n && (e.matrix = Ri(n, 3, 4));
  });
}
function zee(t) {
  for (var e = t.parentElement, n = !1, r = qo(t); e; ) {
    var i = zE(e).transform;
    if (i && i !== "none") {
      n = !0;
      break;
    }
    if (e === r)
      break;
    e = e.parentElement;
  }
  return {
    fixedContainer: e || r,
    hasTransform: n
  };
}
function l0(t, e) {
  return e === void 0 && (e = t.length > 9), "".concat(e ? "matrix3d" : "matrix", "(").concat(bP(t, !e).join(","), ")");
}
function BE(t) {
  var e = t.clientWidth, n = t.clientHeight;
  if (!t)
    return { x: 0, y: 0, width: 0, height: 0, clientWidth: e, clientHeight: n };
  var r = t.viewBox, i = r && r.baseVal || { x: 0, y: 0, width: 0, height: 0 };
  return {
    x: i.x,
    y: i.y,
    width: i.width || e,
    height: i.height || n,
    clientWidth: e,
    clientHeight: n
  };
}
function Hee(t, e) {
  var n, r = BE(t), i = r.width, s = r.height, o = r.clientWidth, a = r.clientHeight, l = o / i, c = a / s, u = t.preserveAspectRatio.baseVal, d = u.align, f = u.meetOrSlice, h = [0, 0], p = [l, c], g = [0, 0];
  if (d !== 1) {
    var m = (d - 2) % 3, v = Math.floor((d - 2) / 3);
    h[0] = i * m / 2, h[1] = s * v / 2;
    var y = f === 2 ? Math.max(c, l) : Math.min(l, c);
    p[0] = y, p[1] = y, g[0] = (o - i) / 2 * m, g[1] = (a - s) / 2 * v;
  }
  var E = xE(p, e);
  return n = F(g, 2), E[e * (e - 1)] = n[0], E[e * (e - 1) + 1] = n[1], cd(E, e, h);
}
function Uee(t, e, n) {
  var r = t.tagName.toLowerCase();
  if (!t.getBBox || !n && r === "g")
    return [0, 0, 0, 0];
  var i = yr(t), s = i("transform-box") === "fill-box", o = t.getBBox(), a = BE(t.ownerSVGElement), l = o.x, c = o.y;
  r === "foreignobject" && !l && !c && (l = parseFloat(t.getAttribute("x")) || 0, c = parseFloat(t.getAttribute("y")) || 0);
  var u = l - a.x, d = c - a.y, f = s ? e[0] : e[0] - u, h = s ? e[1] : e[1] - d;
  return [u, d, f, h];
}
function qt(t, e, n) {
  return Bn(t, Qa(e, n), n);
}
function gl(t, e, n, r) {
  return [[0, 0], [e, 0], [0, n], [e, n]].map(function(i) {
    return qt(t, i, r);
  });
}
function ni(t) {
  var e = t.map(function(c) {
    return c[0];
  }), n = t.map(function(c) {
    return c[1];
  }), r = Math.min.apply(Math, he([], F(e), !1)), i = Math.min.apply(Math, he([], F(n), !1)), s = Math.max.apply(Math, he([], F(e), !1)), o = Math.max.apply(Math, he([], F(n), !1)), a = s - r, l = o - i;
  return {
    left: r,
    top: i,
    right: s,
    bottom: o,
    width: a,
    height: l
  };
}
function JT(t, e, n, r) {
  var i = gl(t, e, n, r);
  return ni(i);
}
function Vee(t, e, n, r, i) {
  var s, o = t.target, a = t.origin, l = e.matrix, c = uL(o), u = c.offsetWidth, d = c.offsetHeight, f = n.getBoundingClientRect(), h = [0, 0];
  n === qo(n) && (h = lL(o, !0));
  for (var p = o.getBoundingClientRect(), g = p.left - f.left + n.scrollLeft - (n.clientLeft || 0) + h[0], m = p.top - f.top + n.scrollTop - (n.clientTop || 0) + h[1], v = p.width, y = p.height, E = Lg(r, i, l), b = JT(E, u, d, r), _ = b.left, w = b.top, S = b.width, x = b.height, k = qt(E, a, r), T = Ke(k, [_, w]), I = [
    g + T[0] * v / S,
    m + T[1] * y / x
  ], R = [0, 0], N = 0; ++N < 10; ) {
    var $ = us(i, r);
    s = F(Ke(qt($, I, r), qt($, k, r)), 2), R[0] = s[0], R[1] = s[1];
    var B = Lg(r, i, el(R, r), l), G = JT(B, u, d, r), M = G.left, A = G.top, z = M - g, V = A - m;
    if (oe(z) < 2 && oe(V) < 2)
      break;
    I[0] -= z, I[1] -= V;
  }
  return R.map(function(U) {
    return Math.round(U);
  });
}
function Wee(t, e, n) {
  var r = t.length === 16, i = r ? 4 : 3, s = e.map(function(l) {
    return qt(t, l, i);
  }), o = n.left, a = n.top;
  return s.map(function(l) {
    return [l[0] + o, l[1] + a];
  });
}
function ci(t) {
  return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
}
function cL(t, e) {
  return ci([
    e[0] - t[0],
    e[1] - t[1]
  ]);
}
function Lu(t, e, n, r) {
  n === void 0 && (n = 1), r === void 0 && (r = Qt(t, e));
  var i = cL(t, e);
  return {
    transform: "translateY(-50%) translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(r, "rad) scaleY(").concat(n, ")"),
    width: "".concat(i, "px")
  };
}
function Vg(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  var i = n.length, s = n.reduce(function(a, l) {
    return a + l[0];
  }, 0) / i, o = n.reduce(function(a, l) {
    return a + l[1];
  }, 0) / i;
  return {
    transform: "translateZ(0px) translate(".concat(s, "px, ").concat(o, "px) rotate(").concat(t, "rad) scale(").concat(e, ")")
  };
}
function nl(t, e) {
  var n = t[e];
  return Ni(n) ? L(L({}, t), n) : t;
}
function uL(t) {
  var e = t && !Uf(t.offsetWidth), n = 0, r = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, u = 0, d = 0, f = 0, h = 0, p = 1 / 0, g = 1 / 0, m = 1 / 0, v = 1 / 0, y = 0, E = 0, b = !1;
  if (t)
    if (!e && t.ownerSVGElement) {
      var _ = t.getBBox();
      b = !0, n = _.width, r = _.height, o = n, a = r, l = n, c = r, i = n, s = r;
    } else {
      var w = yr(t), S = t.style, x = w("boxSizing") === "border-box", k = parseFloat(w("borderLeftWidth")) || 0, T = parseFloat(w("borderRightWidth")) || 0, I = parseFloat(w("borderTopWidth")) || 0, R = parseFloat(w("borderBottomWidth")) || 0, N = parseFloat(w("paddingLeft")) || 0, $ = parseFloat(w("paddingRight")) || 0, B = parseFloat(w("paddingTop")) || 0, G = parseFloat(w("paddingBottom")) || 0, M = N + $, A = B + G, z = k + T, V = I + R, U = M + z, Y = A + V, ne = w("position"), ie = 0, Z = 0;
      if ("clientLeft" in t) {
        var Q = null;
        if (ne === "absolute") {
          var fe = tf(t, qo(t));
          Q = fe.offsetParent;
        } else
          Q = t.parentElement;
        if (Q) {
          var ge = yr(Q);
          ie = parseFloat(ge("width")), Z = parseFloat(ge("height"));
        }
      }
      u = Math.max(M, Ot(w("minWidth"), ie) || 0), d = Math.max(A, Ot(w("minHeight"), Z) || 0), p = Ot(w("maxWidth"), ie), g = Ot(w("maxHeight"), Z), isNaN(p) && (p = 1 / 0), isNaN(g) && (g = 1 / 0), y = Ot(S.width, 0) || 0, E = Ot(S.height, 0) || 0, o = parseFloat(w("width")) || 0, a = parseFloat(w("height")) || 0, l = oe(o - y) < 1 ? h1(u, y || o, p) : o, c = oe(a - E) < 1 ? h1(d, E || a, g) : a, n = l, r = c, i = l, s = c, x ? (m = p, v = g, f = u, h = d, l = n - U, c = r - Y) : (m = p + U, v = g + Y, f = u + U, h = d + Y, n = l + U, r = c + Y), i = l + M, s = c + A;
    }
  return {
    svg: b,
    offsetWidth: n,
    offsetHeight: r,
    clientWidth: i,
    clientHeight: s,
    contentWidth: l,
    contentHeight: c,
    inlineCSSWidth: y,
    inlineCSSHeight: E,
    cssWidth: o,
    cssHeight: a,
    minWidth: u,
    minHeight: d,
    maxWidth: p,
    maxHeight: g,
    minOffsetWidth: f,
    minOffsetHeight: h,
    maxOffsetWidth: m,
    maxOffsetHeight: v
  };
}
function dL(t, e) {
  return Qt(e > 0 ? t[0] : t[1], e > 0 ? t[1] : t[0]);
}
function zh() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function fL(t, e) {
  var n = t === qo(t) || t === vE(t), r = {
    clientLeft: t.clientLeft,
    clientTop: t.clientTop,
    clientWidth: t.clientWidth,
    clientHeight: t.clientHeight,
    scrollWidth: t.scrollWidth,
    scrollHeight: t.scrollHeight,
    overflow: !1
  };
  return n && (r.clientHeight = Math.max(e.height, r.clientHeight), r.scrollHeight = Math.max(e.height, r.scrollHeight)), r.overflow = yr(t)("overflow") !== "visible", L(L({}, e), r);
}
function Nb(t, e, n, r) {
  var i = t.left, s = t.right, o = t.top, a = t.bottom, l = e.top, c = e.left, u = {
    left: c + i,
    top: l + o,
    right: c + s,
    bottom: l + a,
    width: s - i,
    height: a - o
  };
  return n && r ? fL(n, u) : u;
}
function ud(t, e) {
  var n = 0, r = 0, i = 0, s = 0;
  if (t) {
    var o = t.getBoundingClientRect();
    n = o.left, r = o.top, i = o.width, s = o.height;
  }
  var a = {
    left: n,
    top: r,
    width: i,
    height: s,
    right: n + i,
    bottom: r + s
  };
  return t && e ? fL(t, a) : a;
}
function Gee(t) {
  var e = t.props, n = e.groupable, r = e.svgOrigin, i = t.getState(), s = i.offsetWidth, o = i.offsetHeight, a = i.svg, l = i.transformOrigin;
  return !n && a && r ? WE(r, s, o) : l;
}
function hL(t, e, n, r) {
  var i;
  if (t)
    i = t;
  else if (e)
    i = [0, 0];
  else {
    var s = n.target;
    i = pL(s, r);
  }
  return i;
}
function pL(t, e) {
  if (t) {
    var n = t.getAttribute("data-rotation") || "", r = t.getAttribute("data-direction");
    if (e.deg = n, !!r) {
      var i = [0, 0];
      return r.indexOf("w") > -1 && (i[0] = -1), r.indexOf("e") > -1 && (i[0] = 1), r.indexOf("n") > -1 && (i[1] = -1), r.indexOf("s") > -1 && (i[1] = 1), i;
    }
  }
}
function FE(t, e) {
  return [
    wt(e, t[0]),
    wt(e, t[1]),
    wt(e, t[2]),
    wt(e, t[3])
  ];
}
function ui(t) {
  var e = t.left, n = t.top, r = t.pos1, i = t.pos2, s = t.pos3, o = t.pos4;
  return FE([r, i, s, o], [e, n]);
}
function L1(t, e) {
  t[e ? "controlAbles" : "targetAbles"].forEach(function(n) {
    n.unset && n.unset(t);
  });
}
function Ql(t, e) {
  var n = e ? "controlGesto" : "targetGesto", r = t[n];
  (r == null ? void 0 : r.isIdle()) === !1 && L1(t, e), r == null || r.unset(), t[n] = null;
}
function Jn(t, e) {
  if (e) {
    var n = iu(e);
    n.nextStyle = L(L({}, n.nextStyle), t);
  }
  return {
    style: t,
    cssText: Gs(t).map(function(r) {
      return "".concat(Cp(r, "-"), ": ").concat(t[r], ";");
    }).join("")
  };
}
function gL(t, e, n) {
  var r = e.afterTransform || e.transform;
  return L(L({}, Jn(L(L(L({}, t.style), e.style), { transform: r }), n)), { afterTransform: r, transform: t.transform });
}
function st(t, e, n, r) {
  var i = e.datas;
  i.datas || (i.datas = {});
  var s = L(L({}, n), { target: t.state.target, clientX: e.clientX, clientY: e.clientY, inputEvent: e.inputEvent, currentTarget: t, moveable: t, datas: i.datas, isRequest: e.isRequest, isRequestChild: e.isRequestChild, isFirstDrag: !!e.isFirstDrag, isTrusted: e.isTrusted !== !1, stopAble: function() {
    i.isEventStart = !1;
  }, stopDrag: function() {
    var o;
    (o = e.stop) === null || o === void 0 || o.call(e);
  } });
  return i.isStartEvent ? r || (i.lastEvent = s) : i.isStartEvent = !0, s;
}
function zr(t, e, n) {
  var r = e.datas, i = "isDrag" in n ? n.isDrag : e.isDrag;
  return r.datas || (r.datas = {}), L(L({ isDrag: i }, n), { moveable: t, target: t.state.target, clientX: e.clientX, clientY: e.clientY, inputEvent: e.inputEvent, currentTarget: t, lastEvent: r.lastEvent, isDouble: e.isDouble, datas: r.datas, isFirstDrag: !!e.isFirstDrag });
}
function c0(t, e, n) {
  t._emitter.on(e, n);
}
function Ne(t, e, n, r, i) {
  return t.triggerEvent(e, n, r, i);
}
function zE(t, e) {
  return Co(t).getComputedStyle(t, e);
}
function Hh(t, e, n) {
  var r = {}, i = {};
  return t.filter(function(s) {
    var o = s.name;
    if (r[o] || !e.some(function(a) {
      return s[a];
    }))
      return !1;
    if (!n && s.ableGroup) {
      if (i[s.ableGroup])
        return !1;
      i[s.ableGroup] = !0;
    }
    return r[o] = !0, !0;
  });
}
function $1(t, e) {
  return t === e || t == null && e == null;
}
function ZT() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  for (var n = t.length - 1, r = 0; r < n; ++r) {
    var i = t[r];
    if (!Uf(i))
      return i;
  }
  return t[n];
}
function mL(t, e) {
  var n = [], r = [];
  return t.forEach(function(i, s) {
    var o = e(i, s, t), a = r.indexOf(o), l = n[a] || [];
    a === -1 && (r.push(o), n.push(l)), l.push(i);
  }), n;
}
function jee(t, e) {
  var n = [], r = {};
  return t.forEach(function(i, s) {
    var o = e(i, s, t), a = r[o];
    a || (a = [], r[o] = a, n.push(a)), a.push(i);
  }), n;
}
function vL(t) {
  return t.reduce(function(e, n) {
    return e.concat(n);
  }, []);
}
function Uc() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return t.sort(function(n, r) {
    return oe(r) - oe(n);
  }), t[0];
}
function Vc(t, e, n) {
  return Bn(us(t, n), Qa(e, n), n);
}
function bL(t, e) {
  var n, r = t.is3d, i = t.rootMatrix, s = r ? 4 : 3;
  return n = F(Vc(i, [e.distX, e.distY], s), 2), e.distX = n[0], e.distY = n[1], e;
}
function Vr(t, e, n, r) {
  if (!n[0] && !n[1])
    return e;
  var i = qt(t, [KT(n[0] || 1), 0], r), s = qt(t, [0, KT(n[1] || 1)], r), o = qt(t, [
    n[0] / ci(i),
    n[1] / ci(s)
  ], r);
  return wt(e, o);
}
function bi(t, e, n) {
  return n ? "".concat(t / e * 100, "%") : "".concat(t, "px");
}
function Wg(t) {
  return oe(t) <= rr ? 0 : t;
}
function HE(t) {
  return function(e) {
    if (!e.isDragging(t))
      return "";
    var n = LQ(e, t), r = n.deg;
    return r ? qe("view-control-rotation".concat(r)) : "";
  };
}
function UE(t, e) {
  return e === void 0 && (e = [t]), function(n, r) {
    if (r.isRequest)
      return e.some(function(s) {
        return r.requestAble === s;
      }) ? r.parentDirection : !1;
    var i = r.inputEvent.target;
    return fn(i, qe("direction")) && (!t || fn(i, qe(t)));
  };
}
function qee(t, e, n) {
  var r, i = Fc(t, {
    "x%": function(_) {
      return _ / 100 * e.offsetWidth;
    },
    "y%": function(_) {
      return _ / 100 * e.offsetHeight;
    }
  }), s = t.slice(0, n < 0 ? void 0 : n), o = t.slice(0, n < 0 ? void 0 : n + 1), a = t[n] || "", l = n < 0 ? [] : t.slice(n), c = n < 0 ? [] : t.slice(n + 1), u = i.slice(0, n < 0 ? void 0 : n), d = i.slice(0, n < 0 ? void 0 : n + 1), f = (r = i[n]) !== null && r !== void 0 ? r : Fc([""])[0], h = n < 0 ? [] : i.slice(n), p = n < 0 ? [] : i.slice(n + 1), g = f ? [f] : [], m = Hl(u), v = Hl(d), y = Hl(h), E = Hl(p), b = Mt(m, y, 4);
  return {
    transforms: t,
    beforeFunctionMatrix: m,
    beforeFunctionMatrix2: v,
    targetFunctionMatrix: Hl(g),
    afterFunctionMatrix: y,
    afterFunctionMatrix2: E,
    allFunctionMatrix: b,
    beforeFunctions: u,
    beforeFunctions2: d,
    targetFunction: g[0],
    afterFunctions: h,
    afterFunctions2: p,
    beforeFunctionTexts: s,
    beforeFunctionTexts2: o,
    targetFunctionText: a,
    afterFunctionTexts: l,
    afterFunctionTexts2: c
  };
}
function Kee(t) {
  return !t || !Ni(t) || nu(t) ? !1 : rn(t) || "length" in t;
}
function ts(t, e) {
  return t ? nu(t) ? t : vr(t) ? e ? document.querySelector(t) : t : pE(t) ? t() : J2(t) ? t : "current" in t ? t.current : t : null;
}
function VE(t, e) {
  if (!t)
    return [];
  var n = Kee(t) ? [].slice.call(t) : [t];
  return n.reduce(function(r, i) {
    return vr(i) && e ? he(he([], F(r), !1), F([].slice.call(document.querySelectorAll(i))), !1) : (rn(i) ? r.push(VE(i, e)) : r.push(ts(i, e)), r);
  }, []);
}
function Yee(t, e, n) {
  var r = Qt(t, e) / Math.PI * 180;
  return r = n >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;
}
function QT(t, e) {
  var n = t.rootMatrix, r = t.is3d, i = r ? 4 : 3, s = us(n, i);
  return r || (s = Ri(s, 3, 4)), s[12] = 0, s[13] = 0, s[14] = 0, NZ(s, e);
}
function yL(t, e, n, r, i) {
  var s = F(t, 2), o = s[0], a = s[1], l = 0, c = 0;
  if (i && o && a) {
    var u = Qt([0, 0], e), d = Qt([0, 0], r), f = ci(e), h = Math.cos(u - d) * f;
    if (!r[0])
      c = h, l = c * n;
    else if (!r[1])
      l = h, c = l / n;
    else {
      var p = r[0] * o, g = r[1] * a, m = Math.atan2(p + e[0], g + e[1]), v = Math.atan2(p, g);
      m < 0 && (m += Math.PI * 2), v < 0 && (v += Math.PI * 2);
      var y = 0;
      oe(m - v) < Math.PI / 2 || oe(m - v) > Math.PI / 2 * 3 || (v += Math.PI), y = m - v, y > Math.PI * 2 ? y -= Math.PI * 2 : y > Math.PI ? y = 2 * Math.PI - y : y < -Math.PI && (y = -2 * Math.PI - y);
      var E = ci([p + e[0], g + e[1]]) * Math.cos(y);
      l = E * Math.sin(v) - p, c = E * Math.cos(v) - g, r[0] < 0 && (l *= -1), r[1] < 0 && (c *= -1);
    }
  } else
    l = r[0] * e[0], c = r[1] * e[1];
  return [l, c];
}
function wL(t, e, n, r) {
  var i, s = n.ratio, o = n.startOffsetWidth, a = n.startOffsetHeight, l = 0, c = 0, u = r.distX, d = r.distY, f = r.pinchScale, h = r.parentDistance, p = r.parentDist, g = r.parentScale, m = n.fixedDirection, v = [0, 1].map(function(S) {
    return oe(t[S] - m[S]);
  }), y = [0, 1].map(function(S) {
    var x = v[S];
    return x !== 0 && (x = 2 / x), x;
  });
  if (p)
    l = p[0], c = p[1], e && (l ? c || (c = l / s) : l = c * s);
  else if (Bc(f))
    l = (f - 1) * o, c = (f - 1) * a;
  else if (g)
    l = (g[0] - 1) * o, c = (g[1] - 1) * a;
  else if (h) {
    var E = o * v[0], b = a * v[1], _ = ci([E, b]);
    l = h / _ * E * y[0], c = h / _ * b * y[1];
  } else {
    var w = ms({ datas: n, distX: u, distY: d });
    w = y.map(function(S, x) {
      return w[x] * S;
    }), i = F(yL([o, a], w, s, t, e), 2), l = i[0], c = i[1];
  }
  return {
    // direction,
    // sizeDirection,
    distWidth: l,
    distHeight: c
  };
}
function B1(t, e) {
  if (e) {
    if (t === "left")
      return { x: "0%", y: "50%" };
    if (t === "top")
      return { x: "50%", y: "50%" };
    if (t === "center")
      return { x: "50%", y: "50%" };
    if (t === "right")
      return { x: "100%", y: "50%" };
    if (t === "bottom")
      return { x: "50%", y: "100%" };
    var n = F(t.split(" "), 2), r = n[0], i = n[1], s = B1(r || ""), o = B1(i || ""), a = L(L({}, s), o), l = {
      x: "50%",
      y: "50%"
    };
    return a.x && (l.x = a.x), a.y && (l.y = a.y), a.value && (a.x && !a.y && (l.y = a.value), !a.x && a.y && (l.x = a.value)), l;
  }
  return t === "left" ? { x: "0%" } : t === "right" ? { x: "100%" } : t === "top" ? { y: "0%" } : t === "bottom" ? { y: "100%" } : t ? t === "center" ? { value: "50%" } : { value: t } : {};
}
function WE(t, e, n) {
  var r = B1(t, !0), i = r.x, s = r.y;
  return [
    Ot(i, e) || 0,
    Ot(s, n) || 0
  ];
}
function Xee(t, e, n) {
  var r = t.map(function(s) {
    return Ke(s, e);
  }), i = r.map(function(s) {
    return qf(s, n);
  });
  return {
    prev: r,
    next: i,
    result: i.map(function(s) {
      return wt(s, e);
    })
  };
}
function _L(t, e) {
  return t.length === e.length && t.every(function(n, r) {
    var i = e[r], s = rn(n), o = rn(i);
    return s && o ? _L(n, i) : !s && !o ? n === i : !1;
  });
}
function ec(t, e, n, r, i) {
  var s = t._store, o = s[e];
  if (!(e in s))
    if (i != null)
      s[e] = i, o = i;
    else
      return s[e] = n, n;
  return o === n || r(o) === r(n) ? o : (s[e] = n, n);
}
function Kn(t) {
  return t >= 0 ? 1 : -1;
}
function oe(t) {
  return Math.abs(t);
}
function Rb(t, e) {
  return WJ(t).map(function(n) {
    return e(n);
  });
}
function EL(t) {
  return Bc(t) ? {
    top: t,
    left: t,
    right: t,
    bottom: t
  } : {
    left: t.left || 0,
    top: t.top || 0,
    right: t.right || 0,
    bottom: t.bottom || 0
  };
}
var Jee = Xf("pinchable", {
  props: [
    "pinchable"
  ],
  events: [
    "pinchStart",
    "pinch",
    "pinchEnd",
    "pinchGroupStart",
    "pinchGroup",
    "pinchGroupEnd"
  ],
  dragStart: function() {
    return !0;
  },
  pinchStart: function(t, e) {
    var n = e.datas, r = e.targets, i = e.angle, s = e.originalDatas, o = t.props, a = o.pinchable, l = o.ables;
    if (!a)
      return !1;
    var c = "onPinch".concat(r ? "Group" : "", "Start"), u = "drag".concat(r ? "Group" : "", "ControlStart"), d = (a === !0 ? t.controlAbles : l.filter(function(g) {
      return a.indexOf(g.name) > -1;
    })).filter(function(g) {
      return g.canPinch && g[u];
    }), f = st(t, e, {});
    r && (f.targets = r);
    var h = Ne(t, c, f);
    n.isPinch = h !== !1, n.ables = d;
    var p = n.isPinch;
    return p ? (d.forEach(function(g) {
      if (s[g.name] = s[g.name] || {}, !!g[u]) {
        var m = L(L({}, e), { datas: s[g.name], parentRotate: i, isPinch: !0 });
        g[u](t, m);
      }
    }), t.state.snapRenderInfo = {
      request: e.isRequest,
      direction: [0, 0]
    }, p) : !1;
  },
  pinch: function(t, e) {
    var n = e.datas, r = e.scale, i = e.distance, s = e.originalDatas, o = e.inputEvent, a = e.targets, l = e.angle;
    if (n.isPinch) {
      var c = i * (1 - 1 / r), u = st(t, e, {});
      a && (u.targets = a);
      var d = "onPinch".concat(a ? "Group" : "");
      Ne(t, d, u);
      var f = n.ables, h = "drag".concat(a ? "Group" : "", "Control");
      return f.forEach(function(p) {
        p[h] && p[h](t, L(L({}, e), { datas: s[p.name], inputEvent: o, resolveMatrix: !0, pinchScale: r, parentDistance: c, parentRotate: l, isPinch: !0 }));
      }), u;
    }
  },
  pinchEnd: function(t, e) {
    var n = e.datas, r = e.isPinch, i = e.inputEvent, s = e.targets, o = e.originalDatas;
    if (n.isPinch) {
      var a = "onPinch".concat(s ? "Group" : "", "End"), l = zr(t, e, { isDrag: r });
      s && (l.targets = s), Ne(t, a, l);
      var c = n.ables, u = "drag".concat(s ? "Group" : "", "ControlEnd");
      return c.forEach(function(d) {
        d[u] && d[u](t, L(L({}, e), { isDrag: r, datas: o[d.name], inputEvent: i, isPinch: !0 }));
      }), r;
    }
  },
  pinchGroupStart: function(t, e) {
    return this.pinchStart(t, L(L({}, e), { targets: t.props.targets }));
  },
  pinchGroup: function(t, e) {
    return this.pinch(t, L(L({}, e), { targets: t.props.targets }));
  },
  pinchGroupEnd: function(t, e) {
    return this.pinchEnd(t, L(L({}, e), { targets: t.props.targets }));
  }
}), eO = UE("scalable"), Zee = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: [
    "scalable",
    "throttleScale",
    "renderDirections",
    "keepRatio",
    "edge",
    "displayAroundControls"
  ],
  events: [
    "scaleStart",
    "beforeScale",
    "scale",
    "scaleEnd",
    "scaleGroupStart",
    "beforeScaleGroup",
    "scaleGroup",
    "scaleGroupEnd"
  ],
  render: HP("scalable"),
  dragControlCondition: eO,
  viewClassName: HE("scalable"),
  dragControlStart: function(t, e) {
    var n = e.datas, r = e.isPinch, i = e.inputEvent, s = e.parentDirection, o = hL(s, r, i, n), a = t.state, l = a.width, c = a.height, u = a.targetTransform, d = a.target, f = a.pos1, h = a.pos2, p = a.pos4;
    if (!o || !d)
      return !1;
    r || pl(t, e), n.datas = {}, n.transform = u, n.prevDist = [1, 1], n.direction = o, n.startOffsetWidth = l, n.startOffsetHeight = c, n.startValue = [1, 1];
    var g = !o[0] && !o[1] || o[0] || !o[1];
    i0(t, e, "scale"), n.isWidth = g;
    function m(w) {
      n.ratio = w && isFinite(w) ? w : 0;
    }
    n.startPositions = ui(t.state);
    function v(w) {
      var S = QP(n.startPositions, w);
      n.fixedDirection = S.fixedDirection, n.fixedPosition = S.fixedPosition, n.fixedOffset = S.fixedOffset;
    }
    n.setFixedDirection = v, m(Bs(f, h) / Bs(h, p)), v([-o[0], -o[1]]);
    var y = function(w) {
      n.minScaleSize = w;
    }, E = function(w) {
      n.maxScaleSize = w;
    };
    y([-1 / 0, -1 / 0]), E([1 / 0, 1 / 0]);
    var b = st(t, e, L(L({ direction: o, set: function(w) {
      n.startValue = w;
    }, setRatio: m, setFixedDirection: v, setMinScaleSize: y, setMaxScaleSize: E }, r0(t, e)), { dragStart: qn.dragStart(t, new zc().dragStart([0, 0], e)) })), _ = Ne(t, "onScaleStart", b);
    return n.startFixedDirection = n.fixedDirection, _ !== !1 && (n.isScale = !0, t.state.snapRenderInfo = {
      request: e.isRequest,
      direction: o
    }), n.isScale ? b : !1;
  },
  dragControl: function(t, e) {
    t0(t, e, "scale");
    var n = e.datas, r = e.parentKeepRatio, i = e.parentFlag, s = e.isPinch, o = e.dragClient, a = e.isRequest, l = e.useSnap, c = e.resolveMatrix, u = n.prevDist, d = n.direction, f = n.startOffsetWidth, h = n.startOffsetHeight, p = n.isScale, g = n.startValue, m = n.isWidth, v = n.ratio;
    if (!p)
      return !1;
    var y = t.props, E = y.throttleScale, b = y.parentMoveable, _ = d;
    !d[0] && !d[1] && (_ = [1, 1]);
    var w = v && (r ?? y.keepRatio) || !1, S = t.state, x = [
      g[0],
      g[1]
    ];
    function k() {
      var le = wL(_, w, n, e), Ee = le.distWidth, Se = le.distHeight, xe = f ? (f + Ee) / f : 1, Ce = h ? (h + Se) / h : 1;
      g[0] || (x[0] = Ee / f), g[1] || (x[1] = Se / h);
      var _e = (_[0] || w ? xe : 1) * x[0], Je = (_[1] || w ? Ce : 1) * x[1];
      return _e === 0 && (_e = Kn(u[0]) * Lh), Je === 0 && (Je = Kn(u[1]) * Lh), [_e, Je];
    }
    var T = k();
    if (!s && t.props.groupable) {
      var I = S.snapRenderInfo || {}, R = I.direction;
      rn(R) && (R[0] || R[1]) && (S.snapRenderInfo = { direction: d, request: e.isRequest });
    }
    Ne(t, "onBeforeScale", st(t, e, {
      scale: T,
      setFixedDirection: function(le) {
        return n.setFixedDirection(le), T = k(), T;
      },
      startFixedDirection: n.startFixedDirection,
      setScale: function(le) {
        T = le;
      }
    }, !0));
    var N = [
      T[0] / x[0],
      T[1] / x[1]
    ], $ = o, B = [0, 0], G = Kn(N[0] * N[1]), M = !o && !i && s;
    if (M || c ? $ = NE(t, n.targetAllTransform, [0, 0], [0, 0], n) : o || ($ = n.fixedPosition), s || (B = Aee(t, N, d, !l && a, n)), w) {
      _[0] && _[1] && B[0] && B[1] && (Math.abs(B[0] * f) > Math.abs(B[1] * h) ? B[1] = 0 : B[0] = 0);
      var A = !B[0] && !B[1];
      if (A && (m ? N[0] = tt(N[0] * x[0], E) / x[0] : N[1] = tt(N[1] * x[1], E) / x[1]), _[0] && !_[1] || B[0] && !B[1] || A && m) {
        N[0] += B[0];
        var z = f * N[0] * x[0] / v;
        N[1] = Kn(G * N[0]) * oe(z / h / x[1]);
      } else if (!_[0] && _[1] || !B[0] && B[1] || A && !m) {
        N[1] += B[1];
        var V = h * N[1] * x[1] * v;
        N[0] = Kn(G * N[1]) * oe(V / f / x[0]);
      }
    } else
      N[0] += B[0], N[1] += B[1], B[0] || (N[0] = tt(N[0] * x[0], E) / x[0]), B[1] || (N[1] = tt(N[1] * x[1], E) / x[1]);
    N[0] === 0 && (N[0] = Kn(u[0]) * Lh), N[1] === 0 && (N[1] = Kn(u[1]) * Lh), T = Iee(N, [x[0], x[1]]);
    var U = [
      f,
      h
    ], Y = [
      f * T[0],
      h * T[1]
    ];
    Y = j2(Y, n.minScaleSize, n.maxScaleSize, w ? v : !1), T = Rb(2, function(le) {
      return U[le] ? Y[le] / U[le] : Y[le];
    }), N = Rb(2, function(le) {
      return T[le] / x[le];
    });
    var ne = Rb(2, function(le) {
      return u[le] ? N[le] / u[le] : N[le];
    }), ie = "scale(".concat(N.join(", "), ")"), Z = "scale(".concat(T.join(", "), ")"), Q = n0(n, Z, ie), fe = !g[0] || !g[1], ge = AQ(t, fe ? Z : ie, n.fixedDirection, $, n.fixedOffset, n, fe), Re = M ? ge : Ke(ge, n.prevInverseDist || [0, 0]);
    if (n.prevDist = N, n.prevInverseDist = ge, T[0] === u[0] && T[1] === u[1] && Re.every(function(le) {
      return !le;
    }) && !b && !M)
      return !1;
    var Be = st(t, e, L({ offsetWidth: f, offsetHeight: h, direction: d, scale: T, dist: N, delta: ne, isPinch: !!s }, PP(t, Q, Re, s, e)));
    return Ne(t, "onScale", Be), Be;
  },
  dragControlEnd: function(t, e) {
    var n = e.datas;
    if (!n.isScale)
      return !1;
    n.isScale = !1;
    var r = zr(t, e, {});
    return Ne(t, "onScaleEnd", r), r;
  },
  dragGroupControlCondition: eO,
  dragGroupControlStart: function(t, e) {
    var n = e.datas, r = this.dragControlStart(t, e);
    if (!r)
      return !1;
    var i = Ci(t, "resizable", e);
    n.moveableScale = t.scale;
    var s = Fs(t, this, "dragControlStart", e, function(c, u) {
      return Fg(t, c, n, u);
    }), o = function(c) {
      r.setFixedDirection(c), s.forEach(function(u, d) {
        u.setFixedDirection(c), Fg(t, u.moveable, n, i[d]);
      });
    };
    n.setFixedDirection = o;
    var a = L(L({}, r), { targets: t.props.targets, events: s, setFixedDirection: o }), l = Ne(t, "onScaleGroupStart", a);
    return n.isScale = l !== !1, n.isScale ? a : !1;
  },
  dragGroupControl: function(t, e) {
    var n = e.datas;
    if (n.isScale) {
      c0(t, "onBeforeScale", function(u) {
        Ne(t, "onBeforeScaleGroup", st(t, e, L(L({}, u), { targets: t.props.targets }), !0));
      });
      var r = this.dragControl(t, e);
      if (r) {
        var i = r.dist, s = n.moveableScale;
        t.scale = [
          i[0] * s[0],
          i[1] * s[1]
        ];
        var o = t.props.keepRatio, a = n.fixedPosition, l = Fs(t, this, "dragControl", e, function(u, d) {
          var f = F(Bn(Kf(t.rotation / 180 * Math.PI, 3), [
            d.datas.originalX * i[0],
            d.datas.originalY * i[1],
            1
          ], 3), 2), h = f[0], p = f[1];
          return L(L({}, d), {
            parentDist: null,
            parentScale: i,
            parentKeepRatio: o,
            // recalculate child fixed position for parent group's dragging.
            dragClient: wt(a, [h, p])
          });
        }), c = L({ targets: t.props.targets, events: l }, r);
        return Ne(t, "onScaleGroup", c), c;
      }
    }
  },
  dragGroupControlEnd: function(t, e) {
    var n = e.isDrag, r = e.datas;
    if (r.isScale) {
      this.dragControlEnd(t, e);
      var i = Fs(t, this, "dragControlEnd", e), s = zr(t, e, {
        targets: t.props.targets,
        events: i
      });
      return Ne(t, "onScaleGroupEnd", s), n;
    }
  },
  /**
       * @method Moveable.Scalable#request
       * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("scalable");
       *
       * // request
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request: function() {
    var t = {}, e = 0, n = 0, r = !1;
    return {
      isControl: !0,
      requestStart: function(i) {
        return r = i.useSnap, {
          datas: t,
          parentDirection: i.direction || [1, 1],
          useSnap: r
        };
      },
      request: function(i) {
        return e += i.deltaWidth, n += i.deltaHeight, {
          datas: t,
          parentDist: [e, n],
          parentKeepRatio: i.keepRatio,
          useSnap: r
        };
      },
      requestEnd: function() {
        return { datas: t, isDrag: !0, useSnap: r };
      }
    };
  }
};
function eo(t, e) {
  return t.map(function(n, r) {
    return Ig(n, e[r], 1, 2);
  });
}
function tO(t, e, n) {
  var r = Qt(t, e), i = Qt(t, n), s = i - r;
  return s >= 0 ? s : s + 2 * Math.PI;
}
function Qee(t, e) {
  var n = tO(t[0], t[1], t[2]), r = tO(e[0], e[1], e[2]), i = Math.PI;
  return !(n >= i && r <= i || n <= i && r >= i);
}
var ete = {
  name: "warpable",
  ableGroup: "size",
  props: [
    "warpable",
    "renderDirections",
    "edge",
    "displayAroundControls"
  ],
  events: [
    "warpStart",
    "warp",
    "warpEnd"
  ],
  viewClassName: HE("warpable"),
  render: function(t, e) {
    var n = t.props, r = n.resizable, i = n.scalable, s = n.warpable, o = n.zoom;
    if (r || i || !s)
      return [];
    var a = t.state, l = a.pos1, c = a.pos2, u = a.pos3, d = a.pos4, f = eo(l, c), h = eo(c, l), p = eo(l, u), g = eo(u, l), m = eo(u, d), v = eo(d, u), y = eo(c, d), E = eo(d, c);
    return he([
      e.createElement("div", { className: qe("line"), key: "middeLine1", style: Lu(f, m, o) }),
      e.createElement("div", { className: qe("line"), key: "middeLine2", style: Lu(h, v, o) }),
      e.createElement("div", { className: qe("line"), key: "middeLine3", style: Lu(p, y, o) }),
      e.createElement("div", { className: qe("line"), key: "middeLine4", style: Lu(g, E, o) })
    ], F(UP(t, "warpable", e)), !1);
  },
  dragControlCondition: function(t, e) {
    if (e.isRequest)
      return !1;
    var n = e.inputEvent.target;
    return fn(n, qe("direction")) && fn(n, qe("warpable"));
  },
  dragControlStart: function(t, e) {
    var n = e.datas, r = e.inputEvent, i = t.props.target, s = r.target, o = pL(s, n);
    if (!o || !i)
      return !1;
    var a = t.state, l = a.transformOrigin, c = a.is3d, u = a.targetTransform, d = a.targetMatrix, f = a.width, h = a.height, p = a.left, g = a.top;
    n.datas = {}, n.targetTransform = u, n.warpTargetMatrix = c ? d : Ri(d, 3, 4), n.targetInverseMatrix = mP(us(n.warpTargetMatrix, 4), 3, 4), n.direction = o, n.left = p, n.top = g, n.poses = [
      [0, 0],
      [f, 0],
      [0, h],
      [f, h]
    ].map(function(y) {
      return Ke(y, l);
    }), n.nextPoses = n.poses.map(function(y) {
      var E = F(y, 2), b = E[0], _ = E[1];
      return Bn(n.warpTargetMatrix, [b, _, 0, 1], 4);
    }), n.startValue = $t(4), n.prevMatrix = $t(4), n.absolutePoses = ui(a), n.posIndexes = IP(o), pl(t, e), i0(t, e, "matrix3d"), a.snapRenderInfo = {
      request: e.isRequest,
      direction: o
    };
    var m = st(t, e, L({ set: function(y) {
      n.startValue = y;
    } }, r0(t, e))), v = Ne(t, "onWarpStart", m);
    return v !== !1 && (n.isWarp = !0), n.isWarp;
  },
  dragControl: function(t, e) {
    var n = e.datas, r = e.isRequest, i = e.distX, s = e.distY, o = n.targetInverseMatrix, a = n.prevMatrix, l = n.isWarp, c = n.startValue, u = n.poses, d = n.posIndexes, f = n.absolutePoses;
    if (!l)
      return !1;
    if (t0(t, e, "matrix3d"), su(t, "warpable")) {
      var h = d.map(function(k) {
        return f[k];
      });
      h.length > 1 && h.push([
        (h[0][0] + h[1][0]) / 2,
        (h[0][1] + h[1][1]) / 2
      ]);
      var p = a0(t, r, {
        horizontal: h.map(function(k) {
          return k[1] + s;
        }),
        vertical: h.map(function(k) {
          return k[0] + i;
        })
      }), g = p.horizontal, m = p.vertical;
      s -= g.offset, i -= m.offset;
    }
    var v = ms({ datas: n, distX: i, distY: s }, !0), y = n.nextPoses.slice();
    if (d.forEach(function(k) {
      y[k] = wt(y[k], v);
    }), !wQ.every(function(k) {
      return Qee(k.map(function(T) {
        return u[T];
      }), k.map(function(T) {
        return y[T];
      }));
    }))
      return !1;
    var E = kE(u[0], u[2], u[1], u[3], y[0], y[2], y[1], y[3]);
    if (!E.length)
      return !1;
    var b = Mt(o, E, 4), _ = RP(n, b, !0), w = Mt(us(a, 4), _, 4);
    n.prevMatrix = _;
    var S = Mt(c, _, 4), x = n0(n, "matrix3d(".concat(S.join(", "), ")"), "matrix3d(".concat(_.join(", "), ")"));
    return AE(e, x), Ne(t, "onWarp", st(t, e, L({ delta: w, matrix: S, dist: _, multiply: Mt, transform: x }, Jn({
      transform: x
    }, e)))), !0;
  },
  dragControlEnd: function(t, e) {
    var n = e.datas, r = e.isDrag;
    return n.isWarp ? (n.isWarp = !1, Ne(t, "onWarpEnd", zr(t, e, {})), r) : !1;
  }
}, tte = /* @__PURE__ */ qe("area-pieces"), Uh = /* @__PURE__ */ qe("area-piece"), SL = /* @__PURE__ */ qe("avoid"), nte = qe("view-dragging");
function Db(t) {
  var e = t.areaElement;
  if (e) {
    var n = t.state, r = n.width, i = n.height;
    X2(e, SL), e.style.cssText += "left: 0px; top: 0px; width: ".concat(r, "px; height: ").concat(i, "px");
  }
}
function nO(t) {
  return t.createElement(
    "div",
    { key: "area_pieces", className: tte },
    t.createElement("div", { className: Uh }),
    t.createElement("div", { className: Uh }),
    t.createElement("div", { className: Uh }),
    t.createElement("div", { className: Uh })
  );
}
var xL = {
  name: "dragArea",
  props: [
    "dragArea",
    "passDragArea"
  ],
  events: [
    "click",
    "clickGroup"
  ],
  render: function(t, e) {
    var n = t.props, r = n.target, i = n.dragArea, s = n.groupable, o = n.passDragArea, a = t.getState(), l = a.width, c = a.height, u = a.renderPoses, d = o ? qe("area", "pass") : qe("area");
    if (s)
      return [
        e.createElement("div", { key: "area", ref: $s(t, "areaElement"), className: d }),
        nO(e)
      ];
    if (!r || !i)
      return [];
    var f = kE([0, 0], [l, 0], [0, c], [l, c], u[0], u[1], u[2], u[3]), h = f.length ? l0(f, !0) : "none";
    return [
      e.createElement("div", { key: "area", ref: $s(t, "areaElement"), className: d, style: {
        top: "0px",
        left: "0px",
        width: "".concat(l, "px"),
        height: "".concat(c, "px"),
        transformOrigin: "0 0",
        transform: h
      } }),
      nO(e)
    ];
  },
  dragStart: function(t, e) {
    var n = e.datas, r = e.clientX, i = e.clientY, s = e.inputEvent;
    if (!s)
      return !1;
    n.isDragArea = !1;
    var o = t.areaElement, a = t.state, l = a.moveableClientRect, c = a.renderPoses, u = a.rootMatrix, d = a.is3d, f = l.left, h = l.top, p = ni(c), g = p.left, m = p.top, v = p.width, y = p.height, E = d ? 4 : 3, b = F(Vc(u, [r - f, i - h], E), 2), _ = b[0], w = b[1];
    _ -= g, w -= m;
    var S = [
      { left: g, top: m, width: v, height: w - 10 },
      { left: g, top: m, width: _ - 10, height: y },
      { left: g, top: m + w + 10, width: v, height: y - w - 10 },
      { left: g + _ + 10, top: m, width: v - _ - 10, height: y }
    ], x = [].slice.call(o.nextElementSibling.children);
    S.forEach(function(k, T) {
      x[T].style.cssText = "left: ".concat(k.left, "px;top: ").concat(k.top, "px; width: ").concat(k.width, "px; height: ").concat(k.height, "px;");
    }), Y2(o, SL), a.disableNativeEvent = !0;
  },
  drag: function(t, e) {
    var n = e.datas, r = e.inputEvent;
    if (this.enableNativeEvent(t), !r)
      return !1;
    n.isDragArea || (n.isDragArea = !0, Db(t));
  },
  dragEnd: function(t, e) {
    this.enableNativeEvent(t);
    var n = e.inputEvent, r = e.datas;
    if (!n)
      return !1;
    r.isDragArea || Db(t);
  },
  dragGroupStart: function(t, e) {
    return this.dragStart(t, e);
  },
  dragGroup: function(t, e) {
    return this.drag(t, e);
  },
  dragGroupEnd: function(t, e) {
    return this.dragEnd(t, e);
  },
  unset: function(t) {
    Db(t), t.state.disableNativeEvent = !1;
  },
  enableNativeEvent: function(t) {
    var e = t.state;
    e.disableNativeEvent && G2(function() {
      e.disableNativeEvent = !1;
    });
  }
}, rte = Xf("origin", {
  props: ["origin", "svgOrigin"],
  render: function(t, e) {
    var n = t.props, r = n.zoom, i = n.svgOrigin, s = n.groupable, o = t.getState(), a = o.beforeOrigin, l = o.rotation, c = o.svg, u = o.allMatrix, d = o.is3d, f = o.left, h = o.top, p = o.offsetWidth, g = o.offsetHeight, m;
    if (!s && c && i) {
      var v = F(WE(i, p, g), 2), y = v[0], E = v[1], b = d ? 4 : 3, _ = qt(u, [y, E], b);
      m = Vg(l, r, Ke(_, [f, h]));
    } else
      m = Vg(l, r, a);
    return [
      e.createElement("div", { className: qe("control", "origin"), style: m, key: "beforeOrigin" })
    ];
  }
});
function ite(t) {
  var e = t.scrollContainer;
  return [
    e.scrollLeft,
    e.scrollTop
  ];
}
var ste = {
  name: "scrollable",
  canPinch: !0,
  props: [
    "scrollable",
    "scrollContainer",
    "scrollThreshold",
    "scrollThrottleTime",
    "getScrollPosition",
    "scrollOptions"
  ],
  events: [
    "scroll",
    "scrollGroup"
  ],
  dragRelation: "strong",
  dragStart: function(t, e) {
    var n = t.props, r = n.scrollContainer, i = r === void 0 ? t.getContainer() : r, s = n.scrollOptions, o = new FZ(), a = ts(i, !0);
    e.datas.dragScroll = o, t.state.dragScroll = o;
    var l = e.isControl ? "controlGesto" : "targetGesto", c = e.targets;
    o.on("scroll", function(u) {
      var d = u.container, f = u.direction, h = st(t, e, {
        scrollContainer: d,
        direction: f
      }), p = c ? "onScrollGroup" : "onScroll";
      c && (h.targets = c), Ne(t, p, h);
    }).on("move", function(u) {
      var d = u.offsetX, f = u.offsetY, h = u.inputEvent;
      t[l].scrollBy(d, f, h.inputEvent, !1);
    }).on("scrollDrag", function(u) {
      var d = u.next;
      d(t[l].getCurrentEvent());
    }), o.dragStart(e, L({ container: a }, s));
  },
  checkScroll: function(t, e) {
    var n = e.datas.dragScroll;
    if (n) {
      var r = t.props, i = r.scrollContainer, s = i === void 0 ? t.getContainer() : i, o = r.scrollThreshold, a = o === void 0 ? 0 : o, l = r.scrollThrottleTime, c = l === void 0 ? 0 : l, u = r.getScrollPosition, d = u === void 0 ? ite : u, f = r.scrollOptions;
      return n.drag(e, L({ container: s, threshold: a, throttleTime: c, getScrollPosition: function(h) {
        return d({ scrollContainer: h.container, direction: h.direction });
      } }, f)), !0;
    }
  },
  drag: function(t, e) {
    return this.checkScroll(t, e);
  },
  dragEnd: function(t, e) {
    e.datas.dragScroll.dragEnd(), e.datas.dragScroll = null;
  },
  dragControlStart: function(t, e) {
    return this.dragStart(t, L(L({}, e), { isControl: !0 }));
  },
  dragControl: function(t, e) {
    return this.drag(t, e);
  },
  dragControlEnd: function(t, e) {
    return this.dragEnd(t, e);
  },
  dragGroupStart: function(t, e) {
    return this.dragStart(t, L(L({}, e), { targets: t.props.targets }));
  },
  dragGroup: function(t, e) {
    return this.drag(t, L(L({}, e), { targets: t.props.targets }));
  },
  dragGroupEnd: function(t, e) {
    return this.dragEnd(t, L(L({}, e), { targets: t.props.targets }));
  },
  dragGroupControlStart: function(t, e) {
    return this.dragStart(t, L(L({}, e), { targets: t.props.targets, isControl: !0 }));
  },
  dragGroupControl: function(t, e) {
    return this.drag(t, L(L({}, e), { targets: t.props.targets }));
  },
  dragGroupControEnd: function(t, e) {
    return this.dragEnd(t, L(L({}, e), { targets: t.props.targets }));
  },
  unset: function(t) {
    var e, n = t.state;
    (e = n.dragScroll) === null || e === void 0 || e.dragEnd(), n.dragScroll = null;
  }
}, kL = {
  name: "",
  props: [
    "target",
    "dragTargetSelf",
    "dragTarget",
    "dragContainer",
    "container",
    "warpSelf",
    "rootContainer",
    "useResizeObserver",
    "useMutationObserver",
    "zoom",
    "dragFocusedInput",
    "transformOrigin",
    "ables",
    "className",
    "pinchThreshold",
    "pinchOutside",
    "triggerAblesSimultaneously",
    "checkInput",
    "cspNonce",
    "translateZ",
    "hideDefaultLines",
    "props",
    "flushSync",
    "stopPropagation",
    "preventClickEventOnDrag",
    "preventClickDefault",
    "viewContainer",
    "persistData",
    "useAccuratePosition",
    "firstRenderState",
    "linePadding",
    "controlPadding",
    "preventDefault",
    "preventRightClick",
    "preventWheelClick",
    "requestStyles"
  ],
  events: [
    "changeTargets"
  ]
}, ote = Xf("padding", {
  props: ["padding"],
  render: function(t, e) {
    var n = t.props;
    if (n.dragArea)
      return [];
    var r = EL(n.padding || {}), i = r.left, s = r.top, o = r.right, a = r.bottom, l = t.getState(), c = l.renderPoses, u = l.pos1, d = l.pos2, f = l.pos3, h = l.pos4, p = [u, d, f, h], g = [];
    return i > 0 && g.push([0, 2]), s > 0 && g.push([0, 1]), o > 0 && g.push([1, 3]), a > 0 && g.push([2, 3]), g.map(function(m, v) {
      var y = F(m, 2), E = y[0], b = y[1], _ = p[E], w = p[b], S = c[E], x = c[b], k = kE([0, 0], [100, 0], [0, 100], [100, 100], _, w, S, x);
      if (k.length)
        return e.createElement("div", { key: "padding".concat(v), className: qe("padding"), style: {
          transform: l0(k, !0)
        } });
    });
  }
}), rO = ["nw", "ne", "se", "sw"];
function Vh(t, e) {
  var n = t[0] + t[1], r = n > e ? e / n : 1;
  return t[0] *= r, t[1] = e - t[1] * r, t;
}
var ate = [1, 2, 5, 6], lte = [0, 3, 4, 7], aa = [1, -1, -1, 1], la = [1, 1, -1, -1];
function GE(t, e, n, r, i, s, o, a) {
  i === void 0 && (i = 0), s === void 0 && (s = 0), o === void 0 && (o = n), a === void 0 && (a = r);
  var l = [], c = !1, u = t.filter(function(f) {
    return !f.virtual;
  }), d = u.map(function(f) {
    var h = f.horizontal, p = f.vertical, g = f.pos;
    if (p && !c && (c = !0, l.push("/")), c) {
      var m = Math.max(0, p === 1 ? g[1] - s : a - g[1]);
      return l.push(bi(m, r, e)), m;
    } else {
      var m = Math.max(0, h === 1 ? g[0] - i : o - g[0]);
      return l.push(bi(m, n, e)), m;
    }
  });
  return {
    radiusPoses: u,
    styles: l,
    raws: d
  };
}
function CL(t) {
  for (var e = [0, 0], n = [0, 0], r = t.length, i = 0; i < r; ++i) {
    var s = t[i];
    s.sub && (s.horizontal && (e[1] === 0 && (e[0] = i), e[1] = i - e[0] + 1, n[0] = i + 1), s.vertical && (n[1] === 0 && (n[0] = i), n[1] = i - n[0] + 1));
  }
  return {
    horizontalRange: e,
    verticalRange: n
  };
}
function TL(t, e, n, r, i, s, o) {
  var a, l, c, u;
  s === void 0 && (s = [0, 0]), o === void 0 && (o = !1);
  var d = t.indexOf("/"), f = (d > -1 ? t.slice(0, d) : t).length, h = t.slice(0, f), p = t.slice(f + 1), g = h.length, m = p.length, v = m > 0, y = F(h, 4), E = y[0], b = E === void 0 ? "0px" : E, _ = y[1], w = _ === void 0 ? b : _, S = y[2], x = S === void 0 ? b : S, k = y[3], T = k === void 0 ? w : k, I = F(p, 4), R = I[0], N = R === void 0 ? b : R, $ = I[1], B = $ === void 0 ? v ? N : w : $, G = I[2], M = G === void 0 ? v ? N : x : G, A = I[3], z = A === void 0 ? v ? B : T : A, V = [b, w, x, T].map(function(Q) {
    return Ot(Q, e);
  }), U = [N, B, M, z].map(function(Q) {
    return Ot(Q, n);
  }), Y = V.slice(), ne = U.slice();
  a = F(Vh([Y[0], Y[1]], e), 2), Y[0] = a[0], Y[1] = a[1], l = F(Vh([Y[3], Y[2]], e), 2), Y[3] = l[0], Y[2] = l[1], c = F(Vh([ne[0], ne[3]], n), 2), ne[0] = c[0], ne[3] = c[1], u = F(Vh([ne[1], ne[2]], n), 2), ne[1] = u[0], ne[2] = u[1];
  var ie = o ? Y : Y.slice(0, Math.max(s[0], g)), Z = o ? ne : ne.slice(0, Math.max(s[1], m));
  return he(he([], F(ie.map(function(Q, fe) {
    var ge = rO[fe];
    return {
      virtual: fe >= g,
      horizontal: aa[fe],
      vertical: 0,
      pos: [r + Q, i + (la[fe] === -1 ? n : 0)],
      sub: !0,
      raw: V[fe],
      direction: ge
    };
  })), !1), F(Z.map(function(Q, fe) {
    var ge = rO[fe];
    return {
      virtual: fe >= m,
      horizontal: 0,
      vertical: la[fe],
      pos: [r + (aa[fe] === -1 ? e : 0), i + Q],
      sub: !0,
      raw: U[fe],
      direction: ge
    };
  })), !1);
}
function cte(t, e, n, r, i) {
  i === void 0 && (i = e.length);
  var s = CL(t.slice(r)), o = s.horizontalRange, a = s.verticalRange, l = n - r, c = 0;
  if (l === 0)
    c = i;
  else if (l > 0 && l < o[1])
    c = o[1] - l;
  else if (l >= a[0])
    c = a[0] + a[1] - l;
  else
    return;
  t.splice(n, c), e.splice(n, c);
}
function ute(t, e, n, r, i, s, o, a, l, c, u) {
  c === void 0 && (c = 0), u === void 0 && (u = 0);
  var d = CL(t.slice(n)), f = d.horizontalRange, h = d.verticalRange;
  if (r > -1)
    for (var p = aa[r] === 1 ? s - c : a - s, g = f[1]; g <= r; ++g) {
      var m = la[g] === 1 ? u : l, v = 0;
      if (r === g ? v = s : g === 0 ? v = c + p : aa[g] === -1 && (v = a - (e[n][0] - c)), t.splice(n + g, 0, {
        horizontal: aa[g],
        vertical: 0,
        pos: [v, m]
      }), e.splice(n + g, 0, [v, m]), g === 0)
        break;
    }
  else if (i > -1) {
    var y = la[i] === 1 ? o - u : l - o;
    if (f[1] === 0 && h[1] === 0) {
      var E = [
        c + y,
        u
      ];
      t.push({
        horizontal: aa[0],
        vertical: 0,
        pos: E
      }), e.push(E);
    }
    for (var b = h[0], g = h[1]; g <= i; ++g) {
      var v = aa[g] === 1 ? c : a, m = 0;
      if (i === g ? m = o : g === 0 ? m = u + y : la[g] === 1 ? m = e[n + b][1] : la[g] === -1 && (m = l - (e[n + b][1] - u)), t.push({
        horizontal: 0,
        vertical: la[g],
        pos: [v, m]
      }), e.push([v, m]), g === 0)
        break;
    }
  }
}
function dte(t, e) {
  e === void 0 && (e = t.map(function(i) {
    return i.raw;
  }));
  var n = t.map(function(i, s) {
    return i.horizontal ? e[s] : null;
  }).filter(function(i) {
    return i != null;
  }), r = t.map(function(i, s) {
    return i.vertical ? e[s] : null;
  }).filter(function(i) {
    return i != null;
  });
  return {
    horizontals: n,
    verticals: r
  };
}
var fte = [
  [0, -1, "n"],
  [1, 0, "e"]
], hte = [
  [-1, -1, "nw"],
  [0, -1, "n"],
  [1, -1, "ne"],
  [1, 0, "e"],
  [1, 1, "se"],
  [0, 1, "s"],
  [-1, 1, "sw"],
  [-1, 0, "w"]
];
function jE(t, e, n) {
  var r = t.props.clipRelative, i = t.state, s = i.width, o = i.height, a = e, l = a.type, c = a.poses, u = l === "rect", d = l === "circle";
  if (l === "polygon")
    return n.map(function(w) {
      return "".concat(bi(w[0], s, r), " ").concat(bi(w[1], o, r));
    });
  if (u || l === "inset") {
    var f = n[1][1], h = n[3][0], p = n[7][0], g = n[5][1];
    if (u)
      return [
        f,
        h,
        g,
        p
      ].map(function(w) {
        return "".concat(w, "px");
      });
    var m = [f, s - h, o - g, p].map(function(w, S) {
      return bi(w, S % 2 ? s : o, r);
    });
    if (n.length > 8) {
      var v = F(Ke(n[4], n[0]), 2), y = v[0], E = v[1];
      m.push.apply(m, he(["round"], F(GE(c.slice(8).map(function(w, S) {
        return L(L({}, w), { pos: n[S] });
      }), r, y, E, p, f, h, g).styles), !1));
    }
    return m;
  } else if (d || l === "ellipse") {
    var b = n[0], _ = bi(oe(n[1][1] - b[1]), d ? Math.sqrt((s * s + o * o) / 2) : o, r), m = d ? [_] : [bi(oe(n[2][0] - b[0]), s, r), _];
    return m.push("at", bi(b[0], s, r), bi(b[1], o, r)), m;
  }
}
function Gg(t, e, n, r) {
  var i = [r, (r + e) / 2, e], s = [t, (t + n) / 2, n];
  return hte.map(function(o) {
    var a = F(o, 3), l = a[0], c = a[1], u = a[2], d = i[l + 1], f = s[c + 1];
    return {
      vertical: oe(c),
      horizontal: oe(l),
      direction: u,
      pos: [d, f]
    };
  });
}
function OL(t) {
  var e = [1 / 0, -1 / 0], n = [1 / 0, -1 / 0];
  return t.forEach(function(r) {
    var i = r.pos;
    e[0] = Math.min(e[0], i[0]), e[1] = Math.max(e[1], i[0]), n[0] = Math.min(n[0], i[1]), n[1] = Math.max(n[1], i[1]);
  }), [
    oe(e[1] - e[0]),
    oe(n[1] - n[0])
  ];
}
function iO(t, e, n, r, i) {
  var s, o, a, l, c, u, d, f, h;
  if (t) {
    var p = i;
    if (!p) {
      var g = yr(t), m = g("clipPath");
      p = m !== "none" ? m : g("clip");
    }
    if (!((!p || p === "none" || p === "auto") && (p = r, !p))) {
      var v = W2(p), y = v.prefix, E = y === void 0 ? p : y, b = v.value, _ = b === void 0 ? "" : b, w = E === "circle", S = " ";
      if (E === "polygon") {
        var x = ga(_ || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
        S = ",";
        var k = x.map(function(ee) {
          var ce = F(ee.split(" "), 2), Pe = ce[0], ye = ce[1];
          return {
            vertical: 1,
            horizontal: 1,
            pos: [
              Ot(Pe, e),
              Ot(ye, n)
            ]
          };
        }), T = tl(k.map(function(ee) {
          return ee.pos;
        }));
        return {
          type: E,
          clipText: p,
          poses: k,
          splitter: S,
          left: T.minX,
          right: T.maxX,
          top: T.minY,
          bottom: T.maxY
        };
      } else if (w || E === "ellipse") {
        var I = "", R = "", N = 0, $ = 0, x = Do(_);
        if (w) {
          var B = "";
          s = F(x, 4), o = s[0], B = o === void 0 ? "50%" : o, a = s[2], I = a === void 0 ? "50%" : a, l = s[3], R = l === void 0 ? "50%" : l, N = Ot(B, Math.sqrt((e * e + n * n) / 2)), $ = N;
        } else {
          var G = "", M = "";
          c = F(x, 5), u = c[0], G = u === void 0 ? "50%" : u, d = c[1], M = d === void 0 ? "50%" : d, f = c[3], I = f === void 0 ? "50%" : f, h = c[4], R = h === void 0 ? "50%" : h, N = Ot(G, e), $ = Ot(M, n);
        }
        var A = [
          Ot(I, e),
          Ot(R, n)
        ], k = he([
          {
            vertical: 1,
            horizontal: 1,
            pos: A,
            direction: "nesw"
          }
        ], F(fte.slice(0, w ? 1 : 2).map(function(Pe) {
          return {
            vertical: oe(Pe[1]),
            horizontal: Pe[0],
            direction: Pe[2],
            sub: !0,
            pos: [
              A[0] + Pe[0] * N,
              A[1] + Pe[1] * $
            ]
          };
        })), !1);
        return {
          type: E,
          clipText: p,
          radiusX: N,
          radiusY: $,
          left: A[0] - N,
          top: A[1] - $,
          right: A[0] + N,
          bottom: A[1] + $,
          poses: k,
          splitter: S
        };
      } else if (E === "inset") {
        var x = Do(_ || "0 0 0 0"), z = x.indexOf("round"), V = (z > -1 ? x.slice(0, z) : x).length, U = x.slice(V + 1), Y = F(x.slice(0, V), 4), ne = Y[0], ie = Y[1], Z = ie === void 0 ? ne : ie, Q = Y[2], fe = Q === void 0 ? ne : Q, ge = Y[3], Re = ge === void 0 ? Z : ge, Be = F([ne, fe].map(function(Pe) {
          return Ot(Pe, n);
        }), 2), le = Be[0], Ee = Be[1], Se = F([Re, Z].map(function(Pe) {
          return Ot(Pe, e);
        }), 2), xe = Se[0], Ce = Se[1], _e = e - Ce, Je = n - Ee, P = TL(U, _e - xe, Je - le, xe, le), k = he(he([], F(Gg(le, _e, Je, xe)), !1), F(P), !1);
        return {
          type: "inset",
          clipText: p,
          poses: k,
          top: le,
          left: xe,
          right: _e,
          bottom: Je,
          radius: U,
          splitter: S
        };
      } else if (E === "rect") {
        var x = ga(_ || "0px, ".concat(e, "px, ").concat(n, "px, 0px"));
        S = ",";
        var O = F(x.map(function(re) {
          var H = Vf(re).value;
          return H;
        }), 4), q = O[0], Ce = O[1], Ee = O[2], xe = O[3], k = Gg(q, Ce, Ee, xe);
        return {
          type: "rect",
          clipText: p,
          poses: k,
          top: q,
          right: Ce,
          bottom: Ee,
          left: xe,
          values: x,
          splitter: S
        };
      }
    }
  }
}
function pte(t, e, n, r, i) {
  var s = t[e], o = s.direction, a = s.sub, l = t.map(function() {
    return [0, 0];
  }), c = o ? o.split("") : [];
  if (r && e < 8) {
    var u = c.filter(function(N) {
      return N === "w" || N === "e";
    }), d = c.filter(function(N) {
      return N === "n" || N === "s";
    }), f = u[0], h = d[0];
    l[e] = n;
    var p = F(OL(t), 2), g = p[0], m = p[1], v = g && m ? g / m : 0;
    if (v && i) {
      var y = (e + 4) % 8, E = t[y].pos, b = [0, 0];
      o.indexOf("w") > -1 ? b[0] = -1 : o.indexOf("e") > -1 && (b[0] = 1), o.indexOf("n") > -1 ? b[1] = -1 : o.indexOf("s") > -1 && (b[1] = 1);
      var _ = yL([g, m], n, v, b, !0), w = g + _[0], S = m + _[1], x = E[1], k = E[1], T = E[0], I = E[0];
      b[0] === -1 ? T = I - w : b[0] === 1 ? I = T + w : (T = T - w / 2, I = I + w / 2), b[1] === -1 ? x = k - S : (b[1] === 1 || (x = k - S / 2), k = x + S);
      var R = Gg(x, I, k, T);
      t.forEach(function(N, $) {
        l[$][0] = R[$].pos[0] - N.pos[0], l[$][1] = R[$].pos[1] - N.pos[1];
      });
    } else
      t.forEach(function(N, $) {
        var B = N.direction;
        B && (B.indexOf(f) > -1 && (l[$][0] = n[0]), B.indexOf(h) > -1 && (l[$][1] = n[1]));
      }), f && (l[1][0] = n[0] / 2, l[5][0] = n[0] / 2), h && (l[3][1] = n[1] / 2, l[7][1] = n[1] / 2);
  } else
    o && !a ? c.forEach(function(N) {
      var $ = N === "n" || N === "s";
      t.forEach(function(B, G) {
        var M = B.direction, A = B.horizontal, z = B.vertical;
        !M || M.indexOf(N) === -1 || (l[G] = [
          $ || !A ? 0 : n[0],
          !$ || !z ? 0 : n[1]
        ]);
      });
    }) : l[e] = n;
  return l;
}
function gte(t, e) {
  var n = F(NP(t, e), 2), r = n[0], i = n[1], s = e.datas, o = s.clipPath, a = s.clipIndex, l = o, c = l.type, u = l.poses, d = l.splitter, f = u.map(function(y) {
    return y.pos;
  });
  if (c === "polygon")
    f.splice(a, 0, [r, i]);
  else if (c === "inset") {
    var h = ate.indexOf(a), p = lte.indexOf(a), g = u.length;
    if (ute(u, f, 8, h, p, r, i, f[4][0], f[4][1], f[0][0], f[0][1]), g === u.length)
      return;
  } else
    return;
  var m = jE(t, o, f), v = "".concat(c, "(").concat(m.join(d), ")");
  Ne(t, "onClip", st(t, e, L({ clipEventType: "added", clipType: c, poses: f, clipStyles: m, clipStyle: v, distX: 0, distY: 0 }, Jn({
    clipPath: v
  }, e))));
}
function mte(t, e) {
  var n = e.datas, r = n.clipPath, i = n.clipIndex, s = r, o = s.type, a = s.poses, l = s.splitter, c = a.map(function(h) {
    return h.pos;
  }), u = c.length;
  if (o === "polygon")
    a.splice(i, 1), c.splice(i, 1);
  else if (o === "inset") {
    if (i < 8 || (cte(a, c, i, 8, u), u === a.length))
      return;
  } else
    return;
  var d = jE(t, r, c), f = "".concat(o, "(").concat(d.join(l), ")");
  Ne(t, "onClip", st(t, e, L({ clipEventType: "removed", clipType: o, poses: c, clipStyles: d, clipStyle: f, distX: 0, distY: 0 }, Jn({
    clipPath: f
  }, e))));
}
var vte = {
  name: "clippable",
  props: [
    "clippable",
    "defaultClipPath",
    "customClipPath",
    "keepRatio",
    "clipRelative",
    "clipArea",
    "dragWithClip",
    "clipTargetBounds",
    "clipVerticalGuidelines",
    "clipHorizontalGuidelines",
    "clipSnapThreshold"
  ],
  events: [
    "clipStart",
    "clip",
    "clipEnd"
  ],
  css: [
    `.control.clip-control {
background: #6d6;
cursor: pointer;
}
.control.clip-control.clip-radius {
background: #d66;
}
.line.clip-line {
background: #6e6;
cursor: move;
z-index: 1;
}
.clip-area {
position: absolute;
top: 0;
left: 0;
}
.clip-ellipse {
position: absolute;
cursor: move;
border: 1px solid #6d6;
border: var(--zoompx) solid #6d6;
border-radius: 50%;
transform-origin: 0px 0px;
}`,
    `:host {
--bounds-color: #d66;
}`,
    `.guideline {
pointer-events: none;
z-index: 2;
}`,
    `.line.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}`
  ],
  render: function(t, e) {
    var n = t.props, r = n.customClipPath, i = n.defaultClipPath, s = n.clipArea, o = n.zoom, a = n.groupable, l = t.getState(), c = l.target, u = l.width, d = l.height, f = l.allMatrix, h = l.is3d, p = l.left, g = l.top, m = l.pos1, v = l.pos2, y = l.pos3, E = l.pos4, b = l.clipPathState, _ = l.snapBoundInfos, w = l.rotation;
    if (!c || a)
      return [];
    var S = iO(c, u, d, i || "inset", b || r);
    if (!S)
      return [];
    var x = h ? 4 : 3, k = S.type, T = S.poses, I = T.map(function(Ce) {
      var _e = qt(f, Ce.pos, x);
      return [
        _e[0] - p,
        _e[1] - g
      ];
    }), R = [], N = [], $ = k === "rect", B = k === "inset", G = k === "polygon";
    if ($ || B || G) {
      var M = B ? I.slice(0, 8) : I;
      N = M.map(function(Ce, _e) {
        var Je = _e === 0 ? M[M.length - 1] : M[_e - 1], P = Qt(Je, Ce), O = cL(Je, Ce);
        return e.createElement("div", { key: "clipLine".concat(_e), className: qe("line", "clip-line", "snap-control"), "data-clip-index": _e, style: {
          width: "".concat(O, "px"),
          transform: "translate(".concat(Je[0], "px, ").concat(Je[1], "px) rotate(").concat(P, "rad) scaleY(").concat(o, ")")
        } });
      });
    }
    if (R = I.map(function(Ce, _e) {
      return e.createElement("div", { key: "clipControl".concat(_e), className: qe("control", "clip-control", "snap-control"), "data-clip-index": _e, style: {
        transform: "translate(".concat(Ce[0], "px, ").concat(Ce[1], "px) rotate(").concat(w, "rad) scale(").concat(o, ")")
      } });
    }), B && R.push.apply(R, he([], F(I.slice(8).map(function(Ce, _e) {
      return e.createElement("div", { key: "clipRadiusControl".concat(_e), className: qe("control", "clip-control", "clip-radius", "snap-control"), "data-clip-index": 8 + _e, style: {
        transform: "translate(".concat(Ce[0], "px, ").concat(Ce[1], "px) rotate(").concat(w, "rad) scale(").concat(o, ")")
      } });
    })), !1)), k === "circle" || k === "ellipse") {
      var A = S.left, z = S.top, V = S.radiusX, U = S.radiusY, Y = F(Ke(qt(f, [A, z], x), qt(f, [0, 0], x)), 2), ne = Y[0], ie = Y[1], Z = "none";
      if (!s) {
        for (var Q = Math.max(10, V / 5, U / 5), fe = [], ge = 0; ge <= Q; ++ge) {
          var Re = Math.PI * 2 / Q * ge;
          fe.push([
            V + (V - o) * Math.cos(Re),
            U + (U - o) * Math.sin(Re)
          ]);
        }
        fe.push([V, -2]), fe.push([-2, -2]), fe.push([-2, U * 2 + 2]), fe.push([V * 2 + 2, U * 2 + 2]), fe.push([V * 2 + 2, -2]), fe.push([V, -2]), Z = "polygon(".concat(fe.map(function(Ce) {
          return "".concat(Ce[0], "px ").concat(Ce[1], "px");
        }).join(", "), ")");
      }
      R.push(e.createElement("div", { key: "clipEllipse", className: qe("clip-ellipse", "snap-control"), style: {
        width: "".concat(V * 2, "px"),
        height: "".concat(U * 2, "px"),
        clipPath: Z,
        transform: "translate(".concat(-p + ne, "px, ").concat(-g + ie, "px) ").concat(l0(f))
      } }));
    }
    if (s) {
      var Be = ni(he([m, v, y, E], F(I), !1)), le = Be.width, Ee = Be.height, Se = Be.left, xe = Be.top;
      if (G || $ || B) {
        var fe = B ? I.slice(0, 8) : I;
        R.push(e.createElement("div", { key: "clipArea", className: qe("clip-area", "snap-control"), style: {
          width: "".concat(le, "px"),
          height: "".concat(Ee, "px"),
          transform: "translate(".concat(Se, "px, ").concat(xe, "px)"),
          clipPath: "polygon(".concat(fe.map(function(_e) {
            return "".concat(_e[0] - Se, "px ").concat(_e[1] - xe, "px");
          }).join(", "), ")")
        } }));
      }
    }
    return _ && ["vertical", "horizontal"].forEach(function(Ce) {
      var _e = _[Ce], Je = Ce === "horizontal";
      _e.isSnap && N.push.apply(N, he([], F(_e.snap.posInfos.map(function(P, O) {
        var q = P.pos, ee = Ke(qt(f, Je ? [0, q] : [q, 0], x), [p, g]), ce = Ke(qt(f, Je ? [u, q] : [q, d], x), [p, g]);
        return ef(e, "", ee, ce, o, "clip".concat(Ce, "snap").concat(O), "guideline");
      })), !1)), _e.isBound && N.push.apply(N, he([], F(_e.bounds.map(function(P, O) {
        var q = P.pos, ee = Ke(qt(f, Je ? [0, q] : [q, 0], x), [p, g]), ce = Ke(qt(f, Je ? [u, q] : [q, d], x), [p, g]);
        return ef(e, "", ee, ce, o, "clip".concat(Ce, "bounds").concat(O), "guideline", "bounds", "bold");
      })), !1));
    }), he(he([], F(R), !1), F(N), !1);
  },
  dragControlCondition: function(t, e) {
    return e.inputEvent && (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(t, e) {
    var n = t.props, r = n.dragWithClip, i = r === void 0 ? !0 : r;
    return i ? !1 : this.dragControlStart(t, e);
  },
  drag: function(t, e) {
    return this.dragControl(t, L(L({}, e), { isDragTarget: !0 }));
  },
  dragEnd: function(t, e) {
    return this.dragControlEnd(t, e);
  },
  dragControlStart: function(t, e) {
    var n = t.state, r = t.props, i = r.defaultClipPath, s = r.customClipPath, o = n.target, a = n.width, l = n.height, c = e.inputEvent ? e.inputEvent.target : null, u = c && c.getAttribute("class") || "", d = e.datas, f = iO(o, a, l, i || "inset", s);
    if (!f)
      return !1;
    var h = f.clipText, p = f.type, g = f.poses, m = Ne(t, "onClipStart", st(t, e, {
      clipType: p,
      clipStyle: h,
      poses: g.map(function(v) {
        return v.pos;
      })
    }));
    return m === !1 ? (d.isClipStart = !1, !1) : (d.isControl = u && u.indexOf("clip-control") > -1, d.isLine = u.indexOf("clip-line") > -1, d.isArea = u.indexOf("clip-area") > -1 || u.indexOf("clip-ellipse") > -1, d.clipIndex = c ? parseInt(c.getAttribute("data-clip-index"), 10) : -1, d.clipPath = f, d.isClipStart = !0, n.clipPathState = h, pl(t, e), !0);
  },
  dragControl: function(t, e) {
    var n, r, i, s = e.datas, o = e.originalDatas, a = e.isDragTarget;
    if (!s.isClipStart)
      return !1;
    var l = s, c = l.isControl, u = l.isLine, d = l.isArea, f = l.clipIndex, h = l.clipPath;
    if (!h)
      return !1;
    var p = nl(t.props, "clippable"), g = p.keepRatio, m = 0, v = 0, y = o.draggable, E = ms(e);
    a && y ? (n = F(y.prevBeforeDist, 2), m = n[0], v = n[1]) : (r = F(E, 2), m = r[0], v = r[1]);
    var b = [m, v], _ = t.state, w = _.width, S = _.height, x = !d && !c && !u, k = h.type, T = h.poses, I = h.splitter, R = T.map(function(Ye) {
      return Ye.pos;
    });
    x && (m = -m, v = -v);
    var N = !c || T[f].direction === "nesw", $ = k === "inset" || k === "rect", B = T.map(function() {
      return [0, 0];
    });
    if (c && !N) {
      var G = T[f], M = G.horizontal, A = G.vertical, z = [
        m * oe(M),
        v * oe(A)
      ];
      B = pte(T, f, z, $, g);
    } else
      N && (B = R.map(function() {
        return [m, v];
      }));
    var V = R.map(function(Ye, xt) {
      return wt(Ye, B[xt]);
    }), U = he([], F(V), !1);
    _.snapBoundInfos = null;
    var Y = h.type === "circle", ne = h.type === "ellipse";
    if (Y || ne) {
      var ie = ni(V), Z = oe(ie.bottom - ie.top), Q = oe(ne ? ie.right - ie.left : Z), fe = V[0][1] + Z, ge = V[0][0] - Q, Re = V[0][0] + Q;
      Y && (U.push([Re, ie.bottom]), B.push([1, 0])), U.push([ie.left, fe]), B.push([0, 1]), U.push([ge, ie.bottom]), B.push([1, 0]);
    }
    var Be = rL((p.clipHorizontalGuidelines || []).map(function(Ye) {
      return Ot("".concat(Ye), S);
    }), (p.clipVerticalGuidelines || []).map(function(Ye) {
      return Ot("".concat(Ye), w);
    }), w, S), le = [], Ee = [];
    if (Y || ne)
      le = [U[4][0], U[2][0]], Ee = [U[1][1], U[3][1]];
    else if ($) {
      var Se = [U[0], U[2], U[4], U[6]], xe = [B[0], B[2], B[4], B[6]];
      le = Se.filter(function(Ye, xt) {
        return xe[xt][0];
      }).map(function(Ye) {
        return Ye[0];
      }), Ee = Se.filter(function(Ye, xt) {
        return xe[xt][1];
      }).map(function(Ye) {
        return Ye[1];
      });
    } else
      le = U.filter(function(Ye, xt) {
        return B[xt][0];
      }).map(function(Ye) {
        return Ye[0];
      }), Ee = U.filter(function(Ye, xt) {
        return B[xt][1];
      }).map(function(Ye) {
        return Ye[1];
      });
    var Ce = [0, 0], _e = UT(Be, p.clipTargetBounds && { left: 0, top: 0, right: w, bottom: S }, le, Ee, 5, 5), Je = _e.horizontal, P = _e.vertical, O = Je.offset, q = P.offset;
    if (Je.isBound && (Ce[1] += O), P.isBound && (Ce[0] += q), (ne || Y) && B[0][0] === 0 && B[0][1] === 0) {
      var ie = ni(V), ee = ie.bottom - ie.top, ce = ne ? ie.right - ie.left : ee, Pe = P.isBound ? oe(q) : P.snapIndex === 0 ? -q : q, ye = Je.isBound ? oe(O) : Je.snapIndex === 0 ? -O : O;
      ce -= Pe, ee -= ye, Y && (ee = YP(P, Je) > 0 ? ee : ce, ce = ee);
      var j = U[0];
      U[1][1] = j[1] - ee, U[2][0] = j[0] + ce, U[3][1] = j[1] + ee, U[4][0] = j[0] - ce;
    } else if ($ && g && c) {
      var re = F(OL(T), 2), H = re[0], K = re[1], de = H && K ? H / K : 0, Oe = T[f], Xe = Oe.direction || "", pt = U[1][1], fe = U[5][1], ge = U[7][0], Re = U[3][0];
      oe(O) <= oe(q) ? O = Kn(O) * oe(q) / de : q = Kn(q) * oe(O) * de, Xe.indexOf("w") > -1 ? ge -= q : Xe.indexOf("e") > -1 ? Re -= q : (ge += q / 2, Re -= q / 2), Xe.indexOf("n") > -1 ? pt -= O : Xe.indexOf("s") > -1 ? fe -= O : (pt += O / 2, fe -= O / 2);
      var hi = Gg(pt, Re, fe, ge);
      U.forEach(function(vn, bs) {
        var Er;
        Er = F(hi[bs].pos, 2), vn[0] = Er[0], vn[1] = Er[1];
      });
    } else
      U.forEach(function(Ye, xt) {
        var Js = B[xt];
        Js[0] && (Ye[0] -= q), Js[1] && (Ye[1] -= O);
      });
    var D = jE(t, h, V), te = "".concat(k, "(").concat(D.join(I), ")");
    if (_.clipPathState = te, Y || ne)
      le = [U[4][0], U[2][0]], Ee = [U[1][1], U[3][1]];
    else if ($) {
      var Se = [U[0], U[2], U[4], U[6]];
      le = Se.map(function(xt) {
        return xt[0];
      }), Ee = Se.map(function(xt) {
        return xt[1];
      });
    } else
      le = U.map(function(Ye) {
        return Ye[0];
      }), Ee = U.map(function(Ye) {
        return Ye[1];
      });
    if (_.snapBoundInfos = UT(Be, p.clipTargetBounds && { left: 0, top: 0, right: w, bottom: S }, le, Ee, 1, 1), y) {
      var ue = _.is3d, ze = _.allMatrix, Ae = ue ? 4 : 3, gt = Ce;
      a && (gt = [
        b[0] + Ce[0] - E[0],
        b[1] + Ce[1] - E[1]
      ]), y.deltaOffset = Mt(ze, [gt[0], gt[1], 0, 0], Ae);
    }
    return Ne(t, "onClip", st(t, e, L({ clipEventType: "changed", clipType: k, poses: V, clipStyle: te, clipStyles: D, distX: m, distY: v }, Jn((i = {}, i[k === "rect" ? "clip" : "clipPath"] = te, i), e)))), !0;
  },
  dragControlEnd: function(t, e) {
    this.unset(t);
    var n = e.isDrag, r = e.datas, i = e.isDouble, s = r.isLine, o = r.isClipStart, a = r.isControl;
    return o ? (Ne(t, "onClipEnd", zr(t, e, {})), i && (a ? mte(t, e) : s && gte(t, e)), i || n) : !1;
  },
  unset: function(t) {
    t.state.clipPathState = "", t.state.snapBoundInfos = null;
  }
}, bte = {
  name: "originDraggable",
  props: [
    "originDraggable",
    "originRelative"
  ],
  events: [
    "dragOriginStart",
    "dragOrigin",
    "dragOriginEnd"
  ],
  css: [
    `:host[data-able-origindraggable] .control.origin {
pointer-events: auto;
}`
  ],
  dragControlCondition: function(t, e) {
    return e.isRequest ? e.requestAble === "originDraggable" : fn(e.inputEvent.target, qe("origin"));
  },
  dragControlStart: function(t, e) {
    var n = e.datas;
    pl(t, e);
    var r = st(t, e, {
      dragStart: qn.dragStart(t, new zc().dragStart([0, 0], e))
    }), i = Ne(t, "onDragOriginStart", r);
    return n.startOrigin = t.state.transformOrigin, n.startTargetOrigin = t.state.targetOrigin, n.prevOrigin = [0, 0], n.isDragOrigin = !0, i === !1 ? (n.isDragOrigin = !1, !1) : r;
  },
  dragControl: function(t, e) {
    var n = e.datas, r = e.isPinch, i = e.isRequest;
    if (!n.isDragOrigin)
      return !1;
    var s = F(ms(e), 2), o = s[0], a = s[1], l = t.state, c = l.width, u = l.height, d = l.offsetMatrix, f = l.targetMatrix, h = l.is3d, p = t.props.originRelative, g = p === void 0 ? !0 : p, m = h ? 4 : 3, v = [o, a];
    if (i) {
      var y = e.distOrigin;
      (y[0] || y[1]) && (v = y);
    }
    var E = wt(n.startOrigin, v), b = wt(n.startTargetOrigin, v), _ = Ke(v, n.prevOrigin), w = Zf(d, f, E, m), S = t.getRect(), x = ni(gl(w, c, u, m)), k = [
      S.left - x.left,
      S.top - x.top
    ];
    n.prevOrigin = v;
    var T = [
      bi(b[0], c, g),
      bi(b[1], u, g)
    ].join(" "), I = qn.drag(t, Jf(e, t.state, k, !!r, !1)), R = st(t, e, L(L({ width: c, height: u, origin: E, dist: v, delta: _, transformOrigin: T, drag: I }, Jn({
      transformOrigin: T,
      transform: I.transform
    }, e)), { afterTransform: I.transform }));
    return Ne(t, "onDragOrigin", R), R;
  },
  dragControlEnd: function(t, e) {
    var n = e.datas;
    return n.isDragOrigin ? (Ne(t, "onDragOriginEnd", zr(t, e, {})), !0) : !1;
  },
  dragGroupControlCondition: function(t, e) {
    return this.dragControlCondition(t, e);
  },
  dragGroupControlStart: function(t, e) {
    var n = this.dragControlStart(t, e);
    return !!n;
  },
  dragGroupControl: function(t, e) {
    var n = this.dragControl(t, e);
    return n ? (t.transformOrigin = n.transformOrigin, !0) : !1;
  },
  /**
      * @method Moveable.OriginDraggable#request
      * @param {object} e - the OriginDraggable's request parameter
      * @param {number} [e.x] - x position
      * @param {number} [e.y] - y position
      * @param {number} [e.deltaX] - x number to move
      * @param {number} [e.deltaY] - y number to move
      * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
      * @param {array} [e.origin] - transform-origin position
      * @param {number} [e.isInstant] - Whether to execute the request instantly
      * @return {Moveable.Requester} Moveable Requester
      * @example
  
      * // Instantly Request (requestStart - request - requestEnd)
      * // Use Relative Value
      * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 }, true);
      * // Use Transform Value
      * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
      * moveable.request("originDraggable", { origin: [100, 0] }, true);
      * // requestStart
      * const requester = moveable.request("originDraggable");
      *
      * // request
      * // Use Relative Value
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 });
      * moveable.request("originDraggable", { x: 220, y: 100 });
      * moveable.request("originDraggable", { x: 240, y: 100 });
      *
      * // requestEnd
      * requester.requestEnd();
      */
  request: function(t) {
    var e = {}, n = t.getRect(), r = 0, i = 0, s = n.transformOrigin, o = [0, 0];
    return {
      isControl: !0,
      requestStart: function() {
        return { datas: e };
      },
      request: function(a) {
        return "deltaOrigin" in a ? (o[0] += a.deltaOrigin[0], o[1] += a.deltaOrigin[1]) : "origin" in a ? (o[0] = a.origin[0] - s[0], o[1] = a.origin[1] - s[1]) : ("x" in a ? r = a.x - n.left : "deltaX" in a && (r += a.deltaX), "y" in a ? i = a.y - n.top : "deltaY" in a && (i += a.deltaY)), { datas: e, distX: r, distY: i, distOrigin: o };
      },
      requestEnd: function() {
        return { datas: e, isDrag: !0 };
      }
    };
  }
};
function yte(t, e, n, r) {
  var i = t.filter(function(l) {
    var c = l.virtual, u = l.horizontal;
    return u && !c;
  }).length, s = t.filter(function(l) {
    var c = l.virtual, u = l.vertical;
    return u && !c;
  }).length, o = -1;
  if (e === 0 && (i === 0 ? o = 0 : i === 1 && (o = 1)), e === 2 && (i <= 2 ? o = 2 : i <= 3 && (o = 3)), e === 3 && (s === 0 ? o = 4 : s < 4 && (o = 7)), e === 1 && (s <= 1 ? o = 5 : s <= 2 && (o = 6)), !(o === -1 || !t[o].virtual)) {
    var a = t[o];
    wte(t, o), o < 4 ? a.pos[0] = n : a.pos[1] = r;
  }
}
function wte(t, e) {
  e < 4 ? t.slice(0, e + 1).forEach(function(n) {
    n.virtual = !1;
  }) : (t[0].virtual && (t[0].virtual = !1), t.slice(4, e + 1).forEach(function(n) {
    n.virtual = !1;
  }));
}
function _te(t, e) {
  e < 4 ? t.slice(e, 4).forEach(function(n) {
    n.virtual = !0;
  }) : t.slice(e).forEach(function(n) {
    n.virtual = !0;
  });
}
function sO(t, e, n, r, i) {
  r === void 0 && (r = [0, 0]);
  var s = [];
  return !t || t === "0px" ? s = [] : s = Do(t), TL(s, e, n, 0, 0, r, i);
}
function oO(t, e, n, r, i) {
  var s = t.state, o = s.width, a = s.height, l = GE(i, t.props.roundRelative, o, a), c = l.raws, u = l.styles, d = l.radiusPoses, f = dte(d, c), h = f.horizontals, p = f.verticals, g = u.join(" ");
  s.borderRadiusState = g;
  var m = st(t, e, L({ horizontals: h, verticals: p, borderRadius: g, width: o, height: a, delta: r, dist: n }, Jn({
    borderRadius: g
  }, e)));
  return Ne(t, "onRound", m), m;
}
function aO(t) {
  var e, n, r = t.getState().style, i = r.borderRadius || "";
  if (!i && t.props.groupable) {
    var s = t.moveables[0], o = t.getTargets()[0];
    o && ((s == null ? void 0 : s.props.target) === o ? (i = (n = (e = t.moveables[0]) === null || e === void 0 ? void 0 : e.state.style.borderRadius) !== null && n !== void 0 ? n : "", r.borderRadius = i) : (i = zE(o).borderRadius, r.borderRadius = i));
  }
  return i;
}
var Ete = {
  name: "roundable",
  props: [
    "roundable",
    "roundRelative",
    "minRoundControls",
    "maxRoundControls",
    "roundClickable",
    "roundPadding",
    "isDisplayShadowRoundControls"
  ],
  events: [
    "roundStart",
    "round",
    "roundEnd",
    "roundGroupStart",
    "roundGroup",
    "roundGroupEnd"
  ],
  css: [
    `.control.border-radius {
background: #d66;
cursor: pointer;
z-index: 3;
}`,
    `.control.border-radius.vertical {
background: #d6d;
z-index: 2;
}`,
    `.control.border-radius.virtual {
opacity: 0.5;
z-index: 1;
}`,
    `:host.round-line-clickable .line.direction {
cursor: pointer;
}`
  ],
  className: function(t) {
    var e = t.props.roundClickable;
    return e === !0 || e === "line" ? qe("round-line-clickable") : "";
  },
  requestStyle: function() {
    return ["borderRadius"];
  },
  requestChildStyle: function() {
    return ["borderRadius"];
  },
  render: function(t, e) {
    var n = t.getState(), r = n.target, i = n.width, s = n.height, o = n.allMatrix, a = n.is3d, l = n.left, c = n.top, u = n.borderRadiusState, d = t.props, f = d.minRoundControls, h = f === void 0 ? [0, 0] : f, p = d.maxRoundControls, g = p === void 0 ? [4, 4] : p, m = d.zoom, v = d.roundPadding, y = v === void 0 ? 0 : v, E = d.isDisplayShadowRoundControls, b = d.groupable;
    if (!r)
      return null;
    var _ = u || aO(t), w = a ? 4 : 3, S = sO(_, i, s, h, !0);
    if (!S)
      return null;
    var x = 0, k = 0, T = b ? [0, 0] : [l, c];
    return S.map(function(I, R) {
      var N = I.horizontal, $ = I.vertical, B = I.direction || "", G = he([], F(I.pos), !1);
      k += Math.abs(N), x += Math.abs($), N && B.indexOf("n") > -1 && (G[1] -= y), $ && B.indexOf("w") > -1 && (G[0] -= y), N && B.indexOf("s") > -1 && (G[1] += y), $ && B.indexOf("e") > -1 && (G[0] += y);
      var M = Ke(qt(o, G, w), T), A = E && E !== "horizontal", z = I.vertical ? x <= g[1] && (A || !I.virtual) : k <= g[0] && (E || !I.virtual);
      return e.createElement("div", { key: "borderRadiusControl".concat(R), className: qe("control", "border-radius", I.vertical ? "vertical" : "", I.virtual ? "virtual" : ""), "data-radius-index": R, style: {
        display: z ? "block" : "none",
        transform: "translate(".concat(M[0], "px, ").concat(M[1], "px) scale(").concat(m, ")")
      } });
    });
  },
  dragControlCondition: function(t, e) {
    if (!e.inputEvent || e.isRequest)
      return !1;
    var n = e.inputEvent.target.getAttribute("class") || "";
    return n.indexOf("border-radius") > -1 || n.indexOf("moveable-line") > -1 && n.indexOf("moveable-direction") > -1;
  },
  dragGroupControlCondition: function(t, e) {
    return this.dragControlCondition(t, e);
  },
  dragControlStart: function(t, e) {
    var n = e.inputEvent, r = e.datas, i = n.target, s = i.getAttribute("class") || "", o = s.indexOf("border-radius") > -1, a = s.indexOf("moveable-line") > -1 && s.indexOf("moveable-direction") > -1, l = o ? parseInt(i.getAttribute("data-radius-index"), 10) : -1, c = -1;
    if (a) {
      var u = i.getAttribute("data-line-key") || "";
      u && (c = parseInt(u.replace(/render-line-/g, ""), 10), isNaN(c) && (c = -1));
    }
    if (!o && !a)
      return !1;
    var d = st(t, e, {}), f = Ne(t, "onRoundStart", d);
    if (f === !1)
      return !1;
    r.lineIndex = c, r.controlIndex = l, r.isControl = o, r.isLine = a, pl(t, e);
    var h = t.props, p = h.roundRelative, g = h.minRoundControls, m = g === void 0 ? [0, 0] : g, v = t.state, y = v.width, E = v.height;
    r.isRound = !0, r.prevDist = [0, 0];
    var b = aO(t), _ = sO(b || "", y, E, m, !0) || [];
    return r.controlPoses = _, v.borderRadiusState = GE(_, p, y, E).styles.join(" "), d;
  },
  dragControl: function(t, e) {
    var n = e.datas, r = n.controlPoses;
    if (!n.isRound || !n.isControl || !r.length)
      return !1;
    var i = n.controlIndex, s = F(ms(e), 2), o = s[0], a = s[1], l = [o, a], c = Ke(l, n.prevDist), u = t.props.maxRoundControls, d = u === void 0 ? [4, 4] : u, f = t.state, h = f.width, p = f.height, g = r[i], m = g.vertical, v = g.horizontal, y = r.map(function(b) {
      var _ = b.horizontal, w = b.vertical, S = [
        _ * v * l[0],
        w * m * l[1]
      ];
      if (_) {
        if (d[0] === 1)
          return S;
        if (d[0] < 4 && _ !== v)
          return S;
      } else {
        if (d[1] === 0)
          return S[1] = w * v * l[0] / h * p, S;
        if (m) {
          if (d[1] === 1)
            return S;
          if (d[1] < 4 && w !== m)
            return S;
        }
      }
      return [0, 0];
    });
    y[i] = l;
    var E = r.map(function(b, _) {
      return L(L({}, b), { pos: wt(b.pos, y[_]) });
    });
    return i < 4 ? E.slice(0, i + 1).forEach(function(b) {
      b.virtual = !1;
    }) : E.slice(4, i + 1).forEach(function(b) {
      b.virtual = !1;
    }), n.prevDist = [o, a], oO(t, e, l, c, E);
  },
  dragControlEnd: function(t, e) {
    var n = t.state;
    n.borderRadiusState = "";
    var r = e.datas, i = e.isDouble;
    if (!r.isRound)
      return !1;
    var s = r.isControl, o = r.controlIndex, a = r.isLine, l = r.lineIndex, c = r.controlPoses, u = c.filter(function(v) {
      var y = v.virtual;
      return y;
    }).length, d = t.props.roundClickable, f = d === void 0 ? !0 : d;
    if (i && f) {
      if (s && (f === !0 || f === "control"))
        _te(c, o);
      else if (a && (f === !0 || f === "line")) {
        var h = F(NP(t, e), 2), p = h[0], g = h[1];
        yte(c, l, p, g);
      }
      u !== c.filter(function(v) {
        var y = v.virtual;
        return y;
      }).length && oO(t, e, [0, 0], [0, 0], c);
    }
    var m = zr(t, e, {});
    return Ne(t, "onRoundEnd", m), n.borderRadiusState = "", m;
  },
  dragGroupControlStart: function(t, e) {
    var n = this.dragControlStart(t, e);
    if (!n)
      return !1;
    var r = t.moveables, i = t.props.targets, s = Ci(t, "roundable", e), o = L({ targets: t.props.targets, events: s.map(function(a, l) {
      return L(L({}, a), { target: i[l], moveable: r[l], currentTarget: r[l] });
    }) }, n);
    return Ne(t, "onRoundGroupStart", o), n;
  },
  dragGroupControl: function(t, e) {
    var n = this.dragControl(t, e);
    if (!n)
      return !1;
    var r = t.moveables, i = t.props.targets, s = Ci(t, "roundable", e), o = L({ targets: t.props.targets, events: s.map(function(a, l) {
      return L(L(L({}, a), { target: i[l], moveable: r[l], currentTarget: r[l] }), Jn({
        borderRadius: n.borderRadius
      }, a));
    }) }, n);
    return Ne(t, "onRoundGroup", o), o;
  },
  dragGroupControlEnd: function(t, e) {
    var n = t.moveables, r = t.props.targets, i = Ci(t, "roundable", e);
    c0(t, "onRound", function(a) {
      var l = L({ targets: t.props.targets, events: i.map(function(c, u) {
        return L(L(L({}, c), { target: r[u], moveable: n[u], currentTarget: n[u] }), Jn({
          borderRadius: a.borderRadius
        }, c));
      }) }, a);
      Ne(t, "onRoundGroup", l);
    });
    var s = this.dragControlEnd(t, e);
    if (!s)
      return !1;
    var o = L({ targets: t.props.targets, events: i.map(function(a, l) {
      var c;
      return L(L({}, a), { target: r[l], moveable: n[l], currentTarget: n[l], lastEvent: (c = a.datas) === null || c === void 0 ? void 0 : c.lastEvent });
    }) }, s);
    return Ne(t, "onRoundGroupEnd", o), o;
  },
  unset: function(t) {
    t.state.borderRadiusState = "";
  }
};
function Ste(t, e) {
  var n = e ? 4 : 3, r = $t(n), i = "matrix".concat(e ? "3d" : "", "(").concat(r.join(","), ")");
  return t === i || t === "matrix(1,0,0,1,0,0)";
}
var ML = {
  isPinch: !0,
  name: "beforeRenderable",
  props: [],
  events: [
    "beforeRenderStart",
    "beforeRender",
    "beforeRenderEnd",
    "beforeRenderGroupStart",
    "beforeRenderGroup",
    "beforeRenderGroupEnd"
  ],
  dragRelation: "weak",
  setTransform: function(t, e) {
    var n = t.state, r = n.is3d, i = n.targetMatrix, s = n.inlineTransform, o = r ? "matrix3d(".concat(i.join(","), ")") : "matrix(".concat(bP(i, !0), ")"), a = !s || s === "none" ? o : s;
    e.datas.startTransforms = Ste(a, r) ? [] : Do(a);
  },
  resetStyle: function(t) {
    var e = t.datas;
    e.nextStyle = {}, e.nextTransforms = t.datas.startTransforms, e.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(t, e) {
    return st(t, e, {
      setTransform: function(n) {
        e.datas.startTransforms = rn(n) ? n : Do(n);
      },
      isPinch: !!e.isPinch
    });
  },
  fillDragParams: function(t, e) {
    return st(t, e, {
      isPinch: !!e.isPinch
    });
  },
  dragStart: function(t, e) {
    this.setTransform(t, e), this.resetStyle(e), Ne(t, "onBeforeRenderStart", this.fillDragStartParams(t, e));
  },
  drag: function(t, e) {
    e.datas.startTransforms || this.setTransform(t, e), this.resetStyle(e), Ne(t, "onBeforeRender", st(t, e, {
      isPinch: !!e.isPinch
    }));
  },
  dragEnd: function(t, e) {
    e.datas.startTransforms || (this.setTransform(t, e), this.resetStyle(e)), Ne(t, "onBeforeRenderEnd", st(t, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    }));
  },
  dragGroupStart: function(t, e) {
    var n = this;
    this.dragStart(t, e);
    var r = Ci(t, "beforeRenderable", e), i = t.moveables, s = r.map(function(o, a) {
      var l = i[a];
      return n.setTransform(l, o), n.resetStyle(o), n.fillDragStartParams(l, o);
    });
    Ne(t, "onBeforeRenderGroupStart", st(t, e, {
      isPinch: !!e.isPinch,
      targets: t.props.targets,
      setTransform: function() {
      },
      events: s
    }));
  },
  dragGroup: function(t, e) {
    var n = this;
    this.drag(t, e);
    var r = Ci(t, "beforeRenderable", e), i = t.moveables, s = r.map(function(o, a) {
      var l = i[a];
      return n.resetStyle(o), n.fillDragParams(l, o);
    });
    Ne(t, "onBeforeRenderGroup", st(t, e, {
      isPinch: !!e.isPinch,
      targets: t.props.targets,
      events: s
    }));
  },
  dragGroupEnd: function(t, e) {
    this.dragEnd(t, e), Ne(t, "onBeforeRenderGroupEnd", st(t, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: t.props.targets
    }));
  },
  dragControlStart: function(t, e) {
    return this.dragStart(t, e);
  },
  dragControl: function(t, e) {
    return this.drag(t, e);
  },
  dragControlEnd: function(t, e) {
    return this.dragEnd(t, e);
  },
  dragGroupControlStart: function(t, e) {
    return this.dragGroupStart(t, e);
  },
  dragGroupControl: function(t, e) {
    return this.dragGroup(t, e);
  },
  dragGroupControlEnd: function(t, e) {
    return this.dragGroupEnd(t, e);
  }
}, AL = {
  name: "renderable",
  props: [],
  events: [
    "renderStart",
    "render",
    "renderEnd",
    "renderGroupStart",
    "renderGroup",
    "renderGroupEnd"
  ],
  dragRelation: "weak",
  dragStart: function(t, e) {
    Ne(t, "onRenderStart", st(t, e, {
      isPinch: !!e.isPinch
    }));
  },
  drag: function(t, e) {
    Ne(t, "onRender", this.fillDragParams(t, e));
  },
  dragAfter: function(t, e) {
    return this.drag(t, e);
  },
  dragEnd: function(t, e) {
    Ne(t, "onRenderEnd", this.fillDragEndParams(t, e));
  },
  dragGroupStart: function(t, e) {
    Ne(t, "onRenderGroupStart", st(t, e, {
      isPinch: !!e.isPinch,
      targets: t.props.targets
    }));
  },
  dragGroup: function(t, e) {
    var n = this, r = Ci(t, "beforeRenderable", e), i = t.moveables, s = r.map(function(o, a) {
      var l = i[a];
      return n.fillDragParams(l, o);
    });
    Ne(t, "onRenderGroup", st(t, e, L(L({ isPinch: !!e.isPinch, targets: t.props.targets, transform: $h(e), transformObject: {} }, Jn(Bh(e))), { events: s })));
  },
  dragGroupEnd: function(t, e) {
    var n = this, r = Ci(t, "beforeRenderable", e), i = t.moveables, s = r.map(function(o, a) {
      var l = i[a];
      return n.fillDragEndParams(l, o);
    });
    Ne(t, "onRenderGroupEnd", st(t, e, L({ isPinch: !!e.isPinch, isDrag: e.isDrag, targets: t.props.targets, events: s, transformObject: {}, transform: $h(e) }, Jn(Bh(e)))));
  },
  dragControlStart: function(t, e) {
    return this.dragStart(t, e);
  },
  dragControl: function(t, e) {
    return this.drag(t, e);
  },
  dragControlAfter: function(t, e) {
    return this.dragAfter(t, e);
  },
  dragControlEnd: function(t, e) {
    return this.dragEnd(t, e);
  },
  dragGroupControlStart: function(t, e) {
    return this.dragGroupStart(t, e);
  },
  dragGroupControl: function(t, e) {
    return this.dragGroup(t, e);
  },
  dragGroupControlEnd: function(t, e) {
    return this.dragGroupEnd(t, e);
  },
  fillDragParams: function(t, e) {
    var n = {};
    return Fc(Bg(e) || []).forEach(function(r) {
      n[r.name] = r.functionValue;
    }), st(t, e, L({ isPinch: !!e.isPinch, transformObject: n, transform: $h(e) }, Jn(Bh(e))));
  },
  fillDragEndParams: function(t, e) {
    var n = {};
    return Fc(Bg(e) || []).forEach(function(r) {
      n[r.name] = r.functionValue;
    }), st(t, e, L({ isPinch: !!e.isPinch, isDrag: e.isDrag, transformObject: n, transform: $h(e) }, Jn(Bh(e))));
  }
};
function dd(t, e, n, r, i, s, o) {
  s.clientDistX = s.distX, s.clientDistY = s.distY;
  var a = i === "Start", l = i === "End", c = i === "After", u = t.state.target, d = s.isRequest, f = r.indexOf("Control") > -1;
  if (!u || a && f && !d && t.areaElement === s.inputEvent.target)
    return !1;
  var h = he([], F(e), !1);
  if (d) {
    var p = s.requestAble;
    h.some(function(R) {
      return R.name === p;
    }) || h.push.apply(h, he([], F(t.props.ables.filter(function(R) {
      return R.name === p;
    })), !1));
  }
  if (!h.length || h.every(function(R) {
    return R.dragRelation;
  }))
    return !1;
  var g = s.inputEvent, m;
  l && g && (m = document.elementFromPoint(s.clientX, s.clientY) || g.target);
  var v = !1, y = function() {
    var R;
    v = !0, (R = s.stop) === null || R === void 0 || R.call(s);
  }, E = a && (!t.targetGesto || !t.controlGesto || !t.targetGesto.isFlag() || !t.controlGesto.isFlag());
  E && t.updateRect(i, !0, !1);
  var b = s.datas, _ = f ? "controlGesto" : "targetGesto", w = t[_], S = function(R, N, $) {
    if (!(N in R) || w !== t[_])
      return !1;
    var B = R.name, G = b[B] || (b[B] = {});
    if (a && (G.isEventStart = !$ || !R[$] || R[$](t, s)), !G.isEventStart)
      return !1;
    var M = R[N](t, L(L({}, s), { stop: y, datas: G, originalDatas: b, inputTarget: m }));
    return t._emitter.off(), a && M === !1 && (G.isEventStart = !1), M;
  };
  E && h.forEach(function(R) {
    R.unset && R.unset(t);
  }), S(ML, "drag".concat(r).concat(i));
  var x = 0, k = 0;
  n.forEach(function(R) {
    if (v)
      return !1;
    var N = "".concat(R).concat(r).concat(i), $ = "".concat(R).concat(r, "Condition");
    i === "" && !d && bL(t.state, s);
    var B = h.filter(function(A) {
      return A[N];
    });
    B = B.filter(function(A, z) {
      return A.name && B.indexOf(A) === z;
    });
    var G = B.filter(function(A) {
      return S(A, N, $);
    }), M = G.length;
    v && ++x, M && ++k, !v && a && B.length && !M && (x += B.filter(function(A) {
      var z = A.name, V = b[z];
      return V.isEventStart ? A.dragRelation !== "strong" : !1;
    }).length ? 1 : 0);
  }), (!c || k) && S(AL, "drag".concat(r).concat(i));
  var T = w !== t[_] || x === n.length;
  if ((l || v || T) && (t.state.gestos = {}, t.moveables && t.moveables.forEach(function(R) {
    R.state.gestos = {};
  }), h.forEach(function(R) {
    R.unset && R.unset(t);
  })), a && !T && !d && k && t.props.preventDefault && (s == null || s.preventDefault()), t.isUnmounted || T)
    return !1;
  if (!a && k && !o || l) {
    var I = t.props.flushSync || oL;
    I(function() {
      t.updateRect(l ? i : "", !0, !1), t.forceUpdate();
    });
  }
  return !a && !l && !c && k && !o && dd(t, e, n, r, i + "After", s), !0;
}
function qE(t, e) {
  return function(n, r) {
    var i;
    r === void 0 && (r = n.inputEvent.target);
    var s = r, o = t.areaElement, a = t._dragTarget;
    return !a || !e && (!((i = t.controlGesto) === null || i === void 0) && i.isFlag()) ? !1 : s === a || a.contains(s) || s === o || !t.isMoveableElement(s) && !t.controlBox.contains(s) || fn(s, "moveable-area") || fn(s, "moveable-padding") || fn(s, "moveable-edgeDraggable");
  };
}
function NL(t, e, n) {
  var r = t.controlBox, i = [], s = t.props, o = s.dragArea, a = t.state.target, l = s.dragTarget;
  i.push(r), (!o || l) && i.push(e), !o && l && a && e !== a && s.dragTargetSelf && i.push(a);
  var c = qE(t);
  return DL(t, i, "targetAbles", n, {
    dragStart: c,
    pinchStart: c
  });
}
function RL(t, e) {
  var n = t.controlBox, r = [];
  r.push(n);
  var i = qE(t, !0), s = function(o, a) {
    if (a === void 0 && (a = o.inputEvent.target), a === n)
      return !0;
    var l = i(o, a);
    return !l;
  };
  return DL(t, r, "controlAbles", e, {
    dragStart: s,
    pinchStart: s
  });
}
function DL(t, e, n, r, i) {
  i === void 0 && (i = {});
  var s = n === "targetAbles", o = t.props, a = o.pinchOutside, l = o.pinchThreshold, c = o.preventClickEventOnDrag, u = o.preventClickDefault, d = o.checkInput, f = o.dragFocusedInput, h = o.preventDefault, p = h === void 0 ? !0 : h, g = o.preventRightClick, m = g === void 0 ? !0 : g, v = o.preventWheelClick, y = v === void 0 ? !0 : v, E = o.dragContainer, b = ts(E, !0), _ = {
    preventDefault: p,
    preventRightClick: m,
    preventWheelClick: y,
    container: b || Co(t.getControlBoxElement()),
    pinchThreshold: l,
    pinchOutside: a,
    preventClickEventOnDrag: s ? c : !1,
    preventClickEventOnDragStart: s ? u : !1,
    preventClickEventByCondition: s ? null : function(x) {
      return t.controlBox.contains(x.target);
    },
    checkInput: s ? d : !1,
    dragFocusedInput: f
  }, w = new JZ(e, _), S = r === "Control";
  return ["drag", "pinch"].forEach(function(x) {
    ["Start", "", "End"].forEach(function(k) {
      w.on("".concat(x).concat(k), function(T) {
        var I, R = T.eventType, N = x === "drag" && T.isPinch;
        if (i[R] && !i[R](T)) {
          T.stop();
          return;
        }
        if (!N) {
          var $ = x === "drag" ? [x] : ["drag", x], B = he([], F(t[n]), !1), G = dd(t, B, $, r, k, T);
          G ? (t.props.stopPropagation || k === "Start" && S) && ((I = T == null ? void 0 : T.inputEvent) === null || I === void 0 || I.stopPropagation()) : T.stop();
        }
      });
    });
  }), w;
}
var xte = /* @__PURE__ */ function() {
  function t(e, n, r) {
    var i = this;
    this.target = e, this.moveable = n, this.eventName = r, this.ables = [], this._onEvent = function(s) {
      var o = i.eventName, a = i.moveable;
      a.state.disableNativeEvent || i.ables.forEach(function(l) {
        l[o](a, {
          inputEvent: s
        });
      });
    }, e.addEventListener(r.toLowerCase(), this._onEvent);
  }
  return t.prototype.setAbles = function(e) {
    this.ables = e;
  }, t.prototype.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }, t;
}();
function kte(t, e, n, r) {
  var i;
  n === void 0 && (n = e);
  var s = $P(t, e), o = s.matrixes, a = s.is3d, l = s.targetMatrix, c = s.transformOrigin, u = s.targetOrigin, d = s.offsetContainer, f = s.hasFixed, h = s.zoom, p = zQ(d, n), g = p.matrixes, m = p.is3d, v = p.offsetContainer, y = p.zoom, E = r || m || a, b = E ? 4 : 3, _ = t.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in t, w = l, S = $t(b), x = $t(b), k = $t(b), T = $t(b), I = o.length, R = g.map(function(z) {
    return L(L({}, z), { matrix: z.matrix ? he([], F(z.matrix), !1) : void 0 });
  }).reverse();
  o.reverse(), !a && E && (w = Ri(w, 3, 4), P1(o)), !m && E && P1(R), R.forEach(function(z) {
    x = Mt(x, z.matrix, b);
  });
  var N = n || qo(t), $ = ((i = R[0]) === null || i === void 0 ? void 0 : i.target) || tf(N, N, !0).offsetParent, B = R.slice(1).reduce(function(z, V) {
    return Mt(z, V.matrix, b);
  }, $t(b));
  o.forEach(function(z, V) {
    if (I - 2 === V && (k = S.slice()), I - 1 === V && (T = S.slice()), !z.matrix) {
      var U = o[V + 1], Y = Vee(z, U, $, b, Mt(B, S, b));
      z.matrix = el(Y, b);
    }
    S = Mt(S, z.matrix, b);
  });
  var G = !_ && a;
  w || (w = $t(G ? 4 : 3));
  var M = l0(_ && w.length === 16 ? Ri(w, 4, 3) : w, G), A = x;
  return x = mP(x, b, b), {
    hasZoom: h !== 1 || y !== 1,
    hasFixed: f,
    matrixes: o,
    rootMatrix: x,
    originalRootMatrix: A,
    beforeMatrix: k,
    offsetMatrix: T,
    allMatrix: S,
    targetMatrix: w,
    targetTransform: M,
    inlineTransform: t.style.transform,
    transformOrigin: c,
    targetOrigin: u,
    is3d: E,
    offsetContainer: d,
    offsetRootContainer: v
  };
}
function Cte(t, e, n, r) {
  n === void 0 && (n = e);
  var i = 0, s = 0, o = 0, a = {}, l = uL(t);
  if (t && (i = l.offsetWidth, s = l.offsetHeight), t) {
    var c = kte(t, e, n, r), u = ac(c.allMatrix, c.transformOrigin, i, s);
    a = L(L({}, c), u);
    var d = ac(c.allMatrix, [50, 50], 100, 100);
    o = dL([d.pos1, d.pos2], d.direction);
  }
  var f = r ? 4 : 3;
  return L(L(L({ hasZoom: !1, width: i, height: s, rotation: o }, l), { originalRootMatrix: $t(f), rootMatrix: $t(f), beforeMatrix: $t(f), offsetMatrix: $t(f), allMatrix: $t(f), targetMatrix: $t(f), targetTransform: "", inlineTransform: "", transformOrigin: [0, 0], targetOrigin: [0, 0], is3d: !!r, left: 0, top: 0, right: 0, bottom: 0, origin: [0, 0], pos1: [0, 0], pos2: [0, 0], pos3: [0, 0], pos4: [0, 0], direction: 1, hasFixed: !1, offsetContainer: null, offsetRootContainer: null, matrixes: [] }), a);
}
function F1(t, e, n, r, i, s) {
  s === void 0 && (s = []);
  var o = 1, a = [0, 0], l = zh(), c = zh(), u = zh(), d = zh(), f = [0, 0], h = {}, p = Cte(e, n, i, !0);
  if (e) {
    var g = yr(e);
    s.forEach(function(R) {
      h[R] = g(R);
    });
    var m = p.is3d ? 4 : 3, v = ac(p.offsetMatrix, wt(p.transformOrigin, vP(p.targetMatrix, m)), p.width, p.height);
    o = v.direction, a = wt(v.origin, [v.left - p.left, v.top - p.top]), d = ud(p.offsetRootContainer);
    var y = tf(r, r, !0).offsetParent || p.offsetRootContainer;
    if (p.hasZoom) {
      var E = ac(Mt(p.originalRootMatrix, p.allMatrix), p.transformOrigin, p.width, p.height), b = ac(p.originalRootMatrix, Ug(yr(y)("transformOrigin")).map(function(R) {
        return parseFloat(R);
      }), y.offsetWidth, y.offsetHeight);
      if (l = Nb(E, d), u = Nb(b, d, y, !0), t) {
        var _ = E.left, w = E.top;
        c = Nb({
          left: _,
          top: w,
          bottom: w,
          right: w
        }, d);
      }
    } else {
      l = ud(e), u = FQ(y), t && (c = ud(t));
      var S = u.left, x = u.top, k = u.clientLeft, T = u.clientTop, I = [
        l.left - S,
        l.top - x
      ];
      f = Ke(Vc(p.rootMatrix, I, 4), [k + p.left, T + p.top]);
    }
  }
  return L({ targetClientRect: l, containerClientRect: u, moveableClientRect: c, rootContainerClientRect: d, beforeDirection: o, beforeOrigin: a, originalBeforeOrigin: a, target: e, style: h, offsetDelta: f }, p);
}
function lO(t) {
  var e = t.pos1, n = t.pos2, r = t.pos3, i = t.pos4;
  if (!e || !n || !r || !i)
    return null;
  var s = tl([e, n, r, i]), o = [s.minX, s.minY], a = Ke(t.origin, o);
  return e = Ke(e, o), n = Ke(n, o), r = Ke(r, o), i = Ke(i, o), L(L({}, t), {
    left: t.left,
    top: t.top,
    posDelta: o,
    pos1: e,
    pos2: n,
    pos3: r,
    pos4: i,
    origin: a,
    beforeOrigin: a,
    // originalBeforeOrigin: origin,
    isPersisted: !0
  });
}
var Wc = /* @__PURE__ */ function(t) {
  Yf(e, t);
  function e() {
    var n = t !== null && t.apply(this, arguments) || this;
    return n.state = L({ container: null, gestos: {}, renderLines: [
      [[0, 0], [0, 0]],
      [[0, 0], [0, 0]],
      [[0, 0], [0, 0]],
      [[0, 0], [0, 0]]
    ], renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]], disableNativeEvent: !1, posDelta: [0, 0] }, F1(null)), n.renderState = {}, n.enabledAbles = [], n.targetAbles = [], n.controlAbles = [], n.rotation = 0, n.scale = [1, 1], n.isMoveableMounted = !1, n.isUnmounted = !1, n.events = {
      mouseEnter: null,
      mouseLeave: null
    }, n._emitter = new e0(), n._prevOriginalDragTarget = null, n._originalDragTarget = null, n._prevDragTarget = null, n._dragTarget = null, n._prevPropTarget = null, n._propTarget = null, n._prevDragArea = !1, n._isPropTargetChanged = !1, n._hasFirstTarget = !1, n._reiszeObserver = null, n._observerId = 0, n._mutationObserver = null, n._rootContainer = null, n._viewContainer = null, n._viewClassNames = [], n._store = {}, n.checkUpdateRect = function() {
      if (!n.isDragging()) {
        var r = n.props.parentMoveable;
        if (r) {
          r.checkUpdateRect();
          return;
        }
        zJ(n._observerId), n._observerId = G2(function() {
          n.isDragging() || n.updateRect();
        });
      }
    }, n._onPreventClick = function(r) {
      r.stopPropagation(), r.preventDefault();
    }, n;
  }
  return e.prototype.render = function() {
    var n = this.props, r = this.getState(), i = n.parentPosition, s = n.className, o = n.target, a = n.zoom, l = n.cspNonce, c = n.translateZ, u = n.cssStyled, d = n.groupable, f = n.linePadding, h = n.controlPadding;
    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();
    var p = F(i || [0, 0], 2), g = p[0], m = p[1], v = r.left, y = r.top, E = r.target, b = r.direction, _ = r.hasFixed, w = r.offsetDelta, S = n.targets, x = this.isDragging(), k = {};
    this.getEnabledAbles().forEach(function(B) {
      k["data-able-".concat(B.name.toLowerCase())] = !0;
    });
    var T = this._getAbleClassName(), I = S && S.length && (E || d) || o || !this._hasFirstTarget && this.state.isPersisted, R = this.controlBox || this.props.firstRenderState || this.props.persistData, N = [v - g, y - m];
    !d && n.useAccuratePosition && (N[0] += w[0], N[1] += w[1]);
    var $ = {
      position: _ ? "fixed" : "absolute",
      display: I ? "block" : "none",
      visibility: R ? "visible" : "hidden",
      transform: "translate3d(".concat(N[0], "px, ").concat(N[1], "px, ").concat(c, ")"),
      "--zoom": a,
      "--zoompx": "".concat(a, "px")
    };
    return f && ($["--moveable-line-padding"] = f), h && ($["--moveable-control-padding"] = h), ki(
      u,
      L({ cspNonce: l, ref: $s(this, "controlBox"), className: "".concat(qe("control-box", b === -1 ? "reverse" : "", x ? "dragging" : ""), " ").concat(T, " ").concat(s) }, k, { onClick: this._onPreventClick, style: $ }),
      this.renderAbles(),
      this._renderLines()
    );
  }, e.prototype.componentDidMount = function() {
    this.isMoveableMounted = !0, this.isUnmounted = !1;
    var n = this.props, r = n.parentMoveable, i = n.container;
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !i && !r && !this.state.isPersisted && (this.updateRect("", !1, !1), this.forceUpdate());
  }, e.prototype.componentDidUpdate = function(n) {
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateTargets(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(n);
  }, e.prototype.componentWillUnmount = function() {
    var n, r;
    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (n = this._reiszeObserver) === null || n === void 0 || n.disconnect(), (r = this._mutationObserver) === null || r === void 0 || r.disconnect();
    var i = this._viewContainer;
    i && this._changeAbleViewClassNames([]), Ql(this, !1), Ql(this, !0);
    var s = this.events;
    for (var o in s) {
      var a = s[o];
      a && a.destroy();
    }
  }, e.prototype.getTargets = function() {
    var n = this.props.target;
    return n ? [n] : [];
  }, e.prototype.getAble = function(n) {
    var r = this.props.ables || [];
    return br(r, function(i) {
      return i.name === n;
    });
  }, e.prototype.getContainer = function() {
    var n = this.props, r = n.parentMoveable, i = n.wrapperMoveable, s = n.container;
    return s || i && i.getContainer() || r && r.getContainer() || this.controlBox.parentElement;
  }, e.prototype.getControlBoxElement = function() {
    return this.controlBox;
  }, e.prototype.getDragElement = function() {
    return this._dragTarget;
  }, e.prototype.isMoveableElement = function(n) {
    var r;
    return n && (((r = n.getAttribute) === null || r === void 0 ? void 0 : r.call(n, "class")) || "").indexOf(OE) > -1;
  }, e.prototype.dragStart = function(n, r) {
    r === void 0 && (r = n.target);
    var i = this.targetGesto, s = this.controlGesto;
    return i && qE(this)({ inputEvent: n }, r) ? i.isFlag() || i.triggerDragStart(n) : s && this.isMoveableElement(r) && (s.isFlag() || s.triggerDragStart(n)), this;
  }, e.prototype.hitTest = function(n) {
    var r = this.state, i = r.target, s = r.pos1, o = r.pos2, a = r.pos3, l = r.pos4, c = r.targetClientRect;
    if (!i)
      return 0;
    var u;
    if (nu(n)) {
      var d = n.getBoundingClientRect();
      u = {
        left: d.left,
        top: d.top,
        width: d.width,
        height: d.height
      };
    } else
      u = L({ width: 0, height: 0 }, n);
    var f = u.left, h = u.top, p = u.width, g = u.height, m = NT([s, o, l, a], c), v = GZ(m, [
      [f, h],
      [f + p, h],
      [f + p, h + g],
      [f, h + g]
    ]), y = _P(m);
    return !v || !y ? 0 : Math.min(100, v / y * 100);
  }, e.prototype.isInside = function(n, r) {
    var i = this.state, s = i.target, o = i.pos1, a = i.pos2, l = i.pos3, c = i.pos4, u = i.targetClientRect;
    return s ? E1([n, r], NT([o, a, c, l], u)) : !1;
  }, e.prototype.updateRect = function(n, r, i) {
    i === void 0 && (i = !0);
    var s = this.props, o = !s.parentPosition && !s.wrapperMoveable;
    o && Hc(!0);
    var a = s.parentMoveable, l = this.state, c = l.target || s.target, u = this.getContainer(), d = a ? a._rootContainer : this._rootContainer, f = F1(this.controlBox, c, u, u, d || u, this._getRequestStyles());
    if (!c && this._hasFirstTarget && s.persistData) {
      var h = lO(s.persistData);
      for (var p in h)
        f[p] = h[p];
    }
    o && Hc(), this.updateState(f, a ? !1 : i);
  }, e.prototype.isDragging = function(n) {
    var r, i, s = this.targetGesto, o = this.controlGesto;
    if (s != null && s.isFlag()) {
      if (!n)
        return !0;
      var a = s.getEventData();
      return !!(!((r = a[n]) === null || r === void 0) && r.isEventStart);
    }
    if (o != null && o.isFlag()) {
      if (!n)
        return !0;
      var a = o.getEventData();
      return !!(!((i = a[n]) === null || i === void 0) && i.isEventStart);
    }
    return !1;
  }, e.prototype.updateTarget = function(n) {
    this.updateRect(n, !0);
  }, e.prototype.getRect = function() {
    var n = this.state, r = ui(this.state), i = F(r, 4), s = i[0], o = i[1], a = i[2], l = i[3], c = ni(r), u = n.width, d = n.height, f = c.width, h = c.height, p = c.left, g = c.top, m = [n.left, n.top], v = wt(m, n.origin), y = wt(m, n.beforeOrigin), E = n.transformOrigin;
    return {
      width: f,
      height: h,
      left: p,
      top: g,
      pos1: s,
      pos2: o,
      pos3: a,
      pos4: l,
      offsetWidth: u,
      offsetHeight: d,
      beforeOrigin: y,
      origin: v,
      transformOrigin: E,
      rotation: this.getRotation()
    };
  }, e.prototype.getManager = function() {
    return this;
  }, e.prototype.stopDrag = function(n) {
    if (!n || n === "target") {
      var r = this.targetGesto;
      (r == null ? void 0 : r.isIdle()) === !1 && L1(this, !1), r == null || r.stop();
    }
    if (!n || n === "control") {
      var r = this.controlGesto;
      (r == null ? void 0 : r.isIdle()) === !1 && L1(this, !0), r == null || r.stop();
    }
  }, e.prototype.getRotation = function() {
    var n = this.state, r = n.pos1, i = n.pos2, s = n.direction;
    return Yee(r, i, s);
  }, e.prototype.request = function(n, r, i) {
    r === void 0 && (r = {});
    var s = this, o = s.props, a = o.parentMoveable || o.wrapperMoveable || s, l = a.props.ables, c = o.groupable, u = br(l, function(v) {
      return v.name === n;
    });
    if (this.isDragging() || !u || !u.request)
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    var d = u.request(s), f = i || r.isInstant, h = d.isControl ? "controlAbles" : "targetAbles", p = "".concat(c ? "Group" : "").concat(d.isControl ? "Control" : ""), g = he([], F(a[h]), !1), m = {
      request: function(v) {
        return dd(s, g, ["drag"], p, "", L(L({}, d.request(v)), { requestAble: n, isRequest: !0 }), f), m;
      },
      requestEnd: function() {
        return dd(s, g, ["drag"], p, "End", L(L({}, d.requestEnd()), { requestAble: n, isRequest: !0 }), f), m;
      }
    };
    return dd(s, g, ["drag"], p, "Start", L(L({}, d.requestStart(r)), { requestAble: n, isRequest: !0 }), f), f ? m.request(r).requestEnd() : m;
  }, e.prototype.getMoveables = function() {
    return [this];
  }, e.prototype.destroy = function() {
    this.componentWillUnmount();
  }, e.prototype.updateRenderPoses = function() {
    var n = this.getState(), r = this.props, i = r.padding, s = n.originalBeforeOrigin, o = n.transformOrigin, a = n.allMatrix, l = n.is3d, c = n.pos1, u = n.pos2, d = n.pos3, f = n.pos4, h = n.left, p = n.top, g = n.isPersisted, m = r.zoom || 1;
    if (!i && m <= 1) {
      n.renderPoses = [
        c,
        u,
        d,
        f
      ], n.renderLines = [
        [c, u],
        [u, f],
        [f, d],
        [d, c]
      ];
      return;
    }
    var v = EL(i || {}), y = v.left, E = v.top, b = v.bottom, _ = v.right, w = l ? 4 : 3, S = [];
    g ? S = o : this.controlBox && r.groupable ? S = s : S = wt(s, [h, p]);
    var x = Lg(w, el(S.map(function($) {
      return -$;
    }), w), a, el(o, w)), k = Vr(x, c, [-y, -E], w), T = Vr(x, u, [_, -E], w), I = Vr(x, d, [-y, b], w), R = Vr(x, f, [_, b], w);
    if (n.renderPoses = [
      k,
      T,
      I,
      R
    ], n.renderLines = [
      [k, T],
      [T, R],
      [R, I],
      [I, k]
    ], m) {
      var N = m / 2;
      n.renderLines = [
        [
          Vr(x, c, [-y - N, -E], w),
          Vr(x, u, [_ + N, -E], w)
        ],
        [
          Vr(x, u, [_, -E - N], w),
          Vr(x, f, [_, b + N], w)
        ],
        [
          Vr(x, f, [_ + N, b], w),
          Vr(x, d, [-y - N, b], w)
        ],
        [
          Vr(x, d, [-y, b + N], w),
          Vr(x, c, [-y, -E - N], w)
        ]
      ];
    }
  }, e.prototype.checkUpdate = function() {
    this._isPropTargetChanged = !1;
    var n = this.props, r = n.target, i = n.container, s = n.parentMoveable, o = this.state, a = o.target, l = o.container;
    if (!(!a && !r)) {
      this.updateAbles();
      var c = !$1(a, r), u = c || !$1(l, i);
      if (u) {
        var d = i || this.controlBox;
        d && this.unsetAbles(), this.updateState({ target: r, container: i }), !s && d && this.updateRect("End", !1, !1), this._isPropTargetChanged = c;
      }
    }
  }, e.prototype.waitToChangeTarget = function() {
    return new Promise(function() {
    });
  }, e.prototype.triggerEvent = function(n, r) {
    var i = this.props;
    if (this._emitter.trigger(n, r), i.parentMoveable && r.isRequest && !r.isRequestChild)
      return i.parentMoveable.triggerEvent(n, r, !0);
    var s = i[n];
    return s && s(r);
  }, e.prototype.useCSS = function(n, r) {
    var i = this.props.customStyledMap, s = n + r;
    return i[s] || (i[s] = xP(n, r)), i[s];
  }, e.prototype.getState = function() {
    var n, r = this.props;
    (r.target || !((n = r.targets) === null || n === void 0) && n.length) && (this._hasFirstTarget = !0);
    var i = this.controlBox, s = r.persistData, o = r.firstRenderState;
    if (o && !i)
      return o;
    if (!this._hasFirstTarget && s) {
      var a = lO(s);
      if (a)
        return this.updateState(a, !1), this.state;
    }
    return this.state.isPersisted = !1, this.state;
  }, e.prototype.updateSelectors = function() {
  }, e.prototype.unsetAbles = function() {
    var n = this;
    this.targetAbles.forEach(function(r) {
      r.unset && r.unset(n);
    });
  }, e.prototype.updateAbles = function(n, r) {
    n === void 0 && (n = this.props.ables), r === void 0 && (r = "");
    var i = this.props, s = i.triggerAblesSimultaneously, o = this.getEnabledAbles(n), a = "drag".concat(r, "Start"), l = "pinch".concat(r, "Start"), c = "drag".concat(r, "ControlStart"), u = Hh(o, [a, l], s), d = Hh(o, [c], s);
    this.enabledAbles = o, this.targetAbles = u, this.controlAbles = d;
  }, e.prototype.updateState = function(n, r) {
    if (r) {
      if (this.isUnmounted)
        return;
      this.setState(n);
    } else {
      var i = this.state;
      for (var s in n)
        i[s] = n[s];
    }
  }, e.prototype.getEnabledAbles = function(n) {
    n === void 0 && (n = this.props.ables);
    var r = this.props;
    return n.filter(function(i) {
      return i && (i.always && r[i.name] !== !1 || r[i.name]);
    });
  }, e.prototype.renderAbles = function() {
    var n = this, r = this.props, i = r.triggerAblesSimultaneously, s = {
      createElement: ki
    };
    return this.renderState = {}, jee(vL(Hh(this.getEnabledAbles(), ["render"], i).map(function(o) {
      var a = o.render;
      return a(n, s) || [];
    })).filter(function(o) {
      return o;
    }), function(o) {
      var a = o.key;
      return a;
    }).map(function(o) {
      return o[0];
    });
  }, e.prototype.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }, e.prototype._getRequestStyles = function() {
    var n = this.getEnabledAbles().reduce(function(r, i) {
      var s, o, a = (o = (s = i.requestStyle) === null || s === void 0 ? void 0 : s.call(i)) !== null && o !== void 0 ? o : [];
      return he(he([], F(r), !1), F(a), !1);
    }, he([], F(this.props.requestStyles || []), !1));
    return n;
  }, e.prototype._updateObserver = function(n) {
    this._updateResizeObserver(n), this._updateMutationObserver(n);
  }, e.prototype._updateEvents = function() {
    var n = this.targetAbles.length, r = this.controlAbles.length, i = this._dragTarget, s = !n && this.targetGesto || this._isTargetChanged(!0);
    s && (Ql(this, !1), this.updateState({ gestos: {} })), r || Ql(this, !0), i && n && !this.targetGesto && (this.targetGesto = NL(this, i, "")), !this.controlGesto && r && (this.controlGesto = RL(this, "Control"));
  }, e.prototype._updateTargets = function() {
    var n = this.props;
    this._prevPropTarget = this._propTarget, this._prevDragTarget = this._dragTarget, this._prevOriginalDragTarget = this._originalDragTarget, this._prevDragArea = n.dragArea, this._propTarget = n.target, this._originalDragTarget = n.dragTarget || n.target, this._dragTarget = ts(this._originalDragTarget, !0);
  }, e.prototype._renderLines = function() {
    var n = this.props, r = n, i = r.zoom, s = r.hideDefaultLines, o = r.hideChildMoveableDefaultLines, a = r.parentMoveable;
    if (s || a && o)
      return [];
    var l = this.getState(), c = {
      createElement: ki
    };
    return l.renderLines.map(function(u, d) {
      return ef(c, "", u[0], u[1], i, "render-line-".concat(d));
    });
  }, e.prototype._isTargetChanged = function(n) {
    var r = this.props, i = r.dragTarget || r.target, s = this._prevOriginalDragTarget, o = this._prevDragArea, a = r.dragArea, l = !a && s !== i, c = (n || a) && o !== a;
    return l || c || this._prevPropTarget != this._propTarget;
  }, e.prototype._updateNativeEvents = function() {
    var n = this, r = this.props, i = r.dragArea ? this.areaElement : this.state.target, s = this.events, o = Gs(s);
    if (this._isTargetChanged())
      for (var a in s) {
        var l = s[a];
        l && l.destroy(), s[a] = null;
      }
    if (i) {
      var c = this.enabledAbles;
      o.forEach(function(u) {
        var d = Hh(c, [u]), f = d.length > 0, h = s[u];
        if (!f) {
          h && (h.destroy(), s[u] = null);
          return;
        }
        h || (h = new xte(i, n, u), s[u] = h), h.setAbles(d);
      });
    }
  }, e.prototype._checkUpdateRootContainer = function() {
    var n = this.props.rootContainer;
    !this._rootContainer && n && (this._rootContainer = ts(n, !0));
  }, e.prototype._checkUpdateViewContainer = function() {
    var n = this.props.viewContainer;
    !this._viewContainer && n && (this._viewContainer = ts(n, !0));
    var r = this._viewContainer;
    r && this._changeAbleViewClassNames(he(he([], F(this._getAbleViewClassNames()), !1), [
      this.isDragging() ? nte : ""
    ], !1));
  }, e.prototype._changeAbleViewClassNames = function(n) {
    var r = this._viewContainer, i = mL(n.filter(Boolean), function(c) {
      return c;
    }).map(function(c) {
      var u = F(c, 1), d = u[0];
      return d;
    }), s = this._viewClassNames, o = Wf(s, i), a = o.removed, l = o.added;
    a.forEach(function(c) {
      X2(r, s[c]);
    }), l.forEach(function(c) {
      Y2(r, i[c]);
    }), this._viewClassNames = i;
  }, e.prototype._getAbleViewClassNames = function() {
    var n = this;
    return (this.getEnabledAbles().map(function(r) {
      var i;
      return ((i = r.viewClassName) === null || i === void 0 ? void 0 : i.call(r, n)) || "";
    }).join(" ") + " ".concat(this._getAbleClassName("-view"))).split(/\s+/g);
  }, e.prototype._getAbleClassName = function(n) {
    var r = this;
    n === void 0 && (n = "");
    var i = this.getEnabledAbles(), s = this.targetGesto, o = this.controlGesto, a = s != null && s.isFlag() ? s.getEventData() : {}, l = o != null && o.isFlag() ? o.getEventData() : {};
    return i.map(function(c) {
      var u, d, f, h = c.name, p = ((u = c.className) === null || u === void 0 ? void 0 : u.call(c, r)) || "";
      return (!((d = a[h]) === null || d === void 0) && d.isEventStart || !((f = l[h]) === null || f === void 0) && f.isEventStart) && (p += " ".concat(qe("".concat(h).concat(n, "-dragging")))), p.trim();
    }).filter(Boolean).join(" ");
  }, e.prototype._updateResizeObserver = function(n) {
    var r, i = this.props, s = i.target, o = Co(this.getControlBoxElement());
    if (!o.ResizeObserver || !s || !i.useResizeObserver) {
      (r = this._reiszeObserver) === null || r === void 0 || r.disconnect();
      return;
    }
    if (!(n.target === s && this._reiszeObserver)) {
      var a = new o.ResizeObserver(this.checkUpdateRect);
      a.observe(s, {
        box: "border-box"
      }), this._reiszeObserver = a;
    }
  }, e.prototype._updateMutationObserver = function(n) {
    var r = this, i, s = this.props, o = s.target, a = Co(this.getControlBoxElement());
    if (!a.MutationObserver || !o || !s.useMutationObserver) {
      (i = this._mutationObserver) === null || i === void 0 || i.disconnect();
      return;
    }
    if (!(n.target === o && this._mutationObserver)) {
      var l = new a.MutationObserver(function(c) {
        var u, d;
        try {
          for (var f = lQ(c), h = f.next(); !h.done; h = f.next()) {
            var p = h.value;
            p.type === "attributes" && p.attributeName === "style" && r.checkUpdateRect();
          }
        } catch (g) {
          u = { error: g };
        } finally {
          try {
            h && !h.done && (d = f.return) && d.call(f);
          } finally {
            if (u)
              throw u.error;
          }
        }
      });
      l.observe(o, {
        attributes: !0
      }), this._mutationObserver = l;
    }
  }, e.defaultProps = {
    dragTargetSelf: !1,
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: !0,
    parentMoveable: null,
    wrapperMoveable: null,
    isWrapperMounted: !1,
    parentPosition: null,
    warpSelf: !1,
    svgOrigin: "",
    dragContainer: null,
    useResizeObserver: !1,
    useMutationObserver: !1,
    preventDefault: !0,
    preventRightClick: !0,
    preventWheelClick: !0,
    linePadding: 0,
    controlPadding: 0,
    ables: [],
    pinchThreshold: 20,
    dragArea: !1,
    passDragArea: !1,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: !1,
    padding: {},
    pinchOutside: !0,
    checkInput: !1,
    dragFocusedInput: !1,
    groupable: !1,
    hideDefaultLines: !1,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    stopPropagation: !1,
    preventClickDefault: !1,
    preventClickEventOnDrag: !0,
    flushSync: oL,
    firstRenderState: null,
    persistData: null,
    viewContainer: null,
    requestStyles: [],
    useAccuratePosition: !1
  }, e;
}(rP), KE = {
  name: "groupable",
  props: [
    "defaultGroupRotate",
    "useDefaultGroupRotate",
    "defaultGroupOrigin",
    "groupable",
    "groupableProps",
    "targetGroups",
    "hideChildMoveableDefaultLines"
  ],
  events: [],
  render: function(t, e) {
    var n, r = t.props, i = r.targets || [], s = t.getState(), o = s.left, a = s.top, l = s.isPersisted, c = r.zoom || 1, u = t.renderGroupRects, d = ((n = r.persistData) === null || n === void 0 ? void 0 : n.children) || [];
    l ? i = d.map(function() {
      return null;
    }) : d = [];
    var f = ec(t, "parentPosition", [o, a], function(p) {
      return p.join(",");
    }), h = ec(t, "requestStyles", t.getRequestChildStyles(), function(p) {
      return p.join(",");
    });
    return t.moveables = t.moveables.slice(0, i.length), he(he([], F(i.map(function(p, g) {
      return e.createElement(Wc, { key: "moveable" + g, ref: H2(t, "moveables", g), target: p, origin: !1, requestStyles: h, cssStyled: r.cssStyled, customStyledMap: r.customStyledMap, useResizeObserver: r.useResizeObserver, useMutationObserver: r.useMutationObserver, hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines, parentMoveable: t, parentPosition: [o, a], persistData: d[g], zoom: c });
    })), !1), F(vL(u.map(function(p, g) {
      var m = p.pos1, v = p.pos2, y = p.pos3, E = p.pos4, b = [m, v, y, E];
      return [
        [0, 1],
        [1, 3],
        [3, 2],
        [2, 0]
      ].map(function(_, w) {
        var S = F(_, 2), x = S[0], k = S[1];
        return ef(e, "", Ke(b[x], f), Ke(b[k], f), c, "group-rect-".concat(g, "-").concat(w));
      });
    }))), !1);
  }
}, Tte = Xf("clickable", {
  props: [
    "clickable"
  ],
  events: [
    "click",
    "clickGroup"
  ],
  always: !0,
  dragRelation: "weak",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dragStart: function() {
  },
  dragControlStart: function() {
  },
  dragGroupStart: function(t, e) {
    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;
  },
  dragEnd: function(t, e) {
    var n = t.props.target, r = e.inputEvent, i = e.inputTarget, s = t.isMoveableElement(i), o = !s && t.controlBox.contains(i);
    if (!(!r || !i || e.isDrag || t.isMoveableElement(i) || o)) {
      var a = n.contains(i);
      Ne(t, "onClick", st(t, e, {
        isDouble: e.isDouble,
        inputTarget: i,
        isTarget: n === i,
        moveableTarget: t.props.target,
        containsTarget: a
      }));
    }
  },
  dragGroupEnd: function(t, e) {
    var n = e.inputEvent, r = e.inputTarget;
    if (!(!n || !r || e.isDrag || t.isMoveableElement(r) || e.datas.inputTarget === r)) {
      var i = t.props.targets, s = i.indexOf(r), o = s > -1, a = !1;
      s === -1 && (s = Ws(i, function(l) {
        return l.contains(r);
      }), a = s > -1), Ne(t, "onClickGroup", st(t, e, {
        isDouble: e.isDouble,
        targets: i,
        inputTarget: r,
        targetIndex: s,
        isTarget: o,
        containsTarget: a,
        moveableTarget: i[s]
      }));
    }
  },
  dragControlEnd: function(t, e) {
    this.dragEnd(t, e);
  },
  dragGroupControlEnd: function(t, e) {
    this.dragEnd(t, e);
  }
});
function Cl(t) {
  var e = t.originalDatas.draggable;
  return e || (t.originalDatas.draggable = {}, e = t.originalDatas.draggable), L(L({}, t), { datas: e });
}
var Ote = Xf("edgeDraggable", {
  css: [
    `.edge.edgeDraggable.line {
cursor: move;
}`
  ],
  render: function(t, e) {
    var n = t.props, r = n.edgeDraggable;
    return r ? zP(e, "edgeDraggable", r, t.getState().renderPoses, n.zoom) : [];
  },
  dragCondition: function(t, e) {
    var n, r = t.props, i = (n = e.inputEvent) === null || n === void 0 ? void 0 : n.target;
    return !r.edgeDraggable || !i ? !1 : !r.draggable && fn(i, qe("direction")) && fn(i, qe("edge")) && fn(i, qe("edgeDraggable"));
  },
  dragStart: function(t, e) {
    return qn.dragStart(t, Cl(e));
  },
  drag: function(t, e) {
    return qn.drag(t, Cl(e));
  },
  dragEnd: function(t, e) {
    return qn.dragEnd(t, Cl(e));
  },
  dragGroupCondition: function(t, e) {
    var n, r = t.props, i = (n = e.inputEvent) === null || n === void 0 ? void 0 : n.target;
    return !r.edgeDraggable || !i ? !1 : !r.draggable && fn(i, qe("direction")) && fn(i, qe("line"));
  },
  dragGroupStart: function(t, e) {
    return qn.dragGroupStart(t, Cl(e));
  },
  dragGroup: function(t, e) {
    return qn.dragGroup(t, Cl(e));
  },
  dragGroupEnd: function(t, e) {
    return qn.dragGroupEnd(t, Cl(e));
  },
  unset: function(t) {
    return qn.unset(t);
  }
}), IL = {
  name: "individualGroupable",
  props: [
    "individualGroupable",
    "individualGroupableProps"
  ],
  events: []
}, YE = [
  ML,
  kL,
  Dee,
  Jee,
  qn,
  Ote,
  R1,
  Zee,
  ete,
  gee,
  ste,
  ote,
  rte,
  bte,
  vte,
  Ete,
  KE,
  IL,
  Tte,
  xL,
  AL
], Mte = /* @__PURE__ */ YE.reduce(function(t, e) {
  return (e.events || []).forEach(function(n) {
    K2(t, n);
  }), t;
}, []), Ate = /* @__PURE__ */ YE.reduce(function(t, e) {
  return (e.props || []).forEach(function(n) {
    K2(t, n);
  }), t;
}, []);
function cO(t, e) {
  var n = F(t, 3), r = n[0], i = n[1], s = n[2];
  return (r * e[0] + i * e[1] + s) / Math.sqrt(r * r + i * i);
}
function Wh(t, e) {
  var n = F(t, 2), r = n[0], i = n[1];
  return -r * e[0] - i * e[1];
}
function uO(t, e) {
  return Math.max.apply(Math, he([], F(t.map(function(n) {
    var r = F(n, 4), i = r[0], s = r[1], o = r[2], a = r[3];
    return Math.max(i[e], s[e], o[e], a[e]);
  })), !1));
}
function dO(t, e) {
  return Math.min.apply(Math, he([], F(t.map(function(n) {
    var r = F(n, 4), i = r[0], s = r[1], o = r[2], a = r[3];
    return Math.min(i[e], s[e], o[e], a[e]);
  })), !1));
}
function Nte(t, e) {
  var n, r, i, s = [0, 0], o = [0, 0], a = [0, 0], l = [0, 0], c = 0, u = 0;
  if (!t.length)
    return {
      pos1: s,
      pos2: o,
      pos3: a,
      pos4: l,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: c,
      height: u,
      rotation: e
    };
  var d = tt(e, rr);
  if (d % 90) {
    var f = d / 180 * Math.PI, h = Math.tan(f), p = -1 / h, g = [O1, IT], m = [[0, 0], [0, 0]], v = [O1, IT], y = [[0, 0], [0, 0]];
    t.forEach(function(ne) {
      ne.forEach(function(ie) {
        var Z = cO([-h, 1, 0], ie), Q = cO([-p, 1, 0], ie);
        g[0] > Z && (m[0] = ie, g[0] = Z), g[1] < Z && (m[1] = ie, g[1] = Z), v[0] > Q && (y[0] = ie, v[0] = Q), v[1] < Q && (y[1] = ie, v[1] = Q);
      });
    });
    var E = F(m, 2), b = E[0], _ = E[1], w = F(y, 2), S = w[0], x = w[1], k = [-h, 1, Wh([-h, 1], b)], T = [-h, 1, Wh([-h, 1], _)], I = [-p, 1, Wh([-p, 1], S)], R = [-p, 1, Wh([-p, 1], x)];
    n = F([
      [k, I],
      [k, R],
      [T, I],
      [T, R]
    ].map(function(ne) {
      var ie = F(ne, 2), Z = ie[0], Q = ie[1];
      return CE(Z, Q)[0];
    }), 4), s = n[0], o = n[1], a = n[2], l = n[3], c = v[1] - v[0], u = g[1] - g[0];
  } else {
    var N = dO(t, 0), $ = dO(t, 1), B = uO(t, 0), G = uO(t, 1);
    if (s = [N, $], o = [B, $], a = [N, G], l = [B, G], c = B - N, u = G - $, d % 180) {
      var M = [a, s, l, o];
      r = F(M, 4), s = r[0], o = r[1], a = r[2], l = r[3], c = G - $, u = B - N;
    }
  }
  if (d % 360 > 180) {
    var M = [l, a, o, s];
    i = F(M, 4), s = i[0], o = i[1], a = i[2], l = i[3];
  }
  var A = tl([s, o, a, l]), z = A.minX, V = A.minY, U = A.maxX, Y = A.maxY;
  return {
    pos1: s,
    pos2: o,
    pos3: a,
    pos4: l,
    width: c,
    height: u,
    minX: z,
    minY: V,
    maxX: U,
    maxY: Y,
    rotation: e
  };
}
function PL(t, e) {
  var n = e.map(function(r) {
    if (rn(r)) {
      var i = PL(t, r), s = i.length;
      return s > 1 ? i : s === 1 ? i[0] : null;
    } else {
      var o = br(t, function(a) {
        var l = a.manager;
        return l.props.target === r;
      });
      return o ? (o.finded = !0, o.manager) : null;
    }
  }).filter(Boolean);
  return n.length === 1 && rn(n[0]) ? n[0] : n;
}
var Rte = /* @__PURE__ */ function(t) {
  Yf(e, t);
  function e() {
    var n = t !== null && t.apply(this, arguments) || this;
    return n.differ = new wP(), n.moveables = [], n.transformOrigin = "50% 50%", n.renderGroupRects = [], n._targetGroups = [], n._hasFirstTargets = !1, n;
  }
  return e.prototype.componentDidMount = function() {
    t.prototype.componentDidMount.call(this);
  }, e.prototype.checkUpdate = function() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }, e.prototype.getTargets = function() {
    return this.props.targets;
  }, e.prototype.updateRect = function(n, r, i) {
    var s;
    i === void 0 && (i = !0);
    var o = this.state;
    if (!this.controlBox || o.isPersisted)
      return;
    Hc(!0), this.moveables.forEach(function(ge) {
      ge.updateRect(n, !1, !1);
    });
    var a = this.props, l = this.moveables, c = o.target || a.target, u = l.map(function(ge) {
      return { finded: !1, manager: ge };
    }), d = this.props.targetGroups || [], f = PL(u, d), h = a.useDefaultGroupRotate;
    f.push.apply(f, he([], F(u.filter(function(ge) {
      var Re = ge.finded;
      return !Re;
    }).map(function(ge) {
      var Re = ge.manager;
      return Re;
    })), !1));
    var p = [], g = !r || n !== "" && a.updateGroup, m = a.defaultGroupRotate || 0;
    if (!this._hasFirstTargets) {
      var v = (s = a.persistData) === null || s === void 0 ? void 0 : s.rotation;
      v != null && (m = v);
    }
    function y(ge, Re, Be) {
      var le = ge.map(function(P) {
        if (rn(P)) {
          var O = y(P, Re), q = [O.pos1, O.pos2, O.pos3, O.pos4];
          return p.push(O), { poses: q, rotation: O.rotation };
        } else
          return {
            poses: ui(P.state),
            rotation: P.getRotation()
          };
      }), Ee = le.map(function(P) {
        var O = P.rotation;
        return O;
      }), Se = 0, xe = Ee[0], Ce = Ee.every(function(P) {
        return Math.abs(xe - P) < 0.1;
      });
      g ? Se = !h && Ce ? xe : m : Se = !h && !Be && Ce ? xe : Re;
      var _e = le.map(function(P) {
        var O = P.poses;
        return O;
      }), Je = Nte(_e, Se);
      return Je;
    }
    var E = y(f, this.rotation, !0);
    g && (this.rotation = E.rotation, this.transformOrigin = a.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = d, this.renderGroupRects = p;
    var b = this.transformOrigin, _ = this.rotation, w = this.scale, S = E.width, x = E.height, k = E.minX, T = E.minY, I = Xee([
      [0, 0],
      [S, 0],
      [0, x],
      [S, x]
    ], WE(b, S, x), this.rotation / 180 * Math.PI), R = tl(I.result), N = R.minX, $ = R.minY, B = " rotate(".concat(_, "deg)") + " scale(".concat(Kn(w[0]), ", ").concat(Kn(w[1]), ")"), G = "translate(".concat(-N, "px, ").concat(-$, "px)").concat(B);
    this.controlBox.style.transform = "translate3d(".concat(k, "px, ").concat(T, "px, ").concat(this.props.translateZ || 0, ")"), c.style.cssText += "left:0px;top:0px;" + "transform-origin:".concat(b, ";") + "width:".concat(S, "px;height:").concat(x, "px;") + "transform: ".concat(G), o.width = S, o.height = x;
    var M = this.getContainer(), A = F1(this.controlBox, c, this.controlBox, this.getContainer(), this._rootContainer || M, []), z = [A.left, A.top], V = F(ui(A), 4), U = V[0], Y = V[1], ne = V[2], ie = V[3], Z = tl([U, Y, ne, ie]), Q = [Z.minX, Z.minY], fe = Kn(w[0] * w[1]);
    A.pos1 = Ke(U, Q), A.pos2 = Ke(Y, Q), A.pos3 = Ke(ne, Q), A.pos4 = Ke(ie, Q), A.left = k - A.left + Q[0], A.top = T - A.top + Q[1], A.origin = Ke(wt(z, A.origin), Q), A.beforeOrigin = Ke(wt(z, A.beforeOrigin), Q), A.originalBeforeOrigin = wt(z, A.originalBeforeOrigin), A.transformOrigin = Ke(wt(z, A.transformOrigin), Q), c.style.transform = "translate(".concat(-N - Q[0], "px, ").concat(-$ - Q[1], "px)") + B, Hc(), this.updateState(L(L({}, A), { posDelta: Q, direction: fe, beforeDirection: fe }), i);
  }, e.prototype.getRect = function() {
    return L(L({}, t.prototype.getRect.call(this)), { children: this.moveables.map(function(n) {
      return n.getRect();
    }) });
  }, e.prototype.triggerEvent = function(n, r, i) {
    if (i || n.indexOf("Group") > -1)
      return t.prototype.triggerEvent.call(this, n, r);
    this._emitter.trigger(n, r);
  }, e.prototype.getRequestChildStyles = function() {
    var n = this.getEnabledAbles().reduce(function(r, i) {
      var s, o, a = (o = (s = i.requestChildStyle) === null || s === void 0 ? void 0 : s.call(i)) !== null && o !== void 0 ? o : [];
      return he(he([], F(r), !1), F(a), !1);
    }, []);
    return n;
  }, e.prototype.getMoveables = function() {
    return he([], F(this.moveables), !1);
  }, e.prototype.updateAbles = function() {
    t.prototype.updateAbles.call(this, he(he([], F(this.props.ables), !1), [KE], !1), "Group");
  }, e.prototype._updateTargets = function() {
    t.prototype._updateTargets.call(this), this._originalDragTarget = this.props.dragTarget || this.areaElement, this._dragTarget = ts(this._originalDragTarget, !0);
  }, e.prototype._updateEvents = function() {
    var n = this.state, r = this.props, i = this._prevDragTarget, s = r.dragTarget || this.areaElement, o = r.targets, a = this.differ.update(o), l = a.added, c = a.changed, u = a.removed, d = l.length || u.length;
    (d || this._prevOriginalDragTarget !== this._originalDragTarget) && (Ql(this, !1), Ql(this, !0), this.updateState({ gestos: {} })), i !== s && (n.target = null), n.target || (n.target = this.areaElement, this.controlBox.style.display = "block"), n.target && (this.targetGesto || (this.targetGesto = NL(this, this._dragTarget, "Group")), this.controlGesto || (this.controlGesto = RL(this, "GroupControl")));
    var f = !$1(n.container, r.container);
    f && (n.container = r.container), (f || d || this.transformOrigin !== (r.defaultGroupOrigin || "50% 50%") || c.length || o.length && !_L(this._targetGroups, r.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!d;
  }, e.prototype._updateObserver = function() {
  }, e.defaultProps = L(L({}, Wc.defaultProps), { transformOrigin: ["50%", "50%"], groupable: !0, dragArea: !0, keepRatio: !0, targets: [], defaultGroupRotate: 0, defaultGroupOrigin: "50% 50%" }), e;
}(Wc), Dte = /* @__PURE__ */ function(t) {
  Yf(e, t);
  function e() {
    var n = t !== null && t.apply(this, arguments) || this;
    return n.moveables = [], n;
  }
  return e.prototype.render = function() {
    var n = this, r, i = this.props, s = i.cspNonce, o = i.cssStyled, a = i.persistData, l = i.targets || [], c = l.length, u = this.isUnmounted || !c, d = (r = a == null ? void 0 : a.children) !== null && r !== void 0 ? r : [];
    return u && !c && d.length ? l = d.map(function() {
      return null;
    }) : u || (d = []), ki(o, { cspNonce: s, ref: $s(this, "controlBox"), className: qe("control-box") }, l.map(function(f, h) {
      var p, g, m = (g = (p = i.individualGroupableProps) === null || p === void 0 ? void 0 : p.call(i, f, h)) !== null && g !== void 0 ? g : {};
      return ki(Wc, L({ key: "moveable" + h, ref: H2(n, "moveables", h) }, i, m, { target: f, wrapperMoveable: n, isWrapperMounted: n.isMoveableMounted, persistData: d[h] }));
    }));
  }, e.prototype.componentDidMount = function() {
  }, e.prototype.componentDidUpdate = function() {
  }, e.prototype.getTargets = function() {
    return this.props.targets;
  }, e.prototype.updateRect = function(n, r, i) {
    i === void 0 && (i = !0), Hc(!0), this.moveables.forEach(function(s) {
      s.updateRect(n, r, i);
    }), Hc();
  }, e.prototype.getRect = function() {
    return L(L({}, t.prototype.getRect.call(this)), { children: this.moveables.map(function(n) {
      return n.getRect();
    }) });
  }, e.prototype.request = function(n, r, i) {
    r === void 0 && (r = {});
    var s = this.moveables.map(function(l) {
      return l.request(n, L(L({}, r), { isInstant: !1 }), !1);
    }), o = i || r.isInstant, a = {
      request: function(l) {
        return s.forEach(function(c) {
          return c.request(l);
        }), this;
      },
      requestEnd: function() {
        return s.forEach(function(l) {
          return l.requestEnd();
        }), this;
      }
    };
    return o ? a.request(r).requestEnd() : a;
  }, e.prototype.dragStart = function(n, r) {
    r === void 0 && (r = n.target);
    var i = r, s = br(this.moveables, function(o) {
      var a = o.getTargets()[0], l = o.getControlBoxElement(), c = o.getDragElement();
      return !a || !c ? !1 : c === i || c.contains(i) || c !== a && a === i || a.contains(i) || l === i || l.contains(i);
    });
    return s && s.dragStart(n, r), this;
  }, e.prototype.hitTest = function() {
    return 0;
  }, e.prototype.isInside = function() {
    return !1;
  }, e.prototype.isDragging = function() {
    return !1;
  }, e.prototype.getDragElement = function() {
    return null;
  }, e.prototype.getMoveables = function() {
    return he([], F(this.moveables), !1);
  }, e.prototype.updateRenderPoses = function() {
  }, e.prototype.checkUpdate = function() {
  }, e.prototype.triggerEvent = function() {
  }, e.prototype.updateAbles = function() {
  }, e.prototype._updateEvents = function() {
  }, e.prototype._updateObserver = function() {
  }, e;
}(Wc);
function LL(t, e) {
  var n = [];
  return t.forEach(function(r) {
    if (r) {
      if (vr(r)) {
        e[r] && n.push.apply(n, he([], F(e[r]), !1));
        return;
      }
      rn(r) ? n.push.apply(n, he([], F(LL(r, e)), !1)) : n.push(r);
    }
  }), n;
}
function $L(t, e) {
  var n = [];
  return t.forEach(function(r) {
    if (r) {
      if (vr(r)) {
        e[r] && n.push.apply(n, he([], F(e[r]), !1));
        return;
      }
      rn(r) ? n.push($L(r, e)) : n.push(r);
    }
  }), n;
}
function BL(t, e) {
  return t.length !== e.length || t.some(function(n, r) {
    var i = e[r];
    return !n && !i ? !1 : n != i ? rn(n) && rn(i) ? BL(n, i) : !0 : !1;
  });
}
var Ite = /* @__PURE__ */ function(t) {
  Yf(e, t);
  function e() {
    var n = t !== null && t.apply(this, arguments) || this;
    return n.refTargets = [], n.selectorMap = {}, n._differ = new wP(), n._elementTargets = [], n._tmpRefTargets = [], n._tmpSelectorMap = {}, n._onChangeTargets = null, n;
  }
  return e.makeStyled = function() {
    var n = {}, r = this.getTotalAbles();
    r.forEach(function(s) {
      var o = s.css;
      o && o.forEach(function(a) {
        n[a] = !0;
      });
    });
    var i = Gs(n).join(`
`);
    this.defaultStyled = xP("div", OJ(OE, yQ + i));
  }, e.getTotalAbles = function() {
    return he([kL, KE, IL, xL], F(this.defaultAbles), !1);
  }, e.prototype.render = function() {
    var n, r = this.constructor;
    r.defaultStyled || r.makeStyled();
    var i = this.props, s = i.ables, o = i.props, a = oQ(i, ["ables", "props"]), l = F(this._updateRefs(!0), 2), c = l[0], u = l[1], d = LL(c, u), f = d.length > 1, h = r.getTotalAbles(), p = he(he([], F(h), !1), F(s || []), !1), g = L(L(L({}, a), o || {}), { ables: p, cssStyled: r.defaultStyled, customStyledMap: r.customStyledMap });
    this._elementTargets = d;
    var m = null, v = this.moveable, y = a.persistData;
    if (y != null && y.children && (f = !0), a.individualGroupable)
      return ki(Dte, L({ key: "individual-group", ref: $s(this, "moveable") }, g, { target: null, targets: d }));
    if (f) {
      var E = $L(c, u);
      if (v && !v.props.groupable && !v.props.individualGroupable) {
        var b = v.props.target;
        b && d.indexOf(b) > -1 && (m = L({}, v.state));
      }
      return ki(Rte, L({ key: "group", ref: $s(this, "moveable") }, g, (n = a.groupableProps) !== null && n !== void 0 ? n : {}, { target: null, targets: d, targetGroups: E, firstRenderState: m }));
    } else {
      var _ = d[0];
      if (v && (v.props.groupable || v.props.individualGroupable)) {
        var w = v.moveables || [], S = br(w, function(x) {
          return x.props.target === _;
        });
        S && (m = L({}, S.state));
      }
      return ki(Wc, L({ key: "single", ref: $s(this, "moveable") }, g, { target: _, firstRenderState: m }));
    }
  }, e.prototype.componentDidMount = function() {
    this._checkChangeTargets();
  }, e.prototype.componentDidUpdate = function() {
    this._checkChangeTargets();
  }, e.prototype.componentWillUnmount = function() {
    this.selectorMap = {}, this.refTargets = [];
  }, e.prototype.getTargets = function() {
    var n, r;
    return (r = (n = this.moveable) === null || n === void 0 ? void 0 : n.getTargets()) !== null && r !== void 0 ? r : [];
  }, e.prototype.updateSelectors = function() {
    this.selectorMap = {}, this._updateRefs(), this.forceUpdate();
  }, e.prototype.waitToChangeTarget = function() {
    var n = this, r;
    return this._onChangeTargets = function() {
      n._onChangeTargets = null, r();
    }, new Promise(function(i) {
      r = i;
    });
  }, e.prototype.waitToChangeTargets = function() {
    return this.waitToChangeTarget();
  }, e.prototype.getManager = function() {
    return this.moveable;
  }, e.prototype.getMoveables = function() {
    return this.moveable.getMoveables();
  }, e.prototype.getDragElement = function() {
    return this.moveable.getDragElement();
  }, e.prototype._updateRefs = function(n) {
    var r = this.refTargets, i = VE(this.props.target || this.props.targets), s = typeof document < "u", o = BL(r, i), a = this.selectorMap, l = {};
    return this.refTargets.forEach(function c(u) {
      if (vr(u)) {
        var d = a[u];
        d ? l[u] = a[u] : s && (o = !0, l[u] = [].slice.call(document.querySelectorAll(u)));
      } else
        rn(u) && u.forEach(c);
    }), this._tmpRefTargets = i, this._tmpSelectorMap = l, [
      i,
      l,
      !n && o
    ];
  }, e.prototype._checkChangeTargets = function() {
    var n, r, i;
    this.refTargets = this._tmpRefTargets, this.selectorMap = this._tmpSelectorMap;
    var s = this._differ.update(this._elementTargets), o = s.added, a = s.removed, l = o.length || a.length;
    l && ((r = (n = this.props).onChangeTargets) === null || r === void 0 || r.call(n, {
      moveable: this.moveable,
      targets: this._elementTargets
    }), (i = this._onChangeTargets) === null || i === void 0 || i.call(this));
    var c = F(this._updateRefs(), 3), u = c[0], d = c[1], f = c[2];
    this.refTargets = u, this.selectorMap = d, f && this.forceUpdate();
  }, e.defaultAbles = [], e.customStyledMap = {}, e.defaultStyled = null, aQ([
    MJ(AP)
  ], e.prototype, "moveable", void 0), e;
}(rP), Pte = /* @__PURE__ */ function(t) {
  Yf(e, t);
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return e.defaultAbles = YE, e;
}(Ite), z1 = function(t, e) {
  return z1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, z1(t, e);
};
function XE(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  z1(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var nf = function() {
  return nf = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, nf.apply(this, arguments);
};
function Lte(t, e, n, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var a = t.length - 1; a >= 0; a--)
      (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
  return i > 3 && s && Object.defineProperty(e, n, s), s;
}
var $te = /* @__PURE__ */ function(t) {
  XE(e, t);
  function e(r) {
    var i = t.call(this, r) || this;
    return i.state = {}, i.state = i.props, i;
  }
  var n = e.prototype;
  return n.render = function() {
    return ki(Pte, nf({
      ref: $s(this, "moveable")
    }, this.state));
  }, e;
}(wE), jg = Ate, FL = AP, zL = Mte, Bte = /* @__PURE__ */ function(t) {
  XE(e, t);
  function e(r, i) {
    i === void 0 && (i = {});
    var s = t.call(this) || this;
    s.containerProvider = null, s.selfElement = null, s._warp = !1;
    var o = nf({}, i), a = {};
    zL.forEach(function(u) {
      a[FJ("on ".concat(u))] = function(d) {
        return s.trigger(u, d);
      };
    });
    var l;
    i.warpSelf ? (delete i.warpSelf, s._warp = !0, l = r) : (l = tu(r).createElement("div"), r.appendChild(l)), s.containerProvider = OT(ki($te, nf({
      ref: $s(s, "innerMoveable")
    }, o, a)), l), s.selfElement = l;
    var c = o.target;
    return rn(c) && c.length > 1 && s.updateRect(), s;
  }
  var n = e.prototype;
  return n.setState = function(r, i) {
    this.innerMoveable.setState(r, i);
  }, n.forceUpdate = function(r) {
    this.innerMoveable.forceUpdate(r);
  }, n.dragStart = function(r, i) {
    i === void 0 && (i = r.target);
    var s = this.innerMoveable;
    s.$_timer && this.forceUpdate(), this.getMoveable().dragStart(r, i);
  }, n.destroy = function() {
    var r, i = this.selfElement;
    OT(null, i, this.containerProvider), this._warp || (r = i == null ? void 0 : i.parentElement) === null || r === void 0 || r.removeChild(i), this.containerProvider = null, this.off(), this.selfElement = null, this.innerMoveable = null;
  }, n.getMoveable = function() {
    return this.innerMoveable.moveable;
  }, e = Lte([yT(FL, function(r, i) {
    r[i] || (r[i] = function() {
      for (var s = [], o = 0; o < arguments.length; o++)
        s[o] = arguments[o];
      var a = this.getMoveable();
      if (!(!a || !a[i]))
        return a[i].apply(a, s);
    });
  }), yT(jg, function(r, i) {
    Object.defineProperty(r, i, {
      get: function() {
        return this.getMoveable().props[i];
      },
      set: function(s) {
        var o;
        this.setState((o = {}, o[i] = s, o));
      },
      enumerable: !0,
      configurable: !0
    });
  })], e), e;
}(e0), Fte = /* @__PURE__ */ function(t) {
  XE(e, t);
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return e;
}(Bte);
const HL = {};
FL.forEach((t) => {
  HL[t] = function(...e) {
    return this.$_moveable[t](...e);
  };
});
const UL = {};
jg.forEach((t) => {
  UL[t] = function(e) {
    this.$_moveable[t] = e;
  };
});
const zte = ae({
  name: "moveable",
  methods: HL,
  props: jg,
  watch: UL,
  mounted() {
    const t = {}, e = this.$props;
    jg.forEach((s) => {
      const o = e[s];
      Uf(o) || (t[s] = e[s]);
    });
    const r = this.$refs.moveableElement, i = new Fte(r, {
      ...t,
      warpSelf: !0
    });
    zL.forEach((s) => {
      i.on(s, (o) => {
        this.$emit(s, { ...o });
      });
    }), this.$_moveable = i;
  },
  beforeUnmount() {
    this.$_moveable.destroy();
  }
}), Hte = zte, Ute = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, Vte = { ref: "moveableElement" };
function Wte(t, e, n, r, i, s) {
  return J(), be("div", Vte, null, 512);
}
const VL = /* @__PURE__ */ Ute(Hte, [["render", Wte]]), Gte = ["alt", "src"], jte = /* @__PURE__ */ ae({
  __name: "ImageView",
  props: {
    ...A_,
    selected: {
      type: Boolean,
      required: !0
    }
  },
  setup(t) {
    const e = t, n = X(), r = X(), i = X("auto"), s = X("auto"), o = X("auto"), a = X("auto"), l = X(!0), c = X(!1), u = X(!0), d = X(1), f = X(["nw", "n", "ne", "w", "e", "sw", "s", "se"]);
    function h({ width: _, height: w, transform: S }) {
      e.updateAttributes({
        keepRatio: u.value,
        width: _,
        height: w,
        transform: S
      });
    }
    const p = rt(() => {
      const { src: _, alt: w, width: S, height: x, keepRatio: k } = e.node.attrs, T = Rd(S) ? S + "px" : S, I = k ? null : Rd(x) ? x + "px" : x;
      return {
        src: _ || void 0,
        alt: w || void 0,
        style: {
          width: T || void 0,
          height: I || void 0
        }
      };
    }), g = rt(() => {
      const {
        style: { width: _ }
      } = C(p);
      return { width: _ === "100%" ? _ : void 0 };
    }), m = X(!1), v = X({
      width: void 0,
      height: void 0
    }), y = async (_) => {
      m.value = !0, _.width = Math.round(_.width), _.height = Math.round(_.height);
      const w = Math.round(n.value.$el.parentNode.getBoundingClientRect().width);
      if (u.value && _.width >= w) {
        _.width = w, _.height = _.width / _.startRatio, h({
          width: "100%",
          height: _.height
        });
        return;
      }
      h({
        width: _.width,
        height: _.height
      }), _.target.style.width = `${_.width}px`, _.target.style.height = `${_.height}px`;
    };
    function E(_) {
      m.value = !1, v.value.width = p.value.style.width, v.value.height = p.value.style.height, b();
    }
    Bt(
      () => e.node.attrs,
      () => {
        u.value = e.node.attrs.keepRatio;
      },
      {
        immediate: !0,
        deep: !0
      }
    );
    function b() {
      const { editor: _, getPos: w } = e;
      _.commands.setNodeSelection(w());
    }
    return (_, w) => (J(), Ze(C(M_), {
      ref_key: "Wrap",
      ref: n,
      class: It([[e.node.attrs.display], "langeditor-image"]),
      style: Rr(g.value),
      as: "span"
    }, {
      default: Ue(() => [
        se("div", {
          style: Rr(g.value),
          class: "langeditor-image-container"
        }, [
          se("div", {
            ref_key: "targetRef",
            ref: r,
            style: Rr(`max-width: ${i.value};max-height: ${s.value};min-width: ${o.value};min-height: ${a.value};width:${v.value.width}px;height:${v.value.height}px`),
            class: "move-box"
          }, [
            se("img", {
              alt: p.value.alt,
              src: p.value.src,
              style: Rr(p.value.style)
            }, null, 12, Gte)
          ], 4),
          t.selected || m.value ? (J(), Ze(C(VL), {
            key: 0,
            keepRatio: u.value,
            renderDirections: f.value,
            resizable: l.value && _.editor.isEditable,
            rotatable: c.value,
            target: r.value,
            throttleResize: d.value,
            useResizeObserver: !0,
            onResize: y,
            onResizeEnd: E
          }, null, 8, ["keepRatio", "renderDirections", "resizable", "rotatable", "target", "throttleResize"])) : He("", !0)
        ], 4)
      ]),
      _: 1
    }, 8, ["class", "style"]));
  }
});
const qte = /* @__PURE__ */ wr(jte, [["__scopeId", "data-v-be02230a"]]);
function Kte() {
  return CJ.extend({
    addOptions() {
      var t;
      return {
        ...(t = this.parent) == null ? void 0 : t.call(this),
        inline: !0,
        HTMLAttributes: {}
      };
    },
    addNodeView() {
      return Lv(qte);
    },
    addAttributes() {
      return {
        src: {
          default: null
        },
        alt: {
          default: null
        },
        keepRatio: {
          default: !0
        },
        title: {
          default: null
        },
        width: {
          default: "100%"
        },
        height: {
          default: null
        },
        display: {
          default: "inline",
          renderHTML: ({ display: t }) => t ? {
            "data-display": t
          } : {},
          parseHTML: (t) => t.getAttribute("data-display") || "inline"
        }
      };
    },
    addCommands() {
      var t;
      return {
        ...(t = this.parent) == null ? void 0 : t.call(this),
        updateImage: (e) => ({ commands: n }) => n.updateAttributes(this.name, e)
      };
    }
  });
}
const Yte = {
  class: "flex flex-col items-center w-ful langeditor-hover max-w-lg p-5 mx-auto mt-2 text-center border-dashed cursor-pointer langeditor-text langeditor-bg langeditor-border rounded-xl",
  for: "dropzone-file"
}, Xte = { class: "mt-1 font-medium tracking-wide langeditor-text" }, Jte = ["accept"], WL = {
  __name: "LangSimpleUpload",
  props: {
    type: {
      type: String,
      default: "image"
      // image 或  video  或  audio
    }
  },
  emits: ["change"],
  setup(t, { expose: e, emit: n }) {
    const r = t, i = rt(() => {
      switch (r.type) {
        case "image":
          return "image/*";
        case "video":
          return "video/*";
        case "audio":
          return "audio/*";
      }
    }), s = X(null), o = X(null), a = n;
    function l(u) {
      console.log(u), s.value = URL.createObjectURL(u.file.file), o.value = u.file.file, Af(() => {
        a("change", o.value);
      });
    }
    function c() {
      return o.value;
    }
    return e({ getFile: c }), (u, d) => (J(), be("div", null, [
      se("label", Yte, [
        W(C(rG)),
        se("h2", Xte, Ut(C(me)("uploadFile")), 1),
        se("input", {
          accept: i.value,
          class: "hidden",
          type: "file",
          onChange: l
        }, null, 40, Jte)
      ])
    ]));
  }
}, Zte = { class: "relative text-center w-full" }, Qte = {
  key: 0,
  class: "absolute z-10 -translate-x-1/2 -translate-y-1/2 top-2/4 left-1/2",
  role: "status"
}, ene = /* @__PURE__ */ se("svg", {
  "aria-hidden": "true",
  class: "w-4 h-4 text-gray-200 animate-spin fill-blue-600",
  fill: "none",
  viewBox: "0 0 100 101",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ se("path", {
    d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
    fill: "currentColor"
  }),
  /* @__PURE__ */ se("path", {
    d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
    fill: "currentFill"
  })
], -1), tne = [
  ene
], ns = /* @__PURE__ */ ae({
  __name: "LangButton",
  props: {
    loading: {
      type: Boolean,
      require: !1,
      default: !1
    },
    isBorder: {
      type: Boolean,
      require: !1,
      default: !0
    },
    content: {
      type: String,
      require: !0,
      default: ""
    },
    color: {
      type: String,
      require: !0,
      default: ""
    },
    icon: {
      type: Function,
      require: !1,
      default: void 0
    },
    iconIsRight: {
      type: Boolean,
      require: !1,
      default: !1
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    },
    contentClass: {
      type: String,
      required: !1,
      default: ""
    }
  },
  setup(t) {
    return (e, n) => (J(), be("div", Zte, [
      se("div", {
        class: It([[
          t.contentClass,
          {
            "opacity-60 pointer-events-none": t.loading,
            "langeditor-border": t.isBorder || t.isBorder === void 0,
            "!p-1.5 !h-[28px] !gap-1.5 text-sm": t.mini
          }
        ], "cursor-pointer h-[32px] text-sm text-nowrap flex-nowrap flex items-center justify-center gap-2 langeditor-text langeditor-hover relative transition-all p-2 py-1.5 rounded"]),
        style: Rr({ color: t.color })
      }, [
        t.icon && !t.iconIsRight ? (J(), Ze(ii(t.icon), {
          key: 0,
          class: "w-3.5 h-3.5"
        })) : He("", !0),
        se("span", null, Ut(t.content), 1),
        t.icon && t.iconIsRight ? (J(), Ze(ii(t.icon), {
          key: 1,
          class: "w-3.5 h-3.5"
        })) : He("", !0)
      ], 6),
      t.loading ? (J(), be("div", Qte, tne)) : He("", !0)
    ]));
  }
}), nne = { class: "w-80" }, rne = /* @__PURE__ */ ae({
  __name: "LangImageModal",
  props: {
    handleUpload: {
      type: Function,
      required: !1
    }
  },
  emits: ["ok"],
  setup(t, { expose: e, emit: n }) {
    const r = et(), i = X(0), s = [
      { label: me("networkImage"), key: 0 },
      { label: me("localImage"), key: 1 }
    ], o = X(""), a = t, l = n;
    function c(b) {
      g.value = 0, u.value = null, d.value = !1, o.value = (b == null ? void 0 : b.src) || "";
    }
    const u = X(null), d = X(!1), f = X(!1), h = X("");
    async function p() {
      l("ok", h.value);
    }
    Bt(o, () => {
      h.value = o.value, d.value = !!h.value;
    });
    const g = X(0);
    function m(b) {
      g.value = b;
    }
    async function v() {
      if (f.value = !0, !!u.value) {
        if (a.handleUpload) {
          g.value = 0;
          const b = await a.handleUpload(u.value, m);
          h.value = b, o.value = h.value, d.value = !0;
        } else
          g.value = 100, h.value = URL.createObjectURL(u.value), o.value = h.value, d.value = !0;
        f.value = !1;
      }
    }
    function y(b) {
      g.value = 0, d.value = !1, h.value = "", u.value = b;
    }
    function E(b) {
      i.value = b;
    }
    return e({ open: c }), (b, _) => (J(), Ze(fi, { "content-class": "p-3 pt-1" }, {
      button: Ue(() => [
        W(Ve, {
          icon: C(U_),
          "is-active": () => C(r).isActive("image"),
          title: C(me)("image")
        }, null, 8, ["icon", "is-active", "title"])
      ]),
      content: Ue(() => [
        se("div", nne, [
          W(C(S2), { onChange: E }, {
            default: Ue(() => [
              W(C(x2), { class: "flex overflow-x-auto overflow-y-hidden border-b border-gray-200 whitespace-nowrap dark:border-gray-700" }, {
                default: Ue(() => [
                  (J(), be(Vt, null, $n(s, (w) => W(C(k2), {
                    class: It([
                      i.value === w.key ? "border-blue-500 dark:border-blue-400 dark:text-blue-300 text-blue-600" : "border-transparent",
                      "inline-flex items-center px-3 py-2 -mb-px text-xs text-center bg-transparent border-b-2 sm:text-sm whitespace-nowrap focus:outline-none"
                    ])
                  }, {
                    default: Ue(() => [
                      vv(Ut(w.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["class"])), 64))
                ]),
                _: 1
              }),
              W(C(C2), { class: "pt-2 pb-1" }, {
                default: Ue(() => [
                  W(C(Rg), { class: "text-left flex pt-2 flex-col items-center gap-2" }, {
                    default: Ue(() => [
                      W(cE, {
                        icon: C(Dc),
                        input: o.value,
                        placeholder: C(me)("imageUrlTips"),
                        onOk: _[0] || (_[0] = (w) => o.value = w)
                      }, null, 8, ["icon", "input", "placeholder"]),
                      W(ns, {
                        content: C(me)("uploadImage"),
                        icon: C(Ga),
                        loading: f.value,
                        onClick: p
                      }, null, 8, ["content", "icon", "loading"])
                    ]),
                    _: 1
                  }),
                  W(C(Rg), { class: "text-left flex flex-col gap-2" }, {
                    default: Ue(() => [
                      W(WL, { onChange: y }),
                      W(ns, {
                        content: C(me)("uploadImage"),
                        icon: C(Ga),
                        loading: f.value,
                        onClick: v
                      }, null, 8, ["content", "icon", "loading"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])
      ]),
      _: 1
    }));
  }
}), ine = { key: 0 }, sne = /* @__PURE__ */ ae({
  __name: "ImageExt",
  props: {
    handleUpload: {
      type: Function,
      required: !1
    }
  },
  setup(t) {
    const e = et();
    nt(Kte()), zf(() => {
      e.value.storage.image = {
        openUploader: null
      };
    });
    function n(r) {
      r && e.value.chain().setImage({ src: r }).focus().run();
    }
    return (r, i) => C(e) ? (J(), be("div", ine, [
      W(rne, {
        "handle-upload": t.handleUpload,
        onOk: n
      }, null, 8, ["handle-upload"])
    ])) : He("", !0);
  }
}), one = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
const ane = { class: "flex items-center gap-1" }, lne = /* @__PURE__ */ ae({
  __name: "ImageBubbleMenu",
  setup(t) {
    const e = et();
    function n() {
      const { state: r, dispatch: i } = e.value.view;
      one(r, i);
    }
    return (r, i) => (J(), be("div", ane, [
      W(Ve, {
        action: () => C(e).chain().focus().updateImage({ display: "left" }).run(),
        icon: C(Hd),
        "is-active": () => C(e).isActive("image", { display: "left" }),
        title: C(me)("leftFloat")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateImage({ display: "inline" }).run(),
        icon: C(z_),
        "is-active": () => C(e).isActive("image", { display: "inline" }),
        title: C(me)("inline")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateImage({ display: "right" }).run(),
        icon: C(H_),
        "is-active": () => C(e).isActive("image", { display: "right" }),
        title: C(me)("rightFloat")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateImage({ width: 200 }).run(),
        icon: C(MD),
        "is-active": () => C(e).isActive("image", { width: 200 }),
        title: C(me)("smallSize")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateImage({ width: 500 }).run(),
        icon: C(CD),
        "is-active": () => C(e).isActive("image", { width: 500 }),
        title: C(me)("mediumSize")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateImage({ width: "100%" }).run(),
        icon: C(OD),
        "is-active": () => C(e).isActive("image", { width: "100%" }),
        title: C(me)("fullSize")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: n,
        icon: C(zv),
        title: C(me)("delete")
      }, null, 8, ["icon", "title"])
    ]));
  }
});
function cne(t, e, n) {
  return t < e ? e : t > n ? n : t;
}
function une(t, e, n, r) {
  const { doc: i, selection: s } = t;
  if (!i || !s || !(s instanceof Te || s instanceof ur))
    return t;
  const { from: o, to: a } = s;
  return i.nodesBetween(o, a, (l, c) => {
    const u = l.type;
    return n.includes(u.name) ? (t = dne(t, c, e), !1) : !By(l.type.name, r.extensionManager.extensions);
  }), t;
}
function dne(t, e, n) {
  if (!t.doc)
    return t;
  const r = t.doc.nodeAt(e);
  if (!r)
    return t;
  const i = 0, s = 7, o = cne((r.attrs.indent || 0) + n, i, s);
  if (o === r.attrs.indent)
    return t;
  const a = {
    ...r.attrs,
    indent: o
  };
  return t.setNodeMarkup(e, r.type, a, r.marks);
}
function fO({ delta: t, types: e }) {
  return ({ state: n, dispatch: r, editor: i }) => {
    const { selection: s } = n;
    let { tr: o } = n;
    return o = o.setSelection(s), o = une(o, t, e, i), o.docChanged ? (r && r(o), !0) : !1;
  };
}
function fne(t) {
  return Et.create({
    name: "indent",
    addOptions() {
      return {
        types: ["paragraph", "heading"],
        minIndent: 0,
        maxIndent: 7,
        ...t
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            indent: {
              default: 0,
              parseHTML: (e) => {
                const n = e.getAttribute("data-indent");
                return (n ? parseInt(n, 10) : 0) || 0;
              },
              renderHTML: (e) => e.indent ? { "data-indent": e.indent } : {}
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        indent: () => fO({
          delta: 1,
          types: this.options.types
        }),
        outdent: () => fO({
          delta: -1,
          types: this.options.types
        })
      };
    },
    addKeyboardShortcuts() {
      return {
        Tab: () => this.editor.commands.indent(),
        "Shift-Tab": () => this.editor.commands.outdent()
      };
    }
  });
}
const hne = /* @__PURE__ */ ae({
  __name: "IndentExt",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    return nt(fne(t.options)), (n, r) => null;
  }
}), pne = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, gne = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, mne = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, vne = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, GL = mr.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Va({
        find: pne,
        type: this.type
      }),
      Va({
        find: mne,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      No({
        find: gne,
        type: this.type
      }),
      No({
        find: vne,
        type: this.type
      })
    ];
  }
}), bne = { key: 0 }, jL = /* @__PURE__ */ ae({
  __name: "Italic",
  props: {
    options: {
      type: Object,
      required: !1
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(GL.configure(e.options)), (r, i) => C(n) ? (J(), be("div", bne, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleItalic().run(),
          icon: C(dG),
          "is-active": () => C(n).isActive("italic"),
          mini: t.mini,
          title: C(me)("italic")
        }, null, 8, ["action", "icon", "is-active", "mini", "title"])
      ])
    ])) : He("", !0);
  }
});
function Vpe(t) {
  return GL.configure(t);
}
const yne = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", wne = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Gc = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, H1 = "numeric", U1 = "ascii", V1 = "alpha", Op = "asciinumeric", Gh = "alphanumeric", W1 = "domain", qL = "emoji", _ne = "scheme", Ene = "slashscheme", hO = "whitespace";
function Sne(t, e) {
  return t in e || (e[t] = []), e[t];
}
function ma(t, e, n) {
  e[H1] && (e[Op] = !0, e[Gh] = !0), e[U1] && (e[Op] = !0, e[V1] = !0), e[Op] && (e[Gh] = !0), e[V1] && (e[Gh] = !0), e[Gh] && (e[W1] = !0), e[qL] && (e[W1] = !0);
  for (const r in e) {
    const i = Sne(r, n);
    i.indexOf(t) < 0 && i.push(t);
  }
}
function xne(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function ar(t) {
  t === void 0 && (t = null), this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
ar.groups = {};
ar.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0], s = e.jr[r][1];
      if (s && i.test(t))
        return s;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e) {
    return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let i = 0; i < t.length; i++)
      this.tt(t[i], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || ar.groups;
    let i;
    return e && e.j ? i = e : (i = new ar(e), n && r && ma(e, n, r)), this.jr.push([t, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let i = this;
    const s = t.length;
    if (!s)
      return i;
    for (let o = 0; o < s - 1; o++)
      i = i.tt(t[o]);
    return i.tt(t[s - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || ar.groups;
    const i = this;
    if (e && e.j)
      return i.j[t] = e, e;
    const s = e;
    let o, a = i.go(t);
    if (a ? (o = new ar(), Gc(o.j, a.j), o.jr.push.apply(o.jr, a.jr), o.jd = a.jd, o.t = a.t) : o = new ar(), s) {
      if (r)
        if (o.t && typeof o.t == "string") {
          const l = Gc(xne(o.t, r), n);
          ma(s, l, r);
        } else
          n && ma(s, n, r);
      o.t = s;
    }
    return i.j[t] = o, o;
  }
};
const ot = (t, e, n, r, i) => t.ta(e, n, r, i), Wr = (t, e, n, r, i) => t.tr(e, n, r, i), pO = (t, e, n, r, i) => t.ts(e, n, r, i), we = (t, e, n, r, i) => t.tt(e, n, r, i), ks = "WORD", G1 = "UWORD", rf = "LOCALHOST", j1 = "TLD", q1 = "UTLD", Mp = "SCHEME", Ul = "SLASH_SCHEME", JE = "NUM", KL = "WS", ZE = "NL", fd = "OPENBRACE", hd = "CLOSEBRACE", qg = "OPENBRACKET", Kg = "CLOSEBRACKET", Yg = "OPENPAREN", Xg = "CLOSEPAREN", Jg = "OPENANGLEBRACKET", Zg = "CLOSEANGLEBRACKET", Qg = "FULLWIDTHLEFTPAREN", em = "FULLWIDTHRIGHTPAREN", tm = "LEFTCORNERBRACKET", nm = "RIGHTCORNERBRACKET", rm = "LEFTWHITECORNERBRACKET", im = "RIGHTWHITECORNERBRACKET", sm = "FULLWIDTHLESSTHAN", om = "FULLWIDTHGREATERTHAN", am = "AMPERSAND", lm = "APOSTROPHE", cm = "ASTERISK", ao = "AT", um = "BACKSLASH", dm = "BACKTICK", fm = "CARET", uo = "COLON", QE = "COMMA", hm = "DOLLAR", Wi = "DOT", pm = "EQUALS", eS = "EXCLAMATION", Gi = "HYPHEN", gm = "PERCENT", mm = "PIPE", vm = "PLUS", bm = "POUND", ym = "QUERY", tS = "QUOTE", nS = "SEMI", ji = "SLASH", pd = "TILDE", wm = "UNDERSCORE", YL = "EMOJI", _m = "SYM";
var XL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: ks,
  UWORD: G1,
  LOCALHOST: rf,
  TLD: j1,
  UTLD: q1,
  SCHEME: Mp,
  SLASH_SCHEME: Ul,
  NUM: JE,
  WS: KL,
  NL: ZE,
  OPENBRACE: fd,
  CLOSEBRACE: hd,
  OPENBRACKET: qg,
  CLOSEBRACKET: Kg,
  OPENPAREN: Yg,
  CLOSEPAREN: Xg,
  OPENANGLEBRACKET: Jg,
  CLOSEANGLEBRACKET: Zg,
  FULLWIDTHLEFTPAREN: Qg,
  FULLWIDTHRIGHTPAREN: em,
  LEFTCORNERBRACKET: tm,
  RIGHTCORNERBRACKET: nm,
  LEFTWHITECORNERBRACKET: rm,
  RIGHTWHITECORNERBRACKET: im,
  FULLWIDTHLESSTHAN: sm,
  FULLWIDTHGREATERTHAN: om,
  AMPERSAND: am,
  APOSTROPHE: lm,
  ASTERISK: cm,
  AT: ao,
  BACKSLASH: um,
  BACKTICK: dm,
  CARET: fm,
  COLON: uo,
  COMMA: QE,
  DOLLAR: hm,
  DOT: Wi,
  EQUALS: pm,
  EXCLAMATION: eS,
  HYPHEN: Gi,
  PERCENT: gm,
  PIPE: mm,
  PLUS: vm,
  POUND: bm,
  QUERY: ym,
  QUOTE: tS,
  SEMI: nS,
  SLASH: ji,
  TILDE: pd,
  UNDERSCORE: wm,
  EMOJI: YL,
  SYM: _m
});
const Tl = /[a-z]/, Ib = /\p{L}/u, Pb = /\p{Emoji}/u, Lb = /\d/, gO = /\s/, mO = `
`, kne = "️", Cne = "‍";
let jh = null, qh = null;
function Tne(t) {
  t === void 0 && (t = []);
  const e = {};
  ar.groups = e;
  const n = new ar();
  jh == null && (jh = vO(yne)), qh == null && (qh = vO(wne)), we(n, "'", lm), we(n, "{", fd), we(n, "}", hd), we(n, "[", qg), we(n, "]", Kg), we(n, "(", Yg), we(n, ")", Xg), we(n, "<", Jg), we(n, ">", Zg), we(n, "（", Qg), we(n, "）", em), we(n, "「", tm), we(n, "」", nm), we(n, "『", rm), we(n, "』", im), we(n, "＜", sm), we(n, "＞", om), we(n, "&", am), we(n, "*", cm), we(n, "@", ao), we(n, "`", dm), we(n, "^", fm), we(n, ":", uo), we(n, ",", QE), we(n, "$", hm), we(n, ".", Wi), we(n, "=", pm), we(n, "!", eS), we(n, "-", Gi), we(n, "%", gm), we(n, "|", mm), we(n, "+", vm), we(n, "#", bm), we(n, "?", ym), we(n, '"', tS), we(n, "/", ji), we(n, ";", nS), we(n, "~", pd), we(n, "_", wm), we(n, "\\", um);
  const r = Wr(n, Lb, JE, {
    [H1]: !0
  });
  Wr(r, Lb, r);
  const i = Wr(n, Tl, ks, {
    [U1]: !0
  });
  Wr(i, Tl, i);
  const s = Wr(n, Ib, G1, {
    [V1]: !0
  });
  Wr(s, Tl), Wr(s, Ib, s);
  const o = Wr(n, gO, KL, {
    [hO]: !0
  });
  we(n, mO, ZE, {
    [hO]: !0
  }), we(o, mO), Wr(o, gO, o);
  const a = Wr(n, Pb, YL, {
    [qL]: !0
  });
  Wr(a, Pb, a), we(a, kne, a);
  const l = we(a, Cne);
  Wr(l, Pb, a);
  const c = [[Tl, i]], u = [[Tl, null], [Ib, s]];
  for (let d = 0; d < jh.length; d++)
    to(n, jh[d], j1, ks, c);
  for (let d = 0; d < qh.length; d++)
    to(n, qh[d], q1, G1, u);
  ma(j1, {
    tld: !0,
    ascii: !0
  }, e), ma(q1, {
    utld: !0,
    alpha: !0
  }, e), to(n, "file", Mp, ks, c), to(n, "mailto", Mp, ks, c), to(n, "http", Ul, ks, c), to(n, "https", Ul, ks, c), to(n, "ftp", Ul, ks, c), to(n, "ftps", Ul, ks, c), ma(Mp, {
    scheme: !0,
    ascii: !0
  }, e), ma(Ul, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((d, f) => d[0] > f[0] ? 1 : -1);
  for (let d = 0; d < t.length; d++) {
    const f = t[d][0], p = t[d][1] ? {
      [_ne]: !0
    } : {
      [Ene]: !0
    };
    f.indexOf("-") >= 0 ? p[W1] = !0 : Tl.test(f) ? Lb.test(f) ? p[Op] = !0 : p[U1] = !0 : p[H1] = !0, pO(n, f, f, p);
  }
  return pO(n, "localhost", rf, {
    ascii: !0
  }), n.jd = new ar(_m), {
    start: n,
    tokens: Gc({
      groups: e
    }, XL)
  };
}
function One(t, e) {
  const n = Mne(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let s = 0, o = 0;
  for (; o < r; ) {
    let a = t, l = null, c = 0, u = null, d = -1, f = -1;
    for (; o < r && (l = a.go(n[o])); )
      a = l, a.accepts() ? (d = 0, f = 0, u = a) : d >= 0 && (d += n[o].length, f++), c += n[o].length, s += n[o].length, o++;
    s -= d, o -= f, c -= d, i.push({
      t: u.t,
      // token type/name
      v: e.slice(s - c, s),
      // string value
      s: s - c,
      // start index
      e: s
      // end index (excluding)
    });
  }
  return i;
}
function Mne(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let i = t.charCodeAt(r), s, o = i < 55296 || i > 56319 || r + 1 === n || (s = t.charCodeAt(r + 1)) < 56320 || s > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(o), r += o.length;
  }
  return e;
}
function to(t, e, n, r, i) {
  let s;
  const o = e.length;
  for (let a = 0; a < o - 1; a++) {
    const l = e[a];
    t.j[l] ? s = t.j[l] : (s = new ar(r), s.jr = i.slice(), t.j[l] = s), t = s;
  }
  return s = new ar(n), s.jr = i.slice(), t.j[e[o - 1]] = s, s;
}
function vO(t) {
  const e = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < t.length; ) {
    let s = 0;
    for (; i.indexOf(t[r + s]) >= 0; )
      s++;
    if (s > 0) {
      e.push(n.join(""));
      for (let o = parseInt(t.substring(r, r + s), 10); o > 0; o--)
        n.pop();
      r += s;
    } else
      n.push(t[r]), r++;
  }
  return e;
}
const sf = {
  defaultProtocol: "http",
  events: null,
  format: bO,
  formatHref: bO,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function rS(t, e) {
  e === void 0 && (e = null);
  let n = Gc({}, sf);
  t && (n = Gc(n, t instanceof rS ? t.o : t));
  const r = n.ignoreTags, i = [];
  for (let s = 0; s < r.length; s++)
    i.push(r[s].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = i;
}
rS.prototype = {
  o: sf,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let i = this.o[t];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : sf[t], typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function bO(t) {
  return t;
}
function JL(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
JL.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t) {
    return t === void 0 && (t = sf.defaultProtocol), {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), i = t.get("tagName", n, e), s = this.toFormattedString(t), o = {}, a = t.get("className", n, e), l = t.get("target", n, e), c = t.get("rel", n, e), u = t.getObj("attributes", n, e), d = t.getObj("events", n, e);
    return o.href = r, a && (o.class = a), l && (o.target = l), c && (o.rel = c), u && Gc(o, u), {
      tagName: i,
      attributes: o,
      content: s,
      eventListeners: d
    };
  }
};
function u0(t, e) {
  class n extends JL {
    constructor(i, s) {
      super(i, s), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const yO = u0("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), wO = u0("text"), Ane = u0("nl"), Kh = u0("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t) {
    return t === void 0 && (t = sf.defaultProtocol), this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== rf && t[1].t === uo;
  }
}), Gr = (t) => new ar(t);
function Nne(t) {
  let {
    groups: e
  } = t;
  const n = e.domain.concat([am, cm, ao, um, dm, fm, hm, pm, Gi, JE, gm, mm, vm, bm, ji, _m, pd, wm]), r = [lm, uo, QE, Wi, eS, ym, tS, nS, Jg, Zg, fd, hd, Kg, qg, Yg, Xg, Qg, em, tm, nm, rm, im, sm, om], i = [am, lm, cm, um, dm, fm, hm, pm, Gi, fd, hd, gm, mm, vm, bm, ym, ji, _m, pd, wm], s = Gr(), o = we(s, pd);
  ot(o, i, o), ot(o, e.domain, o);
  const a = Gr(), l = Gr(), c = Gr();
  ot(s, e.domain, a), ot(s, e.scheme, l), ot(s, e.slashscheme, c), ot(a, i, o), ot(a, e.domain, a);
  const u = we(a, ao);
  we(o, ao, u), we(l, ao, u), we(c, ao, u);
  const d = we(o, Wi);
  ot(d, i, o), ot(d, e.domain, o);
  const f = Gr();
  ot(u, e.domain, f), ot(f, e.domain, f);
  const h = we(f, Wi);
  ot(h, e.domain, f);
  const p = Gr(yO);
  ot(h, e.tld, p), ot(h, e.utld, p), we(u, rf, p);
  const g = we(f, Gi);
  ot(g, e.domain, f), ot(p, e.domain, f), we(p, Wi, h), we(p, Gi, g);
  const m = we(p, uo);
  ot(m, e.numeric, yO);
  const v = we(a, Gi), y = we(a, Wi);
  ot(v, e.domain, a), ot(y, i, o), ot(y, e.domain, a);
  const E = Gr(Kh);
  ot(y, e.tld, E), ot(y, e.utld, E), ot(E, e.domain, a), ot(E, i, o), we(E, Wi, y), we(E, Gi, v), we(E, ao, u);
  const b = we(E, uo), _ = Gr(Kh);
  ot(b, e.numeric, _);
  const w = Gr(Kh), S = Gr();
  ot(w, n, w), ot(w, r, S), ot(S, n, w), ot(S, r, S), we(E, ji, w), we(_, ji, w);
  const x = we(l, uo), k = we(c, uo), T = we(k, ji), I = we(T, ji);
  ot(l, e.domain, a), we(l, Wi, y), we(l, Gi, v), ot(c, e.domain, a), we(c, Wi, y), we(c, Gi, v), ot(x, e.domain, w), we(x, ji, w), ot(I, e.domain, w), ot(I, n, w), we(I, ji, w);
  const R = [
    [fd, hd],
    // {}
    [qg, Kg],
    // []
    [Yg, Xg],
    // ()
    [Jg, Zg],
    // <>
    [Qg, em],
    // （）
    [tm, nm],
    // 「」
    [rm, im],
    // 『』
    [sm, om]
    // ＜＞
  ];
  for (let N = 0; N < R.length; N++) {
    const [$, B] = R[N], G = we(w, $);
    we(S, $, G), we(G, B, w);
    const M = Gr(Kh);
    ot(G, n, M);
    const A = Gr();
    ot(G, r), ot(M, n, M), ot(M, r, A), ot(A, n, M), ot(A, r, A), we(M, B, w), we(A, B, w);
  }
  return we(s, rf, E), we(s, ZE, Ane), {
    start: s,
    tokens: XL
  };
}
function Rne(t, e, n) {
  let r = n.length, i = 0, s = [], o = [];
  for (; i < r; ) {
    let a = t, l = null, c = null, u = 0, d = null, f = -1;
    for (; i < r && !(l = a.go(n[i].t)); )
      o.push(n[i++]);
    for (; i < r && (c = l || a.go(n[i].t)); )
      l = null, a = c, a.accepts() ? (f = 0, d = a) : f >= 0 && f++, i++, u++;
    if (f < 0)
      i -= u, i < r && (o.push(n[i]), i++);
    else {
      o.length > 0 && (s.push($b(wO, e, o)), o = []), i -= f, u -= f;
      const h = d.t, p = n.slice(i - u, i);
      s.push($b(h, e, p));
    }
  }
  return o.length > 0 && s.push($b(wO, e, o)), s;
}
function $b(t, e, n) {
  const r = n[0].s, i = n[n.length - 1].e, s = e.slice(r, i);
  return new t(s, n);
}
const Dne = typeof console < "u" && console && console.warn || (() => {
}), Ine = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", jt = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function Pne() {
  ar.groups = {}, jt.scanner = null, jt.parser = null, jt.tokenQueue = [], jt.pluginQueue = [], jt.customSchemes = [], jt.initialized = !1;
}
function _O(t, e) {
  if (e === void 0 && (e = !1), jt.initialized && Dne(`linkifyjs: already initialized - will not register custom scheme "${t}" ${Ine}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  jt.customSchemes.push([t, e]);
}
function Lne() {
  jt.scanner = Tne(jt.customSchemes);
  for (let t = 0; t < jt.tokenQueue.length; t++)
    jt.tokenQueue[t][1]({
      scanner: jt.scanner
    });
  jt.parser = Nne(jt.scanner.tokens);
  for (let t = 0; t < jt.pluginQueue.length; t++)
    jt.pluginQueue[t][1]({
      scanner: jt.scanner,
      parser: jt.parser
    });
  jt.initialized = !0;
}
function ZL(t) {
  return jt.initialized || Lne(), Rne(jt.parser.start, t, One(jt.scanner.start, t));
}
function QL(t, e, n) {
  if (e === void 0 && (e = null), n === void 0 && (n = null), e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new rS(n), i = ZL(t), s = [];
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    a.isLink && (!e || a.t === e) && r.check(a) && s.push(a.toFormattedObject(r));
  }
  return s;
}
function $ne(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function Bne(t) {
  return new ut({
    key: new ft("autolink"),
    appendTransaction: (e, n, r) => {
      const i = e.some((c) => c.docChanged) && !n.doc.eq(r.doc), s = e.some((c) => c.getMeta("preventAutolink"));
      if (!i || s)
        return;
      const { tr: o } = r, a = yV(n.doc, [...e]);
      if (TV(a).forEach(({ newRange: c }) => {
        const u = _V(r.doc, c, (h) => h.isTextblock);
        let d, f;
        if (u.length > 1 ? (d = u[0], f = r.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && r.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (d = u[0], f = r.doc.textBetween(d.pos, c.to, void 0, " ")), d && f) {
          const h = f.split(" ").filter((v) => v !== "");
          if (h.length <= 0)
            return !1;
          const p = h[h.length - 1], g = d.pos + f.lastIndexOf(p);
          if (!p)
            return !1;
          const m = ZL(p).map((v) => v.toObject(t.defaultProtocol));
          if (!$ne(m))
            return !1;
          m.filter((v) => v.isLink).map((v) => ({
            ...v,
            from: g + v.start + 1,
            to: g + v.end + 1
          })).filter((v) => r.schema.marks.code ? !r.doc.rangeHasMark(v.from, v.to, r.schema.marks.code) : !0).filter((v) => t.validate(v.value)).forEach((v) => {
            y_(v.from, v.to, r.doc).some((y) => y.mark.type === t.type) || o.addMark(v.from, v.to, t.type.create({
              href: v.href
            }));
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function Fne(t) {
  return new ut({
    key: new ft("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var i, s;
        if (r.button !== 0 || !e.editable)
          return !1;
        let o = r.target;
        const a = [];
        for (; o.nodeName !== "DIV"; )
          a.push(o), o = o.parentNode;
        if (!a.find((f) => f.nodeName === "A"))
          return !1;
        const l = b_(e.state, t.type.name), c = r.target, u = (i = c == null ? void 0 : c.href) !== null && i !== void 0 ? i : l.href, d = (s = c == null ? void 0 : c.target) !== null && s !== void 0 ? s : l.target;
        return c && u ? (window.open(u, d), !0) : !1;
      }
    }
  });
}
function zne(t) {
  return new ut({
    key: new ft("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: i } = e, { selection: s } = i, { empty: o } = s;
        if (o)
          return !1;
        let a = "";
        r.content.forEach((c) => {
          a += c.textContent;
        });
        const l = QL(a, { defaultProtocol: t.defaultProtocol }).find((c) => c.isLink && c.value === a);
        return !a || !l ? !1 : (t.editor.commands.setMark(t.type, {
          href: l.href
        }), !0);
      }
    }
  });
}
const Hne = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function EO(t, e) {
  const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return e && e.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && n.push(i);
  }), !t || t.replace(Hne, "").match(new RegExp(`^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, "i"));
}
const Une = mr.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        _O(t);
        return;
      }
      _O(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    Pne();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [{
      tag: "a[href]",
      getAttrs: (t) => {
        const e = t.getAttribute("href");
        return !e || !EO(e, this.options.protocols) ? !1 : null;
      }
    }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return EO(t.href, this.options.protocols) ? ["a", _t(this.options.HTMLAttributes, t), 0] : ["a", _t(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => e().setMark(this.name, t).setMeta("preventAutolink", !0).run(),
      toggleLink: (t) => ({ chain: e }) => e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      No({
        find: (t) => {
          const e = [];
          if (t) {
            const { validate: n } = this.options, r = QL(t).filter((i) => i.isLink && n(i.value));
            r.length && r.forEach((i) => e.push({
              text: i.value,
              data: {
                href: i.href
              },
              index: i.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [];
    return this.options.autolink && t.push(Bne({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: this.options.validate
    })), this.options.openOnClick === !0 && t.push(Fne({
      type: this.type
    })), this.options.linkOnPaste && t.push(zne({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
});
function Vne(t) {
  return new ut({
    key: new ft("handleClickLink"),
    props: {
      handleClick: (e, n, r) => t.handleClick ? t.handleClick(e, n, r, t.type) : !1,
      handleKeyDown: () => t.handleKeyDown ? t.handleKeyDown() : !1
    }
  });
}
function Wne(t) {
  return Une.extend({
    addProseMirrorPlugins() {
      const e = this.parent().filter((n) => !n.spec.key.key.startsWith("handleClickLink"));
      return this.options.openOnClick && e.push(
        Vne({
          type: this.type,
          handleClick: t.handleClick,
          handleKeyDown: t.handleKeyDown
        })
      ), e;
    }
  }).configure(t);
}
const Gne = { class: "flex flex-col border-gray-100 w-64 rounded-md p-3 gap-2" }, jne = { class: "flex items-center rounded-md gap-1 relative" }, qne = ["placeholder"], Kne = { class: "flex items-center rounded-md gap-1 relative" }, Yne = ["placeholder"], Xne = /* @__PURE__ */ ae({
  __name: "LinkModel",
  props: {
    href: {
      type: String,
      required: !0
    },
    text: {
      type: String,
      required: !0
    }
  },
  emits: ["ok"],
  setup(t, { emit: e }) {
    const n = e, r = et(), i = X({
      href: "",
      text: ""
    });
    function s() {
      n("ok", i.value.text, i.value.href);
    }
    return (o, a) => (J(), Ze(fi, { "content-class": "rounded-md !p-0 langeditor-bg" }, {
      button: Ue(() => [
        W(Ve, {
          icon: C(Dc),
          "is-active": () => {
            var l;
            return (l = C(r)) == null ? void 0 : l.isActive("link");
          },
          title: C(me)("link")
        }, null, 8, ["icon", "is-active", "title"])
      ]),
      content: Ue(() => [
        se("div", Gne, [
          se("div", jne, [
            W(C(Dc), { class: "absolute left-3 w-3 h-3" }),
            Yr(se("input", {
              "onUpdate:modelValue": a[0] || (a[0] = (l) => i.value.href = l),
              placeholder: C(me)("linkUrlTips"),
              class: "flex w-full pl-8 px-3 rounded-md py-2 langeditor-text langeditor-hover langeditor-border text-sm langeditor-bg"
            }, null, 8, qne), [
              [vc, i.value.href]
            ])
          ]),
          se("div", Kne, [
            W(C(Hd), { class: "absolute left-3 w-3 h-3" }),
            Yr(se("input", {
              "onUpdate:modelValue": a[1] || (a[1] = (l) => i.value.text = l),
              placeholder: C(me)("linkTextTips"),
              class: "flex w-full pl-8 px-3 rounded-md py-2 langeditor-text langeditor-hover langeditor-border text-sm langeditor-bg"
            }, null, 8, Yne), [
              [vc, i.value.text]
            ])
          ]),
          W(ns, {
            content: C(me)("insertLink"),
            onClick: s
          }, null, 8, ["content"])
        ])
      ]),
      _: 1
    }));
  }
}), Jne = { style: { display: "none" } }, Zne = { class: "flex bg-white z-10 border-gray-100 p-2 flex-col w-80 shadow-md border rounded-md overflow-hidden" }, Qne = { class: "flex items-center justify-between mb-2" }, ere = { class: "flex items-center gap-1 relative px-1" }, tre = { class: "text-stone-600 rounded-md text-sm bg-gray-100 text-left p-2 py-1.5 w-fit hover:bg-gray-200 transition-all cursor-pointer" }, nre = { class: "flex items-center gap-1 relative border border-gray-100 !bg-gray-100 rounded-md" }, rre = ["placeholder"], ire = /* @__PURE__ */ ae({
  __name: "LinkExt",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = et(), n = X(), r = X(!1), i = X(""), s = X(""), o = X("_blank");
    let a;
    function l() {
      e.value.isActive("link") && e.value.chain().focus().unsetLink().run();
    }
    zf(() => {
      e.value.storage.link = {
        openLink: l
      };
    });
    function c(m, v) {
      String(v).length != 0 && (String(m).length == 0 && (m = v), e.value.chain().insertContent({
        type: "text",
        text: m,
        marks: [
          {
            type: "link",
            attrs: {
              href: v,
              target: "_blank"
            }
          }
        ]
      }).setLink({ href: v }).focus().run());
    }
    function u(m, v, y, E) {
      if (!m.editable || y.button !== 0)
        return !1;
      let b = y.target;
      const _ = [];
      for (; b.nodeName !== "DIV"; )
        _.push(b), b = b.parentNode;
      if (!_.find((k) => k.nodeName === "A"))
        return !1;
      const w = b_(m.state, E.name), S = y.target, x = m.state.doc.nodeAt(v);
      if (x && x.marks.filter((T) => T.type.name === "link").length) {
        const { schema: T, doc: I, tr: R } = m.state, N = Nv(I.resolve(v), T.marks.link);
        if (!N)
          return !1;
        const $ = I.resolve(N.from), B = I.resolve(N.to), G = R.setSelection(new Te($, B));
        return m.dispatch(G), f(), d(S, w), !0;
      }
      return !1;
    }
    function d(m, v) {
      if (!n.value)
        return;
      s.value = (m == null ? void 0 : m.href) ?? v.href, i.value = (m == null ? void 0 : m.innerText) ?? v.text, o.value = (m == null ? void 0 : m.target) ?? v.target;
      const y = document.createElement("div");
      y.append(n.value), a = Vo("body", {
        duration: 0,
        getReferenceClientRect: () => m.getBoundingClientRect(),
        content: y,
        interactive: !0,
        trigger: "manual",
        placement: "bottom-start"
      })[0], a.show();
    }
    function f() {
      return a && a.destroy(), r.value = !1, !1;
    }
    nt(
      Wne({
        handleClick: u,
        handleKeyDown: f,
        protocols: ["ftp", "mailto", "http", "https"],
        autolink: !1
      })
    );
    function h() {
      e.value.chain().focus().unsetLink().run(), f();
    }
    function p() {
      e.value.chain().extendMarkRange("link").setLink({ href: s.value, target: "_blank" }).focus().run(), f();
    }
    function g() {
      window.open(s.value, "_blank");
    }
    return (m, v) => (J(), be("div", null, [
      Lt(m.$slots, "default", {}, () => [
        W(Xne, {
          href: s.value,
          text: i.value,
          onOk: c
        }, null, 8, ["href", "text"])
      ]),
      se("div", Jne, [
        se("div", {
          ref_key: "root",
          ref: n
        }, [
          se("div", Zne, [
            se("div", Qne, [
              se("div", ere, [
                W(Ve, {
                  action: g,
                  icon: C(sG),
                  title: C(me)("openLink")
                }, null, 8, ["icon", "title"]),
                W(Ve, {
                  action: h,
                  icon: C($G),
                  title: C(me)("unsetLink")
                }, null, 8, ["icon", "title"])
              ]),
              se("div", tre, Ut(C(me)("saveLink")), 1)
            ]),
            se("div", nre, [
              W(C(Dc), { class: "absolute left-3 w-3 h-3" }),
              Yr(se("input", {
                "onUpdate:modelValue": v[0] || (v[0] = (y) => s.value = y),
                placeholder: C(me)("linkUrlTips"),
                class: "flex w-full pl-8 px-3 py-2 bg-transparent text-sm hover:outline-1 hover:outline-stone-700 !focus:outline-none focus-visible:outline-none",
                onKeydown: mA(p, ["enter"])
              }, null, 40, rre), [
                [vc, s.value]
              ])
            ])
          ])
        ], 512)
      ])
    ]));
  }
}), e$ = an.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", _t(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), sre = /* @__PURE__ */ ae({
  __name: "ListItem",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t;
    return nt(e$.configure(e.options)), (n, r) => null;
  }
});
function Wpe(t) {
  return e$.configure(t);
}
function ore() {
  return an.create({
    name: "hb-math",
    addOptions() {
      return {
        inline: !0,
        HTMLAttributes: {}
      };
    },
    inline() {
      return this.options.inline;
    },
    group() {
      return this.options.inline ? "inline" : "block";
    },
    draggable: !1,
    addAttributes() {
      return {
        tex: ""
      };
    },
    parseHTML() {
      return [
        {
          tag: "span[tex]"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["span", _t(this.options.HTMLAttributes, e)];
    },
    addCommands() {
      return {
        setHbMath: (e) => ({ commands: n }) => n.insertContent({
          type: this.name,
          attrs: e
        })
      };
    }
  }).extend({
    addNodeView() {
      return Lv(new n2());
    }
  });
}
const t$ = (t) => (vA("data-v-f9e675e2"), t = t(), bA(), t), are = { class: "p-2 flex flex-col gap-3 w-80 !langeditor-bg" }, lre = { class: "flex items-center gap-2" }, cre = { class: "grid my-1 grid-cols-12 gap-1 grip-row" }, ure = ["onClick"], dre = { class: "item-hover" }, fre = { class: "grid my-1 grid-cols-12 gap-1 grip-row" }, hre = ["onClick"], pre = { class: "item-hover" }, gre = /* @__PURE__ */ t$(() => /* @__PURE__ */ se("label", {
  class: "block text-left text-xs text-gray-500 dark:text-gray-300",
  for: "Description"
}, " TeX公式 ", -1)), mre = /* @__PURE__ */ t$(() => /* @__PURE__ */ se("label", {
  class: "block text-left text-xs text-gray-500 dark:text-gray-300",
  for: "Description"
}, " 渲染内容 ", -1)), vre = /* @__PURE__ */ ae({
  __name: "LangMathModal",
  props: {
    content: {
      type: String,
      require: !1,
      default: ""
    }
  },
  emits: ["ok"],
  setup(t, { emit: e }) {
    const n = t, r = {
      α: "\\alpha",
      β: "\\beta",
      γ: "\\gamma",
      δ: "\\delta",
      "ϵ": "\\epsilon",
      ζ: "\\zeta",
      η: "\\eta",
      θ: "\\theta",
      ι: "\\iota",
      κ: "\\kappa",
      λ: "\\lambda",
      μ: "\\mu",
      ν: "\\nu",
      ξ: "\\xi",
      ο: "\\omicron",
      π: "\\pi",
      ρ: "\\rho",
      σ: "\\sigma",
      τ: "\\tau",
      υ: "\\upsilon",
      ϕ: "\\phi",
      χ: "\\chi",
      ψ: "\\psi",
      ω: "\\omega",
      ε: "\\varepsilon",
      ϰ: "\\varkappa",
      ϑ: "\\vartheta",
      ϖ: "\\varpi",
      ϱ: "\\varrho",
      ς: "\\varsigma",
      φ: "\\varphi",
      ϝ: "\\digamma"
    }, i = {
      "×": "\\times",
      "÷": "\\div",
      "≈": "\\approx",
      "≪": "\\ll",
      "≫": "\\gg",
      "≂": "\\eqsim",
      "⪖": "\\eqslantgtr",
      "⪕": "\\eqslantless",
      "⊕": "\\oplus",
      "±": "\\pm",
      "∙": "\\bullet",
      "∀": "\\forall",
      "∁": "\\complement",
      "∴": "\\therefore",
      "∅": "\\varnothing",
      "∃": "\\exists",
      "⊂": "\\subset",
      "∵": "\\because",
      "⊃": "\\supset",
      "↦": "\\mapsto",
      "∄": "\\nexists",
      "∣": "\\mid",
      "→": "\\to",
      "⟹": "\\implies",
      "∈": "\\in",
      "∧": "\\land",
      "←": "\\gets",
      "⟸": "\\impliedby",
      "∨": "\\lor",
      "↔": "\\leftrightarrow",
      "⟺": "\\iff",
      "∋": "\\ni",
      "¬": "\\neg"
    }, s = X(""), o = X();
    Zt(() => {
      s.value = n.content;
    });
    function a(f) {
      const h = o.value.selectionStart, p = o.value.selectionEnd;
      s.value = s.value.substr(0, h) + f + s.value.substr(p, s.value.length);
    }
    Bt(s, () => {
      u();
    });
    const l = X(), c = e;
    function u() {
      if (!s.value) {
        l.value.innerHTML = "";
        return;
      }
      yA.render(s.value, l.value, {
        throwOnError: !1
      });
    }
    function d() {
      c("ok", s.value);
    }
    return (f, h) => (J(), be("div", are, [
      se("div", lre, [
        W(kg, null, {
          button: Ue(() => [
            W(ns, {
              icon: C(Jy),
              content: "希腊字母"
            }, null, 8, ["icon"])
          ]),
          content: Ue(() => [
            se("div", cre, [
              (J(), be(Vt, null, $n(r, (p, g) => se("div", {
                key: g,
                onClick: (m) => a(p)
              }, [
                se("div", dre, Ut(g), 1)
              ], 8, ure)), 64))
            ])
          ]),
          _: 1
        }),
        W(kg, null, {
          button: Ue(() => [
            W(ns, {
              icon: C(Jy),
              content: "逻辑符号"
            }, null, 8, ["icon"])
          ]),
          content: Ue(() => [
            se("div", fre, [
              (J(), be(Vt, null, $n(i, (p, g) => se("div", {
                key: g,
                onClick: (m) => a(p)
              }, [
                se("div", pre, Ut(g), 1)
              ], 8, hre)), 64))
            ])
          ]),
          _: 1
        })
      ]),
      se("div", null, [
        gre,
        Yr(se("textarea", {
          ref_key: "TEXAREA",
          ref: o,
          "onUpdate:modelValue": h[0] || (h[0] = (p) => s.value = p),
          class: "block mt-1 w-full placeholder-gray-400/70 dark:placeholder-gray-500 rounded-lg langeditor-border langeditor-text langeditor-bg px-4 h-28 py-2.5 focus:outline-none focus:ring focus:ring-blue-300 focus:ring-opacity-40",
          placeholder: "输入TeX公式..."
        }, null, 512), [
          [vc, s.value]
        ])
      ]),
      se("div", null, [
        mre,
        se("div", {
          ref_key: "box",
          ref: l,
          class: "block text-left mt-1 border-dashed w-full placeholder-gray-400/70 dark:placeholder-gray-500 rounded-lg langeditor-border langeditor-text langeditor-bg px-4 h-24 py-2.5 focus:outline-none focus:ring focus:ring-blue-300 focus:ring-opacity-40 dark:focus:border-blue-300"
        }, null, 512)
      ]),
      W(ns, {
        icon: C(Ga),
        content: "插入公式",
        onClick: d
      }, null, 8, ["icon"])
    ]));
  }
});
const n$ = /* @__PURE__ */ wr(vre, [["__scopeId", "data-v-f9e675e2"]]), bre = { key: 0 }, yre = /* @__PURE__ */ ae({
  __name: "MathExt",
  setup(t) {
    const e = et();
    nt(ore()), zf(() => {
      e.value.storage["hb-math"] = {
        openEditor: null
      };
    });
    function n(r) {
      e.value.chain().focus().setHbMath({ tex: r }).run();
    }
    return (r, i) => C(e) ? (J(), be("div", bre, [
      Lt(r.$slots, "default", {}, () => [
        W(fi, null, {
          button: Ue(() => [
            W(Ve, {
              icon: C(ND),
              "is-active": () => C(e).isActive("hb-math"),
              title: C(me)("math")
            }, null, 8, ["icon", "is-active", "title"])
          ]),
          content: Ue(() => [
            W(n$, { onOk: n })
          ]),
          _: 1
        })
      ])
    ])) : He("", !0);
  }
}), wre = { class: "flex items-center gap-1 px-2" }, _re = /* @__PURE__ */ ae({
  __name: "MathBubbleMenu",
  setup(t) {
    const e = et(), n = X("");
    function r() {
      const o = e.value.state.selection;
      o.node && (n.value = o.node.attrs.tex);
    }
    function i() {
      e.value.commands.deleteSelection();
    }
    function s(o) {
      if (!o) {
        e.value.commands.deleteSelection();
        return;
      }
      const a = e.value.state.selection;
      e.value.commands.command(({ tr: c }) => {
        const u = a.from;
        return c.setNodeMarkup(u, void 0, {
          tex: o
        }), !0;
      });
    }
    return (o, a) => (J(), be("div", wre, [
      W(fi, null, {
        button: Ue(() => [
          W(Ve, {
            action: r,
            icon: C(yG),
            "is-active": () => {
            },
            title: "修改公式"
          }, null, 8, ["icon"])
        ]),
        content: Ue(() => [
          W(n$, {
            content: n.value,
            onOk: s
          }, null, 8, ["content"])
        ]),
        _: 1
      }),
      W(Ve, {
        action: i,
        icon: C(zv),
        "is-active": () => {
        },
        title: "删除"
      }, null, 8, ["icon"])
    ]));
  }
}), Ere = "listItem", SO = "textStyle", xO = /^(\d+)\.\s$/, r$ = an.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", _t(this.options.HTMLAttributes, n), 0] : ["ol", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Ere, this.editor.getAttributes(SO)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = Ec({
      find: xO,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Ec({
      find: xO,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(SO) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), Sre = { key: 0 }, xre = /* @__PURE__ */ ae({
  __name: "OrderedList",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(r$.configure(e.options)), (r, i) => C(n) ? (J(), be("div", Sre, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleOrderedList().run(),
          icon: C(hG),
          "is-active": () => C(n).isActive("orderedList"),
          title: C(me)("orderList")
        }, null, 8, ["action", "icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
});
function Gpe(t) {
  return r$.configure(t);
}
const i$ = an.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), kre = { key: 0 }, Cre = /* @__PURE__ */ ae({
  __name: "Paragraph",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(i$.configure(e.options)), (r, i) => C(n) ? (J(), be("div", kre)) : He("", !0);
  }
});
function jpe(t) {
  return i$.configure(t);
}
const Tre = Et.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      considerAnyAsEmpty: !1,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            var n;
            const r = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = e, s = [];
            if (!r)
              return null;
            const { firstChild: o } = t.content, a = o && o.type.isLeaf, l = o && o.isAtom, c = this.options.considerAnyAsEmpty ? !0 : o && o.type.name === ((n = t.type.contentMatch.defaultType) === null || n === void 0 ? void 0 : n.name), u = t.content.childCount <= 1 && o && c && o.nodeSize <= 2 && (!a || !l);
            return t.descendants((d, f) => {
              const h = i >= f && i <= f + d.nodeSize, p = !d.isLeaf && !d.childCount;
              if ((h || !this.options.showOnlyCurrent) && p) {
                const g = [this.options.emptyNodeClass];
                u && g.push(this.options.emptyEditorClass);
                const m = xn.node(f, f + d.nodeSize, {
                  class: g.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: d,
                    pos: f,
                    hasAnchor: h
                  }) : this.options.placeholder
                });
                s.push(m);
              }
              return this.options.includeChildren;
            }), Ht.create(t, s);
          }
        }
      })
    ];
  }
});
function Ore(t) {
  return t || (t = {
    placeholder: ({ node: e, pos: n }) => {
      var r, i;
      return ((r = e == null ? void 0 : e.type) == null ? void 0 : r.name) === "heading" ? `标题${e.attrs.level}` : ((i = e == null ? void 0 : e.type) == null ? void 0 : i.name) === "codeBlock" ? "" : me("placeholderCommand");
    }
  }), Tre.configure(t);
}
const Mre = /* @__PURE__ */ ae({
  __name: "PlaceholderExt",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    return nt(Ore(t.options)), (n, r) => null;
  }
}), Are = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, Nre = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, s$ = mr.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Va({
        find: Are,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      No({
        find: Nre,
        type: this.type
      })
    ];
  }
}), Rre = { key: 0 }, o$ = /* @__PURE__ */ ae({
  __name: "Strike",
  props: {
    options: {
      type: Object,
      required: !1
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(s$.configure(e.options)), (r, i) => C(n) ? (J(), be("div", Rre, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleStrike().run(),
          icon: C(AG),
          "is-active": () => C(n).isActive("strike"),
          mini: t.mini,
          title: C(me)("strike")
        }, null, 8, ["action", "icon", "is-active", "mini", "title"])
      ])
    ])) : He("", !0);
  }
});
function qpe(t) {
  return s$.configure(t);
}
const a$ = mr.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), Dre = { key: 0 }, Ire = /* @__PURE__ */ ae({
  __name: "Subscript",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(a$.configure(e.options)), (r, i) => C(n) ? (J(), be("div", Dre, [
      W(Ve, {
        action: () => C(n).chain().focus().toggleSubscript().run(),
        icon: C(NG),
        "is-active": () => C(n).isActive("subscript"),
        title: C(me)("subscript")
      }, null, 8, ["action", "icon", "is-active", "title"])
    ])) : He("", !0);
  }
});
function Kpe(t) {
  return a$.configure(t);
}
const l$ = mr.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), Pre = { key: 0 }, Lre = /* @__PURE__ */ ae({
  __name: "Superscript",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(l$.configure(e.options)), (r, i) => C(n) ? (J(), be("div", Pre, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleSuperscript().run(),
          icon: C(RG),
          "is-active": () => C(n).isActive("superscript"),
          title: C(me)("superscript")
        }, null, 8, ["action", "icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
});
function Ype(t) {
  return l$.configure(t);
}
var K1, Y1;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  K1 = (e) => t.get(e), Y1 = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  K1 = (r) => {
    for (let i = 0; i < t.length; i += 2)
      if (t[i] == r)
        return t[i + 1];
  }, Y1 = (r, i) => (n == 10 && (n = 0), t[n++] = r, t[n++] = i);
}
var St = class {
  constructor(e, n, r, i) {
    this.width = e, this.height = n, this.map = r, this.problems = i;
  }
  // Find the dimensions of the cell at the given position.
  findCell(e) {
    for (let n = 0; n < this.map.length; n++) {
      const r = this.map[n];
      if (r != e)
        continue;
      const i = n % this.width, s = n / this.width | 0;
      let o = i + 1, a = s + 1;
      for (let l = 1; o < this.width && this.map[n + l] == r; l++)
        o++;
      for (let l = 1; a < this.height && this.map[n + this.width * l] == r; l++)
        a++;
      return { left: i, top: s, right: o, bottom: a };
    }
    throw new RangeError(`No cell with offset ${e} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(e) {
    for (let n = 0; n < this.map.length; n++)
      if (this.map[n] == e)
        return n % this.width;
    throw new RangeError(`No cell with offset ${e} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(e, n, r) {
    const { left: i, right: s, top: o, bottom: a } = this.findCell(e);
    return n == "horiz" ? (r < 0 ? i == 0 : s == this.width) ? null : this.map[o * this.width + (r < 0 ? i - 1 : s)] : (r < 0 ? o == 0 : a == this.height) ? null : this.map[i + this.width * (r < 0 ? o - 1 : a)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(e, n) {
    const {
      left: r,
      right: i,
      top: s,
      bottom: o
    } = this.findCell(e), {
      left: a,
      right: l,
      top: c,
      bottom: u
    } = this.findCell(n);
    return {
      left: Math.min(r, a),
      top: Math.min(s, c),
      right: Math.max(i, l),
      bottom: Math.max(o, u)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(e) {
    const n = [], r = {};
    for (let i = e.top; i < e.bottom; i++)
      for (let s = e.left; s < e.right; s++) {
        const o = i * this.width + s, a = this.map[o];
        r[a] || (r[a] = !0, !(s == e.left && s && this.map[o - 1] == a || i == e.top && i && this.map[o - this.width] == a) && n.push(a));
      }
    return n;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(e, n, r) {
    for (let i = 0, s = 0; ; i++) {
      const o = s + r.child(i).nodeSize;
      if (i == e) {
        let a = n + e * this.width;
        const l = (e + 1) * this.width;
        for (; a < l && this.map[a] < s; )
          a++;
        return a == l ? o - 1 : this.map[a];
      }
      s = o;
    }
  }
  // Find the table map for the given table node.
  static get(e) {
    return K1(e) || Y1(e, $re(e));
  }
};
function $re(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = Bre(t), n = t.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let c = 0, u = e * n; c < u; c++)
    r[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = t.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; i < r.length && r[i] != 0; )
        i++;
      if (p == d.childCount)
        break;
      const g = d.child(p), { colspan: m, rowspan: v, colwidth: y } = g.attrs;
      for (let E = 0; E < v; E++) {
        if (E + c >= n) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: v - E
          });
          break;
        }
        const b = i + E * e;
        for (let _ = 0; _ < m; _++) {
          r[b + _] == 0 ? r[b + _] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: m - _
          });
          const w = y && y[_];
          if (w) {
            const S = (b + _) % e * 2, x = o[S];
            x == null || x != w && o[S + 1] == 1 ? (o[S] = w, o[S + 1] = 1) : x == w && o[S + 1]++;
          }
        }
      }
      i += m, u += g.nodeSize;
    }
    const f = (c + 1) * e;
    let h = 0;
    for (; i < f; )
      r[i++] == 0 && h++;
    h && (s || (s = [])).push({ type: "missing", row: c, n: h }), u++;
  }
  const a = new St(e, n, r, s);
  let l = !1;
  for (let c = 0; !l && c < o.length; c += 2)
    o[c] != null && o[c + 1] < n && (l = !0);
  return l && Fre(a, o, t), a;
}
function Bre(t) {
  let e = -1, n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const i = t.child(r);
    let s = 0;
    if (n)
      for (let o = 0; o < r; o++) {
        const a = t.child(o);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          o + c.attrs.rowspan > r && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const a = i.child(o);
      s += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function Fre(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let i = 0; i < t.map.length; i++) {
    const s = t.map[i];
    if (r[s])
      continue;
    r[s] = !0;
    const o = n.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let a = null;
    const l = o.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = (i + c) % t.width, d = e[u * 2];
      d != null && (!l.colwidth || l.colwidth[c] != d) && ((a || (a = zre(l)))[c] = d);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: a
    });
  }
}
function zre(t) {
  if (t.colwidth)
    return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++)
    e.push(0);
  return e;
}
function Fn(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var fo = new ft("selectingCells");
function ou(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function Hre(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell")
      return t.node(e);
  }
  return null;
}
function Li(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function d0(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = ou(e.$head) || Ure(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function Ure(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function X1(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function Vre(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function iS(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function c$(t, e, n) {
  const r = t.node(-1), i = St.get(r), s = t.start(-1), o = i.nextCell(t.pos - s, e, n);
  return o == null ? null : t.node(0).resolve(s + o);
}
function rl(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function u$(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan + n };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < n; i++)
      r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function Wre(t, e, n) {
  const r = Fn(e.type.schema).header_cell;
  for (let i = 0; i < t.height; i++)
    if (e.nodeAt(t.map[n + i * t.width]).type != r)
      return !1;
  return !0;
}
var Ct = class Cs extends $e {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const r = e.node(-1), i = St.get(r), s = e.start(-1), o = i.rectBetween(
      e.pos - s,
      n.pos - s
    ), a = e.node(0), l = i.cellsInRect(o).filter((u) => u != n.pos - s);
    l.unshift(n.pos - s);
    const c = l.map((u) => {
      const d = r.nodeAt(u);
      if (!d)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new Jw(
        a.resolve(f),
        a.resolve(f + d.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)), i = e.resolve(n.map(this.$headCell.pos));
    if (X1(r) && X1(i) && iS(r, i)) {
      const s = this.$anchorCell.node(-1) != r.node(-1);
      return s && this.isRowSelection() ? Cs.rowSelection(r, i) : s && this.isColSelection() ? Cs.colSelection(r, i) : new Cs(r, i);
    }
    return Te.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = St.get(e), r = this.$anchorCell.start(-1), i = n.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), s = {}, o = [];
    for (let l = i.top; l < i.bottom; l++) {
      const c = [];
      for (let u = l * n.width + i.left, d = i.left; d < i.right; d++, u++) {
        const f = n.map[u];
        if (s[f])
          continue;
        s[f] = !0;
        const h = n.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const g = i.left - h.left, m = h.right - i.right;
        if (g > 0 || m > 0) {
          let v = p.attrs;
          if (g > 0 && (v = rl(v, 0, g)), m > 0 && (v = rl(
            v,
            v.colspan - m,
            m
          )), h.left < i.left) {
            if (p = p.type.createAndFill(v), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(v)}`
              );
          } else
            p = p.type.create(v, p.content);
        }
        if (h.top < i.top || h.bottom > i.bottom) {
          const v = {
            ...p.attrs,
            rowspan: Math.min(h.bottom, i.bottom) - Math.max(h.top, i.top)
          };
          h.top < i.top ? p = p.type.createAndFill(v) : p = p.type.create(v, p.content);
        }
        c.push(p);
      }
      o.push(e.child(l).copy(pe.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : o;
    return new De(pe.from(a), 1, 1);
  }
  replace(e, n = De.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: a, $to: l } = i[o], c = e.mapping.slice(r);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        o ? De.empty : n
      );
    }
    const s = $e.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, n) {
    this.replace(e, new De(pe.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), r = St.get(n), i = this.$anchorCell.start(-1), s = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < s.length; o++)
      e(n.nodeAt(s[o]), i + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0)
      return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const r = e.node(-1), i = St.get(r), s = e.start(-1), o = i.findCell(e.pos - s), a = i.findCell(n.pos - s), l = e.node(0);
    return o.top <= a.top ? (o.top > 0 && (e = l.resolve(s + i.map[o.left])), a.bottom < i.height && (n = l.resolve(
      s + i.map[i.width * (i.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (n = l.resolve(s + i.map[a.left])), o.bottom < i.height && (e = l.resolve(
      s + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new Cs(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = St.get(e), r = this.$anchorCell.start(-1), i = n.colCount(this.$anchorCell.pos - r), s = n.colCount(this.$headCell.pos - r);
    if (Math.min(i, s) > 0)
      return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, a) == n.width;
  }
  eq(e) {
    return e instanceof Cs && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const r = e.node(-1), i = St.get(r), s = e.start(-1), o = i.findCell(e.pos - s), a = i.findCell(n.pos - s), l = e.node(0);
    return o.left <= a.left ? (o.left > 0 && (e = l.resolve(
      s + i.map[o.top * i.width]
    )), a.right < i.width && (n = l.resolve(
      s + i.map[i.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (n = l.resolve(s + i.map[a.top * i.width])), o.right < i.width && (e = l.resolve(
      s + i.map[i.width * (o.top + 1) - 1]
    ))), new Cs(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Cs(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new Cs(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new Gre(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Ct.prototype.visible = !1;
$e.jsonID("cell", Ct);
var Gre = class d$ {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new d$(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && iS(n, r) ? new Ct(n, r) : $e.near(r, 1);
  }
};
function jre(t) {
  if (!(t.selection instanceof Ct))
    return null;
  const e = [];
  return t.selection.forEachCell((n, r) => {
    e.push(
      xn.node(r, r + n.nodeSize, { class: "selectedCell" })
    );
  }), Ht.create(t.doc, e);
}
function qre({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6)
    return !1;
  let n = t.pos, r = e.pos, i = t.depth;
  for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--)
    ;
  return n == r && /row|table/.test(t.node(i).type.spec.tableRole);
}
function Kre({ $from: t, $to: e }) {
  let n, r;
  for (let i = t.depth; i > 0; i--) {
    const s = t.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      n = s;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const s = e.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  return n !== r && e.parentOffset === 0;
}
function Yre(t, e, n) {
  const r = (e || t).selection, i = (e || t).doc;
  let s, o;
  if (r instanceof ve && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = Ct.create(i, r.from);
    else if (o == "row") {
      const a = i.resolve(r.from + 1);
      s = Ct.rowSelection(a, a);
    } else if (!n) {
      const a = St.get(r.node), l = r.from + 1, c = l + a.map[a.width * a.height - 1];
      s = Ct.create(i, l + 1, c);
    }
  } else
    r instanceof Te && qre(r) ? s = Te.create(i, r.from) : r instanceof Te && Kre(r) && (s = Te.create(i, r.$from.start(), r.$from.end()));
  return s && (e || (e = t.tr)).setSelection(s), e;
}
var Xre = new ft("fix-tables");
function f$(t, e, n, r) {
  const i = t.childCount, s = e.childCount;
  e:
    for (let o = 0, a = 0; o < s; o++) {
      const l = e.child(o);
      for (let c = a, u = Math.min(i, o + 3); c < u; c++)
        if (t.child(c) == l) {
          a = c + 1, n += l.nodeSize;
          continue e;
        }
      r(l, n), a < i && t.child(a).sameMarkup(l) ? f$(t.child(a), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
    }
}
function h$(t, e) {
  let n;
  const r = (i, s) => {
    i.type.spec.tableRole == "table" && (n = Jre(t, i, s, n));
  };
  return e ? e.doc != t.doc && f$(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function Jre(t, e, n, r) {
  const i = St.get(e);
  if (!i.problems)
    return r;
  r || (r = t.tr);
  const s = [];
  for (let l = 0; l < i.height; l++)
    s.push(0);
  for (let l = 0; l < i.problems.length; l++) {
    const c = i.problems[l];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      const d = u.attrs;
      for (let f = 0; f < d.rowspan; f++)
        s[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(n + 1 + c.pos),
        null,
        rl(d, d.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    }
  }
  let o, a;
  for (let l = 0; l < s.length; l++)
    s[l] && (o == null && (o = l), a = l);
  for (let l = 0, c = n + 1; l < i.height; l++) {
    const u = e.child(l), d = c + u.nodeSize, f = s[l];
    if (f > 0) {
      let h = "cell";
      u.firstChild && (h = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let m = 0; m < f; m++) {
        const v = Fn(t.schema)[h].createAndFill();
        v && p.push(v);
      }
      const g = (l == 0 || o == l - 1) && a == l ? c + 1 : d - 1;
      r.insert(r.mapping.map(g), p);
    }
    c = d;
  }
  return r.setMeta(Xre, { fixTables: !0 });
}
function vs(t) {
  const e = t.selection, n = d0(t), r = n.node(-1), i = n.start(-1), s = St.get(r);
  return { ...e instanceof Ct ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(n.pos - i), tableStart: i, map: s, table: r };
}
function p$(t, { map: e, tableStart: n, table: r }, i) {
  let s = i > 0 ? -1 : 0;
  Wre(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const a = o * e.width + i;
    if (i > 0 && i < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = r.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        u$(c.attrs, i - e.colCount(l))
      ), o += c.attrs.rowspan - 1;
    } else {
      const l = s == null ? Fn(r.type.schema).cell : r.nodeAt(e.map[a + s]).type, c = e.positionAt(o, i, r);
      t.insert(t.mapping.map(n + c), l.createAndFill());
    }
  }
  return t;
}
function Zre(t, e) {
  if (!Li(t))
    return !1;
  if (e) {
    const n = vs(t);
    e(p$(t.tr, n, n.left));
  }
  return !0;
}
function Qre(t, e) {
  if (!Li(t))
    return !1;
  if (e) {
    const n = vs(t);
    e(p$(t.tr, n, n.right));
  }
  return !0;
}
function eie(t, { map: e, table: n, tableStart: r }, i) {
  const s = t.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const a = o * e.width + i, l = e.map[a], c = n.nodeAt(l), u = c.attrs;
    if (i > 0 && e.map[a - 1] == l || i < e.width - 1 && e.map[a + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(s).map(r + l),
        null,
        rl(u, i - e.colCount(l))
      );
    else {
      const d = t.mapping.slice(s).map(r + l);
      t.delete(d, d + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function tie(t, e) {
  if (!Li(t))
    return !1;
  if (e) {
    const n = vs(t), r = t.tr;
    if (n.left == 0 && n.right == n.map.width)
      return !1;
    for (let i = n.right - 1; eie(r, n, i), i != n.left; i--) {
      const s = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      n.table = s, n.map = St.get(s);
    }
    e(r);
  }
  return !0;
}
function nie(t, e, n) {
  var r;
  const i = Fn(e.type.schema).header_cell;
  for (let s = 0; s < t.width; s++)
    if (((r = e.nodeAt(t.map[s + n * t.width])) == null ? void 0 : r.type) != i)
      return !1;
  return !0;
}
function g$(t, { map: e, tableStart: n, table: r }, i) {
  var s;
  let o = n;
  for (let c = 0; c < i; c++)
    o += r.child(c).nodeSize;
  const a = [];
  let l = i > 0 ? -1 : 0;
  nie(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0);
  for (let c = 0, u = e.width * i; c < e.width; c++, u++)
    if (i > 0 && i < e.height && e.map[u] == e.map[u - e.width]) {
      const d = e.map[u], f = r.nodeAt(d).attrs;
      t.setNodeMarkup(n + d, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), c += f.colspan - 1;
    } else {
      const d = l == null ? Fn(r.type.schema).cell : (s = r.nodeAt(e.map[u + l * e.width])) == null ? void 0 : s.type, f = d == null ? void 0 : d.createAndFill();
      f && a.push(f);
    }
  return t.insert(o, Fn(r.type.schema).row.create(null, a)), t;
}
function rie(t, e) {
  if (!Li(t))
    return !1;
  if (e) {
    const n = vs(t);
    e(g$(t.tr, n, n.top));
  }
  return !0;
}
function iie(t, e) {
  if (!Li(t))
    return !1;
  if (e) {
    const n = vs(t);
    e(g$(t.tr, n, n.bottom));
  }
  return !0;
}
function sie(t, { map: e, table: n, tableStart: r }, i) {
  let s = 0;
  for (let c = 0; c < i; c++)
    s += n.child(c).nodeSize;
  const o = s + n.child(i).nodeSize, a = t.mapping.maps.length;
  t.delete(s + r, o + r);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = i * e.width; c < e.width; c++, u++) {
    const d = e.map[u];
    if (!l.has(d)) {
      if (l.add(d), i > 0 && d == e.map[u - e.width]) {
        const f = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && d == e.map[u + e.width]) {
        const f = n.nodeAt(d), h = f.attrs, p = f.type.create(
          { ...h, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), g = e.positionAt(i + 1, c, n);
        t.insert(t.mapping.slice(a).map(r + g), p), c += h.colspan - 1;
      }
    }
  }
}
function oie(t, e) {
  if (!Li(t))
    return !1;
  if (e) {
    const n = vs(t), r = t.tr;
    if (n.top == 0 && n.bottom == n.map.height)
      return !1;
    for (let i = n.bottom - 1; sie(r, n, i), i != n.top; i--) {
      const s = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      n.table = s, n.map = St.get(n.table);
    }
    e(r);
  }
  return !0;
}
function kO(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function aie({ width: t, height: e, map: n }, r) {
  let i = r.top * t + r.left, s = i, o = (r.bottom - 1) * t + r.left, a = i + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if (r.left > 0 && n[s] == n[s - 1] || r.right < t && n[a] == n[a + 1])
      return !0;
    s += t, a += t;
  }
  for (let l = r.left; l < r.right; l++) {
    if (r.top > 0 && n[i] == n[i - t] || r.bottom < e && n[o] == n[o + t])
      return !0;
    i++, o++;
  }
  return !1;
}
function CO(t, e) {
  const n = t.selection;
  if (!(n instanceof Ct) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const r = vs(t), { map: i } = r;
  if (aie(i, r))
    return !1;
  if (e) {
    const s = t.tr, o = {};
    let a = pe.empty, l, c;
    for (let u = r.top; u < r.bottom; u++)
      for (let d = r.left; d < r.right; d++) {
        const f = i.map[u * i.width + d], h = r.table.nodeAt(f);
        if (!(o[f] || !h))
          if (o[f] = !0, l == null)
            l = f, c = h;
          else {
            kO(h) || (a = a.append(h.content));
            const p = s.mapping.map(f + r.tableStart);
            s.delete(p, p + h.nodeSize);
          }
      }
    if (l == null || c == null)
      return !0;
    if (s.setNodeMarkup(l + r.tableStart, null, {
      ...u$(
        c.attrs,
        c.attrs.colspan,
        r.right - r.left - c.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), a.size) {
      const u = l + 1 + c.content.size, d = kO(c) ? l + 1 : u;
      s.replaceWith(d + r.tableStart, u + r.tableStart, a);
    }
    s.setSelection(
      new Ct(s.doc.resolve(l + r.tableStart))
    ), e(s);
  }
  return !0;
}
function TO(t, e) {
  const n = Fn(t.schema);
  return lie(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function lie(t) {
  return (e, n) => {
    var r;
    const i = e.selection;
    let s, o;
    if (i instanceof Ct) {
      if (i.$anchorCell.pos != i.$headCell.pos)
        return !1;
      s = i.$anchorCell.nodeAfter, o = i.$anchorCell.pos;
    } else {
      if (s = Hre(i.$from), !s)
        return !1;
      o = (r = ou(i.$from)) == null ? void 0 : r.pos;
    }
    if (s == null || o == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1)
      return !1;
    if (n) {
      let a = s.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
      const u = vs(e), d = e.tr;
      for (let h = 0; h < u.right - u.left; h++)
        l.push(
          c ? {
            ...a,
            colwidth: c && c[h] ? [c[h]] : null
          } : a
        );
      let f;
      for (let h = u.top; h < u.bottom; h++) {
        let p = u.map.positionAt(h, u.left, u.table);
        h == u.top && (p += s.nodeSize);
        for (let g = u.left, m = 0; g < u.right; g++, m++)
          g == u.left && h == u.top || d.insert(
            f = d.mapping.map(p + u.tableStart, 1),
            t({ node: s, row: h, col: g }).createAndFill(l[m])
          );
      }
      d.setNodeMarkup(
        o,
        t({ node: s, row: u.top, col: u.left }),
        l[0]
      ), i instanceof Ct && d.setSelection(
        new Ct(
          d.doc.resolve(i.$anchorCell.pos),
          f ? d.doc.resolve(f) : void 0
        )
      ), n(d);
    }
    return !0;
  };
}
function cie(t, e) {
  return function(n, r) {
    if (!Li(n))
      return !1;
    const i = d0(n);
    if (i.nodeAfter.attrs[t] === e)
      return !1;
    if (r) {
      const s = n.tr;
      n.selection instanceof Ct ? n.selection.forEachCell((o, a) => {
        o.attrs[t] !== e && s.setNodeMarkup(a, null, {
          ...o.attrs,
          [t]: e
        });
      }) : s.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [t]: e
      }), r(s);
    }
    return !0;
  };
}
function uie(t) {
  return function(e, n) {
    if (!Li(e))
      return !1;
    if (n) {
      const r = Fn(e.schema), i = vs(e), s = e.tr, o = i.map.cellsInRect(
        t == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : t == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), a = o.map((l) => i.table.nodeAt(l));
      for (let l = 0; l < o.length; l++)
        a[l].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[l],
          r.cell,
          a[l].attrs
        );
      if (s.steps.length == 0)
        for (let l = 0; l < o.length; l++)
          s.setNodeMarkup(
            i.tableStart + o[l],
            r.header_cell,
            a[l].attrs
          );
      n(s);
    }
    return !0;
  };
}
function OO(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function of(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? uie(t) : function(n, r) {
    if (!Li(n))
      return !1;
    if (r) {
      const i = Fn(n.schema), s = vs(n), o = n.tr, a = OO("row", s, i), l = OO(
        "column",
        s,
        i
      ), u = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0, d = t == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : t == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = t == "column" ? l ? i.cell : i.header_cell : t == "row" ? a ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(d).forEach((h) => {
        const p = h + s.tableStart, g = o.doc.nodeAt(p);
        g && o.setNodeMarkup(p, f, g.attrs);
      }), r(o);
    }
    return !0;
  };
}
of("row", {
  useDeprecatedLogic: !0
});
of("column", {
  useDeprecatedLogic: !0
});
var die = of("cell", {
  useDeprecatedLogic: !0
});
function fie(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n)
      return t.pos - n.nodeSize;
    for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) {
      const s = t.node(-1).child(r), o = s.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= s.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) {
      const s = n.child(r);
      if (s.childCount)
        return i + 1;
      i += s.nodeSize;
    }
  }
  return null;
}
function MO(t) {
  return function(e, n) {
    if (!Li(e))
      return !1;
    const r = fie(d0(e), t);
    if (r == null)
      return !1;
    if (n) {
      const i = e.doc.resolve(r);
      n(
        e.tr.setSelection(Te.between(i, Vre(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function hie(t, e) {
  const n = t.selection.$anchor;
  for (let r = n.depth; r > 0; r--)
    if (n.node(r).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(r), n.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function Yh(t, e) {
  const n = t.selection;
  if (!(n instanceof Ct))
    return !1;
  if (e) {
    const r = t.tr, i = Fn(t.schema).cell.createAndFill().content;
    n.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new De(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function pie(t) {
  if (!t.size)
    return null;
  let { content: e, openStart: n, openEnd: r } = t;
  for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, r--, e = e.child(0).content;
  const i = e.child(0), s = i.type.spec.tableRole, o = i.type.schema, a = [];
  if (s == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const u = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || d) && (c = J1(
        Fn(o).row,
        new De(c, u, d)
      ).content), a.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    a.push(
      n || r ? J1(
        Fn(o).row,
        new De(e, n, r)
      ).content : e
    );
  else
    return null;
  return gie(o, a);
}
function gie(t, e) {
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: a, colspan: l } = s.child(o).attrs;
      for (let c = i; c < i + a; c++)
        n[c] = (n[c] || 0) + l;
    }
  }
  let r = 0;
  for (let i = 0; i < n.length; i++)
    r = Math.max(r, n[i]);
  for (let i = 0; i < n.length; i++)
    if (i >= e.length && e.push(pe.empty), n[i] < r) {
      const s = Fn(t).cell.createAndFill(), o = [];
      for (let a = n[i]; a < r; a++)
        o.push(s);
      e[i] = e[i].append(pe.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function J1(t, e) {
  const n = t.createAndFill();
  return new xN(n).replace(0, n.content.size, e).doc;
}
function mie({ width: t, height: e, rows: n }, r, i) {
  if (t != r) {
    const s = [], o = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = [];
      for (let u = s[a] || 0, d = 0; u < r; d++) {
        let f = l.child(d % l.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          rl(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let h = 1; h < f.attrs.rowspan; h++)
          s[a + h] = (s[a + h] || 0) + f.attrs.colspan;
      }
      o.push(pe.from(c));
    }
    n = o, t = r;
  }
  if (e != i) {
    const s = [];
    for (let o = 0, a = 0; o < i; o++, a++) {
      const l = [], c = n[a % e];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        o + d.attrs.rowspan > i && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, i - d.attrs.rowspan)
          },
          d.content
        )), l.push(d);
      }
      s.push(pe.from(l));
    }
    n = s, e = i;
  }
  return { width: t, height: e, rows: n };
}
function vie(t, e, n, r, i, s, o) {
  const a = t.doc.type.schema, l = Fn(a);
  let c, u;
  if (i > e.width)
    for (let d = 0, f = 0; d < e.height; d++) {
      const h = n.child(d);
      f += h.nodeSize;
      const p = [];
      let g;
      h.lastChild == null || h.lastChild.type == l.cell ? g = c || (c = l.cell.createAndFill()) : g = u || (u = l.header_cell.createAndFill());
      for (let m = e.width; m < i; m++)
        p.push(g);
      t.insert(t.mapping.slice(o).map(f - 1 + r), p);
    }
  if (s > e.height) {
    const d = [];
    for (let p = 0, g = (e.height - 1) * e.width; p < Math.max(e.width, i); p++) {
      const m = p >= e.width ? !1 : n.nodeAt(e.map[g + p]).type == l.header_cell;
      d.push(
        m ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, pe.from(d)), h = [];
    for (let p = e.height; p < s; p++)
      h.push(f);
    t.insert(t.mapping.slice(o).map(r + n.nodeSize - 2), h);
  }
  return !!(c || u);
}
function AO(t, e, n, r, i, s, o, a) {
  if (o == 0 || o == e.height)
    return !1;
  let l = !1;
  for (let c = i; c < s; c++) {
    const u = o * e.width + c, d = e.map[u];
    if (e.map[u - e.width] == d) {
      l = !0;
      const f = n.nodeAt(d), { top: h, left: p } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
        ...f.attrs,
        rowspan: o - h
      }), t.insert(
        t.mapping.slice(a).map(e.positionAt(o, p, n)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: h + f.attrs.rowspan - o
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function NO(t, e, n, r, i, s, o, a) {
  if (o == 0 || o == e.width)
    return !1;
  let l = !1;
  for (let c = i; c < s; c++) {
    const u = c * e.width + o, d = e.map[u];
    if (e.map[u - 1] == d) {
      l = !0;
      const f = n.nodeAt(d), h = e.colCount(d), p = t.mapping.slice(a).map(d + r);
      t.setNodeMarkup(
        p,
        null,
        rl(
          f.attrs,
          o - h,
          f.attrs.colspan - (o - h)
        )
      ), t.insert(
        p + f.nodeSize,
        f.type.createAndFill(
          rl(f.attrs, 0, o - h)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function RO(t, e, n, r, i) {
  let s = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!s)
    throw new Error("No table found");
  let o = St.get(s);
  const { top: a, left: l } = r, c = l + i.width, u = a + i.height, d = t.tr;
  let f = 0;
  function h() {
    if (s = n ? d.doc.nodeAt(n - 1) : d.doc, !s)
      throw new Error("No table found");
    o = St.get(s), f = d.mapping.maps.length;
  }
  vie(d, o, s, n, c, u, f) && h(), AO(d, o, s, n, l, c, a, f) && h(), AO(d, o, s, n, l, c, u, f) && h(), NO(d, o, s, n, a, u, l, f) && h(), NO(d, o, s, n, a, u, c, f) && h();
  for (let p = a; p < u; p++) {
    const g = o.positionAt(p, l, s), m = o.positionAt(p, c, s);
    d.replace(
      d.mapping.slice(f).map(g + n),
      d.mapping.slice(f).map(m + n),
      new De(i.rows[p - a], 0, 0)
    );
  }
  h(), d.setSelection(
    new Ct(
      d.doc.resolve(n + o.positionAt(a, l, s)),
      d.doc.resolve(n + o.positionAt(u - 1, c - 1, s))
    )
  ), e(d);
}
var bie = kv({
  ArrowLeft: Xh("horiz", -1),
  ArrowRight: Xh("horiz", 1),
  ArrowUp: Xh("vert", -1),
  ArrowDown: Xh("vert", 1),
  "Shift-ArrowLeft": Jh("horiz", -1),
  "Shift-ArrowRight": Jh("horiz", 1),
  "Shift-ArrowUp": Jh("vert", -1),
  "Shift-ArrowDown": Jh("vert", 1),
  Backspace: Yh,
  "Mod-Backspace": Yh,
  Delete: Yh,
  "Mod-Delete": Yh
});
function Ap(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function Xh(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const s = n.selection;
    if (s instanceof Ct)
      return Ap(
        n,
        r,
        $e.near(s.$headCell, e)
      );
    if (t != "horiz" && !s.empty)
      return !1;
    const o = m$(i, t, e);
    if (o == null)
      return !1;
    if (t == "horiz")
      return Ap(
        n,
        r,
        $e.near(n.doc.resolve(s.head + e), e)
      );
    {
      const a = n.doc.resolve(o), l = c$(a, t, e);
      let c;
      return l ? c = $e.near(l, 1) : e < 0 ? c = $e.near(n.doc.resolve(a.before(-1)), -1) : c = $e.near(n.doc.resolve(a.after(-1)), 1), Ap(n, r, c);
    }
  };
}
function Jh(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const s = n.selection;
    let o;
    if (s instanceof Ct)
      o = s;
    else {
      const l = m$(i, t, e);
      if (l == null)
        return !1;
      o = new Ct(n.doc.resolve(l));
    }
    const a = c$(o.$headCell, t, e);
    return a ? Ap(
      n,
      r,
      new Ct(o.$anchorCell, a)
    ) : !1;
  };
}
function yie(t, e) {
  const n = t.state.doc, r = ou(n.resolve(e));
  return r ? (t.dispatch(t.state.tr.setSelection(new Ct(r))), !0) : !1;
}
function wie(t, e, n) {
  if (!Li(t.state))
    return !1;
  let r = pie(n);
  const i = t.state.selection;
  if (i instanceof Ct) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        pe.from(
          J1(Fn(t.state.schema).cell, n)
        )
      ]
    });
    const s = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), a = St.get(s).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = mie(r, a.right - a.left, a.bottom - a.top), RO(t.state, t.dispatch, o, a, r), !0;
  } else if (r) {
    const s = d0(t.state), o = s.start(-1);
    return RO(
      t.state,
      t.dispatch,
      o,
      St.get(s.node(-1)).findCell(s.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function _ie(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey)
    return;
  const r = DO(t, e.target);
  let i;
  if (e.shiftKey && t.state.selection instanceof Ct)
    s(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = ou(t.state.selection.$anchor)) != null && ((n = Bb(t, e)) == null ? void 0 : n.pos) != i.pos)
    s(i, e), e.preventDefault();
  else if (!r)
    return;
  function s(l, c) {
    let u = Bb(t, c);
    const d = fo.getState(t.state) == null;
    if (!u || !iS(l, u))
      if (d)
        u = l;
      else
        return;
    const f = new Ct(l, u);
    if (d || !t.state.selection.eq(f)) {
      const h = t.state.tr.setSelection(f);
      d && h.setMeta(fo, l.pos), t.dispatch(h);
    }
  }
  function o() {
    t.root.removeEventListener("mouseup", o), t.root.removeEventListener("dragstart", o), t.root.removeEventListener("mousemove", a), fo.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(fo, -1));
  }
  function a(l) {
    const c = l, u = fo.getState(t.state);
    let d;
    if (u != null)
      d = t.state.doc.resolve(u);
    else if (DO(t, c.target) != r && (d = Bb(t, e), !d))
      return o();
    d && s(d, c);
  }
  t.root.addEventListener("mouseup", o), t.root.addEventListener("dragstart", o), t.root.addEventListener("mousemove", a);
}
function m$(t, e, n) {
  if (!(t.state.selection instanceof Te))
    return null;
  const { $head: r } = t.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : s.childCount))
      return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const a = r.before(i), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function DO(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Bb(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? ou(t.state.doc.resolve(n.pos)) : null;
}
var Eie = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${n}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Z1(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, Z1(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function Z1(t, e, n, r, i, s) {
  var o;
  let a = 0, l = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u) {
    for (let d = 0, f = 0; d < u.childCount; d++) {
      const { colspan: h, colwidth: p } = u.child(d).attrs;
      for (let g = 0; g < h; g++, f++) {
        const m = i == f ? s : p && p[g], v = m ? m + "px" : "";
        if (a += m || r, m || (l = !1), c)
          c.style.width != v && (c.style.width = v), c = c.nextSibling;
        else {
          const y = document.createElement("col");
          y.style.width = v, e.appendChild(y);
        }
      }
    }
    for (; c; ) {
      const d = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = d;
    }
    l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
  }
}
var Ar = new ft(
  "tableColumnResizing"
);
function Sie({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: r = Eie,
  lastColumnResizable: i = !0
} = {}) {
  const s = new ut({
    key: Ar,
    state: {
      init(o, a) {
        var l, c;
        const u = (c = (l = s.spec) == null ? void 0 : l.props) == null ? void 0 : c.nodeViews, d = Fn(a.schema).table.name;
        return r && u && (u[d] = (f, h) => new r(f, n, h)), new xie(-1, !1);
      },
      apply(o, a) {
        return a.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const a = Ar.getState(o);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, a) => {
          kie(o, a, t, i);
        },
        mouseleave: (o) => {
          Cie(o);
        },
        mousedown: (o, a) => {
          Tie(o, a, e, n);
        }
      },
      decorations: (o) => {
        const a = Ar.getState(o);
        if (a && a.activeHandle > -1)
          return Rie(o, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var xie = class Np {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, r = e.getMeta(Ar);
    if (r && r.setHandle != null)
      return new Np(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Np(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(n.activeHandle, -1);
      return X1(e.doc.resolve(i)) || (i = -1), new Np(i, n.dragging);
    }
    return n;
  }
};
function kie(t, e, n, r) {
  const i = Ar.getState(t.state);
  if (i && !i.dragging) {
    const s = Mie(e.target);
    let o = -1;
    if (s) {
      const { left: a, right: l } = s.getBoundingClientRect();
      e.clientX - a <= n ? o = IO(t, e, "left", n) : l - e.clientX <= n && (o = IO(t, e, "right", n));
    }
    if (o != i.activeHandle) {
      if (!r && o !== -1) {
        const a = t.state.doc.resolve(o), l = a.node(-1), c = St.get(l), u = a.start(-1);
        if (c.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      v$(t, o);
    }
  }
}
function Cie(t) {
  const e = Ar.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && v$(t, -1);
}
function Tie(t, e, n, r) {
  var i;
  const s = (i = t.dom.ownerDocument.defaultView) != null ? i : window, o = Ar.getState(t.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const a = t.state.doc.nodeAt(o.activeHandle), l = Oie(t, o.activeHandle, a.attrs);
  t.dispatch(
    t.state.tr.setMeta(Ar, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function c(d) {
    s.removeEventListener("mouseup", c), s.removeEventListener("mousemove", u);
    const f = Ar.getState(t.state);
    f != null && f.dragging && (Aie(
      t,
      f.activeHandle,
      PO(f.dragging, d, n)
    ), t.dispatch(
      t.state.tr.setMeta(Ar, { setDragging: null })
    ));
  }
  function u(d) {
    if (!d.which)
      return c(d);
    const f = Ar.getState(t.state);
    if (f && f.dragging) {
      const h = PO(f.dragging, d, n);
      LO(
        t,
        f.activeHandle,
        h,
        r
      );
    }
  }
  return LO(
    t,
    o.activeHandle,
    l,
    r
  ), s.addEventListener("mouseup", c), s.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function Oie(t, e, { colspan: n, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i)
    return i;
  const s = t.domAtPos(e);
  let a = s.node.childNodes[s.offset].offsetWidth, l = n;
  if (r)
    for (let c = 0; c < n; c++)
      r[c] && (a -= r[c], l--);
  return a / l;
}
function Mie(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function IO(t, e, n, r) {
  const i = n == "right" ? -r : r, s = t.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!s)
    return -1;
  const { pos: o } = s, a = ou(t.state.doc.resolve(o));
  if (!a)
    return -1;
  if (n == "right")
    return a.pos;
  const l = St.get(a.node(-1)), c = a.start(-1), u = l.map.indexOf(a.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function PO(t, e, n) {
  const r = e.clientX - t.startX;
  return Math.max(n, t.startWidth + r);
}
function v$(t, e) {
  t.dispatch(
    t.state.tr.setMeta(Ar, { setHandle: e })
  );
}
function Aie(t, e, n) {
  const r = t.state.doc.resolve(e), i = r.node(-1), s = St.get(i), o = r.start(-1), a = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + a;
    if (c && s.map[u] == s.map[u - s.width])
      continue;
    const d = s.map[u], f = i.nodeAt(d).attrs, h = f.colspan == 1 ? 0 : a - s.colCount(d);
    if (f.colwidth && f.colwidth[h] == n)
      continue;
    const p = f.colwidth ? f.colwidth.slice() : Nie(f.colspan);
    p[h] = n, l.setNodeMarkup(o + d, null, { ...f, colwidth: p });
  }
  l.docChanged && t.dispatch(l);
}
function LO(t, e, n, r) {
  const i = t.state.doc.resolve(e), s = i.node(-1), o = i.start(-1), a = St.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(i.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && Z1(
    s,
    l.firstChild,
    l,
    r,
    a,
    n
  );
}
function Nie(t) {
  return Array(t).fill(0);
}
function Rie(t, e) {
  var n;
  const r = [], i = t.doc.resolve(e), s = i.node(-1);
  if (!s)
    return Ht.empty;
  const o = St.get(s), a = i.start(-1), l = o.colCount(i.pos - a) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < o.height; c++) {
    const u = l + c * o.width;
    if ((l == o.width - 1 || o.map[u] != o.map[u + 1]) && (c == 0 || o.map[u] != o.map[u - o.width])) {
      const d = o.map[u], f = a + d + s.nodeAt(d).nodeSize - 1, h = document.createElement("div");
      h.className = "column-resize-handle", (n = Ar.getState(t)) != null && n.dragging && r.push(
        xn.node(
          a + d,
          a + d + s.nodeAt(d).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(xn.widget(f, h));
    }
  }
  return Ht.create(t.doc, r);
}
function Die({
  allowTableNodeSelection: t = !1
} = {}) {
  return new ut({
    key: fo,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const r = e.getMeta(fo);
        if (r != null)
          return r == -1 ? null : r;
        if (n == null || !e.docChanged)
          return n;
        const { deleted: i, pos: s } = e.mapping.mapResult(n);
        return i ? null : s;
      }
    },
    props: {
      decorations: jre,
      handleDOMEvents: {
        mousedown: _ie
      },
      createSelectionBetween(e) {
        return fo.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: yie,
      handleKeyDown: bie,
      handlePaste: wie
    },
    appendTransaction(e, n, r) {
      return Yre(
        r,
        h$(r, n),
        t
      );
    }
  });
}
function $O(t, e, n, r, i, s) {
  let o = 0, a = !0, l = e.firstChild;
  const c = t.firstChild;
  for (let u = 0, d = 0; u < c.childCount; u += 1) {
    const { colspan: f, colwidth: h } = c.child(u).attrs;
    for (let p = 0; p < f; p += 1, d += 1) {
      const g = i === d ? s : h && h[p], m = g ? `${g}px` : "";
      o += g || r, g || (a = !1), l ? (l.style.width !== m && (l.style.width = m), l = l.nextSibling) : e.appendChild(document.createElement("col")).style.width = m;
    }
  }
  for (; l; ) {
    const u = l.nextSibling;
    l.parentNode.removeChild(l), l = u;
  }
  a ? (n.style.width = `${o}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${o}px`);
}
class Iie {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), $O(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, $O(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
}
function Pie(t, e, n, r) {
  let i = 0, s = !0;
  const o = [], a = t.firstChild;
  if (!a)
    return {};
  for (let d = 0, f = 0; d < a.childCount; d += 1) {
    const { colspan: h, colwidth: p } = a.child(d).attrs;
    for (let g = 0; g < h; g += 1, f += 1) {
      const m = n === f ? r : p && p[g], v = m ? `${m}px` : "";
      i += m || e, m || (s = !1), o.push(["col", v ? { style: `width: ${v}` } : {}]);
    }
  }
  const l = s ? `${i}px` : "", c = s ? "" : `${i}px`;
  return { colgroup: ["colgroup", {}, ...o], tableWidth: l, tableMinWidth: c };
}
function BO(t, e) {
  return e ? t.createChecked(null, e) : t.createAndFill();
}
function Lie(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const r = t.nodes[n];
    r.spec.tableRole && (e[r.spec.tableRole] = r);
  }), t.cached.tableNodeTypes = e, e;
}
function $ie(t, e, n, r, i) {
  const s = Lie(t), o = [], a = [];
  for (let c = 0; c < n; c += 1) {
    const u = BO(s.cell, i);
    if (u && a.push(u), r) {
      const d = BO(s.header_cell, i);
      d && o.push(d);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(s.row.createChecked(null, r && c === 0 ? o : a));
  return s.table.createChecked(null, l);
}
function Bie(t) {
  return t instanceof Ct;
}
const Zh = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!Bie(e))
    return !1;
  let n = 0;
  const r = _R(e.ranges[0].$from, (s) => s.type.name === "table");
  return r == null || r.node.descendants((s) => {
    if (s.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(s.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, Fie = an.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: Iie,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: r, tableMinWidth: i } = Pie(t, this.options.cellMinWidth);
    return [
      "table",
      _t(this.options.HTMLAttributes, e, {
        style: r ? `width: ${r}` : `min-width: ${i}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: i, editor: s }) => {
        const o = $ie(s.schema, t, e, n);
        if (i) {
          const a = r.selection.from + 1;
          r.replaceSelectionWith(o).scrollIntoView().setSelection(Te.near(r.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => Zre(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => Qre(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => tie(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => rie(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => iie(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => oie(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => hie(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => CO(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => TO(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => of("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => of("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => die(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => CO(t, e) ? !0 : TO(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: r }) => cie(t, e)(n, r),
      goToNextCell: () => ({ state: t, dispatch: e }) => MO(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => MO(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && h$(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const r = Ct.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(r);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: Zh,
      "Mod-Backspace": Zh,
      Delete: Zh,
      "Mod-Delete": Zh
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        Sie({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      Die({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: lt(Le(t, "tableRole", e))
    };
  }
}), zie = an.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", _t(this.options.HTMLAttributes, t), 0];
  }
}), Hie = zie.extend({}), Uie = an.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", _t(this.options.HTMLAttributes, t), 0];
  }
}), sS = (t) => (e) => {
  const n = St.get(e.$anchorCell.node(-1)), r = e.$anchorCell.start(-1), i = n.cellsInRect(t), s = n.cellsInRect(
    n.rectBetween(e.$anchorCell.pos - r, e.$headCell.pos - r)
  );
  for (let o = 0, a = i.length; o < a; o += 1)
    if (s.indexOf(i[o]) === -1)
      return !1;
  return !0;
}, f0 = (t) => Iv((e) => e.type.spec.tableRole && e.type.spec.tableRole === "table")(
  t
), oS = (t) => t instanceof Ct, Vie = (t) => (e) => {
  if (oS(e)) {
    const n = St.get(e.$anchorCell.node(-1));
    return sS({
      left: t,
      right: t + 1,
      top: 0,
      bottom: n.height
    })(e);
  }
  return !1;
}, Wie = (t) => (e) => {
  if (oS(e)) {
    const n = St.get(e.$anchorCell.node(-1));
    return sS({
      left: 0,
      right: n.width,
      top: t,
      bottom: t + 1
    })(e);
  }
  return !1;
}, Gie = (t) => {
  if (oS(t)) {
    const e = St.get(t.$anchorCell.node(-1));
    return sS({
      left: 0,
      right: e.width,
      top: 0,
      bottom: e.height
    })(t);
  }
  return !1;
}, jie = (t) => (e) => {
  const n = f0(e);
  if (n) {
    const r = St.get(n.node);
    return (Array.isArray(t) ? t : Array.from([t])).reduce((s, o) => {
      if (o >= 0 && o <= r.width - 1) {
        const a = r.cellsInRect({
          left: o,
          right: o + 1,
          top: 0,
          bottom: r.height
        });
        return s.concat(
          // @ts-ignore
          a.map((l) => {
            const c = n.node.nodeAt(l), u = l + n.start;
            return { pos: u, start: u + 1, node: c };
          })
        );
      }
      return s;
    }, []);
  }
  return null;
}, qie = (t) => (e) => {
  const n = f0(e);
  if (n) {
    const r = St.get(n.node);
    return (Array.isArray(t) ? t : Array.from([t])).reduce((s, o) => {
      if (o >= 0 && o <= r.height - 1) {
        const a = r.cellsInRect({
          left: 0,
          right: r.width,
          top: o,
          bottom: o + 1
        });
        return s.concat(
          // @ts-ignore
          a.map((l) => {
            const c = n.node.nodeAt(l), u = l + n.start;
            return { pos: u, start: u + 1, node: c };
          })
        );
      }
      return s;
    }, []);
  }
  return null;
}, b$ = (t) => (e) => (n) => {
  const r = f0(n.selection), i = t === "row";
  if (r) {
    const s = St.get(r.node);
    if (e >= 0 && e < (i ? s.height : s.width)) {
      const o = i ? 0 : e, a = i ? e : 0, l = i ? s.width : e + 1, c = i ? e + 1 : s.height, u = s.cellsInRect({
        left: o,
        top: a,
        right: i ? l : o + 1,
        bottom: i ? a + 1 : c
      }), d = c - a === 1 ? u : s.cellsInRect({
        left: i ? o : l - 1,
        top: i ? c - 1 : a,
        right: l,
        bottom: c
      }), f = r.start + u[0], h = r.start + d[d.length - 1], p = n.doc.resolve(f), g = n.doc.resolve(h);
      return n.setSelection(new Ct(g, p));
    }
  }
  return n;
}, Kie = b$("column"), Yie = b$("row"), Xie = (t) => {
  const e = f0(t.selection);
  if (e) {
    const { map: n } = St.get(e.node);
    if (n && n.length) {
      const r = e.start + n[0], i = e.start + n[n.length - 1], s = t.doc.resolve(r), o = t.doc.resolve(i);
      return t.setSelection(new Ct(o, s));
    }
  }
  return t;
}, Jie = Uie.extend({
  addAttributes() {
    return {
      HTMLAttributes: {},
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      },
      style: {
        default: null
      }
    };
  },
  addProseMirrorPlugins() {
    const { isEditable: t } = this.editor;
    return [
      new ut({
        props: {
          // @ts-ignore
          decorations: (e) => {
            if (!t)
              return Ht.empty;
            const { doc: n, selection: r } = e, i = [], s = qie(0)(r);
            return s && s.forEach(({ pos: o, node: a }, l) => {
              i.push(
                xn.widget(o + 1, () => {
                  const c = Vie(l)(r);
                  let u = "grip-column";
                  c && (u += " selected"), l === 0 && (u += " first"), l === s.length - 1 && (u += " last");
                  const d = document.createElement("a");
                  return d.className = u, d.addEventListener("mousedown", (f) => {
                    f.preventDefault(), f.stopImmediatePropagation(), this.editor.view.dispatch(Kie(l)(this.editor.state.tr));
                  }), d;
                })
              );
            }), Ht.create(n, i);
          }
        }
      })
    ];
  }
}), Zie = an.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", _t(this.options.HTMLAttributes, t), 0];
  }
}), Qie = Zie.extend({
  addAttributes() {
    return {
      colspan: {
        default: 1,
        parseHTML: (t) => {
          const e = t.getAttribute("colspan");
          return e ? parseInt(e, 10) : 1;
        }
      },
      rowspan: {
        default: 1,
        parseHTML: (t) => {
          const e = t.getAttribute("rowspan");
          return e ? parseInt(e, 10) : 1;
        }
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? [parseInt(e, 10)] : null;
        }
      },
      style: {
        default: null
      }
    };
  },
  addProseMirrorPlugins() {
    const { isEditable: t } = this.editor;
    return [
      new ut({
        props: {
          // @ts-ignore
          decorations: (e) => {
            if (!t)
              return Ht.empty;
            const { doc: n, selection: r } = e, i = [], s = jie(0)(r);
            return s && s.forEach(({ pos: o }, a) => {
              a === 0 && i.push(
                xn.widget(o + 1, () => {
                  const l = Gie(r);
                  let c = "grip-row-col";
                  l && (c += " selected");
                  const u = document.createElement("a");
                  return u.className = c, u.addEventListener("mousedown", (d) => {
                    d.preventDefault(), d.stopImmediatePropagation(), this.editor.view.dispatch(Xie(this.editor.state.tr));
                  }), u;
                })
              ), i.push(
                xn.widget(o + 1, () => {
                  const l = Wie(a)(r);
                  let c = "grip-row";
                  l && (c += " selected"), a === 0 && (c += " first"), a === s.length - 1 && (c += " last");
                  const u = document.createElement("a");
                  return u.className = c, u.addEventListener("mousedown", (d) => {
                    d.preventDefault(), d.stopImmediatePropagation(), this.editor.view.dispatch(Yie(a)(this.editor.state.tr));
                  }), u;
                })
              );
            }), Ht.create(n, i);
          }
        }
      })
    ];
  }
});
function ese(t) {
  return t || (t = {
    resizable: !0
  }), Fie.extend({
    addExtensions() {
      return [Jie, Hie, Qie];
    }
  }).configure(t);
}
const tse = {
  class: "hb-tiptap-table-creator",
  draggable: "false"
}, nse = {
  class: "grid",
  draggable: "false"
}, rse = ["onMousedown", "onMouseenter", "onMouseup"], ise = { class: "actions w-full" }, sse = {
  __name: "LangTableCreator",
  emits: ["insert"],
  setup(t, { emit: e }) {
    const n = X(3), r = X(3);
    function i(v, y) {
      c && (o.value = v, l.value = y, f());
    }
    const s = X(0), o = X(0), a = X(0), l = X(0);
    let c = !1;
    function u(v, y) {
      if (c) {
        d(v, y);
        return;
      }
      s.value = v, a.value = y, o.value = v, l.value = y, c = !0, f();
    }
    function d(v, y) {
      c && (o.value = v, l.value = y, f(), c = !1, console.log(`(${s.value},${a.value})=>(${o.value},${l.value})`));
    }
    function f() {
      n.value = Math.abs(o.value - s.value) + 1, r.value = Math.abs(l.value - a.value) + 1;
    }
    function h(v) {
      v.preventDefault();
    }
    function p(v, y) {
      const E = Math.min(s.value, o.value), b = Math.max(s.value, o.value), _ = Math.min(a.value, l.value), w = Math.max(a.value, l.value);
      return v >= E && v <= b && y >= _ && y <= w;
    }
    const g = e;
    function m() {
      g("insert", n.value, r.value);
    }
    return (v, y) => (J(), be("div", tse, [
      se("div", null, [
        se("div", nse, [
          (J(), be(Vt, null, $n(10, (E) => se("div", {
            key: E,
            class: "grid-row",
            draggable: "false"
          }, [
            (J(), be(Vt, null, $n(12, (b) => se("div", {
              key: b,
              class: It([{ "grid-item-selected": p(E, b) }, "grid-item"]),
              draggable: "false",
              onDragstart: h,
              onMousedown: () => u(E, b),
              onMouseenter: () => i(E, b),
              onMouseup: () => d(E, b)
            }, null, 42, rse)), 64))
          ])), 64))
        ])
      ]),
      se("div", ise, [
        W(ns, {
          content: C(me)("insertTable"),
          icon: C(Ga),
          onClick: m
        }, null, 8, ["content", "icon"])
      ])
    ]));
  }
}, ose = /* @__PURE__ */ wr(sse, [["__scopeId", "data-v-3bf31205"]]), ase = { key: 0 }, lse = /* @__PURE__ */ ae({
  __name: "TableExt",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = X(!1), n = et();
    nt(ese());
    function r(i, s) {
      e.value = !1, n.value.chain().focus().insertTable({ rows: i, cols: s, withHeaderRow: !0 }).run();
    }
    return (i, s) => C(n) ? (J(), be("div", ase, [
      Lt(i.$slots, "default", {}, () => [
        se("div", null, [
          W(fi, { "content-class": "" }, {
            button: Ue(() => [
              W(Ve, {
                action: () => {
                },
                icon: C(aG),
                title: C(me)("table")
              }, null, 8, ["icon", "title"])
            ]),
            content: Ue(() => [
              W(ose, { onInsert: r })
            ]),
            _: 1
          })
        ])
      ])
    ])) : He("", !0);
  }
}), ml = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, y$ = function(t, e, n, r) {
  return n && (FO(t, e, n, r, -1) || FO(t, e, n, r, 1));
}, cse = /^(img|br|input|textarea|hr)$/i;
function FO(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Em(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || aS(t) || cse.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = ml(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = i < 0 ? Em(t) : 0;
    } else
      return !1;
  }
}
function Em(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function use(t, e, n) {
  for (let r = e == 0, i = e == Em(t); r || i; ) {
    if (t == n)
      return !0;
    let s = ml(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && s == 0, i = i && s == Em(t);
  }
}
function aS(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const w$ = function(t) {
  return t.focusNode && y$(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function _$(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
const ds = typeof navigator < "u" ? navigator : null, zO = typeof document < "u" ? document : null, Ko = ds && ds.userAgent || "", Q1 = /Edge\/(\d+)/.exec(Ko), E$ = /MSIE \d/.exec(Ko), ew = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ko), Qf = !!(E$ || ew || Q1), S$ = E$ ? document.documentMode : ew ? +ew[1] : Q1 ? +Q1[1] : 0, h0 = !Qf && /gecko\/(\d+)/i.test(Ko);
h0 && +(/Firefox\/(\d+)/.exec(Ko) || [0, 0])[1];
const tw = !Qf && /Chrome\/(\d+)/.exec(Ko), vl = !!tw, dse = tw ? +tw[1] : 0, bl = !Qf && !!ds && /Apple Computer/.test(ds.vendor), lS = bl && (/Mobile\/\w+/.test(Ko) || !!ds && ds.maxTouchPoints > 2), qr = lS || (ds ? /Mac/.test(ds.platform) : !1), fse = ds ? /Win/.test(ds.platform) : !1, eh = /Android \d/.test(Ko), cS = !!zO && "webkitFontSmoothing" in zO.documentElement.style, hse = cS ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function pse(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let i = t.docView.nearestDesc(n.focusNode), s = i && i.size == 0, o = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (o < 0)
    return null;
  let a = r.resolve(o), l, c;
  if (w$(n)) {
    for (l = a; i && !i.node; )
      i = i.parent;
    let u = i.node;
    if (i && u.isAtom && ve.isSelectable(u) && i.parent && !(u.isInline && use(n.focusNode, n.focusOffset, i.dom))) {
      let d = i.posBefore;
      c = new ve(o == d ? a : r.resolve(d));
    }
  } else {
    let u = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (u < 0)
      return null;
    l = r.resolve(u);
  }
  if (!c) {
    let u = e == "pointer" || t.state.selection.head < a.pos && !s ? 1 : -1;
    c = k$(t, l, a, u);
  }
  return c;
}
function x$(t) {
  return t.editable ? t.hasFocus() : bse(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function uS(t, e = !1) {
  let n = t.state.selection;
  if (vse(t, n), !!x$(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && vl) {
      let r = t.domSelectionRange(), i = t.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && y$(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      mse(t);
    else {
      let { anchor: r, head: i } = n, s, o;
      HO && !(n instanceof Te) && (n.$from.parent.inlineContent || (s = UO(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (o = UO(t, n.to))), t.docView.setSelection(r, i, t.root, e), HO && (s && VO(s), o && VO(o)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && gse(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const HO = bl || vl && dse < 63;
function UO(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, s = r ? n.childNodes[r - 1] : null;
  if (bl && i && i.contentEditable == "false")
    return Fb(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return Fb(i);
    if (s)
      return Fb(s);
  }
}
function Fb(t) {
  return t.contentEditable = "true", bl && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function VO(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function gse(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!x$(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function mse(t) {
  let e = t.domSelection(), n = document.createRange(), r = t.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setEnd(r.parentNode, ml(r) + 1) : n.setEnd(r, 0), n.collapse(!1), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && Qf && S$ <= 11 && (r.disabled = !0, r.disabled = !1);
}
function vse(t, e) {
  if (e instanceof ve) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (WO(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    WO(t);
}
function WO(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function k$(t, e, n, r) {
  return t.someProp("createSelectionBetween", (i) => i(t, e, n)) || Te.between(e, n, r);
}
function bse(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function nw(t, e) {
  let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), s = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && $e.findFrom(s, e);
}
function lo(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function GO(t, e, n) {
  let r = t.state.selection;
  if (r instanceof Te)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = t.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return lo(t, new Te(r.$anchor, o));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = nw(t.state, e);
        return i && i instanceof ve ? lo(t, i) : !1;
      } else if (!(qr && n.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let a = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = t.docView.descAt(a)) && !o.contentDOM ? ve.isSelectable(s) ? lo(t, new ve(e < 0 ? t.state.doc.resolve(i.pos - s.nodeSize) : i)) : cS ? lo(t, new Te(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
      }
    } else
      return !1;
  else {
    if (r instanceof ve && r.node.isInline)
      return lo(t, new Te(e > 0 ? r.$to : r.$from));
    {
      let i = nw(t.state, e);
      return i ? lo(t, i) : !1;
    }
  }
}
function Sm(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function gd(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Ol(t, e) {
  return e < 0 ? yse(t) : wse(t);
}
function yse(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i, s, o = !1;
  for (h0 && n.nodeType == 1 && r < Sm(n) && gd(n.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (gd(a, -1))
          i = n, s = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (C$(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && gd(a, -1); )
          i = n.parentNode, s = ml(a), a = a.previousSibling;
        if (a)
          n = a, r = Sm(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  o ? rw(t, n, r) : i && rw(t, i, s);
}
function wse(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i = Sm(n), s, o;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (gd(a, 1))
        s = n, o = ++r;
      else
        break;
    } else {
      if (C$(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && gd(a, 1); )
          s = a.parentNode, o = ml(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = Sm(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && rw(t, s, o);
}
function C$(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function _se(t, e) {
  for (; t && e == t.childNodes.length && !aS(t); )
    e = ml(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function Ese(t, e) {
  for (; t && !e && !aS(t); )
    e = ml(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function rw(t, e, n) {
  if (e.nodeType != 3) {
    let s, o;
    (o = _se(e, n)) ? (e = o, n = 0) : (s = Ese(e, n)) && (e = s, n = s.nodeValue.length);
  }
  let r = t.domSelection();
  if (w$(r)) {
    let s = document.createRange();
    s.setEnd(e, n), s.setStart(e, n), r.removeAllRanges(), r.addRange(s);
  } else
    r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: i } = t;
  setTimeout(() => {
    t.state == i && uS(t);
  }, 50);
}
function jO(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(vl || fse) && n.parent.inlineContent) {
    let i = t.coordsAtPos(e);
    if (e > n.start()) {
      let s = t.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let s = t.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function qO(t, e, n) {
  let r = t.state.selection;
  if (r instanceof Te && !r.empty || n.indexOf("s") > -1 || qr && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = nw(t.state, e);
    if (o && o instanceof ve)
      return lo(t, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, a = r instanceof ur ? $e.near(o, e) : $e.findFrom(o, e);
    return a ? lo(t, a) : !1;
  }
  return !1;
}
function KO(t, e) {
  if (!(t.state.selection instanceof Te))
    return !0;
  let { $head: n, $anchor: r, empty: i } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (s && !s.isText) {
    let o = t.state.tr;
    return e < 0 ? o.delete(n.pos - s.nodeSize, n.pos) : o.delete(n.pos, n.pos + s.nodeSize), t.dispatch(o), !0;
  }
  return !1;
}
function YO(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function Sse(t) {
  if (!bl || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    YO(t, r, "true"), setTimeout(() => YO(t, r, "false"), 20);
  }
  return !1;
}
function xse(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function kse(t, e) {
  let n = e.keyCode, r = xse(e);
  if (n == 8 || qr && n == 72 && r == "c")
    return KO(t, -1) || Ol(t, -1);
  if (n == 46 && !e.shiftKey || qr && n == 68 && r == "c")
    return KO(t, 1) || Ol(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || qr && n == 66 && r == "c") {
    let i = n == 37 ? jO(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return GO(t, i, r) || Ol(t, i);
  } else if (n == 39 || qr && n == 70 && r == "c") {
    let i = n == 39 ? jO(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return GO(t, i, r) || Ol(t, i);
  } else {
    if (n == 38 || qr && n == 80 && r == "c")
      return qO(t, -1, r) || Ol(t, -1);
    if (n == 40 || qr && n == 78 && r == "c")
      return Sse(t) || qO(t, 1, r) || Ol(t, 1);
    if (r == (qr ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function T$(t, e) {
  t.someProp("transformCopied", (h) => {
    e = h(e, t);
  });
  let n = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let h = r.firstChild;
    n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), r = h.content;
  }
  let o = t.someProp("clipboardSerializer") || jw.fromSchema(t.state.schema), a = D$(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(r, { document: a }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = R$[c.nodeName.toLowerCase()]); ) {
    for (let h = u.length - 1; h >= 0; h--) {
      let p = a.createElement(u[h]);
      for (; l.firstChild; )
        p.appendChild(l.firstChild);
      l.appendChild(p), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (h) => h(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function O$(t, e, n, r, i) {
  let s = i.parent.type.spec.code, o, a;
  if (!n && !e)
    return null;
  let l = e && (r || s || !n);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, s || r, t);
    }), s)
      return e ? new Fe(je.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : Fe.empty;
    let d = t.someProp("clipboardTextParser", (f) => f(e, i, r, t));
    if (d)
      a = d;
    else {
      let f = i.marks(), { schema: h } = t.state, p = jw.fromSchema(h);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let m = o.appendChild(document.createElement("p"));
        g && m.appendChild(p.serializeNode(h.text(g, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), o = Ose(n), cS && Mse(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || A3.fromSchema(t.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !Cse.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    a = Ase(XO(a, +u[1], +u[2]), u[4]);
  else if (a = Fe.maxOpen(Tse(a.content, i), !0), a.openStart || a.openEnd) {
    let d = 0, f = 0;
    for (let h = a.content.firstChild; d < a.openStart && !h.type.spec.isolating; d++, h = h.firstChild)
      ;
    for (let h = a.content.lastChild; f < a.openEnd && !h.type.spec.isolating; f++, h = h.lastChild)
      ;
    a = XO(a, d, f);
  }
  return t.someProp("transformPasted", (d) => {
    a = d(a, t);
  }), a;
}
const Cse = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function Tse(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)), s, o = [];
    if (t.forEach((a) => {
      if (!o)
        return;
      let l = i.findWrapping(a.type), c;
      if (!l)
        return o = null;
      if (c = o.length && s.length && A$(l, s, a, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = N$(o[o.length - 1], s.length));
        let u = M$(a, l);
        o.push(u), i = i.matchType(u.type), s = l;
      }
    }), o)
      return je.from(o);
  }
  return t;
}
function M$(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, je.from(t));
  return t;
}
function A$(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let s = A$(t, e, n, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(je.from(M$(n, t, i + 1))));
  }
}
function N$(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, N$(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(je.empty, !0);
  return t.copy(n.append(r));
}
function iw(t, e, n, r, i, s) {
  let o = e < 0 ? t.firstChild : t.lastChild, a = o.content;
  return t.childCount > 1 && (s = 0), i < r - 1 && (a = iw(a, e, n, r, i + 1, s)), i >= n && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, s <= i).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(je.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, o.copy(a));
}
function XO(t, e, n) {
  return e < t.openStart && (t = new Fe(iw(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new Fe(iw(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const R$ = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let JO = null;
function D$() {
  return JO || (JO = document.implementation.createHTMLDocument("title"));
}
function Ose(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = D$().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
  if ((i = r && R$[r[1].toLowerCase()]) && (t = i.map((s) => "<" + s + ">").join("") + t + i.map((s) => "</" + s + ">").reverse().join("")), n.innerHTML = t, i)
    for (let s = 0; s < i.length; s++)
      n = n.querySelector(i[s]) || n;
  return n;
}
function Mse(t) {
  let e = t.querySelectorAll(vl ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function Ase(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: i, openStart: s, openEnd: o } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = je.from(l.create(r[a + 1], i)), s++, o++;
  }
  return new Fe(i, s, o);
}
const $i = {}, Hr = {};
function _o(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
Hr.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !P$(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(eh && vl && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), lS && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (i) => i(t, _$(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else
      t.someProp("handleKeyDown", (r) => r(t, n)) || kse(t, n) ? n.preventDefault() : _o(t, "key");
};
Hr.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Hr.keypress = (t, e) => {
  let n = e;
  if (P$(t, n) || !n.charCode || n.ctrlKey && !n.altKey || qr && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (i) => i(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof Te) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(i) && !t.someProp("handleTextInput", (s) => s(t, r.$from.pos, r.$to.pos, i)) && t.dispatch(t.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
  }
};
function p0(t) {
  return { left: t.clientX, top: t.clientY };
}
function Nse(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function dS(t, e, n, r, i) {
  if (r == -1)
    return !1;
  let s = t.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (t.someProp(e, (a) => o > s.depth ? a(t, n, s.nodeAfter, s.before(o), i, !0) : a(t, n, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function lc(t, e, n) {
  t.focused || t.focus();
  let r = t.state.tr.setSelection(e);
  n == "pointer" && r.setMeta("pointer", !0), t.dispatch(r);
}
function Rse(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && ve.isSelectable(r) ? (lc(t, new ve(n), "pointer"), !0) : !1;
}
function Dse(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, i;
  n instanceof ve && (r = n.node);
  let s = t.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o);
    if (ve.isSelectable(a)) {
      r && n.$from.depth > 0 && o >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? i = s.before(n.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (lc(t, ve.create(t.state.doc, i), "pointer"), !0) : !1;
}
function Ise(t, e, n, r, i) {
  return dS(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (s) => s(t, e, r)) || (i ? Dse(t, n) : Rse(t, n));
}
function Pse(t, e, n, r) {
  return dS(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (i) => i(t, e, r));
}
function Lse(t, e, n, r) {
  return dS(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (i) => i(t, e, r)) || $se(t, n, r);
}
function $se(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (lc(t, Te.create(r, 0, r.content.size), "pointer"), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), a = i.before(s);
    if (o.inlineContent)
      lc(t, Te.create(r, a + 1, a + 1 + o.content.size), "pointer");
    else if (ve.isSelectable(o))
      lc(t, ve.create(r, a), "pointer");
    else
      continue;
    return !0;
  }
}
function fS(t) {
  return xm(t);
}
const I$ = qr ? "metaKey" : "ctrlKey";
$i.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = fS(t), i = Date.now(), s = "singleClick";
  i - t.input.lastClick.time < 500 && Nse(n, t.input.lastClick) && !n[I$] && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: s };
  let o = t.posAtCoords(p0(n));
  o && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new Bse(t, o, n, !!r)) : (s == "doubleClick" ? Pse : Lse)(t, o.pos, o.inside, n) ? n.preventDefault() : _o(t, "pointer"));
};
class Bse {
  constructor(e, n, r, i) {
    this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[I$], this.allowDefault = r.shiftKey;
    let s, o;
    if (n.inside > -1)
      s = e.state.doc.nodeAt(n.inside), o = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const a = i ? null : r.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l ? l.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof ve && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && h0 && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), _o(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => uS(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(p0(e))), this.updateAllowDefault(e), this.allowDefault || !n ? _o(this.view, "pointer") : Ise(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    bl && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    vl && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (lc(this.view, $e.near(this.view.state.doc.resolve(n.pos)), "pointer"), e.preventDefault()) : _o(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), _o(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
$i.touchstart = (t) => {
  t.input.lastTouch = Date.now(), fS(t), _o(t, "pointer");
};
$i.touchmove = (t) => {
  t.input.lastTouch = Date.now(), _o(t, "pointer");
};
$i.contextmenu = (t) => fS(t);
function P$(t, e) {
  return t.composing ? !0 : bl && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const Fse = eh ? 5e3 : -1;
Hr.compositionstart = Hr.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$from;
    if (e.selection.empty && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), xm(t, !0), t.markCursor = null;
    else if (xm(t), h0 && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          t.domSelection().collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    t.input.composing = !0;
  }
  L$(t, Fse);
};
Hr.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, L$(t, 20));
};
function L$(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => xm(t), e));
}
function zse(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = Hse()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function Hse() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function xm(t, e = !1) {
  if (!(eh && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), zse(t), e || t.docView && t.docView.dirty) {
      let n = pse(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function Use(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const af = Qf && S$ < 15 || lS && hse < 604;
$i.copy = Hr.cut = (t, e) => {
  let n = e, r = t.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let s = af ? null : n.clipboardData, o = r.content(), { dom: a, text: l } = T$(t, o);
  s ? (n.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : Use(t, a), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function Vse(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function Wse(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? sw(t, r.value, null, i, e) : sw(t, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function sw(t, e, n, r, i) {
  let s = O$(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, i, s || Fe.empty)))
    return !0;
  if (!s)
    return !1;
  let o = Vse(s), a = o ? t.state.tr.replaceSelectionWith(o, r) : t.state.tr.replaceSelection(s);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function $$(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Hr.paste = (t, e) => {
  let n = e;
  if (t.composing && !eh)
    return;
  let r = af ? null : n.clipboardData, i = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && sw(t, $$(r), r.getData("text/html"), i, n) ? n.preventDefault() : Wse(t, n);
};
class Gse {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
}
const B$ = qr ? "altKey" : "ctrlKey";
$i.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = t.state.selection, s = i.empty ? null : t.posAtCoords(p0(n)), o;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof ve ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = ve.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (o = ve.create(t.state.doc, d.posBefore));
    }
  }
  let a = (o || t.state.selection).content(), { dom: l, text: c, slice: u } = T$(t, a);
  n.dataTransfer.clearData(), n.dataTransfer.setData(af ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", af || n.dataTransfer.setData("text/plain", c), t.dragging = new Gse(u, !n[B$], o);
};
$i.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Hr.dragover = Hr.dragenter = (t, e) => e.preventDefault();
Hr.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let i = t.posAtCoords(p0(n));
  if (!i)
    return;
  let s = t.state.doc.resolve(i.pos), o = r && r.slice;
  o ? t.someProp("transformPasted", (p) => {
    o = p(o, t);
  }) : o = O$(t, $$(n.dataTransfer), af ? null : n.dataTransfer.getData("text/html"), !1, s);
  let a = !!(r && !n[B$]);
  if (t.someProp("handleDrop", (p) => p(t, n, o || Fe.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!o)
    return;
  n.preventDefault();
  let l = o ? Z3(t.state.doc, s.pos, o) : s.pos;
  l == null && (l = s.pos);
  let c = t.state.tr;
  if (a) {
    let { node: p } = r;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (d ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let h = c.doc.resolve(u);
  if (d && ve.isSelectable(o.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ve(h));
  else {
    let p = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((g, m, v, y) => p = y), c.setSelection(k$(t, h, c.doc.resolve(p)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
$i.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && uS(t);
  }, 20));
};
$i.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
$i.beforeinput = (t, e) => {
  if (vl && eh && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (s) => s(t, _$(8, "Backspace")))))
        return;
      let { $cursor: i } = t.state.selection;
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Hr)
  $i[t] = Hr[t];
function lf(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class km {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || Da, this.side = this.spec.side || 0;
  }
  map(e, n, r, i) {
    let { pos: s, deleted: o } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new Si(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof km && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && lf(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class To {
  constructor(e, n) {
    this.attrs = e, this.spec = n || Da;
  }
  map(e, n, r, i) {
    let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new Si(s, o, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof To && lf(this.attrs, e.attrs) && lf(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof To;
  }
  destroy() {
  }
}
class hS {
  constructor(e, n) {
    this.attrs = e, this.spec = n || Da;
  }
  map(e, n, r, i) {
    let s = e.mapResult(n.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(n.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new Si(s.pos - r, o.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from), s;
    return i == n.from && !(s = e.child(r)).isText && i + s.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof hS && lf(this.attrs, e.attrs) && lf(this.spec, e.spec);
  }
  destroy() {
  }
}
class Si {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new Si(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new Si(e, e, new km(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, i) {
    return new Si(e, n, new To(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, i) {
    return new Si(e, n, new hS(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof To;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof km;
  }
}
const Vl = [], Da = {};
class un {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : Vl, this.children = n.length ? n : Vl;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? Cm(n, e, 0, Da) : jn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let i = [];
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(e, n, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= n && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < n && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, n - a, r, i + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == jn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Da);
  }
  /**
  @internal
  */
  mapInner(e, n, r, i, s) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, i);
      l && l.type.valid(n, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? jse(this.children, o || [], e, n, r, i, s) : o ? new un(o.sort(Ia), Vl) : jn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == jn ? un.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let i, s = 0;
    e.forEach((a, l) => {
      let c = l + r, u;
      if (u = z$(n, a, c)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < l; )
          s += 3;
        i[s] == l ? i[s + 2] = i[s + 2].addInner(a, u, c + 1) : i.splice(s, 0, l, l + a.nodeSize, Cm(u, a, c + 1, Da)), s += 3;
      }
    });
    let o = F$(s ? H$(n) : n, -r);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new un(o.length ? this.local.concat(o).sort(Ia) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == jn ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, a = r[s] + n, l = r[s + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (o || (o = [])).push(d));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[s + 2].removeInner(o, a + 1);
      c != jn ? r[s + 2] = c : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let a = 0; a < i.length; a++)
            i[a].eq(o, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new un(i, r) : jn;
  }
  forChild(e, n) {
    if (this == jn)
      return this;
    if (n.isLeaf)
      return un.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let s = e + 1, o = s + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > s && l.type instanceof To) {
        let c = Math.max(s, l.from) - s, u = Math.min(o, l.to) - s;
        c < u && (i || (i = [])).push(l.copy(c, u));
      }
    }
    if (i) {
      let a = new un(i.sort(Ia), Vl);
      return r ? new ca([a, r]) : a;
    }
    return r || jn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof un) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return pS(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == jn)
      return Vl;
    if (e.inlineContent || !this.local.some(To.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof To || n.push(this.local[r]);
    return n;
  }
}
un.empty = new un([], []);
un.removeOverlap = pS;
const jn = un.empty;
class ca {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, Da));
    return ca.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return un.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, n);
      s != jn && (s instanceof ca ? r = r.concat(s.members) : r.push(s));
    }
    return ca.from(r);
  }
  eq(e) {
    if (!(e instanceof ca) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!n)
          n = s;
        else {
          r && (n = n.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            n.push(s[o]);
        }
    }
    return n ? pS(r ? n : n.sort(Ia)) : Vl;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return jn;
      case 1:
        return e[0];
      default:
        return new ca(e.every((n) => n instanceof un) ? e : e.reduce((n, r) => n.concat(r instanceof un ? r : r.members), []));
    }
  }
}
function jse(t, e, n, r, i, s, o) {
  let a = t.slice();
  for (let c = 0, u = s; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((f, h, p, g) => {
      let m = g - p - (h - f);
      for (let v = 0; v < a.length; v += 3) {
        let y = a[v + 1];
        if (y < 0 || f > y + u - d)
          continue;
        let E = a[v] + u - d;
        h >= E ? a[v + 1] = f <= E ? -2 : -1 : f >= u && m && (a[v] += m, a[v + 1] += m);
      }
      d += m;
    }), u = n.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let u = n.map(t[c] + s), d = u - i;
      if (d < 0 || d >= r.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[c + 1] + s, -1), h = f - i, { index: p, offset: g } = r.content.findIndex(d), m = r.maybeChild(p);
      if (m && g == d && g + m.nodeSize == h) {
        let v = a[c + 2].mapInner(n, m, u + 1, t[c] + s + 1, o);
        v != jn ? (a[c] = d, a[c + 1] = h, a[c + 2] = v) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = qse(a, t, e, n, i, s, o), u = Cm(c, r, 0, o);
    e = u.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let h = u.children[d];
      for (; f < a.length && a[f] < h; )
        f += 3;
      a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new un(e.sort(Ia), a);
}
function F$(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    n.push(new Si(i.from + e, i.to + e, i.type));
  }
  return n;
}
function qse(t, e, n, r, i, s, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(r, i, c);
      d ? n.push(d) : o.onRemove && o.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1);
  return n;
}
function z$(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, i = null;
  for (let s = 0, o; s < t.length; s++)
    (o = t[s]) && o.from > n && o.to < r && ((i || (i = [])).push(o), t[s] = null);
  return i;
}
function H$(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function Cm(t, e, n, r) {
  let i = [], s = !1;
  e.forEach((a, l) => {
    let c = z$(t, a, l + n);
    if (c) {
      s = !0;
      let u = Cm(c, a, n + l + 1, r);
      u != jn && i.push(l, l + a.nodeSize, u);
    }
  });
  let o = F$(s ? H$(t) : t, -n).sort(Ia);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || i.length ? new un(o, i) : jn;
}
function Ia(t, e) {
  return t.from - e.from || t.to - e.to;
}
function pS(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == t && (e = t.slice()), e[i] = s.copy(s.from, r.to), ZO(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, s.from), ZO(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function ZO(t, e, n) {
  for (; e < t.length && Ia(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
var ow, aw;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  ow = (e) => t.get(e), aw = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  ow = (r) => {
    for (let i = 0; i < t.length; i += 2)
      if (t[i] == r)
        return t[i + 1];
  }, aw = (r, i) => (n == 10 && (n = 0), t[n++] = r, t[n++] = i);
}
var Rs = class {
  constructor(t, e, n, r) {
    this.width = t, this.height = e, this.map = n, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t)
        continue;
      const r = e % this.width, i = e / this.width | 0;
      let s = r + 1, o = i + 1;
      for (let a = 1; s < this.width && this.map[e + a] == n; a++)
        s++;
      for (let a = 1; o < this.height && this.map[e + this.width * a] == n; a++)
        o++;
      return { left: r, top: i, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: r, right: i, top: s, bottom: o } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (n < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: r,
      top: i,
      bottom: s
    } = this.findCell(t), {
      left: o,
      right: a,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(n, o),
      top: Math.min(i, l),
      right: Math.max(r, a),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let r = t.top; r < t.bottom; r++)
      for (let i = t.left; i < t.right; i++) {
        const s = r * this.width + i, o = this.map[s];
        n[o] || (n[o] = !0, !(i == t.left && i && this.map[s - 1] == o || r == t.top && r && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let r = 0, i = 0; ; r++) {
      const s = i + n.child(r).nodeSize;
      if (r == t) {
        let o = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; o < a && this.map[o] < i; )
          o++;
        return o == a ? s - 1 : this.map[o];
      }
      i = s;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return ow(t) || aw(t, Kse(t));
  }
};
function Kse(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = Yse(t), n = t.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let c = 0, u = e * n; c < u; c++)
    r[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = t.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; i < r.length && r[i] != 0; )
        i++;
      if (p == d.childCount)
        break;
      const g = d.child(p), { colspan: m, rowspan: v, colwidth: y } = g.attrs;
      for (let E = 0; E < v; E++) {
        if (E + c >= n) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: v - E
          });
          break;
        }
        const b = i + E * e;
        for (let _ = 0; _ < m; _++) {
          r[b + _] == 0 ? r[b + _] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: m - _
          });
          const w = y && y[_];
          if (w) {
            const S = (b + _) % e * 2, x = o[S];
            x == null || x != w && o[S + 1] == 1 ? (o[S] = w, o[S + 1] = 1) : x == w && o[S + 1]++;
          }
        }
      }
      i += m, u += g.nodeSize;
    }
    const f = (c + 1) * e;
    let h = 0;
    for (; i < f; )
      r[i++] == 0 && h++;
    h && (s || (s = [])).push({ type: "missing", row: c, n: h }), u++;
  }
  const a = new Rs(e, n, r, s);
  let l = !1;
  for (let c = 0; !l && c < o.length; c += 2)
    o[c] != null && o[c + 1] < n && (l = !0);
  return l && Xse(a, o, t), a;
}
function Yse(t) {
  let e = -1, n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const i = t.child(r);
    let s = 0;
    if (n)
      for (let o = 0; o < r; o++) {
        const a = t.child(o);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          o + c.attrs.rowspan > r && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const a = i.child(o);
      s += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function Xse(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let i = 0; i < t.map.length; i++) {
    const s = t.map[i];
    if (r[s])
      continue;
    r[s] = !0;
    const o = n.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let a = null;
    const l = o.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = (i + c) % t.width, d = e[u * 2];
      d != null && (!l.colwidth || l.colwidth[c] != d) && ((a || (a = Jse(l)))[c] = d);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: a
    });
  }
}
function Jse(t) {
  if (t.colwidth)
    return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++)
    e.push(0);
  return e;
}
function gS(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
new ft("selectingCells");
function Zse(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function U$(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function Qse(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = Zse(e.$head) || eoe(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function eoe(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function QO(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function V$(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function W$(t, e, n) {
  const r = t.node(-1), i = Rs.get(r), s = t.start(-1), o = i.nextCell(t.pos - s, e, n);
  return o == null ? null : t.node(0).resolve(s + o);
}
function eM(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
var Ti = class Ts extends $e {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const r = e.node(-1), i = Rs.get(r), s = e.start(-1), o = i.rectBetween(
      e.pos - s,
      n.pos - s
    ), a = e.node(0), l = i.cellsInRect(o).filter((u) => u != n.pos - s);
    l.unshift(n.pos - s);
    const c = l.map((u) => {
      const d = r.nodeAt(u);
      if (!d)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new Jw(
        a.resolve(f),
        a.resolve(f + d.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)), i = e.resolve(n.map(this.$headCell.pos));
    if (QO(r) && QO(i) && V$(r, i)) {
      const s = this.$anchorCell.node(-1) != r.node(-1);
      return s && this.isRowSelection() ? Ts.rowSelection(r, i) : s && this.isColSelection() ? Ts.colSelection(r, i) : new Ts(r, i);
    }
    return Te.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = Rs.get(e), r = this.$anchorCell.start(-1), i = n.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), s = {}, o = [];
    for (let l = i.top; l < i.bottom; l++) {
      const c = [];
      for (let u = l * n.width + i.left, d = i.left; d < i.right; d++, u++) {
        const f = n.map[u];
        if (s[f])
          continue;
        s[f] = !0;
        const h = n.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const g = i.left - h.left, m = h.right - i.right;
        if (g > 0 || m > 0) {
          let v = p.attrs;
          if (g > 0 && (v = eM(v, 0, g)), m > 0 && (v = eM(
            v,
            v.colspan - m,
            m
          )), h.left < i.left) {
            if (p = p.type.createAndFill(v), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(v)}`
              );
          } else
            p = p.type.create(v, p.content);
        }
        if (h.top < i.top || h.bottom > i.bottom) {
          const v = {
            ...p.attrs,
            rowspan: Math.min(h.bottom, i.bottom) - Math.max(h.top, i.top)
          };
          h.top < i.top ? p = p.type.createAndFill(v) : p = p.type.create(v, p.content);
        }
        c.push(p);
      }
      o.push(e.child(l).copy(je.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : o;
    return new Fe(je.from(a), 1, 1);
  }
  replace(e, n = Fe.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: a, $to: l } = i[o], c = e.mapping.slice(r);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        o ? Fe.empty : n
      );
    }
    const s = $e.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, n) {
    this.replace(e, new Fe(je.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), r = Rs.get(n), i = this.$anchorCell.start(-1), s = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < s.length; o++)
      e(n.nodeAt(s[o]), i + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0)
      return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const r = e.node(-1), i = Rs.get(r), s = e.start(-1), o = i.findCell(e.pos - s), a = i.findCell(n.pos - s), l = e.node(0);
    return o.top <= a.top ? (o.top > 0 && (e = l.resolve(s + i.map[o.left])), a.bottom < i.height && (n = l.resolve(
      s + i.map[i.width * (i.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (n = l.resolve(s + i.map[a.left])), o.bottom < i.height && (e = l.resolve(
      s + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new Ts(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = Rs.get(e), r = this.$anchorCell.start(-1), i = n.colCount(this.$anchorCell.pos - r), s = n.colCount(this.$headCell.pos - r);
    if (Math.min(i, s) > 0)
      return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, a) == n.width;
  }
  eq(e) {
    return e instanceof Ts && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const r = e.node(-1), i = Rs.get(r), s = e.start(-1), o = i.findCell(e.pos - s), a = i.findCell(n.pos - s), l = e.node(0);
    return o.left <= a.left ? (o.left > 0 && (e = l.resolve(
      s + i.map[o.top * i.width]
    )), a.right < i.width && (n = l.resolve(
      s + i.map[i.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (n = l.resolve(s + i.map[a.top * i.width])), o.right < i.width && (e = l.resolve(
      s + i.map[i.width * (o.top + 1) - 1]
    ))), new Ts(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Ts(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new Ts(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new toe(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Ti.prototype.visible = !1;
$e.jsonID("cell", Ti);
var toe = class G$ {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new G$(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && V$(n, r) ? new Ti(n, r) : $e.near(r, 1);
  }
};
new ft("fix-tables");
kv({
  ArrowLeft: Qh("horiz", -1),
  ArrowRight: Qh("horiz", 1),
  ArrowUp: Qh("vert", -1),
  ArrowDown: Qh("vert", 1),
  "Shift-ArrowLeft": ep("horiz", -1),
  "Shift-ArrowRight": ep("horiz", 1),
  "Shift-ArrowUp": ep("vert", -1),
  "Shift-ArrowDown": ep("vert", 1),
  Backspace: tp,
  "Mod-Backspace": tp,
  Delete: tp,
  "Mod-Delete": tp
});
function Rp(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function Qh(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const s = n.selection;
    if (s instanceof Ti)
      return Rp(
        n,
        r,
        $e.near(s.$headCell, e)
      );
    if (t != "horiz" && !s.empty)
      return !1;
    const o = j$(i, t, e);
    if (o == null)
      return !1;
    if (t == "horiz")
      return Rp(
        n,
        r,
        $e.near(n.doc.resolve(s.head + e), e)
      );
    {
      const a = n.doc.resolve(o), l = W$(a, t, e);
      let c;
      return l ? c = $e.near(l, 1) : e < 0 ? c = $e.near(n.doc.resolve(a.before(-1)), -1) : c = $e.near(n.doc.resolve(a.after(-1)), 1), Rp(n, r, c);
    }
  };
}
function ep(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const s = n.selection;
    let o;
    if (s instanceof Ti)
      o = s;
    else {
      const l = j$(i, t, e);
      if (l == null)
        return !1;
      o = new Ti(n.doc.resolve(l));
    }
    const a = W$(o.$headCell, t, e);
    return a ? Rp(
      n,
      r,
      new Ti(o.$anchorCell, a)
    ) : !1;
  };
}
function tp(t, e) {
  const n = t.selection;
  if (!(n instanceof Ti))
    return !1;
  if (e) {
    const r = t.tr, i = gS(t.schema).cell.createAndFill().content;
    n.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new Fe(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function j$(t, e, n) {
  if (!(t.state.selection instanceof Te))
    return null;
  const { $head: r } = t.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : s.childCount))
      return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const a = r.before(i), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
new ft(
  "tableColumnResizing"
);
function q$(t) {
  const e = t.selection, n = Qse(t), r = n.node(-1), i = n.start(-1), s = Rs.get(r);
  return { ...e instanceof Ti ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(n.pos - i), tableStart: i, map: s, table: r };
}
function noe(t) {
  return function(e, n) {
    if (!U$(e))
      return !1;
    if (n) {
      const r = gS(e.schema), i = q$(e), s = e.tr, o = i.map.cellsInRect(
        t == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : t == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), a = o.map((l) => i.table.nodeAt(l));
      for (let l = 0; l < o.length; l++)
        a[l].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[l],
          r.cell,
          a[l].attrs
        );
      if (s.steps.length == 0)
        for (let l = 0; l < o.length; l++)
          s.setNodeMarkup(
            i.tableStart + o[l],
            r.header_cell,
            a[l].attrs
          );
      n(s);
    }
    return !0;
  };
}
function tM(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function mS(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? noe(t) : function(n, r) {
    if (!U$(n))
      return !1;
    if (r) {
      const i = gS(n.schema), s = q$(n), o = n.tr, a = tM("row", s, i), l = tM(
        "column",
        s,
        i
      ), u = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0, d = t == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : t == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = t == "column" ? l ? i.cell : i.header_cell : t == "row" ? a ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(d).forEach((h) => {
        const p = h + s.tableStart, g = o.doc.nodeAt(p);
        g && o.setNodeMarkup(p, f, g.attrs);
      }), r(o);
    }
    return !0;
  };
}
mS("row", {
  useDeprecatedLogic: !0
});
mS("column", {
  useDeprecatedLogic: !0
});
mS("cell", {
  useDeprecatedLogic: !0
});
const roe = {
  key: 0,
  class: "table-bubble-menu"
}, ioe = { class: "flex items-center gap-1" }, soe = {
  __name: "TableBubbleMenu",
  setup(t) {
    const e = Ln("editorInstance"), n = (i) => {
      const s = i.state.selection;
      if (s instanceof Ti) {
        let o = 0, a = 0;
        return s.forEachCell((l) => {
          o++, (l.attrs.colspan > 1 || l.attrs.rowspan > 1) && a++;
        }), {
          isRowSelection: s.isRowSelection(),
          isColSelection: s.isColSelection(),
          cellCount: o,
          mergedCellCount: a
        };
      }
      return null;
    }, r = rt(() => n(e.value));
    return (i, s) => C(e) && r.value ? (J(), be("div", roe, [
      se("div", ioe, [
        r.value.cellCount > 1 ? (J(), Ze(Ve, {
          key: 0,
          action: () => C(e).chain().focus().mergeOrSplit().run(),
          icon: C(oG),
          title: C(me)("mergeCells")
        }, null, 8, ["action", "icon", "title"])) : He("", !0),
        r.value.mergedCellCount > 0 ? (J(), Ze(Ve, {
          key: 1,
          action: () => C(e).chain().focus().mergeOrSplit().run(),
          icon: C(LG),
          title: C(me)("splitCells")
        }, null, 8, ["action", "icon", "title"])) : He("", !0),
        W(Ve, {
          action: () => C(e).chain().focus().addRowBefore().run(),
          icon: C(Z6),
          title: C(me)("addTopRow")
        }, null, 8, ["action", "icon", "title"]),
        W(Ve, {
          action: () => C(e).chain().focus().addRowAfter().run(),
          icon: C(Y6),
          title: C(me)("addBottomRow")
        }, null, 8, ["action", "icon", "title"]),
        W(Ve, {
          action: () => C(e).chain().focus().addColumnBefore().run(),
          icon: C(X6),
          title: C(me)("addLeftCell")
        }, null, 8, ["action", "icon", "title"]),
        W(Ve, {
          action: () => C(e).chain().focus().addColumnAfter().run(),
          icon: C(J6),
          title: C(me)("addRightCell")
        }, null, 8, ["action", "icon", "title"]),
        r.value.isRowSelection && !r.value.isColSelection ? (J(), Ze(Ve, {
          key: 2,
          action: () => C(e).chain().focus().deleteRow().run(),
          icon: C(TG),
          title: C(me)("delRow")
        }, null, 8, ["action", "icon", "title"])) : He("", !0),
        r.value.isColSelection && !r.value.isRowSelection ? (J(), Ze(Ve, {
          key: 3,
          action: () => C(e).chain().focus().deleteColumn().run(),
          icon: C(OG),
          title: C(me)("delCol")
        }, null, 8, ["action", "icon", "title"])) : He("", !0),
        r.value.isColSelection && r.value.isRowSelection ? (J(), Ze(Ve, {
          key: 4,
          action: () => C(e).chain().focus().deleteTable().run(),
          icon: C(zv),
          title: C(me)("delTable")
        }, null, 8, ["action", "icon", "title"])) : He("", !0)
      ])
    ])) : He("", !0);
  }
}, ooe = an.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", _t(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
function aoe(t) {
  return t || (t = {
    HTMLAttributes: {
      class: "contains-task-list"
    }
  }), ooe.configure(t);
}
const loe = /^\s*(\[([( |x])?\])\s$/, coe = an.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      _t(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: n, editor: r }) => {
      const i = document.createElement("li"), s = document.createElement("label"), o = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
      return s.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (c) => c.preventDefault()), a.addEventListener("change", (c) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: u } = c.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: d }) => {
          const f = n();
          if (typeof f != "number")
            return !1;
          const h = d.doc.nodeAt(f);
          return d.setNodeMarkup(f, void 0, {
            ...h == null ? void 0 : h.attrs,
            checked: u
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, u) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([c, u]) => {
        i.setAttribute(c, u);
      }), i.dataset.checked = t.attrs.checked, t.attrs.checked && a.setAttribute("checked", "checked"), s.append(a, o), i.append(s, l), Object.entries(e).forEach(([c, u]) => {
        i.setAttribute(c, u);
      }), {
        dom: i,
        contentDOM: l,
        update: (c) => c.type !== this.type ? !1 : (i.dataset.checked = c.attrs.checked, c.attrs.checked ? a.setAttribute("checked", "checked") : a.removeAttribute("checked"), !0)
      };
    };
  },
  addInputRules() {
    return [
      Ec({
        find: loe,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
});
function uoe(t) {
  return t || (t = {
    nested: !0
  }), coe.extend({
    addAttributes() {
      var e;
      return {
        ...(e = this.parent) == null ? void 0 : e.call(this),
        checked: {
          default: !1,
          keepOnSplit: !1,
          parseHTML: (n) => n.getAttribute("data-checked") === "true",
          renderHTML: (n) => ({
            "data-checked": n.checked,
            class: n.checked ? "task-list-item enabled" : "task-list-item"
          })
        }
      };
    },
    renderHTML({ node: e, HTMLAttributes: n }) {
      return [
        "li",
        _t(this.options.HTMLAttributes, n, {
          "data-type": this.name
        }),
        [
          "label",
          [
            "input",
            {
              type: "checkbox",
              checked: e.attrs.checked ? "checked" : null,
              class: "task-list-item-checkbox"
            }
          ],
          ["span"]
        ],
        ["div", 0]
      ];
    },
    addNodeView() {
      return ({ node: e, HTMLAttributes: n, getPos: r, editor: i }) => {
        const s = document.createElement("li"), o = document.createElement("label"), a = document.createElement("span"), l = document.createElement("input"), c = document.createElement("div");
        return o.contentEditable = "false", l.type = "checkbox", l.classList.add("task-list-item-checkbox"), l.addEventListener("change", (u) => {
          if (!i.isEditable && !this.options.onReadOnlyChecked) {
            l.checked = !l.checked;
            return;
          }
          const { checked: d } = u.target;
          i.isEditable && typeof r == "function" && i.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: f }) => {
            const h = r(), p = f.doc.nodeAt(h);
            return f.setNodeMarkup(h, void 0, {
              ...p == null ? void 0 : p.attrs,
              checked: d
            }), !0;
          }).run(), !i.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(e, d) || (l.checked = !l.checked));
        }), Object.entries(this.options.HTMLAttributes).forEach(([u, d]) => {
          s.setAttribute(u, d);
        }), s.dataset.checked = e.attrs.checked, e.attrs.checked && l.setAttribute("checked", "checked"), o.append(l, a), s.append(o, c), Object.entries(n).forEach(([u, d]) => {
          s.setAttribute(u, d);
        }), {
          dom: s,
          contentDOM: c,
          update: (u) => u.type !== this.type ? !1 : (s.dataset.checked = u.attrs.checked, s.classList.add("task-list-item"), u.attrs.checked ? s.classList.add("enabled") : s.classList.remove("enabled"), u.attrs.checked ? l.setAttribute("checked", "checked") : l.removeAttribute("checked"), !0)
        };
      };
    }
  }).configure(t);
}
const doe = { key: 0 }, foe = /* @__PURE__ */ ae({
  __name: "TaskListExt",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(aoe(e.options)), nt(uoe()), (r, i) => C(n) ? (J(), be("div", doe, [
      Lt(r.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(n).chain().focus().toggleTaskList().run(),
          icon: C(pG),
          "is-active": () => C(n).isActive("taskList"),
          title: C(me)("taskList")
        }, null, 8, ["action", "icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
}), K$ = an.create({
  name: "text",
  group: "inline"
}), hoe = /* @__PURE__ */ ae({
  __name: "Text",
  setup(t) {
    return nt(K$), (e, n) => null;
  }
});
function Zpe() {
  return K$;
}
const Y$ = Et.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign || this.options.defaultAlignment;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign === this.options.defaultAlignment ? {} : { style: `text-align: ${t.textAlign}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), poe = { key: 0 }, goe = ["onClick"], moe = { class: "flex items-center space-x-2" }, X$ = /* @__PURE__ */ ae({
  __name: "TextAlign",
  props: {
    options: {
      type: Object,
      required: !1,
      default: () => ({
        types: ["heading", "paragraph"]
      })
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    nt(Y$.configure(e.options));
    const r = [
      {
        name: me("alignLeft"),
        icon: Hd,
        command: () => n.value.chain().focus().setTextAlign("left").run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("align-left");
        }
      },
      {
        name: me("alignCenter"),
        icon: z_,
        command: () => n.value.chain().focus().setTextAlign("center").run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("align-center");
        }
      },
      {
        name: me("alignRight"),
        icon: H_,
        command: () => n.value.chain().focus().setTextAlign("right").run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("align-right");
        }
      },
      {
        name: me("alignJustify"),
        icon: K6,
        command: () => n.value.chain().focus().setTextAlign("justify").run(),
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("align-justify");
        }
      }
    ], i = rt(
      () => r.filter((s) => s == null ? void 0 : s.isActive()).pop() ?? {
        name: "",
        icon: Hd,
        isActive: () => {
          var s;
          return (s = n.value) == null ? void 0 : s.isActive("align-left");
        }
      }
    );
    return (s, o) => C(n) ? (J(), be("div", poe, [
      W(fi, null, {
        button: Ue(() => [
          W(Jv, {
            mini: !0,
            text: i.value.name,
            title: C(me)("align")
          }, {
            default: Ue(() => [
              (J(), Ze(ii(i.value.icon), {
                size: 14,
                class: "text-sm"
              }))
            ]),
            _: 1
          }, 8, ["text", "title"])
        ]),
        content: Ue(() => [
          (J(), be(Vt, null, $n(r, (a, l) => se("div", {
            key: l,
            class: "flex items-center rounded gap-1.5 px-2 py-1.5 cursor-pointer text-sm langeditor-text langeditor-hover",
            type: "button",
            onClick: (c) => a.command()
          }, [
            (J(), Ze(ii(a.icon), {
              size: 14,
              class: "text-sm"
            })),
            se("div", moe, Ut(a.name), 1),
            i.value.isActive() ? (J(), Ze(C(Fv), {
              key: 0,
              class: "w-4 h-4"
            })) : He("", !0)
          ], 8, goe)), 64))
        ]),
        _: 1
      })
    ])) : He("", !0);
  }
});
function Qpe(t) {
  return t || (t = {
    types: ["heading", "paragraph"]
  }), Y$.configure(t);
}
const voe = /* @__PURE__ */ ae({
  __name: "TextStyle",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t;
    return nt(r2.configure(e.options)), (n, r) => null;
  }
});
function ege(t) {
  return r2.configure(t);
}
const J$ = mr.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", _t(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), boe = { key: 0 }, Z$ = /* @__PURE__ */ ae({
  __name: "Underline",
  props: {
    options: {
      type: Object,
      required: !1
    },
    mini: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = et();
    return nt(J$.configure(e.options)), (r, i) => C(n) ? (J(), be("div", boe, [
      W(Ve, {
        action: () => C(n).chain().focus().toggleUnderline().run(),
        icon: C(IG),
        "is-active": () => C(n).isActive("underline"),
        mini: t.mini,
        title: C(me)("underline")
      }, null, 8, ["action", "icon", "is-active", "mini", "title"])
    ])) : He("", !0);
  }
});
function tge(t) {
  return J$.configure(t);
}
const yoe = ["controls", "loop", "muted", "src"], woe = /* @__PURE__ */ ae({
  __name: "VideoView",
  props: {
    ...A_,
    selected: {
      type: Boolean,
      required: !0
    }
  },
  setup(t) {
    const e = t, n = X(), r = X(), i = X("auto"), s = X("auto"), o = X("auto"), a = X("auto"), l = X(!0), c = X(!1), u = X(!1), d = X(1), f = X(["nw", "n", "ne", "w", "e", "sw", "s", "se"]);
    function h({ width: _, height: w, transform: S }) {
      e.updateAttributes({
        keepRatio: u.value,
        width: _,
        height: w,
        transform: S
      });
    }
    const p = rt(() => {
      const { src: _, alt: w, width: S, height: x, keepRatio: k, controls: T, loop: I, muted: R } = e.node.attrs, N = Rd(S) ? S + "px" : S, $ = k ? null : Rd(x) ? x + "px" : x;
      return {
        src: _ || void 0,
        alt: w || void 0,
        controls: T || !1,
        loop: I || !1,
        muted: R || !1,
        style: {
          width: N || void 0,
          height: $ || void 0
        }
      };
    }), g = rt(() => {
      const {
        style: { width: _ }
      } = C(p);
      return { width: _ === "100%" ? _ : void 0 };
    }), m = X(!1), v = X({
      width: void 0,
      height: void 0
    }), y = async (_) => {
      m.value = !0, _.width = Math.round(_.width), _.height = Math.round(_.height);
      const w = Math.round(n.value.$el.parentNode.getBoundingClientRect().width);
      if (u.value && _.width >= w) {
        _.width = w, _.height = _.width / _.startRatio, h({
          width: "100%",
          height: _.height
        });
        return;
      }
      h({
        width: _.width,
        height: _.height
      }), _.target.style.width = `${_.width}px`, _.target.style.height = `${_.height}px`;
    };
    function E(_) {
      m.value = !1, v.value.width = p.value.style.width, v.value.height = p.value.style.height, b();
    }
    Bt(
      () => e.node.attrs,
      () => {
        u.value = e.node.attrs.keepRatio;
      },
      {
        immediate: !0,
        deep: !0
      }
    );
    function b() {
      const { editor: _, getPos: w } = e;
      _.commands.setNodeSelection(w());
    }
    return (_, w) => (J(), Ze(C(M_), {
      ref_key: "Wrap",
      ref: n,
      class: It([[e.node.attrs.display], "langeditor-video"]),
      style: Rr(g.value),
      as: "span"
    }, {
      default: Ue(() => [
        se("div", {
          style: Rr(g.value),
          class: "langeditor-video-container"
        }, [
          se("div", {
            ref_key: "targetRef",
            ref: r,
            style: Rr(`max-width: ${i.value};max-height: ${s.value};min-width: ${o.value};min-height: ${a.value};width:${v.value.width}px;height:${v.value.height}px`),
            class: "move-box"
          }, [
            se("video", {
              controls: p.value.controls,
              loop: p.value.loop,
              muted: p.value.muted,
              src: e.node.attrs.src,
              style: Rr(p.value.style),
              autoplay: ""
            }, null, 12, yoe)
          ], 4),
          t.selected || m.value ? (J(), Ze(C(VL), {
            key: 0,
            keepRatio: u.value,
            renderDirections: f.value,
            resizable: l.value && _.editor.isEditable,
            rotatable: c.value,
            target: r.value,
            throttleResize: d.value,
            useResizeObserver: !0,
            onResize: y,
            onResizeEnd: E
          }, null, 8, ["keepRatio", "renderDirections", "resizable", "rotatable", "target", "throttleResize"])) : He("", !0)
        ], 4)
      ]),
      _: 1
    }, 8, ["class", "style"]));
  }
});
const _oe = /* @__PURE__ */ wr(woe, [["__scopeId", "data-v-31997889"]]);
function Eoe() {
  return an.create({
    name: "video",
    atom: !0,
    draggable: !0,
    addOptions() {
      return {
        inline: !0,
        HTMLAttributes: {}
      };
    },
    inline() {
      return this.options.inline;
    },
    group() {
      return this.options.inline ? "inline" : "block";
    },
    addAttributes() {
      return {
        src: {
          default: null
        },
        alt: {
          default: null
        },
        keepRatio: {
          default: !0
        },
        controls: {
          default: !1
        },
        loop: {
          default: !1
        },
        muted: {
          default: !1
        },
        title: {
          default: null
        },
        width: {
          default: "100%"
        },
        height: {
          default: null
        },
        display: {
          default: "inline",
          renderHTML: ({ display: e }) => e ? {
            "data-display": e
          } : {},
          parseHTML: (e) => e.getAttribute("data-display") || "inline"
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "video[src]"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["video", _t(this.options.HTMLAttributes, e)];
    },
    addCommands() {
      return {
        setVideo: (e) => ({ commands: n }) => n.insertContent({
          type: this.name,
          attrs: e
        }),
        updateVideo: (e) => ({ commands: n }) => n.updateAttributes(this.name, e)
      };
    }
  }).extend({
    addNodeView() {
      return Lv(new _oe());
    }
  });
}
const Soe = { class: "w-80" }, xoe = /* @__PURE__ */ ae({
  __name: "LangVideoModal",
  props: {
    handleUpload: {
      type: Function,
      required: !1
    }
  },
  emits: ["ok"],
  setup(t, { expose: e, emit: n }) {
    const r = et(), i = t, s = X(0), o = [
      { label: me("networkVideo"), key: 0 },
      { label: me("localVideo"), key: 1 }
    ], a = X(""), l = n;
    function c(b) {
      g.value = 0, u.value = null, d.value = !1, f.value = !1, a.value = (b == null ? void 0 : b.src) || "";
    }
    const u = X(null), d = X(!1), f = X(!1), h = X("");
    function p() {
      l("ok", h.value);
    }
    Bt(a, () => {
      h.value = a.value, d.value = !!h.value;
    });
    const g = X(0);
    function m(b) {
      g.value = b;
    }
    async function v() {
      if (f.value = !0, !!u.value) {
        if (i.handleUpload) {
          g.value = 0;
          const b = await i.handleUpload(u.value, m);
          h.value = b, a.value = h.value, d.value = !0;
        } else
          g.value = 100, h.value = URL.createObjectURL(u.value), a.value = h.value, d.value = !0;
        f.value = !1;
      }
    }
    function y(b) {
      g.value = 0, d.value = !1, h.value = "", u.value = b;
    }
    function E(b) {
      s.value = b;
    }
    return e({ open: c }), (b, _) => (J(), Ze(fi, { "content-class": "p-3 pt-1" }, {
      button: Ue(() => [
        W(Ve, {
          icon: C(DD),
          "is-active": () => C(r).isActive("video"),
          title: C(me)("video")
        }, null, 8, ["icon", "is-active", "title"])
      ]),
      content: Ue(() => [
        se("div", Soe, [
          W(C(S2), { onChange: E }, {
            default: Ue(() => [
              W(C(x2), { class: "flex overflow-x-auto overflow-y-hidden border-b border-gray-200 whitespace-nowrap dark:border-gray-700" }, {
                default: Ue(() => [
                  (J(), be(Vt, null, $n(o, (w) => W(C(k2), {
                    class: It([
                      s.value === w.key ? "border-blue-500 dark:border-blue-400 dark:text-blue-300 text-blue-600" : "border-transparent",
                      "inline-flex items-center px-3 py-2 -mb-px text-xs text-center bg-transparent border-b-2 sm:text-sm whitespace-nowrap focus:outline-none"
                    ])
                  }, {
                    default: Ue(() => [
                      vv(Ut(w.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["class"])), 64))
                ]),
                _: 1
              }),
              W(C(C2), { class: "pt-2 pb-1" }, {
                default: Ue(() => [
                  W(C(Rg), { class: "text-left flex pt-2 flex-col items-center gap-2" }, {
                    default: Ue(() => [
                      W(cE, {
                        icon: C(Dc),
                        input: a.value,
                        placeholder: C(me)("videoUrlTips"),
                        onOk: _[0] || (_[0] = (w) => a.value = w)
                      }, null, 8, ["icon", "input", "placeholder"]),
                      W(ns, {
                        content: C(me)("uploadVideo"),
                        icon: C(Ga),
                        loading: f.value,
                        onClick: p
                      }, null, 8, ["content", "icon", "loading"])
                    ]),
                    _: 1
                  }),
                  W(C(Rg), { class: "text-left flex flex-col gap-2" }, {
                    default: Ue(() => [
                      W(WL, { onChange: y }),
                      W(ns, {
                        content: C(me)("uploadVideo"),
                        icon: C(Ga),
                        loading: f.value,
                        onClick: v
                      }, null, 8, ["content", "icon", "loading"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])
      ]),
      _: 1
    }));
  }
}), koe = { key: 0 }, Coe = /* @__PURE__ */ ae({
  __name: "VideoExt",
  props: {
    handleUpload: {
      type: Function,
      required: !1
    }
  },
  setup(t) {
    const e = et();
    nt(Eoe()), zf(() => {
      e.value.storage.video = {
        openUploader: null
      };
    });
    function n(r) {
      r && e.value.chain().focus().setVideo({ src: r }).run();
    }
    return (r, i) => C(e) ? (J(), be("div", koe, [
      W(xoe, {
        "handle-upload": t.handleUpload,
        onOk: n
      }, null, 8, ["handle-upload"])
    ])) : He("", !0);
  }
}), Toe = { class: "flex items-center gap-1" }, Ooe = /* @__PURE__ */ ae({
  __name: "VideoBubbleMenu",
  setup(t) {
    const e = et();
    function n() {
      const { state: o, dispatch: a } = e.value.view;
      aR(o, a);
    }
    function r() {
      e.value.isActive("video", { controls: !0 }) ? e.value.chain().focus().updateVideo({ controls: !1 }).run() : e.value.chain().focus().updateVideo({ controls: !0 }).run();
    }
    function i() {
      e.value.isActive("video", { loop: !0 }) ? e.value.chain().focus().updateVideo({ loop: !1 }).run() : e.value.chain().focus().updateVideo({ loop: !0 }).run();
    }
    function s() {
      e.value.isActive("video", { muted: !0 }) ? e.value.chain().focus().updateVideo({ muted: !1 }).run() : e.value.chain().focus().updateVideo({ muted: !0 }).run();
    }
    return (o, a) => (J(), be("div", Toe, [
      W(Ve, {
        action: () => C(e).chain().focus().updateVideo({ display: "left" }).run(),
        icon: C(Hd),
        "is-active": () => C(e).isActive("video", { display: "left" }),
        title: C(me)("leftFloat")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateVideo({ display: "inline" }).run(),
        icon: C(z_),
        "is-active": () => C(e).isActive("video", { display: "inline" }),
        title: C(me)("inline")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateVideo({ display: "right" }).run(),
        icon: C(H_),
        "is-active": () => C(e).isActive("video", { display: "right" }),
        title: C(me)("rightFloat")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateVideo({ width: 200 }).run(),
        icon: C(MD),
        "is-active": () => C(e).isActive("video", { width: 200 }),
        title: C(me)("smallSize")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateVideo({ width: 500 }).run(),
        icon: C(CD),
        "is-active": () => C(e).isActive("video", { width: 500 }),
        title: C(me)("mediumSize")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: () => C(e).chain().focus().updateVideo({ width: "100%" }).run(),
        icon: C(OD),
        "is-active": () => C(e).isActive("video", { width: "100%" }),
        title: C(me)("fullSize")
      }, null, 8, ["action", "icon", "is-active", "title"]),
      W(Ve, {
        action: r,
        icon: C(DG),
        "is-active": () => C(e).isActive("video", { controls: !0 }),
        title: C(me)("displayVideo")
      }, null, 8, ["icon", "is-active", "title"]),
      W(Ve, {
        action: i,
        icon: C(CG),
        "is-active": () => C(e).isActive("video", { loop: !0 }),
        title: C(me)("loopPlay")
      }, null, 8, ["icon", "is-active", "title"]),
      W(Ve, {
        action: s,
        icon: C(BG),
        "is-active": () => C(e).isActive("video", { muted: !0 }),
        title: C(me)("soundOff")
      }, null, 8, ["icon", "is-active", "title"]),
      W(Ve, {
        action: n,
        icon: C(zv),
        title: C(me)("delete")
      }, null, 8, ["icon", "title"])
    ]));
  }
}), Moe = { key: 0 }, Aoe = /* @__PURE__ */ ae({
  __name: "Undo",
  setup(t) {
    const e = et();
    return (n, r) => C(e) ? (J(), be("div", Moe, [
      W(Ve, {
        action: () => C(e).chain().focus().undo().run(),
        icon: C(PG),
        title: C(me)("undo")
      }, null, 8, ["action", "icon", "title"])
    ])) : He("", !0);
  }
}), Noe = { key: 0 }, Roe = /* @__PURE__ */ ae({
  __name: "Redo",
  setup(t) {
    const e = et();
    return (n, r) => C(e) ? (J(), be("div", Noe, [
      Lt(n.$slots, "default", {}, () => [
        W(Ve, {
          action: () => C(e).chain().focus().redo().run(),
          icon: C(kG),
          title: C(me)("redo")
        }, null, 8, ["action", "icon", "title"])
      ])
    ])) : He("", !0);
  }
}), Doe = Math.floor, Ioe = (t, e) => t < e ? t : e, Poe = (t, e) => t > e ? t : e, Q$ = 128, Dp = 127, Loe = Number.MAX_SAFE_INTEGER, $oe = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = /** @type {number} */
    e.codePointAt(i);
  return r;
}, cf = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), Boe = (t) => cf.encode(t), Foe = cf ? Boe : $oe;
let md = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
md && md.decode(new Uint8Array()).length === 1 && (md = null);
const Tm = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, g0 = (t, e) => {
  for (; e > Dp; )
    Tm(t, Q$ | Dp & e), e = Doe(e / 128);
  Tm(t, Dp & e);
}, lw = new Uint8Array(3e4), zoe = lw.length / 3, Hoe = (t, e) => {
  if (e.length < zoe) {
    const n = cf.encodeInto(e, lw).written || 0;
    g0(t, n);
    for (let r = 0; r < n; r++)
      Tm(t, lw[r]);
  } else
    Goe(t, Foe(e));
}, Uoe = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  g0(t, r);
  for (let i = 0; i < r; i++)
    Tm(
      t,
      /** @type {number} */
      n.codePointAt(i)
    );
}, Voe = cf && /** @type {any} */
cf.encodeInto ? Hoe : Uoe, Woe = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, i = Ioe(n - r, e.length), s = e.length - i;
  t.cbuf.set(e.subarray(0, i), r), t.cpos += i, s > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(Poe(n * 2, s)), t.cbuf.set(e.subarray(i)), t.cpos = s);
}, Goe = (t, e) => {
  g0(t, e.byteLength), Woe(t, e);
}, eB = (t) => new Error(t), joe = eB("Unexpected end of array"), qoe = eB("Integer out of Range"), Koe = (t, e) => {
  const n = new Uint8Array(t.arr.buffer, t.pos + t.arr.byteOffset, e);
  return t.pos += e, n;
}, Yoe = (t) => Koe(t, vS(t)), nM = (t) => t.arr[t.pos++], vS = (t) => {
  let e = 0, n = 1;
  const r = t.arr.length;
  for (; t.pos < r; ) {
    const i = t.arr[t.pos++];
    if (e = e + (i & Dp) * n, n *= 128, i < Q$)
      return e;
    if (e > Loe)
      throw qoe;
  }
  throw joe;
}, Xoe = (t) => {
  let e = vS(t);
  if (e === 0)
    return "";
  {
    let n = String.fromCodePoint(nM(t));
    if (--e < 100)
      for (; e--; )
        n += String.fromCodePoint(nM(t));
    else
      for (; e > 0; ) {
        const r = e < 1e4 ? e : 1e4, i = t.arr.subarray(t.pos, t.pos + r);
        t.pos += r, n += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), e -= r;
      }
    return decodeURIComponent(escape(n));
  }
}, Joe = (t) => (
  /** @type any */
  md.decode(Yoe(t))
), rM = md ? Joe : Xoe;
var uf;
(function(t) {
  t[t.Token = 0] = "Token", t[t.PermissionDenied = 1] = "PermissionDenied", t[t.Authenticated = 2] = "Authenticated";
})(uf || (uf = {}));
const Zoe = (t, e) => {
  g0(t, uf.Token), Voe(t, e);
}, Qoe = (t, e, n) => {
  switch (vS(t)) {
    case uf.PermissionDenied: {
      e(rM(t));
      break;
    }
    case uf.Authenticated: {
      n(rM(t));
      break;
    }
  }
}, eae = {
  code: 1009,
  reason: "Message Too Big"
}, iM = {
  code: 4401,
  reason: "Unauthorized"
}, tae = {
  code: 4403,
  reason: "Forbidden"
}, sM = (t) => Array.from(t.entries()).map(([e, n]) => ({
  clientId: e,
  ...n
}));
var cw;
(function(t) {
  t[t.Connecting = 0] = "Connecting", t[t.Open = 1] = "Open", t[t.Closing = 2] = "Closing", t[t.Closed = 3] = "Closed";
})(cw || (cw = {}));
const ri = () => /* @__PURE__ */ new Map(), uw = (t) => {
  const e = ri();
  return t.forEach((n, r) => {
    e.set(r, n);
  }), e;
}, Ys = (t, e, n) => {
  let r = t.get(e);
  return r === void 0 && t.set(e, r = n()), r;
}, nae = (t, e) => {
  const n = [];
  for (const [r, i] of t)
    n.push(e(i, r));
  return n;
}, rae = (t, e) => {
  for (const [n, r] of t)
    if (e(r, n))
      return !0;
  return !1;
}, il = () => /* @__PURE__ */ new Set(), zb = (t) => t[t.length - 1], iae = (t, e) => {
  for (let n = 0; n < e.length; n++)
    t.push(e[n]);
}, Lo = Array.from, sae = (t, e) => {
  for (let n = 0; n < t.length; n++)
    if (e(t[n], n, t))
      return !0;
  return !1;
}, dw = Array.isArray;
class tB {
  constructor() {
    this._observers = ri();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, n) {
    return Ys(
      this._observers,
      /** @type {string} */
      e,
      il
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, n) {
    const r = (...i) => {
      this.off(
        e,
        /** @type {any} */
        r
      ), n(...i);
    };
    this.on(
      e,
      /** @type {any} */
      r
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, n) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return Lo((this._observers.get(e) || ri()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = ri();
  }
}
const js = Math.floor, Ip = Math.abs, Pa = (t, e) => t < e ? t : e, qs = (t, e) => t > e ? t : e, nB = (t) => t !== 0 ? t < 0 : 1 / t < 0, oM = 1, aM = 2, Hb = 4, Ub = 8, df = 32, zs = 64, Lr = 128, m0 = 31, fw = 63, La = 127, oae = 2147483647, rB = Number.MAX_SAFE_INTEGER, aae = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && js(t) === t), lae = (t) => t.toLowerCase(), cae = /^\s*/g, uae = (t) => t.replace(cae, ""), dae = /([A-Z])/g, lM = (t, e) => uae(t.replace(dae, (n) => `${e}${lae(n)}`)), fae = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = /** @type {number} */
    e.codePointAt(i);
  return r;
}, ff = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), hae = (t) => ff.encode(t), pae = ff ? hae : fae;
let vd = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
vd && vd.decode(new Uint8Array()).length === 1 && (vd = null);
let th = class {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
};
const v0 = () => new th(), gae = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, Ji = (t) => {
  const e = new Uint8Array(gae(t));
  let n = 0;
  for (let r = 0; r < t.bufs.length; r++) {
    const i = t.bufs[r];
    e.set(i, n), n += i.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, mae = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(qs(n, e) * 2), t.cpos = 0);
}, yn = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, hw = yn, ht = (t, e) => {
  for (; e > La; )
    yn(t, Lr | La & e), e = js(e / 128);
  yn(t, La & e);
}, bS = (t, e) => {
  const n = nB(e);
  for (n && (e = -e), yn(t, (e > fw ? Lr : 0) | (n ? zs : 0) | fw & e), e = js(e / 64); e > 0; )
    yn(t, (e > La ? Lr : 0) | La & e), e = js(e / 128);
}, pw = new Uint8Array(3e4), vae = pw.length / 3, bae = (t, e) => {
  if (e.length < vae) {
    const n = ff.encodeInto(e, pw).written || 0;
    ht(t, n);
    for (let r = 0; r < n; r++)
      yn(t, pw[r]);
  } else
    Cr(t, pae(e));
}, yae = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  ht(t, r);
  for (let i = 0; i < r; i++)
    yn(
      t,
      /** @type {number} */
      n.codePointAt(i)
    );
}, cc = ff && /** @type {any} */
ff.encodeInto ? bae : yae, b0 = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, i = Pa(n - r, e.length), s = e.length - i;
  t.cbuf.set(e.subarray(0, i), r), t.cpos += i, s > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(qs(n * 2, s)), t.cbuf.set(e.subarray(i)), t.cpos = s);
}, Cr = (t, e) => {
  ht(t, e.byteLength), b0(t, e);
}, yS = (t, e) => {
  mae(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, wae = (t, e) => yS(t, 4).setFloat32(0, e, !1), _ae = (t, e) => yS(t, 8).setFloat64(0, e, !1), Eae = (t, e) => (
  /** @type {any} */
  yS(t, 8).setBigInt64(0, e, !1)
), cM = new DataView(new ArrayBuffer(4)), Sae = (t) => (cM.setFloat32(0, t), cM.getFloat32(0) === t), hf = (t, e) => {
  switch (typeof e) {
    case "string":
      yn(t, 119), cc(t, e);
      break;
    case "number":
      aae(e) && Ip(e) <= oae ? (yn(t, 125), bS(t, e)) : Sae(e) ? (yn(t, 124), wae(t, e)) : (yn(t, 123), _ae(t, e));
      break;
    case "bigint":
      yn(t, 122), Eae(t, e);
      break;
    case "object":
      if (e === null)
        yn(t, 126);
      else if (dw(e)) {
        yn(t, 117), ht(t, e.length);
        for (let n = 0; n < e.length; n++)
          hf(t, e[n]);
      } else if (e instanceof Uint8Array)
        yn(t, 116), Cr(t, e);
      else {
        yn(t, 118);
        const n = Object.keys(e);
        ht(t, n.length);
        for (let r = 0; r < n.length; r++) {
          const i = n[r];
          cc(t, i), hf(t, e[i]);
        }
      }
      break;
    case "boolean":
      yn(t, e ? 120 : 121);
      break;
    default:
      yn(t, 127);
  }
};
class uM extends th {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && ht(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const dM = (t) => {
  t.count > 0 && (bS(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && ht(t.encoder, t.count - 2));
};
class Pp {
  constructor() {
    this.encoder = new th(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (dM(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return dM(this), Ji(this.encoder);
  }
}
const fM = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    bS(t.encoder, e), t.count > 1 && ht(t.encoder, t.count - 2);
  }
};
class Vb {
  constructor() {
    this.encoder = new th(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (fM(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return fM(this), Ji(this.encoder);
  }
}
class xae {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Pp();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new th();
    return this.sarr.push(this.s), this.s = "", cc(e, this.sarr.join("")), b0(e, this.lensE.toUint8Array()), Ji(e);
  }
}
const $o = (t) => new Error(t), Oi = () => {
  throw $o("Method unimplemented");
}, di = () => {
  throw $o("Unexpected case");
}, iB = $o("Unexpected end of array"), sB = $o("Integer out of Range");
let y0 = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
};
const au = (t) => new y0(t), kae = (t) => t.pos !== t.arr.length, Cae = (t, e) => {
  const n = new Uint8Array(t.arr.buffer, t.pos + t.arr.byteOffset, e);
  return t.pos += e, n;
}, Tr = (t) => Cae(t, ct(t)), jc = (t) => t.arr[t.pos++], ct = (t) => {
  let e = 0, n = 1;
  const r = t.arr.length;
  for (; t.pos < r; ) {
    const i = t.arr[t.pos++];
    if (e = e + (i & La) * n, n *= 128, i < Lr)
      return e;
    if (e > rB)
      throw sB;
  }
  throw iB;
}, wS = (t) => {
  let e = t.arr[t.pos++], n = e & fw, r = 64;
  const i = (e & zs) > 0 ? -1 : 1;
  if (!(e & Lr))
    return i * n;
  const s = t.arr.length;
  for (; t.pos < s; ) {
    if (e = t.arr[t.pos++], n = n + (e & La) * r, r *= 128, e < Lr)
      return i * n;
    if (n > rB)
      throw sB;
  }
  throw iB;
}, Tae = (t) => {
  let e = ct(t);
  if (e === 0)
    return "";
  {
    let n = String.fromCodePoint(jc(t));
    if (--e < 100)
      for (; e--; )
        n += String.fromCodePoint(jc(t));
    else
      for (; e > 0; ) {
        const r = e < 1e4 ? e : 1e4, i = t.arr.subarray(t.pos, t.pos + r);
        t.pos += r, n += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), e -= r;
      }
    return decodeURIComponent(escape(n));
  }
}, Oae = (t) => (
  /** @type any */
  vd.decode(Tr(t))
), uc = vd ? Oae : Tae, _S = (t, e) => {
  const n = new DataView(t.arr.buffer, t.arr.byteOffset + t.pos, e);
  return t.pos += e, n;
}, Mae = (t) => _S(t, 4).getFloat32(0, !1), Aae = (t) => _S(t, 8).getFloat64(0, !1), Nae = (t) => (
  /** @type {any} */
  _S(t, 8).getBigInt64(0, !1)
), Rae = [
  (t) => {
  },
  // CASE 127: undefined
  (t) => null,
  // CASE 126: null
  wS,
  // CASE 125: integer
  Mae,
  // CASE 124: float32
  Aae,
  // CASE 123: float64
  Nae,
  // CASE 122: bigint
  (t) => !1,
  // CASE 121: boolean (false)
  (t) => !0,
  // CASE 120: boolean (true)
  uc,
  // CASE 119: string
  (t) => {
    const e = ct(t), n = {};
    for (let r = 0; r < e; r++) {
      const i = uc(t);
      n[i] = pf(t);
    }
    return n;
  },
  (t) => {
    const e = ct(t), n = [];
    for (let r = 0; r < e; r++)
      n.push(pf(t));
    return n;
  },
  Tr
  // CASE 116: Uint8Array
], pf = (t) => Rae[127 - jc(t)](t);
class hM extends y0 {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(e, n) {
    super(e), this.reader = n, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), kae(this) ? this.count = ct(this) + 1 : this.count = -1), this.count--, /** @type {T} */
    this.s;
  }
}
class Lp extends y0 {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = wS(this);
      const e = nB(this.s);
      this.count = 1, e && (this.s = -this.s, this.count = ct(this) + 2);
    }
    return this.count--, /** @type {number} */
    this.s;
  }
}
class Wb extends y0 {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const e = wS(this), n = e & 1;
      this.diff = js(e / 2), this.count = 1, n && (this.count = ct(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class Dae {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    this.decoder = new Lp(e), this.str = uc(this.decoder), this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const e = this.spos + this.decoder.read(), n = this.str.slice(this.spos, e);
    return this.spos = e, n;
  }
}
const Iae = crypto.getRandomValues.bind(crypto), Pae = Math.random, oB = () => Iae(new Uint32Array(1))[0], Lae = (t) => t[js(Pae() * t.length)], $ae = [1e7] + -1e3 + -4e3 + -8e3 + -1e11, Bae = () => $ae.replace(
  /[018]/g,
  /** @param {number} c */
  (t) => (t ^ oB() & 15 >> t / 4).toString(16)
), Fae = Date.now, pM = (t) => (
  /** @type {Promise<T>} */
  new Promise(t)
);
Promise.all.bind(Promise);
const gM = (t) => t === void 0 ? null : t;
let zae = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}, aB = new zae(), Hae = !0;
try {
  typeof localStorage < "u" && localStorage && (aB = localStorage, Hae = !1);
} catch {
}
const Uae = aB, Vae = Object.assign, lB = Object.keys, Wae = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, mM = (t) => lB(t).length, Gae = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, jae = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, qae = (t, e) => Object.prototype.hasOwnProperty.call(t, e), Kae = (t, e) => t === e || mM(t) === mM(e) && jae(t, (n, r) => (n !== void 0 || qae(e, r)) && e[r] === n), ES = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && ES(t, e, n + 1);
  }
}, Yae = (t) => t, Xae = (t, e) => e.includes(t), qc = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", Jae = typeof window < "u" && typeof document < "u" && !qc;
let Hi;
const Zae = () => {
  if (Hi === void 0)
    if (qc) {
      Hi = ri();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        r[0] === "-" ? (e !== null && Hi.set(e, ""), e = r) : e !== null && (Hi.set(e, r), e = null);
      }
      e !== null && Hi.set(e, "");
    } else
      typeof location == "object" ? (Hi = ri(), (location.search || "?").slice(1).split("&").forEach((t) => {
        if (t.length !== 0) {
          const [e, n] = t.split("=");
          Hi.set(`--${lM(e, "-")}`, n), Hi.set(`-${lM(e, "-")}`, n);
        }
      })) : Hi = ri();
  return Hi;
}, gw = (t) => Zae().has(t), mw = (t) => gM(qc ? process.env[t.toUpperCase().replaceAll("-", "_")] : Uae.getItem(t)), Qae = (t) => gw("--" + t) || mw(t) !== null;
Qae("production");
const vM = qc && Xae(process.env.FORCE_COLOR, ["true", "1", "2"]), ele = !gw("--no-colors") && (!qc || process.stdout.isTTY || vM) && (!qc || gw("--color") || vM || mw("COLORTERM") !== null || (mw("TERM") || "").includes("color")), tle = (t) => new Uint8Array(t), nle = (t) => {
  const e = tle(t.byteLength);
  return e.set(t), e;
};
class rle {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const Es = (t, e) => new rle(t, e), ile = (
  /** @type {Document} */
  typeof document < "u" ? document : {}
);
typeof DOMParser < "u" && new DOMParser();
const sle = (t) => nae(t, (e, n) => `${n}:${e};`).join(""), ole = (t) => class {
  /**
   * @param {number} timeoutId
   */
  constructor(n) {
    this._ = n;
  }
  destroy() {
    t(this._);
  }
}, ale = ole(clearTimeout), Om = (t, e) => new ale(setTimeout(e, t)), Xs = Symbol, cB = Xs(), uB = Xs(), lle = Xs(), cle = Xs(), ule = Xs(), dB = Xs(), dle = Xs(), SS = Xs(), fle = Xs(), hle = (t) => {
  var r;
  t.length === 1 && ((r = t[0]) == null ? void 0 : r.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [];
  let n = 0;
  for (; n < t.length; n++) {
    const i = t[n];
    i === void 0 || i.constructor === String || i.constructor === Number || i.constructor === Object && e.push(JSON.stringify(i));
  }
  return e;
}, ple = {
  [cB]: Es("font-weight", "bold"),
  [uB]: Es("font-weight", "normal"),
  [lle]: Es("color", "blue"),
  [ule]: Es("color", "green"),
  [cle]: Es("color", "grey"),
  [dB]: Es("color", "red"),
  [dle]: Es("color", "purple"),
  [SS]: Es("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [fle]: Es("color", "black")
}, gle = (t) => {
  var o;
  t.length === 1 && ((o = t[0]) == null ? void 0 : o.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [], r = ri();
  let i = [], s = 0;
  for (; s < t.length; s++) {
    const a = t[s], l = ple[a];
    if (l !== void 0)
      r.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = sle(r);
        s > 0 || c.length > 0 ? (e.push("%c" + a), n.push(c)) : e.push(a);
      } else
        break;
    }
  }
  for (s > 0 && (i = n, i.unshift(e.join(""))); s < t.length; s++) {
    const a = t[s];
    a instanceof Symbol || i.push(a);
  }
  return i;
}, fB = ele ? gle : hle, mle = (...t) => {
  console.log(...fB(t)), hB.forEach((e) => e.print(t));
}, vle = (...t) => {
  console.warn(...fB(t)), t.unshift(SS), hB.forEach((e) => e.print(t));
}, hB = il(), pB = (t) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: t
}), ble = (t, e) => pB(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), Gb = (t, e) => pB(() => {
  const { done: n, value: r } = t.next();
  return { done: n, value: n ? void 0 : e(r) };
});
class xS {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class lu {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const Bo = (t, e, n) => e.clients.forEach((r, i) => {
  const s = (
    /** @type {Array<GC|Item>} */
    t.doc.store.clients.get(i)
  );
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    TB(t, s, a.clock, a.len, n);
  }
}), yle = (t, e) => {
  let n = 0, r = t.length - 1;
  for (; n <= r; ) {
    const i = js((n + r) / 2), s = t[i], o = s.clock;
    if (o <= e) {
      if (e < o + s.len)
        return i;
      n = i + 1;
    } else
      r = i - 1;
  }
  return null;
}, cu = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && yle(n, e.clock) !== null;
}, kS = (t) => {
  t.clients.forEach((e) => {
    e.sort((i, s) => i.clock - s.clock);
    let n, r;
    for (n = 1, r = 1; n < e.length; n++) {
      const i = e[r - 1], s = e[n];
      i.clock + i.len >= s.clock ? i.len = qs(i.len, s.clock + s.len - i.clock) : (r < n && (e[r] = s), r++);
    }
    e.length = r;
  });
}, vw = (t) => {
  const e = new lu();
  for (let n = 0; n < t.length; n++)
    t[n].clients.forEach((r, i) => {
      if (!e.clients.has(i)) {
        const s = r.slice();
        for (let o = n + 1; o < t.length; o++)
          iae(s, t[o].clients.get(i) || []);
        e.clients.set(i, s);
      }
    });
  return kS(e), e;
}, gf = (t, e, n, r) => {
  Ys(t.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new xS(n, r));
}, CS = () => new lu(), gB = (t) => {
  const e = CS();
  return t.clients.forEach((n, r) => {
    const i = [];
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      if (o.deleted) {
        const a = o.id.clock;
        let l = o.length;
        if (s + 1 < n.length)
          for (let c = n[s + 1]; s + 1 < n.length && c.deleted; c = n[++s + 1])
            l += c.length;
        i.push(new xS(a, l));
      }
    }
    i.length > 0 && e.clients.set(r, i);
  }), e;
}, uu = (t, e) => {
  ht(t.restEncoder, e.clients.size), Lo(e.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    t.resetDsCurVal(), ht(t.restEncoder, n);
    const i = r.length;
    ht(t.restEncoder, i);
    for (let s = 0; s < i; s++) {
      const o = r[s];
      t.writeDsClock(o.clock), t.writeDsLen(o.len);
    }
  });
}, TS = (t) => {
  const e = new lu(), n = ct(t.restDecoder);
  for (let r = 0; r < n; r++) {
    t.resetDsCurVal();
    const i = ct(t.restDecoder), s = ct(t.restDecoder);
    if (s > 0) {
      const o = Ys(e.clients, i, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let a = 0; a < s; a++)
        o.push(new xS(t.readDsClock(), t.readDsLen()));
    }
  }
  return e;
}, bM = (t, e, n) => {
  const r = new lu(), i = ct(t.restDecoder);
  for (let s = 0; s < i; s++) {
    t.resetDsCurVal();
    const o = ct(t.restDecoder), a = ct(t.restDecoder), l = n.clients.get(o) || [], c = Jt(n, o);
    for (let u = 0; u < a; u++) {
      const d = t.readDsClock(), f = d + t.readDsLen();
      if (d < c) {
        c < f && gf(r, o, c, f - c);
        let h = fs(l, d), p = l[h];
        for (!p.deleted && p.id.clock < d && (l.splice(h + 1, 0, Im(e, p, d - p.id.clock)), h++); h < l.length && (p = l[h++], p.id.clock < f); )
          p.deleted || (f < p.id.clock + p.length && l.splice(h, 0, Im(e, p, f - p.id.clock)), p.delete(e));
      } else
        gf(r, o, d, f - d);
    }
  }
  if (r.clients.size > 0) {
    const s = new sl();
    return ht(s.restEncoder, 0), uu(s, r), s.toUint8Array();
  }
  return null;
}, mB = oB;
class du extends tB {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = Bae(), collectionid: n = null, gc: r = !0, gcFilter: i = () => !0, meta: s = null, autoLoad: o = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = i, this.clientID = mB(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new kB(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = o, this.meta = s, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = pM((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => pM((c) => {
      const u = (d) => {
        (d === void 0 || d === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && Dt(
      /** @type {any} */
      e.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Lo(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, n = null) {
    return Dt(this, e, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, n = (
    /** @type {any} */
    An
  )) {
    const r = Ys(this.share, e, () => {
      const s = new n();
      return s._integrate(this, null), s;
    }), i = r.constructor;
    if (n !== An && i !== n)
      if (i === An) {
        const s = new n();
        s._map = r._map, r._map.forEach(
          /** @param {Item?} n */
          (o) => {
            for (; o !== null; o = o.left)
              o.parent = s;
          }
        ), s._start = r._start;
        for (let o = s._start; o !== null; o = o.right)
          o.parent = s;
        return s._length = r._length, this.share.set(e, s), s._integrate(this, null), /** @type {InstanceType<Type>} */
        s;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      r
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, fc)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, ol);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, Yc)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, Zn)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, al);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((n, r) => {
      e[r] = n.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    Lo(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        e.content
      );
      n.doc = new du({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, Dt(
        /** @type {any} */
        e.parent.doc,
        (r) => {
          const i = n.doc;
          e.deleted || r.subdocsAdded.add(i), r.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class vB {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.restDecoder = e;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return ct(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return ct(this.restDecoder);
  }
}
class bB extends vB {
  /**
   * @return {ID}
   */
  readLeftID() {
    return it(ct(this.restDecoder), ct(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return it(ct(this.restDecoder), ct(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return ct(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return jc(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return uc(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return ct(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return ct(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return ct(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return pf(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return nle(Tr(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(uc(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return uc(this.restDecoder);
  }
}
class wle {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.dsCurrVal = 0, this.restDecoder = e;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return this.dsCurrVal += ct(this.restDecoder), this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const e = ct(this.restDecoder) + 1;
    return this.dsCurrVal += e, e;
  }
}
class Kc extends wle {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    super(e), this.keys = [], ct(e), this.keyClockDecoder = new Wb(Tr(e)), this.clientDecoder = new Lp(Tr(e)), this.leftClockDecoder = new Wb(Tr(e)), this.rightClockDecoder = new Wb(Tr(e)), this.infoDecoder = new hM(Tr(e), jc), this.stringDecoder = new Dae(Tr(e)), this.parentInfoDecoder = new hM(Tr(e), jc), this.typeRefDecoder = new Lp(Tr(e)), this.lenDecoder = new Lp(Tr(e));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new dc(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new dc(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return pf(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return Tr(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return pf(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const e = this.keyClockDecoder.read();
    if (e < this.keys.length)
      return this.keys[e];
    {
      const n = this.stringDecoder.read();
      return this.keys.push(n), n;
    }
  }
}
class yB {
  constructor() {
    this.restEncoder = v0();
  }
  toUint8Array() {
    return Ji(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    ht(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    ht(this.restEncoder, e);
  }
}
class nh extends yB {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    ht(this.restEncoder, e.client), ht(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    ht(this.restEncoder, e.client), ht(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    ht(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    hw(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    cc(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    ht(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    ht(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    ht(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    hf(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Cr(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    cc(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    cc(this.restEncoder, e);
  }
}
class wB {
  constructor() {
    this.restEncoder = v0(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Ji(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, ht(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && di(), ht(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class sl extends wB {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Vb(), this.clientEncoder = new Pp(), this.leftClockEncoder = new Vb(), this.rightClockEncoder = new Vb(), this.infoEncoder = new uM(hw), this.stringEncoder = new xae(), this.parentInfoEncoder = new uM(hw), this.typeRefEncoder = new Pp(), this.lenEncoder = new Pp();
  }
  toUint8Array() {
    const e = v0();
    return ht(e, 0), Cr(e, this.keyClockEncoder.toUint8Array()), Cr(e, this.clientEncoder.toUint8Array()), Cr(e, this.leftClockEncoder.toUint8Array()), Cr(e, this.rightClockEncoder.toUint8Array()), Cr(e, Ji(this.infoEncoder)), Cr(e, this.stringEncoder.toUint8Array()), Cr(e, Ji(this.parentInfoEncoder)), Cr(e, this.typeRefEncoder.toUint8Array()), Cr(e, this.lenEncoder.toUint8Array()), b0(e, Ji(this.restEncoder)), Ji(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    hf(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Cr(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    hf(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const _le = (t, e, n, r) => {
  r = qs(r, e[0].id.clock);
  const i = fs(e, r);
  ht(t.restEncoder, e.length - i), t.writeClient(n), ht(t.restEncoder, r);
  const s = e[i];
  s.write(t, r - s.id.clock);
  for (let o = i + 1; o < e.length; o++)
    e[o].write(t, 0);
}, OS = (t, e, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((i, s) => {
    Jt(e, s) > i && r.set(s, i);
  }), rh(e).forEach((i, s) => {
    n.has(s) || r.set(s, 0);
  }), ht(t.restEncoder, r.size), Lo(r.entries()).sort((i, s) => s[0] - i[0]).forEach(([i, s]) => {
    _le(
      t,
      /** @type {Array<GC|Item>} */
      e.clients.get(i),
      i,
      s
    );
  });
}, Ele = (t, e) => {
  const n = ri(), r = ct(t.restDecoder);
  for (let i = 0; i < r; i++) {
    const s = ct(t.restDecoder), o = new Array(s), a = t.readClient();
    let l = ct(t.restDecoder);
    n.set(a, { i: 0, refs: o });
    for (let c = 0; c < s; c++) {
      const u = t.readInfo();
      switch (m0 & u) {
        case 0: {
          const d = t.readLen();
          o[c] = new Jr(it(a, l), d), l += d;
          break;
        }
        case 10: {
          const d = ct(t.restDecoder);
          o[c] = new Zr(it(a, l), d), l += d;
          break;
        }
        default: {
          const d = (u & (zs | Lr)) === 0, f = new kt(
            it(a, l),
            null,
            // leftd
            (u & Lr) === Lr ? t.readLeftID() : null,
            // origin
            null,
            // right
            (u & zs) === zs ? t.readRightID() : null,
            // right origin
            d ? t.readParentInfo() ? e.get(t.readString()) : t.readLeftID() : null,
            // parent
            d && (u & df) === df ? t.readString() : null,
            // parentSub
            YB(t, u)
            // item content
          );
          o[c] = f, l += f.length;
        }
      }
    }
  }
  return n;
}, Sle = (t, e, n) => {
  const r = [];
  let i = Lo(n.keys()).sort((h, p) => h - p);
  if (i.length === 0)
    return null;
  const s = () => {
    if (i.length === 0)
      return null;
    let h = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      n.get(i[i.length - 1])
    );
    for (; h.refs.length === h.i; )
      if (i.pop(), i.length > 0)
        h = /** @type {{i:number,refs:Array<GC|Item>}} */
        n.get(i[i.length - 1]);
      else
        return null;
    return h;
  };
  let o = s();
  if (o === null)
    return null;
  const a = new kB(), l = /* @__PURE__ */ new Map(), c = (h, p) => {
    const g = l.get(h);
    (g == null || g > p) && l.set(h, p);
  };
  let u = (
    /** @type {any} */
    o.refs[
      /** @type {any} */
      o.i++
    ]
  );
  const d = /* @__PURE__ */ new Map(), f = () => {
    for (const h of r) {
      const p = h.id.client, g = n.get(p);
      g ? (g.i--, a.clients.set(p, g.refs.slice(g.i)), n.delete(p), g.i = 0, g.refs = []) : a.clients.set(p, [h]), i = i.filter((m) => m !== p);
    }
    r.length = 0;
  };
  for (; ; ) {
    if (u.constructor !== Zr) {
      const p = Ys(d, u.id.client, () => Jt(e, u.id.client)) - u.id.clock;
      if (p < 0)
        r.push(u), c(u.id.client, u.id.clock - 1), f();
      else {
        const g = u.getMissing(t, e);
        if (g !== null) {
          r.push(u);
          const m = n.get(
            /** @type {number} */
            g
          ) || { refs: [], i: 0 };
          if (m.refs.length === m.i)
            c(
              /** @type {number} */
              g,
              Jt(e, g)
            ), f();
          else {
            u = m.refs[m.i++];
            continue;
          }
        } else
          (p === 0 || p < u.length) && (u.integrate(t, p), d.set(u.id.client, u.id.clock + u.length));
      }
    }
    if (r.length > 0)
      u = /** @type {GC|Item} */
      r.pop();
    else if (o !== null && o.i < o.refs.length)
      u = /** @type {GC|Item} */
      o.refs[o.i++];
    else {
      if (o = s(), o === null)
        break;
      u = /** @type {GC|Item} */
      o.refs[o.i++];
    }
  }
  if (a.clients.size > 0) {
    const h = new sl();
    return OS(h, a, /* @__PURE__ */ new Map()), ht(h.restEncoder, 0), { missing: l, update: h.toUint8Array() };
  }
  return null;
}, xle = (t, e) => OS(t, e.doc.store, e.beforeState), kle = (t, e, n, r = new Kc(t)) => Dt(e, (i) => {
  i.local = !1;
  let s = !1;
  const o = i.doc, a = o.store, l = Ele(r, o), c = Sle(i, a, l), u = a.pendingStructs;
  if (u) {
    for (const [f, h] of u.missing)
      if (h < Jt(a, f)) {
        s = !0;
        break;
      }
    if (c) {
      for (const [f, h] of c.missing) {
        const p = u.missing.get(f);
        (p == null || p > h) && u.missing.set(f, h);
      }
      u.update = Mm([u.update, c.update]);
    }
  } else
    a.pendingStructs = c;
  const d = bM(r, i, a);
  if (a.pendingDs) {
    const f = new Kc(au(a.pendingDs));
    ct(f.restDecoder);
    const h = bM(f, i, a);
    d && h ? a.pendingDs = Mm([d, h]) : a.pendingDs = d || h;
  } else
    a.pendingDs = d;
  if (s) {
    const f = (
      /** @type {{update: Uint8Array}} */
      a.pendingStructs.update
    );
    a.pendingStructs = null, _B(i.doc, f);
  }
}, n, !1), _B = (t, e, n, r = Kc) => {
  const i = au(e);
  kle(i, t, n, new r(i));
}, Cle = (t, e, n) => _B(t, e, n, bB), Tle = (t, e, n = /* @__PURE__ */ new Map()) => {
  OS(t, e.store, n), uu(t, gB(e.store));
}, Ole = (t, e = new Uint8Array([0]), n = new sl()) => {
  const r = EB(e);
  Tle(n, t, r);
  const i = [n.toUint8Array()];
  if (t.store.pendingDs && i.push(t.store.pendingDs), t.store.pendingStructs && i.push(Kle(t.store.pendingStructs.update, e)), i.length > 1) {
    if (n.constructor === nh)
      return jle(i.map((s, o) => o === 0 ? s : Xle(s)));
    if (n.constructor === sl)
      return Mm(i);
  }
  return i[0];
}, Mle = (t, e) => Ole(t, e, new nh()), Ale = (t) => {
  const e = /* @__PURE__ */ new Map(), n = ct(t.restDecoder);
  for (let r = 0; r < n; r++) {
    const i = ct(t.restDecoder), s = ct(t.restDecoder);
    e.set(i, s);
  }
  return e;
}, EB = (t) => Ale(new vB(au(t))), SB = (t, e) => (ht(t.restEncoder, e.size), Lo(e.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
  ht(t.restEncoder, n), ht(t.restEncoder, r);
}), t), Nle = (t, e) => SB(t, rh(e.store)), Rle = (t, e = new wB()) => (t instanceof Map ? SB(e, t) : Nle(e, t), e.toUint8Array()), Dle = (t) => Rle(t, new yB());
class Ile {
  constructor() {
    this.l = [];
  }
}
const yM = () => new Ile(), wM = (t, e) => t.l.push(e), _M = (t, e) => {
  const n = t.l, r = n.length;
  t.l = n.filter((i) => e !== i), r === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, xB = (t, e, n) => ES(t.l, [e, n]);
class dc {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const tc = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, it = (t, e) => new dc(t, e), mf = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw di();
}, vf = (t, e) => {
  for (; e !== null; ) {
    if (e.parent === t)
      return !0;
    e = /** @type {AbstractType<any>} */
    e.parent._item;
  }
  return !1;
};
class bf {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, n, r, i = 0) {
    this.type = e, this.tname = n, this.item = r, this.assoc = i;
  }
}
const bd = (t) => new bf(t.type == null ? null : it(t.type.client, t.type.clock), t.tname || null, t.item == null ? null : it(t.item.client, t.item.clock), t.assoc == null ? 0 : t.assoc);
class Ple {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(e, n, r = 0) {
    this.type = e, this.index = n, this.assoc = r;
  }
}
const Lle = (t, e, n = 0) => new Ple(t, e, n), np = (t, e, n) => {
  let r = null, i = null;
  return t._item === null ? i = mf(t) : r = it(t._item.id.client, t._item.id.clock), new bf(r, i, e, n);
}, jb = (t, e, n = 0) => {
  let r = t._start;
  if (n < 0) {
    if (e === 0)
      return np(t, null, n);
    e--;
  }
  for (; r !== null; ) {
    if (!r.deleted && r.countable) {
      if (r.length > e)
        return np(t, it(r.id.client, r.id.clock + e), n);
      e -= r.length;
    }
    if (r.right === null && n < 0)
      return np(t, r.lastId, n);
    r = r.right;
  }
  return np(t, null, n);
}, $le = (t, e) => {
  const n = e.store, r = t.item, i = t.type, s = t.tname, o = t.assoc;
  let a = null, l = 0;
  if (r !== null) {
    if (Jt(n, r.client) <= r.clock)
      return null;
    const c = _w(n, r), u = c.item;
    if (!(u instanceof kt))
      return null;
    if (a = /** @type {AbstractType<any>} */
    u.parent, a._item === null || !a._item.deleted) {
      l = u.deleted || !u.countable ? 0 : c.diff + (o >= 0 ? 0 : 1);
      let d = u.left;
      for (; d !== null; )
        !d.deleted && d.countable && (l += d.length), d = d.left;
    }
  } else {
    if (s !== null)
      a = e.get(s);
    else if (i !== null) {
      if (Jt(n, i.client) <= i.clock)
        return null;
      const { item: c } = _w(n, i);
      if (c instanceof kt && c.content instanceof Bi)
        a = c.content.type;
      else
        return null;
    } else
      throw di();
    o >= 0 ? l = a._length : l = 0;
  }
  return Lle(a, l, t.assoc);
}, EM = (t, e) => t === e || t !== null && e !== null && t.tname === e.tname && tc(t.item, e.item) && tc(t.type, e.type) && t.assoc === e.assoc;
class MS {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(e, n) {
    this.ds = e, this.sv = n;
  }
}
const AS = (t, e) => new MS(t, e);
AS(CS(), /* @__PURE__ */ new Map());
const Ble = (t) => AS(gB(t.store), rh(t.store)), ua = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !cu(e.ds, t.id), bw = (t, e) => {
  const n = Ys(t.meta, bw, il), r = t.doc.store;
  n.has(e) || (e.sv.forEach((i, s) => {
    i < Jt(r, s) && lr(t, it(s, i));
  }), Bo(t, e.ds, (i) => {
  }), n.add(e));
};
class kB {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const rh = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, r) => {
    const i = n[n.length - 1];
    e.set(r, i.id.clock + i.length);
  }), e;
}, Jt = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, CB = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== e.id.clock)
      throw di();
  }
  n.push(e);
}, fs = (t, e) => {
  let n = 0, r = t.length - 1, i = t[r], s = i.id.clock;
  if (s === e)
    return r;
  let o = js(e / (s + i.length - 1) * r);
  for (; n <= r; ) {
    if (i = t[o], s = i.id.clock, s <= e) {
      if (e < s + i.length)
        return o;
      n = o + 1;
    } else
      r = o - 1;
    o = js((n + r) / 2);
  }
  throw di();
}, Fle = (t, e) => {
  const n = t.clients.get(e.client);
  return n[fs(n, e.clock)];
}, $p = (
  /** @type {function(StructStore,ID):Item} */
  Fle
), yw = (t, e, n) => {
  const r = fs(e, n), i = e[r];
  return i.id.clock < n && i instanceof kt ? (e.splice(r + 1, 0, Im(t, i, n - i.id.clock)), r + 1) : r;
}, lr = (t, e) => {
  const n = (
    /** @type {Array<Item>} */
    t.doc.store.clients.get(e.client)
  );
  return n[yw(t, n, e.clock)];
}, SM = (t, e, n) => {
  const r = e.clients.get(n.client), i = fs(r, n.clock), s = r[i];
  return n.clock !== s.id.clock + s.length - 1 && s.constructor !== Jr && r.splice(i + 1, 0, Im(t, s, n.clock - s.id.clock + 1)), s;
}, zle = (t, e, n) => {
  const r = (
    /** @type {Array<GC|Item>} */
    t.clients.get(e.id.client)
  );
  r[fs(r, e.id.clock)] = n;
}, TB = (t, e, n, r, i) => {
  if (r === 0)
    return;
  const s = n + r;
  let o = yw(t, e, n), a;
  do
    a = e[o++], s < a.id.clock + a.length && yw(t, e, s), i(a);
  while (o < e.length && e[o].id.clock < s);
};
class Hle {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, n, r) {
    this.doc = e, this.deleteSet = new lu(), this.beforeState = rh(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const xM = (t, e) => e.deleteSet.clients.size === 0 && !rae(e.afterState, (n, r) => e.beforeState.get(r) !== n) ? !1 : (kS(e.deleteSet), xle(t, e), uu(t, e.deleteSet), !0), kM = (t, e, n) => {
  const r = e._item;
  (r === null || r.id.clock < (t.beforeState.get(r.id.client) || 0) && !r.deleted) && Ys(t.changed, e, il).add(n);
}, Bp = (t, e) => {
  let n = t[e], r = t[e - 1], i = e;
  for (; i > 0; n = r, r = t[--i - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof kt && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        r
      );
      continue;
    }
    break;
  }
  const s = e - i;
  return s && t.splice(e + 1 - s, s), s;
}, Ule = (t, e, n) => {
  for (const [r, i] of t.clients.entries()) {
    const s = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let o = i.length - 1; o >= 0; o--) {
      const a = i[o], l = a.clock + a.len;
      for (let c = fs(s, a.clock), u = s[c]; c < s.length && u.id.clock < l; u = s[++c]) {
        const d = s[c];
        if (a.clock + a.len <= d.id.clock)
          break;
        d instanceof kt && d.deleted && !d.keep && n(d) && d.gc(e, !1);
      }
    }
  }
}, Vle = (t, e) => {
  t.clients.forEach((n, r) => {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let s = n.length - 1; s >= 0; s--) {
      const o = n[s], a = Pa(i.length - 1, 1 + fs(i, o.clock + o.len - 1));
      for (let l = a, c = i[l]; l > 0 && c.id.clock >= o.clock; c = i[l])
        l -= 1 + Bp(i, l);
    }
  });
}, OB = (t, e) => {
  if (e < t.length) {
    const n = t[e], r = n.doc, i = r.store, s = n.deleteSet, o = n._mergeStructs;
    try {
      kS(s), n.afterState = rh(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const a = [];
      n.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, l);
        })
      ), a.push(() => {
        n.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, d) => u.path.length - d.path.length), xB(c._dEH, l, n));
        });
      }), a.push(() => r.emit("afterTransaction", [n, r])), ES(a, []), n._needFormattingCleanup && uce(n);
    } finally {
      r.gc && Ule(s, i, r.gcFilter), Vle(s, i), n.afterState.forEach((u, d) => {
        const f = n.beforeState.get(d) || 0;
        if (f !== u) {
          const h = (
            /** @type {Array<GC|Item>} */
            i.clients.get(d)
          ), p = qs(fs(h, f), 1);
          for (let g = h.length - 1; g >= p; )
            g -= 1 + Bp(h, g);
        }
      });
      for (let u = o.length - 1; u >= 0; u--) {
        const { client: d, clock: f } = o[u].id, h = (
          /** @type {Array<GC|Item>} */
          i.clients.get(d)
        ), p = fs(h, f);
        p + 1 < h.length && Bp(h, p + 1) > 1 || p > 0 && Bp(h, p);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (mle(SS, cB, "[yjs] ", uB, dB, "Changed the client-id because another client seems to be using it."), r.clientID = mB()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const u = new nh();
        xM(u, n) && r.emit("update", [u.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const u = new sl();
        xM(u, n) && r.emit("updateV2", [u.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = n;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = r.clientID, u.collectionid == null && (u.collectionid = r.collectionid), r.subdocs.add(u);
      }), c.forEach((u) => r.subdocs.delete(u)), r.emit("subdocs", [{ loaded: l, added: a, removed: c }, r, n]), c.forEach((u) => u.destroy())), t.length <= e + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, t])) : OB(t, e + 1);
    }
  }
}, Dt = (t, e, n = null, r = !0) => {
  const i = t._transactionCleanups;
  let s = !1, o = null;
  t._transaction === null && (s = !0, t._transaction = new Hle(t, n, r), i.push(t._transaction), i.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    o = e(t._transaction);
  } finally {
    if (s) {
      const a = t._transaction === i[0];
      t._transaction = null, a && OB(i, 0);
    }
  }
  return o;
};
class Wle {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(e, n) {
    this.insertions = n, this.deletions = e, this.meta = /* @__PURE__ */ new Map();
  }
}
const CM = (t, e, n) => {
  Bo(t, n.deletions, (r) => {
    r instanceof kt && e.scope.some((i) => vf(i, r)) && BS(r, !1);
  });
}, TM = (t, e, n) => {
  let r = null;
  const i = t.doc, s = t.scope;
  if (Dt(i, (o) => {
    for (; e.length > 0 && t.currStackItem === null; ) {
      const a = i.store, l = (
        /** @type {StackItem} */
        e.pop()
      ), c = /* @__PURE__ */ new Set(), u = [];
      let d = !1;
      Bo(o, l.insertions, (f) => {
        if (f instanceof kt) {
          if (f.redone !== null) {
            let { item: h, diff: p } = _w(a, f.id);
            p > 0 && (h = lr(o, it(h.id.client, h.id.clock + p))), f = h;
          }
          !f.deleted && s.some((h) => vf(
            h,
            /** @type {Item} */
            f
          )) && u.push(f);
        }
      }), Bo(o, l.deletions, (f) => {
        f instanceof kt && s.some((h) => vf(h, f)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !cu(l.insertions, f.id) && c.add(f);
      }), c.forEach((f) => {
        d = KB(o, f, c, l.insertions, t.ignoreRemoteMapChanges, t) !== null || d;
      });
      for (let f = u.length - 1; f >= 0; f--) {
        const h = u[f];
        t.deleteFilter(h) && (h.delete(o), d = !0);
      }
      t.currStackItem = d ? l : null;
    }
    o.changed.forEach((a, l) => {
      a.has(null) && l._searchMarker && (l._searchMarker.length = 0);
    }), r = o;
  }, t), t.currStackItem != null) {
    const o = r.changedParentTypes;
    t.emit("stack-item-popped", [{ stackItem: t.currStackItem, type: n, changedParentTypes: o, origin: t }, t]), t.currStackItem = null;
  }
  return t.currStackItem;
};
class MB extends tB {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(e, {
    captureTimeout: n = 500,
    captureTransaction: r = (l) => !0,
    deleteFilter: i = () => !0,
    trackedOrigins: s = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: o = !1,
    doc: a = (
      /** @type {Doc} */
      dw(e) ? e[0].doc : e.doc
    )
  } = {}) {
    super(), this.scope = [], this.doc = a, this.addToScope(e), this.deleteFilter = i, s.add(this), this.trackedOrigins = s, this.captureTransaction = r, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.currStackItem = null, this.lastChange = 0, this.ignoreRemoteMapChanges = o, this.captureTimeout = n, this.afterTransactionHandler = (l) => {
      if (!this.captureTransaction(l) || !this.scope.some((m) => l.changedParentTypes.has(m)) || !this.trackedOrigins.has(l.origin) && (!l.origin || !this.trackedOrigins.has(l.origin.constructor)))
        return;
      const c = this.undoing, u = this.redoing, d = c ? this.redoStack : this.undoStack;
      c ? this.stopCapturing() : u || this.clear(!1, !0);
      const f = new lu();
      l.afterState.forEach((m, v) => {
        const y = l.beforeState.get(v) || 0, E = m - y;
        E > 0 && gf(f, v, y, E);
      });
      const h = Fae();
      let p = !1;
      if (this.lastChange > 0 && h - this.lastChange < this.captureTimeout && d.length > 0 && !c && !u) {
        const m = d[d.length - 1];
        m.deletions = vw([m.deletions, l.deleteSet]), m.insertions = vw([m.insertions, f]);
      } else
        d.push(new Wle(l.deleteSet, f)), p = !0;
      !c && !u && (this.lastChange = h), Bo(
        l,
        l.deleteSet,
        /** @param {Item|GC} item */
        (m) => {
          m instanceof kt && this.scope.some((v) => vf(v, m)) && BS(m, !0);
        }
      );
      const g = [{ stackItem: d[d.length - 1], origin: l.origin, type: c ? "redo" : "undo", changedParentTypes: l.changedParentTypes }, this];
      p ? this.emit("stack-item-added", g) : this.emit("stack-item-updated", g);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(e) {
    e = dw(e) ? e : [e], e.forEach((n) => {
      this.scope.every((r) => r !== n) && (n.doc !== this.doc && vle("[yjs#509] Not same Y.Doc"), this.scope.push(n));
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(e) {
    this.trackedOrigins.add(e);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(e) {
    this.trackedOrigins.delete(e);
  }
  clear(e = !0, n = !0) {
    (e && this.canUndo() || n && this.canRedo()) && this.doc.transact((r) => {
      e && (this.undoStack.forEach((i) => CM(r, this, i)), this.undoStack = []), n && (this.redoStack.forEach((i) => CM(r, this, i)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: e, redoStackCleared: n }]);
    });
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = !0;
    let e;
    try {
      e = TM(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return e;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = !0;
    let e;
    try {
      e = TM(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return e;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* Gle(t) {
  const e = ct(t.restDecoder);
  for (let n = 0; n < e; n++) {
    const r = ct(t.restDecoder), i = t.readClient();
    let s = ct(t.restDecoder);
    for (let o = 0; o < r; o++) {
      const a = t.readInfo();
      if (a === 10) {
        const l = ct(t.restDecoder);
        yield new Zr(it(i, s), l), s += l;
      } else if (m0 & a) {
        const l = (a & (zs | Lr)) === 0, c = new kt(
          it(i, s),
          null,
          // left
          (a & Lr) === Lr ? t.readLeftID() : null,
          // origin
          null,
          // right
          (a & zs) === zs ? t.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          l ? t.readParentInfo() ? t.readString() : t.readLeftID() : null,
          // parent
          l && (a & df) === df ? t.readString() : null,
          // parentSub
          YB(t, a)
          // item content
        );
        yield c, s += c.length;
      } else {
        const l = t.readLen();
        yield new Jr(it(i, s), l), s += l;
      }
    }
  }
}
class NS {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(e, n) {
    this.gen = Gle(e), this.curr = null, this.done = !1, this.filterSkips = n, this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === Zr);
    return this.curr;
  }
}
class RS {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(e) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = e, this.clientStructs = [];
  }
}
const jle = (t) => Mm(t, bB, nh), qle = (t, e) => {
  if (t.constructor === Jr) {
    const { client: n, clock: r } = t.id;
    return new Jr(it(n, r + e), t.length - e);
  } else if (t.constructor === Zr) {
    const { client: n, clock: r } = t.id;
    return new Zr(it(n, r + e), t.length - e);
  } else {
    const n = (
      /** @type {Item} */
      t
    ), { client: r, clock: i } = n.id;
    return new kt(
      it(r, i + e),
      null,
      it(r, i + e - 1),
      null,
      n.rightOrigin,
      n.parent,
      n.parentSub,
      n.content.splice(e)
    );
  }
}, Mm = (t, e = Kc, n = sl) => {
  if (t.length === 1)
    return t[0];
  const r = t.map((u) => new e(au(u)));
  let i = r.map((u) => new NS(u, !0)), s = null;
  const o = new n(), a = new RS(o);
  for (; i = i.filter((f) => f.curr !== null), i.sort(
    /** @type {function(any,any):number} */
    (f, h) => {
      if (f.curr.id.client === h.curr.id.client) {
        const p = f.curr.id.clock - h.curr.id.clock;
        return p === 0 ? f.curr.constructor === h.curr.constructor ? 0 : f.curr.constructor === Zr ? 1 : -1 : p;
      } else
        return h.curr.id.client - f.curr.id.client;
    }
  ), i.length !== 0; ) {
    const u = i[0], d = (
      /** @type {Item | GC} */
      u.curr.id.client
    );
    if (s !== null) {
      let f = (
        /** @type {Item | GC | null} */
        u.curr
      ), h = !1;
      for (; f !== null && f.id.clock + f.length <= s.struct.id.clock + s.struct.length && f.id.client >= s.struct.id.client; )
        f = u.next(), h = !0;
      if (f === null || // current decoder is empty
      f.id.client !== d || // check whether there is another decoder that has has updates from `firstClient`
      h && f.id.clock > s.struct.id.clock + s.struct.length)
        continue;
      if (d !== s.struct.id.client)
        ho(a, s.struct, s.offset), s = { struct: f, offset: 0 }, u.next();
      else if (s.struct.id.clock + s.struct.length < f.id.clock)
        if (s.struct.constructor === Zr)
          s.struct.length = f.id.clock + f.length - s.struct.id.clock;
        else {
          ho(a, s.struct, s.offset);
          const p = f.id.clock - s.struct.id.clock - s.struct.length;
          s = { struct: new Zr(it(d, s.struct.id.clock + s.struct.length), p), offset: 0 };
        }
      else {
        const p = s.struct.id.clock + s.struct.length - f.id.clock;
        p > 0 && (s.struct.constructor === Zr ? s.struct.length -= p : f = qle(f, p)), s.struct.mergeWith(
          /** @type {any} */
          f
        ) || (ho(a, s.struct, s.offset), s = { struct: f, offset: 0 }, u.next());
      }
    } else
      s = { struct: (
        /** @type {Item | GC} */
        u.curr
      ), offset: 0 }, u.next();
    for (let f = u.curr; f !== null && f.id.client === d && f.id.clock === s.struct.id.clock + s.struct.length && f.constructor !== Zr; f = u.next())
      ho(a, s.struct, s.offset), s = { struct: f, offset: 0 };
  }
  s !== null && (ho(a, s.struct, s.offset), s = null), DS(a);
  const l = r.map((u) => TS(u)), c = vw(l);
  return uu(o, c), o.toUint8Array();
}, Kle = (t, e, n = Kc, r = sl) => {
  const i = EB(e), s = new r(), o = new RS(s), a = new n(au(t)), l = new NS(a, !1);
  for (; l.curr; ) {
    const u = l.curr, d = u.id.client, f = i.get(d) || 0;
    if (l.curr.constructor === Zr) {
      l.next();
      continue;
    }
    if (u.id.clock + u.length > f)
      for (ho(o, u, qs(f - u.id.clock, 0)), l.next(); l.curr && l.curr.id.client === d; )
        ho(o, l.curr, 0), l.next();
    else
      for (; l.curr && l.curr.id.client === d && l.curr.id.clock + l.curr.length <= f; )
        l.next();
  }
  DS(o);
  const c = TS(a);
  return uu(s, c), s.toUint8Array();
}, AB = (t) => {
  t.written > 0 && (t.clientStructs.push({ written: t.written, restEncoder: Ji(t.encoder.restEncoder) }), t.encoder.restEncoder = v0(), t.written = 0);
}, ho = (t, e, n) => {
  t.written > 0 && t.currClient !== e.id.client && AB(t), t.written === 0 && (t.currClient = e.id.client, t.encoder.writeClient(e.id.client), ht(t.encoder.restEncoder, e.id.clock + n)), e.write(t.encoder, n), t.written++;
}, DS = (t) => {
  AB(t);
  const e = t.encoder.restEncoder;
  ht(e, t.clientStructs.length);
  for (let n = 0; n < t.clientStructs.length; n++) {
    const r = t.clientStructs[n];
    ht(e, r.written), b0(e, r.restEncoder);
  }
}, Yle = (t, e, n, r) => {
  const i = new n(au(t)), s = new NS(i, !1), o = new r(), a = new RS(o);
  for (let c = s.curr; c !== null; c = s.next())
    ho(a, e(c), 0);
  DS(a);
  const l = TS(i);
  return uu(o, l), o.toUint8Array();
}, Xle = (t) => Yle(t, Yae, Kc, nh), OM = "You must not compute changes after the event-handler fired.";
class w0 {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = Jle(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return cu(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw $o(OM);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((i) => {
        if (i !== null) {
          const s = (
            /** @type {Item} */
            n._map.get(i)
          );
          let o, a;
          if (this.adds(s)) {
            let l = s.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(s))
              if (l !== null && this.deletes(l))
                o = "delete", a = zb(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (o = "update", a = zb(l.content.getContent())) : (o = "add", a = void 0);
          } else if (this.deletes(s))
            o = "delete", a = zb(
              /** @type {Item} */
              s.content.getContent()
            );
          else
            return;
          e.set(i, { action: o, oldValue: a });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw $o(OM);
      const n = this.target, r = il(), i = il(), s = [];
      if (e = {
        added: r,
        deleted: i,
        delta: s,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let a = null;
        const l = () => {
          a && s.push(a);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, i.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), r.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const Jle = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let r = 0, i = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; i !== e._item && i !== null; )
        i.deleted || r++, i = i.right;
      n.unshift(r);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return n;
}, NB = 80;
let IS = 0;
class Zle {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = IS++;
  }
}
const Qle = (t) => {
  t.timestamp = IS++;
}, RB = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = IS++;
}, ece = (t, e, n) => {
  if (t.length >= NB) {
    const r = t.reduce((i, s) => i.timestamp < s.timestamp ? i : s);
    return RB(r, e, n), r;
  } else {
    const r = new Zle(e, n);
    return t.push(r), r;
  }
}, _0 = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((s, o) => Ip(e - s.index) < Ip(e - o.index) ? s : o);
  let r = t._start, i = 0;
  for (n !== null && (r = n.p, i = n.index, Qle(n)); r.right !== null && i < e; ) {
    if (!r.deleted && r.countable) {
      if (e < i + r.length)
        break;
      i += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && i > e; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  return n !== null && Ip(n.index - i) < /** @type {YText|YArray<any>} */
  r.parent.length / NB ? (RB(n, r, i), n) : ece(t._searchMarker, r, i);
}, yf = (t, e, n) => {
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    if (n > 0) {
      let s = i.p;
      for (s.marker = !1; s && (s.deleted || !s.countable); )
        s = s.left, s && !s.deleted && s.countable && (i.index -= s.length);
      if (s === null || s.marker === !0) {
        t.splice(r, 1);
        continue;
      }
      i.p = s, s.marker = !0;
    }
    (e < i.index || n > 0 && e === i.index) && (i.index = qs(e, i.index + n));
  }
}, E0 = (t, e, n) => {
  const r = t, i = e.changedParentTypes;
  for (; Ys(i, t, () => []).push(n), t._item !== null; )
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  xB(r._eH, n, e);
};
class An {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = yM(), this._dEH = yM(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw Oi();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw Oi();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    wM(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    wM(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    _M(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    _M(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const DB = (t, e, n) => {
  e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let r = n - e;
  const i = [];
  let s = t._start;
  for (; s !== null && r > 0; ) {
    if (s.countable && !s.deleted) {
      const o = s.content.getContent();
      if (o.length <= e)
        e -= o.length;
      else {
        for (let a = e; a < o.length && r > 0; a++)
          i.push(o[a]), r--;
        e = 0;
      }
    }
    s = s.right;
  }
  return i;
}, IB = (t) => {
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let i = 0; i < r.length; i++)
        e.push(r[i]);
    }
    n = n.right;
  }
  return e;
}, PB = (t, e) => {
  const n = [];
  let r = t._start;
  for (; r !== null; ) {
    if (r.countable && ua(r, e)) {
      const i = r.content.getContent();
      for (let s = 0; s < i.length; s++)
        n.push(i[s]);
    }
    r = r.right;
  }
  return n;
}, wf = (t, e) => {
  let n = 0, r = t._start;
  for (; r !== null; ) {
    if (r.countable && !r.deleted) {
      const i = r.content.getContent();
      for (let s = 0; s < i.length; s++)
        e(i[s], n++, t);
    }
    r = r.right;
  }
}, LB = (t, e) => {
  const n = [];
  return wf(t, (r, i) => {
    n.push(e(r, i, t));
  }), n;
}, tce = (t) => {
  let e = t._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), r = 0, e = e.right;
      }
      const i = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: i
      };
    }
  };
}, $B = (t, e) => {
  const n = _0(t, e);
  let r = t._start;
  for (n !== null && (r = n.p, e -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (e < r.length)
        return r.content.getContent()[e];
      e -= r.length;
    }
}, Am = (t, e, n, r) => {
  let i = n;
  const s = t.doc, o = s.clientID, a = s.store, l = n === null ? e._start : n.right;
  let c = [];
  const u = () => {
    c.length > 0 && (i = new kt(it(o, Jt(a, o)), i, i && i.lastId, l, l && l.id, e, null, new ll(c)), i.integrate(t, 0), c = []);
  };
  r.forEach((d) => {
    if (d === null)
      c.push(d);
    else
      switch (d.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(d);
          break;
        default:
          switch (u(), d.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new kt(it(o, Jt(a, o)), i, i && i.lastId, l, l && l.id, e, null, new ih(new Uint8Array(
                /** @type {Uint8Array} */
                d
              ))), i.integrate(t, 0);
              break;
            case du:
              i = new kt(it(o, Jt(a, o)), i, i && i.lastId, l, l && l.id, e, null, new sh(
                /** @type {Doc} */
                d
              )), i.integrate(t, 0);
              break;
            default:
              if (d instanceof An)
                i = new kt(it(o, Jt(a, o)), i, i && i.lastId, l, l && l.id, e, null, new Bi(d)), i.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, BB = () => $o("Length exceeded!"), FB = (t, e, n, r) => {
  if (n > e._length)
    throw BB();
  if (n === 0)
    return e._searchMarker && yf(e._searchMarker, n, r.length), Am(t, e, null, r);
  const i = n, s = _0(e, n);
  let o = e._start;
  for (s !== null && (o = s.p, n -= s.index, n === 0 && (o = o.prev, n += o && o.countable && !o.deleted ? o.length : 0)); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (n <= o.length) {
        n < o.length && lr(t, it(o.id.client, o.id.clock + n));
        break;
      }
      n -= o.length;
    }
  return e._searchMarker && yf(e._searchMarker, i, r.length), Am(t, e, o, r);
}, nce = (t, e, n) => {
  let i = (e._searchMarker || []).reduce((s, o) => o.index > s.index ? o : s, { index: 0, p: e._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return Am(t, e, i, n);
}, zB = (t, e, n, r) => {
  if (r === 0)
    return;
  const i = n, s = r, o = _0(e, n);
  let a = e._start;
  for (o !== null && (a = o.p, n -= o.index); a !== null && n > 0; a = a.right)
    !a.deleted && a.countable && (n < a.length && lr(t, it(a.id.client, a.id.clock + n)), n -= a.length);
  for (; r > 0 && a !== null; )
    a.deleted || (r < a.length && lr(t, it(a.id.client, a.id.clock + r)), a.delete(t), r -= a.length), a = a.right;
  if (r > 0)
    throw BB();
  e._searchMarker && yf(
    e._searchMarker,
    i,
    -s + r
    /* in case we remove the above exception */
  );
}, Nm = (t, e, n) => {
  const r = e._map.get(n);
  r !== void 0 && r.delete(t);
}, PS = (t, e, n, r) => {
  const i = e._map.get(n) || null, s = t.doc, o = s.clientID;
  let a;
  if (r == null)
    a = new ll([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        a = new ll([r]);
        break;
      case Uint8Array:
        a = new ih(
          /** @type {Uint8Array} */
          r
        );
        break;
      case du:
        a = new sh(
          /** @type {Doc} */
          r
        );
        break;
      default:
        if (r instanceof An)
          a = new Bi(r);
        else
          throw new Error("Unexpected content type");
    }
  new kt(it(o, Jt(s.store, o)), i, i && i.lastId, null, null, e, n, a).integrate(t, 0);
}, LS = (t, e) => {
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, HB = (t) => {
  const e = {};
  return t._map.forEach((n, r) => {
    n.deleted || (e[r] = n.content.getContent()[n.length - 1]);
  }), e;
}, UB = (t, e) => {
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, rce = (t, e) => {
  const n = {};
  return t._map.forEach((r, i) => {
    let s = r;
    for (; s !== null && (!e.sv.has(s.id.client) || s.id.clock >= (e.sv.get(s.id.client) || 0)); )
      s = s.left;
    s !== null && ua(s, e) && (n[i] = s.content.getContent()[s.length - 1]);
  }), n;
}, rp = (t) => ble(
  t.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
);
class ice extends w0 {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(e, n) {
    super(e, n), this._transaction = n;
  }
}
class fc extends An {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const n = new fc();
    return n.push(e), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new fc();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const e = new fc();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof An ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n), E0(this, e, new ice(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? Dt(this.doc, (r) => {
      FB(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? Dt(this.doc, (n) => {
      nce(
        n,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? Dt(this.doc, (r) => {
      zB(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return $B(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return IB(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, n = this.length) {
    return DB(this, e, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof An ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return LB(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    wf(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return tce(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(Oce);
  }
}
const sce = (t) => new fc();
class oce extends w0 {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, n, r) {
    super(e, n), this.keysChanged = r;
  }
}
class Yc extends An {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((r, i) => {
      this.set(i, r);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new Yc();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new Yc();
    return this.forEach((n, r) => {
      e.set(r, n instanceof An ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    E0(this, e, new oce(this, e, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const e = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const i = n.content.getContent()[n.length - 1];
        e[r] = i instanceof An ? i.toJSON() : i;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...rp(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return Gb(
      rp(this._map),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return Gb(
      rp(this._map),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return Gb(
      rp(this._map),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this._map.forEach((n, r) => {
      n.deleted || e(n.content.getContent()[n.length - 1], r, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? Dt(this.doc, (n) => {
      Nm(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, n) {
    return this.doc !== null ? Dt(this.doc, (r) => {
      PS(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(e, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      LS(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return UB(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? Dt(this.doc, (e) => {
      this.forEach(function(n, r, i) {
        Nm(e, i, r);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(Mce);
  }
}
const ace = (t) => new Yc(), Eo = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && Kae(t, e);
class ww {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, n, r, i) {
    this.left = e, this.right = n, this.index = r, this.currentAttributes = i;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && di(), this.right.content.constructor) {
      case sn:
        this.right.deleted || fu(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const MM = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case sn:
        e.right.deleted || fu(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (n < e.right.length && lr(t, it(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, ip = (t, e, n, r) => {
  const i = /* @__PURE__ */ new Map(), s = r ? _0(e, n) : null;
  if (s) {
    const o = new ww(s.p.left, s.p, s.index, i);
    return MM(t, o, n - s.index);
  } else {
    const o = new ww(null, e._start, 0, i);
    return MM(t, o, n);
  }
}, VB = (t, e, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === sn && Eo(
    r.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || r.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const i = t.doc, s = i.clientID;
  r.forEach((o, a) => {
    const l = n.left, c = n.right, u = new kt(it(s, Jt(i.store, s)), l, l && l.lastId, c, c && c.id, e, null, new sn(a, o));
    u.integrate(t, 0), n.right = u, n.forward();
  });
}, fu = (t, e) => {
  const { key: n, value: r } = e;
  r === null ? t.delete(n) : t.set(n, r);
}, WB = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === sn && Eo(
      e[
        /** @type {ContentFormat} */
        t.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      t.right.content.value
    )))
      break;
    t.forward();
  }
}, GB = (t, e, n, r) => {
  const i = t.doc, s = i.clientID, o = /* @__PURE__ */ new Map();
  for (const a in r) {
    const l = r[a], c = n.currentAttributes.get(a) ?? null;
    if (!Eo(c, l)) {
      o.set(a, c);
      const { left: u, right: d } = n;
      n.right = new kt(it(s, Jt(i.store, s)), u, u && u.lastId, d, d && d.id, e, null, new sn(a, l)), n.right.integrate(t, 0), n.forward();
    }
  }
  return o;
}, qb = (t, e, n, r, i) => {
  n.currentAttributes.forEach((f, h) => {
    i[h] === void 0 && (i[h] = null);
  });
  const s = t.doc, o = s.clientID;
  WB(n, i);
  const a = GB(t, e, n, i), l = r.constructor === String ? new Di(
    /** @type {string} */
    r
  ) : r instanceof An ? new Bi(r) : new yl(r);
  let { left: c, right: u, index: d } = n;
  e._searchMarker && yf(e._searchMarker, n.index, l.getLength()), u = new kt(it(o, Jt(s.store, o)), c, c && c.lastId, u, u && u.id, e, null, l), u.integrate(t, 0), n.right = u, n.index = d, n.forward(), VB(t, e, n, a);
}, AM = (t, e, n, r, i) => {
  const s = t.doc, o = s.clientID;
  WB(n, i);
  const a = GB(t, e, n, i);
  e:
    for (; n.right !== null && (r > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === sn)); ) {
      if (!n.right.deleted)
        switch (n.right.content.constructor) {
          case sn: {
            const { key: l, value: c } = (
              /** @type {ContentFormat} */
              n.right.content
            ), u = i[l];
            if (u !== void 0) {
              if (Eo(u, c))
                a.delete(l);
              else {
                if (r === 0)
                  break e;
                a.set(l, c);
              }
              n.right.delete(t);
            } else
              n.currentAttributes.set(l, c);
            break;
          }
          default:
            r < n.right.length && lr(t, it(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
            break;
        }
      n.forward();
    }
  if (r > 0) {
    let l = "";
    for (; r > 0; r--)
      l += `
`;
    n.right = new kt(it(o, Jt(s.store, o)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new Di(l)), n.right.integrate(t, 0), n.forward();
  }
  VB(t, e, n, a);
}, jB = (t, e, n, r, i) => {
  let s = e;
  const o = ri();
  for (; s && (!s.countable || s.deleted); ) {
    if (!s.deleted && s.content.constructor === sn) {
      const c = (
        /** @type {ContentFormat} */
        s.content
      );
      o.set(c.key, c);
    }
    s = s.right;
  }
  let a = 0, l = !1;
  for (; e !== s; ) {
    if (n === e && (l = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case sn: {
          const { key: u, value: d } = (
            /** @type {ContentFormat} */
            c
          ), f = r.get(u) ?? null;
          (o.get(u) !== c || f === d) && (e.delete(t), a++, !l && (i.get(u) ?? null) === d && f !== d && (f === null ? i.delete(u) : i.set(u, f))), !l && !e.deleted && fu(
            i,
            /** @type {ContentFormat} */
            c
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return a;
}, lce = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === sn) {
      const r = (
        /** @type {ContentFormat} */
        e.content.key
      );
      n.has(r) ? e.delete(t) : n.add(r);
    }
    e = e.left;
  }
}, cce = (t) => {
  let e = 0;
  return Dt(
    /** @type {Doc} */
    t.doc,
    (n) => {
      let r = (
        /** @type {Item} */
        t._start
      ), i = t._start, s = ri();
      const o = uw(s);
      for (; i; ) {
        if (i.deleted === !1)
          switch (i.content.constructor) {
            case sn:
              fu(
                o,
                /** @type {ContentFormat} */
                i.content
              );
              break;
            default:
              e += jB(n, r, i, s, o), s = uw(o), r = i;
              break;
          }
        i = i.right;
      }
    }
  ), e;
}, uce = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [r, i] of t.afterState.entries()) {
    const s = t.beforeState.get(r) || 0;
    i !== s && TB(
      t,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(r),
      s,
      i,
      (o) => {
        !o.deleted && /** @type {Item} */
        o.content.constructor === sn && o.constructor !== Jr && e.add(
          /** @type {any} */
          o.parent
        );
      }
    );
  }
  Dt(n, (r) => {
    Bo(t, t.deleteSet, (i) => {
      if (i instanceof Jr || !/** @type {YText} */
      i.parent._hasFormatting || e.has(
        /** @type {YText} */
        i.parent
      ))
        return;
      const s = (
        /** @type {YText} */
        i.parent
      );
      i.content.constructor === sn ? e.add(s) : lce(r, i);
    });
    for (const i of e)
      cce(i);
  });
}, NM = (t, e, n) => {
  const r = n, i = uw(e.currentAttributes), s = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case Bi:
        case yl:
        case Di:
          n < e.right.length && lr(t, it(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  s && jB(t, s, e.right, i, e.currentAttributes);
  const o = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return o._searchMarker && yf(o._searchMarker, e.index, -r + n), e;
};
class dce extends w0 {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, n, r) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      Dt(e, (r) => {
        const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
        let o = this.target._start, a = null;
        const l = {};
        let c = "", u = 0, d = 0;
        const f = () => {
          if (a !== null) {
            let h = null;
            switch (a) {
              case "delete":
                d > 0 && (h = { delete: d }), d = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (h = { insert: c }, i.size > 0 && (h.attributes = {}, i.forEach((p, g) => {
                  p !== null && (h.attributes[g] = p);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (h = { retain: u }, Gae(l) || (h.attributes = Vae({}, l))), u = 0;
                break;
            }
            h && n.push(h), a = null;
          }
        };
        for (; o !== null; ) {
          switch (o.content.constructor) {
            case Bi:
            case yl:
              this.adds(o) ? this.deletes(o) || (f(), a = "insert", c = o.content.getContent()[0], f()) : this.deletes(o) ? (a !== "delete" && (f(), a = "delete"), d += 1) : o.deleted || (a !== "retain" && (f(), a = "retain"), u += 1);
              break;
            case Di:
              this.adds(o) ? this.deletes(o) || (a !== "insert" && (f(), a = "insert"), c += /** @type {ContentString} */
              o.content.str) : this.deletes(o) ? (a !== "delete" && (f(), a = "delete"), d += o.length) : o.deleted || (a !== "retain" && (f(), a = "retain"), u += o.length);
              break;
            case sn: {
              const { key: h, value: p } = (
                /** @type {ContentFormat} */
                o.content
              );
              if (this.adds(o)) {
                if (!this.deletes(o)) {
                  const g = i.get(h) ?? null;
                  Eo(g, p) ? p !== null && o.delete(r) : (a === "retain" && f(), Eo(p, s.get(h) ?? null) ? delete l[h] : l[h] = p);
                }
              } else if (this.deletes(o)) {
                s.set(h, p);
                const g = i.get(h) ?? null;
                Eo(g, p) || (a === "retain" && f(), l[h] = g);
              } else if (!o.deleted) {
                s.set(h, p);
                const g = l[h];
                g !== void 0 && (Eo(g, p) ? g !== null && o.delete(r) : (a === "retain" && f(), p === null ? delete l[h] : l[h] = p));
              }
              o.deleted || (a === "insert" && f(), fu(
                i,
                /** @type {ContentFormat} */
                o.content
              ));
              break;
            }
          }
          o = o.right;
        }
        for (f(); n.length > 0; ) {
          const h = n[n.length - 1];
          if (h.retain !== void 0 && h.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class ol extends An {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new ol();
  }
  /**
   * @return {YText}
   */
  clone() {
    const e = new ol();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n);
    const r = new dce(this, e, n);
    E0(this, e, r), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === Di && (e += /** @type {ContentString} */
      n.content.str), n = n.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? Dt(this.doc, (r) => {
      const i = new ww(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (o.insert !== void 0) {
          const a = !n && typeof o.insert == "string" && s === e.length - 1 && i.right === null && o.insert.slice(-1) === `
` ? o.insert.slice(0, -1) : o.insert;
          (typeof a != "string" || a.length > 0) && qb(r, this, i, a, o.attributes || {});
        } else
          o.retain !== void 0 ? AM(r, this, i, o.retain, o.attributes || {}) : o.delete !== void 0 && NM(r, i, o.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, n, r) {
    const i = [], s = /* @__PURE__ */ new Map(), o = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const d = {};
        let f = !1;
        s.forEach((p, g) => {
          f = !0, d[g] = p;
        });
        const h = { insert: a };
        f && (h.attributes = d), i.push(h), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (ua(l, e) || n !== void 0 && ua(l, n))
          switch (l.content.constructor) {
            case Di: {
              const d = s.get("ychange");
              e !== void 0 && !ua(l, e) ? (d === void 0 || d.user !== l.id.client || d.type !== "removed") && (c(), s.set("ychange", r ? r("removed", l.id) : { type: "removed" })) : n !== void 0 && !ua(l, n) ? (d === void 0 || d.user !== l.id.client || d.type !== "added") && (c(), s.set("ychange", r ? r("added", l.id) : { type: "added" })) : d !== void 0 && (c(), s.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case Bi:
            case yl: {
              c();
              const d = {
                insert: l.content.getContent()[0]
              };
              if (s.size > 0) {
                const f = (
                  /** @type {Object<string,any>} */
                  {}
                );
                d.attributes = f, s.forEach((h, p) => {
                  f[p] = h;
                });
              }
              i.push(d);
              break;
            }
            case sn:
              ua(l, e) && (c(), fu(
                s,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || n ? Dt(o, (d) => {
      e && bw(d, e), n && bw(d, n), u();
    }, "cleanup") : u(), i;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, n, r) {
    if (n.length <= 0)
      return;
    const i = this.doc;
    i !== null ? Dt(i, (s) => {
      const o = ip(s, this, e, !r);
      r || (r = {}, o.currentAttributes.forEach((a, l) => {
        r[l] = a;
      })), qb(s, this, o, n, r);
    }) : this._pending.push(() => this.insert(e, n, r));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, n, r) {
    const i = this.doc;
    i !== null ? Dt(i, (s) => {
      const o = ip(s, this, e, !r);
      qb(s, this, o, n, r || {});
    }) : this._pending.push(() => this.insertEmbed(e, n, r || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? Dt(r, (i) => {
      NM(i, ip(i, this, e, !0), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, n, r) {
    if (n === 0)
      return;
    const i = this.doc;
    i !== null ? Dt(i, (s) => {
      const o = ip(s, this, e, !1);
      o.right !== null && AM(s, this, o, n, r);
    }) : this._pending.push(() => this.format(e, n, r));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? Dt(this.doc, (n) => {
      Nm(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? Dt(this.doc, (r) => {
      PS(r, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      LS(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return HB(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(Ace);
  }
}
const fce = (t) => new ol();
class Kb {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, n = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        e.content.type, !e.deleted && (n.constructor === Zn || n.constructor === al) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else
              e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
              e.parent._item;
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class al extends An {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new al();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const e = new al();
    return e.insert(0, this.toArray().map((n) => n instanceof An ? n.clone() : n)), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new Kb(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const r = new Kb(this, (i) => i.nodeName && i.nodeName.toUpperCase() === e).next();
    return r.done ? null : r.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), Lo(new Kb(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    E0(this, e, new gce(this, n, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return LB(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createDocumentFragment();
    return r !== void 0 && r._createAssociation(i, this), wf(this, (s) => {
      i.insertBefore(s.toDOM(e, n, r), null);
    }), i;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? Dt(this.doc, (r) => {
      FB(r, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, n) {
    if (this.doc !== null)
      Dt(this.doc, (r) => {
        const i = e && e instanceof An ? e._item : e;
        Am(r, this, i, n);
      });
    else {
      const r = (
        /** @type {Array<any>} */
        this._prelimContent
      ), i = e === null ? 0 : r.findIndex((s) => s === e) + 1;
      if (i === 0 && e !== null)
        throw $o("Reference item not found");
      r.splice(i, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? Dt(this.doc, (r) => {
      zB(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return IB(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return $B(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, n = this.length) {
    return DB(this, e, n);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    wf(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(Rce);
  }
}
const hce = (t) => new al();
class Zn extends al {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((r, i) => {
      this.setAttribute(i, r);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Zn(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new Zn(this.nodeName), n = this.getAttributes();
    return Wae(n, (r, i) => {
      typeof r == "string" && e.setAttribute(i, r);
    }), e.insert(0, this.toArray().map((r) => r instanceof An ? r.clone() : r)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), n = [], r = [];
    for (const a in e)
      r.push(a);
    r.sort();
    const i = r.length;
    for (let a = 0; a < i; a++) {
      const l = r[a];
      n.push(l + '="' + e[l] + '"');
    }
    const s = this.nodeName.toLocaleLowerCase(), o = n.length > 0 ? " " + n.join(" ") : "";
    return `<${s}${o}>${super.toString()}</${s}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? Dt(this.doc, (n) => {
      Nm(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? Dt(this.doc, (r) => {
      PS(r, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      LS(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      UB(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? rce(this, e) : HB(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createElement(this.nodeName), s = this.getAttributes();
    for (const o in s) {
      const a = s[o];
      typeof a == "string" && i.setAttribute(o, a);
    }
    return wf(this, (o) => {
      i.appendChild(o.toDOM(e, n, r));
    }), r !== void 0 && r._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(Nce), e.writeKey(this.nodeName);
  }
}
const pce = (t) => new Zn(t.readKey());
class gce extends w0 {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(e, n, r) {
    super(e, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class Rm extends Yc {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(e) {
    super(), this.hookName = e;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new Rm(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const e = new Rm(this.hookName);
    return this.forEach((n, r) => {
      e.set(r, n);
    }), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = n[this.hookName];
    let s;
    return i !== void 0 ? s = i.createDom(this) : s = document.createElement(this.hookName), s.setAttribute("data-yjs-hook", this.hookName), r !== void 0 && r._createAssociation(s, this), s;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(Dce), e.writeKey(this.hookName);
  }
}
const mce = (t) => new Rm(t.readKey());
class $r extends ol {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new $r();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const e = new $r();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n, r) {
    const i = e.createTextNode(this.toString());
    return r !== void 0 && r._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((e) => {
      const n = [];
      for (const i in e.attributes) {
        const s = [];
        for (const o in e.attributes[i])
          s.push({ key: o, value: e.attributes[i][o] });
        s.sort((o, a) => o.key < a.key ? -1 : 1), n.push({ nodeName: i, attrs: s });
      }
      n.sort((i, s) => i.nodeName < s.nodeName ? -1 : 1);
      let r = "";
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        r += `<${s.nodeName}`;
        for (let o = 0; o < s.attrs.length; o++) {
          const a = s.attrs[o];
          r += ` ${a.key}="${a.value}"`;
        }
        r += ">";
      }
      r += e.insert;
      for (let i = n.length - 1; i >= 0; i--)
        r += `</${n[i].nodeName}>`;
      return r;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(Ice);
  }
}
const vce = (t) => new $r();
class $S {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw Oi();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, n, r) {
    throw Oi();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    throw Oi();
  }
}
const bce = 0;
class Jr extends $S {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), CB(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo(bce), e.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
class ih {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ih(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw Oi();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
const yce = (t) => new ih(t.readBuf());
class _f {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _f(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const n = new _f(this.len - e);
    return this.len = e, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    gf(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const wce = (t) => new _f(t.readLen()), qB = (t, e) => new du({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class sh {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new sh(qB(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw Oi();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
const _ce = (t) => new sh(qB(t.readString(), t.readAny()));
class yl {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new yl(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw Oi();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
const Ece = (t) => new yl(t.readJSON());
class sn {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new sn(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw Oi();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, n) {
    const r = (
      /** @type {YText} */
      n.parent
    );
    r._searchMarker = null, r._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const Sce = (t) => new sn(t.readKey(), t.readJSON());
class Dm {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new Dm(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(e) {
    const n = new Dm(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const s = this.arr[i];
      e.writeString(s === void 0 ? "undefined" : JSON.stringify(s));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
}
const xce = (t) => {
  const e = t.readLen(), n = [];
  for (let r = 0; r < e; r++) {
    const i = t.readString();
    i === "undefined" ? n.push(void 0) : n.push(JSON.parse(i));
  }
  return new Dm(n);
};
class ll {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ll(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const n = new ll(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const s = this.arr[i];
      e.writeAny(s);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
const kce = (t) => {
  const e = t.readLen(), n = [];
  for (let r = 0; r < e; r++)
    n.push(t.readAny());
  return new ll(n);
};
class Di {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Di(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const n = new Di(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const r = this.str.charCodeAt(e - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", n.str = "�" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const Cce = (t) => new Di(t.readString()), Tce = [
  sce,
  ace,
  fce,
  pce,
  hce,
  mce,
  vce
], Oce = 0, Mce = 1, Ace = 2, Nce = 3, Rce = 4, Dce = 5, Ice = 6;
class Bi {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new Bi(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw Oi();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (e.beforeState.get(r.id.client) || 0) && e._mergeStructs.push(r) : r.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (r) => {
        for (; r !== null; )
          r.gc(e, !0), r = r.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const Pce = (t) => new Bi(Tce[t.readTypeRef()](t)), _w = (t, e) => {
  let n = e, r = 0, i;
  do
    r > 0 && (n = it(n.client, n.clock + r)), i = $p(t, n), r = n.clock - i.id.clock, n = i.redone;
  while (n !== null && i instanceof kt);
  return {
    item: i,
    diff: r
  };
}, BS = (t, e) => {
  for (; t !== null && t.keep !== e; )
    t.keep = e, t = /** @type {AbstractType<any>} */
    t.parent._item;
}, Im = (t, e, n) => {
  const { client: r, clock: i } = e.id, s = new kt(
    it(r, i + n),
    e,
    it(r, i + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && s.markDeleted(), e.keep && (s.keep = !0), e.redone !== null && (s.redone = it(e.redone.client, e.redone.clock + n)), e.right = s, s.right !== null && (s.right.left = s), t._mergeStructs.push(s), s.parentSub !== null && s.right === null && s.parent._map.set(s.parentSub, s), e.length = n, s;
}, RM = (t, e) => sae(
  t,
  /** @param {StackItem} s */
  (n) => cu(n.deletions, e)
), KB = (t, e, n, r, i, s) => {
  const o = t.doc, a = o.store, l = o.clientID, c = e.redone;
  if (c !== null)
    return lr(t, c);
  let u = (
    /** @type {AbstractType<any>} */
    e.parent._item
  ), d = null, f;
  if (u !== null && u.deleted === !0) {
    if (u.redone === null && (!n.has(u) || KB(t, u, n, r, i, s) === null))
      return null;
    for (; u.redone !== null; )
      u = lr(t, u.redone);
  }
  const h = u === null ? (
    /** @type {AbstractType<any>} */
    e.parent
  ) : (
    /** @type {ContentType} */
    u.content.type
  );
  if (e.parentSub === null) {
    for (d = e.left, f = e; d !== null; ) {
      let v = d;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== u; )
        v = v.redone === null ? null : lr(t, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === u) {
        d = v;
        break;
      }
      d = d.left;
    }
    for (; f !== null; ) {
      let v = f;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== u; )
        v = v.redone === null ? null : lr(t, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === u) {
        f = v;
        break;
      }
      f = f.right;
    }
  } else if (f = null, e.right && !i) {
    for (d = e; d !== null && d.right !== null && (d.right.redone || cu(r, d.right.id) || RM(s.undoStack, d.right.id) || RM(s.redoStack, d.right.id)); )
      for (d = d.right; d.redone; )
        d = lr(t, d.redone);
    if (d && d.right !== null)
      return null;
  } else
    d = h._map.get(e.parentSub) || null;
  const p = Jt(a, l), g = it(l, p), m = new kt(
    g,
    d,
    d && d.lastId,
    f,
    f && f.id,
    h,
    e.parentSub,
    e.content.copy()
  );
  return e.redone = g, BS(m, !0), m.integrate(t, 0), m;
};
class kt extends $S {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, n, r, i, s, o, a, l) {
    super(e, l.getLength()), this.origin = r, this.left = n, this.right = i, this.rightOrigin = s, this.parent = o, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? aM : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & Ub) > 0 !== e && (this.info ^= Ub);
  }
  get marker() {
    return (this.info & Ub) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & oM) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= oM);
  }
  get countable() {
    return (this.info & aM) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & Hb) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= Hb);
  }
  markDeleted() {
    this.info |= Hb;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Jt(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Jt(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === dc && this.id.client !== this.parent.client && this.parent.clock >= Jt(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = SM(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = lr(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === Jr || this.right && this.right.constructor === Jr)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === kt && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === kt && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === dc) {
      const r = $p(n, this.parent);
      r.constructor === Jr ? this.parent = null : this.parent = /** @type {ContentType} */
      r.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = SM(e, e.doc.store, it(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, i;
        if (r !== null)
          i = r.right;
        else if (this.parentSub !== null)
          for (i = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = /** @type {AbstractType<any>} */
          this.parent._start;
        const s = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (o.add(i), s.add(i), tc(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              r = i, s.clear();
            else if (tc(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && o.has($p(e.doc.store, i.origin)))
            s.has($p(e.doc.store, i.origin)) || (r = i, s.clear());
          else
            break;
          i = i.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), CB(e.doc.store, this), this.content.integrate(e, this), kM(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new Jr(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : it(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && tc(e.origin, this.lastId) && this.right === e && tc(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((r) => {
        r.p === e && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), gf(e.deleteSet, this.id.client, this.id.clock, this.length), kM(e, n, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, n) {
    if (!this.deleted)
      throw di();
    this.content.gc(e), n ? zle(e, this, new Jr(this.id, this.length)) : this.content = new _f(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, n) {
    const r = n > 0 ? it(this.id.client, this.id.clock + n - 1) : this.origin, i = this.rightOrigin, s = this.parentSub, o = this.content.getRef() & m0 | (r === null ? 0 : Lr) | // origin is defined
    (i === null ? 0 : zs) | // right origin is defined
    (s === null ? 0 : df);
    if (e.writeInfo(o), r !== null && e.writeLeftID(r), i !== null && e.writeRightID(i), r === null && i === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = mf(a);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else
        a.constructor === String ? (e.writeParentInfo(!0), e.writeString(a)) : a.constructor === dc ? (e.writeParentInfo(!1), e.writeLeftID(a)) : di();
      s !== null && e.writeString(s);
    }
    this.content.write(e, n);
  }
}
const YB = (t, e) => Lce[e & m0](t), Lce = [
  () => {
    di();
  },
  // GC is not ItemContent
  wce,
  // 1
  xce,
  // 2
  yce,
  // 3
  Cce,
  // 4
  Ece,
  // 5
  Sce,
  // 6
  Pce,
  // 7
  kce,
  // 8
  _ce,
  // 9
  () => {
    di();
  }
  // 10 - Skip is not ItemContent
], $ce = 10;
class Zr extends $S {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    di();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo($ce), ht(e.restEncoder, this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
const XB = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), JB = "__ $YJS$ __";
XB[JB] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
XB[JB] = !0;
function Bce(t) {
  return t || (t = {}), {
    delay: t.delay === void 0 ? 200 : t.delay,
    initialDelay: t.initialDelay === void 0 ? 0 : t.initialDelay,
    minDelay: t.minDelay === void 0 ? 0 : t.minDelay,
    maxDelay: t.maxDelay === void 0 ? 0 : t.maxDelay,
    factor: t.factor === void 0 ? 0 : t.factor,
    maxAttempts: t.maxAttempts === void 0 ? 3 : t.maxAttempts,
    timeout: t.timeout === void 0 ? 0 : t.timeout,
    jitter: t.jitter === !0,
    initialJitter: t.initialJitter === !0,
    handleError: t.handleError === void 0 ? null : t.handleError,
    handleTimeout: t.handleTimeout === void 0 ? null : t.handleTimeout,
    beforeAttempt: t.beforeAttempt === void 0 ? null : t.beforeAttempt,
    calculateDelay: t.calculateDelay === void 0 ? null : t.calculateDelay
  };
}
async function Yb(t) {
  return new Promise((e) => setTimeout(e, t));
}
function Fce(t, e) {
  let n = e.delay;
  if (n === 0)
    return 0;
  if (e.factor && (n *= Math.pow(e.factor, t.attemptNum - 1), e.maxDelay !== 0 && (n = Math.min(n, e.maxDelay))), e.jitter) {
    const r = Math.ceil(e.minDelay), i = Math.floor(n);
    n = Math.floor(Math.random() * (i - r + 1)) + r;
  }
  return Math.round(n);
}
async function zce(t, e) {
  const n = Bce(e);
  for (const a of [
    "delay",
    "initialDelay",
    "minDelay",
    "maxDelay",
    "maxAttempts",
    "timeout"
  ]) {
    const l = n[a];
    if (!Number.isInteger(l) || l < 0)
      throw new Error(`Value for ${a} must be an integer greater than or equal to 0`);
  }
  if (n.factor.constructor !== Number || n.factor < 0)
    throw new Error("Value for factor must be a number greater than or equal to 0");
  if (n.delay < n.minDelay)
    throw new Error(`delay cannot be less than minDelay (delay: ${n.delay}, minDelay: ${n.minDelay}`);
  const r = {
    attemptNum: 0,
    attemptsRemaining: n.maxAttempts ? n.maxAttempts : -1,
    aborted: !1,
    abort() {
      r.aborted = !0;
    }
  }, i = n.calculateDelay || Fce;
  async function s() {
    if (n.beforeAttempt && n.beforeAttempt(r, n), r.aborted) {
      const l = new Error("Attempt aborted");
      throw l.code = "ATTEMPT_ABORTED", l;
    }
    const a = async (l) => {
      if (n.handleError && await n.handleError(l, r, n), r.aborted || r.attemptsRemaining === 0)
        throw l;
      r.attemptNum++;
      const c = i(r, n);
      return c && await Yb(c), s();
    };
    return r.attemptsRemaining > 0 && r.attemptsRemaining--, n.timeout ? new Promise((l, c) => {
      const u = setTimeout(() => {
        if (n.handleTimeout)
          try {
            l(n.handleTimeout(r, n));
          } catch (d) {
            c(d);
          }
        else {
          const d = new Error(`Retry timeout (attemptNum: ${r.attemptNum}, timeout: ${n.timeout})`);
          d.code = "ATTEMPT_TIMEOUT", c(d);
        }
      }, n.timeout);
      t(r, n).then((d) => {
        clearTimeout(u), l(d);
      }).catch((d) => {
        clearTimeout(u), a(d).then(l).catch(c);
      });
    }) : t(r, n).catch(a);
  }
  const o = n.calculateDelay ? n.calculateDelay(r, n) : n.initialDelay;
  if (o && await Yb(o), r.attemptNum < 1 && n.initialJitter) {
    const a = i(r, n);
    a && await Yb(a);
  }
  return s();
}
const hc = () => /* @__PURE__ */ new Map(), ZB = (t, e, n) => {
  let r = t.get(e);
  return r === void 0 && t.set(e, r = n()), r;
}, QB = () => /* @__PURE__ */ new Set(), Hce = Array.from, Uce = String.fromCharCode, Vce = (t) => t.toLowerCase(), Wce = /^\s*/g, Gce = (t) => t.replace(Wce, ""), jce = /([A-Z])/g, DM = (t, e) => Gce(t.replace(jce, (n) => `${e}${Vce(n)}`)), qce = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = /** @type {number} */
    e.codePointAt(i);
  return r;
}, Ef = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), Kce = (t) => Ef.encode(t), Yce = Ef ? Kce : qce;
let yd = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
yd && yd.decode(new Uint8Array()).length === 1 && (yd = null);
const IM = (t) => t === void 0 ? null : t;
class Xce {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let eF = new Xce(), FS = !0;
try {
  typeof localStorage < "u" && localStorage && (eF = localStorage, FS = !1);
} catch {
}
const tF = eF, Jce = (t) => FS || addEventListener(
  "storage",
  /** @type {any} */
  t
), Zce = (t) => FS || removeEventListener(
  "storage",
  /** @type {any} */
  t
), Qce = Object.keys, eue = (t, e) => {
  const n = [];
  for (const r in t)
    n.push(e(t[r], r));
  return n;
}, PM = (t) => Qce(t).length, tue = (t, e) => Object.prototype.hasOwnProperty.call(t, e), nue = (t, e) => t === e, wd = (t, e) => {
  if (t == null || e == null)
    return nue(t, e);
  if (t.constructor !== e.constructor)
    return !1;
  if (t === e)
    return !0;
  switch (t.constructor) {
    case ArrayBuffer:
      t = new Uint8Array(t), e = new Uint8Array(e);
    case Uint8Array: {
      if (t.byteLength !== e.byteLength)
        return !1;
      for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n])
          return !1;
      break;
    }
    case Set: {
      if (t.size !== e.size)
        return !1;
      for (const n of t)
        if (!e.has(n))
          return !1;
      break;
    }
    case Map: {
      if (t.size !== e.size)
        return !1;
      for (const n of t.keys())
        if (!e.has(n) || !wd(t.get(n), e.get(n)))
          return !1;
      break;
    }
    case Object:
      if (PM(t) !== PM(e))
        return !1;
      for (const n in t)
        if (!tue(t, n) || !wd(t[n], e[n]))
          return !1;
      break;
    case Array:
      if (t.length !== e.length)
        return !1;
      for (let n = 0; n < t.length; n++)
        if (!wd(t[n], e[n]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, rue = (t, e) => e.includes(t), Xc = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", nF = typeof window < "u" && typeof document < "u" && !Xc;
let Ui;
const iue = () => {
  if (Ui === void 0)
    if (Xc) {
      Ui = hc();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        r[0] === "-" ? (e !== null && Ui.set(e, ""), e = r) : e !== null && (Ui.set(e, r), e = null);
      }
      e !== null && Ui.set(e, "");
    } else
      typeof location == "object" ? (Ui = hc(), (location.search || "?").slice(1).split("&").forEach((t) => {
        if (t.length !== 0) {
          const [e, n] = t.split("=");
          Ui.set(`--${DM(e, "-")}`, n), Ui.set(`-${DM(e, "-")}`, n);
        }
      })) : Ui = hc();
  return Ui;
}, Ew = (t) => iue().has(t), Sw = (t) => IM(Xc ? process.env[t.toUpperCase()] : tF.getItem(t)), sue = (t) => Ew("--" + t) || Sw(t) !== null;
sue("production");
const LM = Xc && rue(process.env.FORCE_COLOR, ["true", "1", "2"]);
!Ew("no-colors") && (!Xc || process.stdout.isTTY || LM) && (!Xc || Ew("color") || LM || Sw("COLORTERM") !== null || (Sw("TERM") || "").includes("color"));
const rF = Math.floor, oue = (t, e) => t < e ? t : e, aue = (t, e) => t > e ? t : e, lue = 64, Pm = 128, cue = 63, _d = 127, iF = Number.MAX_SAFE_INTEGER;
class uue {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const zS = () => new uue(), sF = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, HS = (t) => {
  const e = new Uint8Array(sF(t));
  let n = 0;
  for (let r = 0; r < t.bufs.length; r++) {
    const i = t.bufs[r];
    e.set(i, n), n += i.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, Lm = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, Sn = (t, e) => {
  for (; e > _d; )
    Lm(t, Pm | _d & e), e = rF(e / 128);
  Lm(t, _d & e);
}, xw = new Uint8Array(3e4), due = xw.length / 3, fue = (t, e) => {
  if (e.length < due) {
    const n = Ef.encodeInto(e, xw).written || 0;
    Sn(t, n);
    for (let r = 0; r < n; r++)
      Lm(t, xw[r]);
  } else
    hu(t, Yce(e));
}, hue = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  Sn(t, r);
  for (let i = 0; i < r; i++)
    Lm(
      t,
      /** @type {number} */
      n.codePointAt(i)
    );
}, Ii = Ef && /** @type {any} */
Ef.encodeInto ? fue : hue, pue = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, i = oue(n - r, e.length), s = e.length - i;
  t.cbuf.set(e.subarray(0, i), r), t.cpos += i, s > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(aue(n * 2, s)), t.cbuf.set(e.subarray(i)), t.cpos = s);
}, hu = (t, e) => {
  Sn(t, e.byteLength), pue(t, e);
}, oF = (t) => new Error(t), aF = oF("Unexpected end of array"), lF = oF("Integer out of Range");
class gue {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
}
const cF = (t) => new gue(t), mue = (t, e) => {
  const n = new Uint8Array(t.arr.buffer, t.pos + t.arr.byteOffset, e);
  return t.pos += e, n;
}, S0 = (t) => mue(t, $a(t)), $M = (t) => t.arr[t.pos++], $a = (t) => {
  let e = 0, n = 1;
  const r = t.arr.length;
  for (; t.pos < r; ) {
    const i = t.arr[t.pos++];
    if (e = e + (i & _d) * n, n *= 128, i < Pm)
      return e;
    if (e > iF)
      throw lF;
  }
  throw aF;
}, vue = (t) => {
  let e = t.arr[t.pos++], n = e & cue, r = 64;
  const i = (e & lue) > 0 ? -1 : 1;
  if (!(e & Pm))
    return i * n;
  const s = t.arr.length;
  for (; t.pos < s; ) {
    if (e = t.arr[t.pos++], n = n + (e & _d) * r, r *= 128, e < Pm)
      return i * n;
    if (n > iF)
      throw lF;
  }
  throw aF;
}, bue = (t) => {
  let e = $a(t);
  if (e === 0)
    return "";
  {
    let n = String.fromCodePoint($M(t));
    if (--e < 100)
      for (; e--; )
        n += String.fromCodePoint($M(t));
    else
      for (; e > 0; ) {
        const r = e < 1e4 ? e : 1e4, i = t.arr.subarray(t.pos, t.pos + r);
        t.pos += r, n += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), e -= r;
      }
    return decodeURIComponent(escape(n));
  }
}, yue = (t) => (
  /** @type any */
  yd.decode(S0(t))
), x0 = yd ? yue : bue, wue = (t) => {
  const e = t.pos, n = x0(t);
  return t.pos = e, n;
}, _ue = (t) => new Uint8Array(t), Eue = (t, e, n) => new Uint8Array(t, e, n), Sue = (t) => new Uint8Array(t), xue = (t) => {
  let e = "";
  for (let n = 0; n < t.byteLength; n++)
    e += Uce(t[n]);
  return btoa(e);
}, kue = (t) => Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("base64"), Cue = (t) => {
  const e = atob(t), n = _ue(e.length);
  for (let r = 0; r < e.length; r++)
    n[r] = e.charCodeAt(r);
  return n;
}, Tue = (t) => {
  const e = Buffer.from(t, "base64");
  return Eue(e.buffer, e.byteOffset, e.byteLength);
}, Oue = nF ? xue : kue, Mue = nF ? Cue : Tue, uF = /* @__PURE__ */ new Map();
class Aue {
  /**
   * @param {string} room
   */
  constructor(e) {
    this.room = e, this.onmessage = null, this._onChange = (n) => n.key === e && this.onmessage !== null && this.onmessage({ data: Mue(n.newValue || "") }), Jce(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(e) {
    tF.setItem(this.room, Oue(Sue(e)));
  }
  close() {
    Zce(this._onChange);
  }
}
const Nue = typeof BroadcastChannel > "u" ? Aue : BroadcastChannel, US = (t) => ZB(uF, t, () => {
  const e = QB(), n = new Nue(t);
  return n.onmessage = (r) => e.forEach((i) => i(r.data, "broadcastchannel")), {
    bc: n,
    subs: e
  };
}), Rue = (t, e) => (US(t).subs.add(e), e), Due = (t, e) => {
  const n = US(t), r = n.subs.delete(e);
  return r && n.subs.size === 0 && (n.bc.close(), uF.delete(t)), r;
}, Iue = (t, e, n = null) => {
  const r = US(t);
  r.bc.postMessage(e), r.subs.forEach((i) => i(e, n));
}, Pue = () => {
  let t = !0;
  return (e, n) => {
    if (t) {
      t = !1;
      try {
        e();
      } finally {
        t = !0;
      }
    } else
      n !== void 0 && n();
  };
}, Jc = Date.now;
class Lue {
  constructor() {
    this._observers = hc();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(e, n) {
    ZB(this._observers, e, QB).add(n);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(e, n) {
    const r = (...i) => {
      this.off(e, r), n(...i);
    };
    this.on(e, r);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(e, n) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return Hce((this._observers.get(e) || hc()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = hc();
  }
}
const Xb = 3e4;
class $ue extends Lue {
  /**
   * @param {Y.Doc} doc
   */
  constructor(e) {
    super(), this.doc = e, this.clientID = e.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = /** @type {any} */
    setInterval(() => {
      const n = Jc();
      this.getLocalState() !== null && Xb / 2 <= n - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const r = [];
      this.meta.forEach((i, s) => {
        s !== this.clientID && Xb <= n - i.lastUpdated && this.states.has(s) && r.push(s);
      }), r.length > 0 && Fp(this, r, "timeout");
    }, rF(Xb / 10)), e.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(e) {
    const n = this.clientID, r = this.meta.get(n), i = r === void 0 ? 0 : r.clock + 1, s = this.states.get(n);
    e === null ? this.states.delete(n) : this.states.set(n, e), this.meta.set(n, {
      clock: i,
      lastUpdated: Jc()
    });
    const o = [], a = [], l = [], c = [];
    e === null ? c.push(n) : s == null ? e != null && o.push(n) : (a.push(n), wd(s, e) || l.push(n)), (o.length > 0 || l.length > 0 || c.length > 0) && this.emit("change", [{ added: o, updated: l, removed: c }, "local"]), this.emit("update", [{ added: o, updated: a, removed: c }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(e, n) {
    const r = this.getLocalState();
    r !== null && this.setLocalState({
      ...r,
      [e]: n
    });
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
}
const Fp = (t, e, n) => {
  const r = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (t.states.has(s)) {
      if (t.states.delete(s), s === t.clientID) {
        const o = (
          /** @type {MetaClientState} */
          t.meta.get(s)
        );
        t.meta.set(s, {
          clock: o.clock + 1,
          lastUpdated: Jc()
        });
      }
      r.push(s);
    }
  }
  r.length > 0 && (t.emit("change", [{ added: [], updated: [], removed: r }, n]), t.emit("update", [{ added: [], updated: [], removed: r }, n]));
}, kw = (t, e, n = t.states) => {
  const r = e.length, i = zS();
  Sn(i, r);
  for (let s = 0; s < r; s++) {
    const o = e[s], a = n.get(o) || null, l = (
      /** @type {MetaClientState} */
      t.meta.get(o).clock
    );
    Sn(i, o), Sn(i, l), Ii(i, JSON.stringify(a));
  }
  return HS(i);
}, Bue = (t, e, n) => {
  const r = cF(e), i = Jc(), s = [], o = [], a = [], l = [], c = $a(r);
  for (let u = 0; u < c; u++) {
    const d = $a(r);
    let f = $a(r);
    const h = JSON.parse(x0(r)), p = t.meta.get(d), g = t.states.get(d), m = p === void 0 ? 0 : p.clock;
    (m < f || m === f && h === null && t.states.has(d)) && (h === null ? d === t.clientID && t.getLocalState() != null ? f++ : t.states.delete(d) : t.states.set(d, h), t.meta.set(d, {
      clock: f,
      lastUpdated: i
    }), p === void 0 && h !== null ? s.push(d) : p !== void 0 && h === null ? l.push(d) : h !== null && (wd(h, g) || a.push(d), o.push(d)));
  }
  (s.length > 0 || a.length > 0 || l.length > 0) && t.emit("change", [{
    added: s,
    updated: a,
    removed: l
  }, n]), (s.length > 0 || o.length > 0 || l.length > 0) && t.emit("update", [{
    added: s,
    updated: o,
    removed: l
  }, n]);
};
class dF {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return r && (n ? this.callbacks[e] = r.filter((i) => i !== n) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
const Fue = (t) => eue(t, (e, n) => `${encodeURIComponent(n)}=${encodeURIComponent(e)}`).join("&");
var _n;
(function(t) {
  t[t.Sync = 0] = "Sync", t[t.Awareness = 1] = "Awareness", t[t.Auth = 2] = "Auth", t[t.QueryAwareness = 3] = "QueryAwareness", t[t.Stateless = 5] = "Stateless", t[t.CLOSE = 7] = "CLOSE", t[t.SyncStatus = 8] = "SyncStatus";
})(_n || (_n = {}));
var bn;
(function(t) {
  t.Connecting = "connecting", t.Connected = "connected", t.Disconnected = "disconnected";
})(bn || (bn = {}));
class zp {
  constructor(e) {
    this.data = e, this.encoder = zS(), this.decoder = cF(new Uint8Array(this.data));
  }
  peekVarString() {
    return wue(this.decoder);
  }
  readVarUint() {
    return $a(this.decoder);
  }
  readVarString() {
    return x0(this.decoder);
  }
  readVarUint8Array() {
    return S0(this.decoder);
  }
  writeVarUint(e) {
    return Sn(this.encoder, e);
  }
  writeVarString(e) {
    return Ii(this.encoder, e);
  }
  writeVarUint8Array(e) {
    return hu(this.encoder, e);
  }
  length() {
    return sF(this.encoder);
  }
}
class zue extends dF {
  constructor(e) {
    super(), this.messageQueue = [], this.configuration = {
      url: "",
      // @ts-ignore
      document: void 0,
      WebSocketPolyfill: void 0,
      parameters: {},
      connect: !0,
      broadcast: !0,
      forceSyncInterval: !1,
      // TODO: this should depend on awareness.outdatedTime
      messageReconnectTimeout: 3e4,
      // 1 second
      delay: 1e3,
      // instant
      initialDelay: 0,
      // double the delay each time
      factor: 2,
      // unlimited retries
      maxAttempts: 0,
      // wait at least 1 second
      minDelay: 1e3,
      // at least every 30 seconds
      maxDelay: 3e4,
      // randomize
      jitter: !0,
      // retry forever
      timeout: 0,
      onOpen: () => null,
      onConnect: () => null,
      onMessage: () => null,
      onOutgoingMessage: () => null,
      onStatus: () => null,
      onDisconnect: () => null,
      onClose: () => null,
      onDestroy: () => null,
      onAwarenessUpdate: () => null,
      onAwarenessChange: () => null,
      quiet: !1,
      providerMap: /* @__PURE__ */ new Map()
    }, this.webSocket = null, this.webSocketHandlers = {}, this.shouldConnect = !0, this.status = bn.Disconnected, this.lastMessageReceived = 0, this.identifier = 0, this.intervals = {
      forceSync: null,
      connectionChecker: null
    }, this.connectionAttempt = null, this.receivedOnOpenPayload = void 0, this.receivedOnStatusPayload = void 0, this.closeTries = 0, this.setConfiguration(e), this.configuration.WebSocketPolyfill = e.WebSocketPolyfill ? e.WebSocketPolyfill : WebSocket, this.on("open", this.configuration.onOpen), this.on("open", this.onOpen.bind(this)), this.on("connect", this.configuration.onConnect), this.on("message", this.configuration.onMessage), this.on("outgoingMessage", this.configuration.onOutgoingMessage), this.on("status", this.configuration.onStatus), this.on("status", this.onStatus.bind(this)), this.on("disconnect", this.configuration.onDisconnect), this.on("close", this.configuration.onClose), this.on("destroy", this.configuration.onDestroy), this.on("awarenessUpdate", this.configuration.onAwarenessUpdate), this.on("awarenessChange", this.configuration.onAwarenessChange), this.on("close", this.onClose.bind(this)), this.on("message", this.onMessage.bind(this)), this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10), typeof e.connect < "u" && (this.shouldConnect = e.connect), this.shouldConnect && this.connect();
  }
  async onOpen(e) {
    this.receivedOnOpenPayload = e;
  }
  async onStatus(e) {
    this.receivedOnStatusPayload = e;
  }
  attach(e) {
    let n;
    return this.configuration.providerMap.set(e.configuration.name, e), this.status === bn.Disconnected && this.shouldConnect && (n = this.connect()), this.receivedOnOpenPayload && e.onOpen(this.receivedOnOpenPayload), this.receivedOnStatusPayload && e.onStatus(this.receivedOnStatusPayload), n;
  }
  detach(e) {
    this.configuration.providerMap.delete(e.configuration.name);
  }
  setConfiguration(e = {}) {
    this.configuration = { ...this.configuration, ...e };
  }
  async connect() {
    if (this.status === bn.Connected)
      return;
    this.cancelWebsocketRetry && (this.cancelWebsocketRetry(), this.cancelWebsocketRetry = void 0), this.receivedOnOpenPayload = void 0, this.receivedOnStatusPayload = void 0, this.shouldConnect = !0;
    const e = () => {
      let i = !1;
      return {
        retryPromise: zce(this.createWebSocketConnection.bind(this), {
          delay: this.configuration.delay,
          initialDelay: this.configuration.initialDelay,
          factor: this.configuration.factor,
          maxAttempts: this.configuration.maxAttempts,
          minDelay: this.configuration.minDelay,
          maxDelay: this.configuration.maxDelay,
          jitter: this.configuration.jitter,
          timeout: this.configuration.timeout,
          beforeAttempt: (o) => {
            (!this.shouldConnect || i) && o.abort();
          }
        }).catch((o) => {
          if (o && o.code !== "ATTEMPT_ABORTED")
            throw o;
        }),
        cancelFunc: () => {
          i = !0;
        }
      };
    }, { retryPromise: n, cancelFunc: r } = e();
    return this.cancelWebsocketRetry = r, n;
  }
  attachWebSocketListeners(e, n) {
    const { identifier: r } = e, i = (c) => this.emit("message", c), s = (c) => this.emit("close", { event: c }), o = (c) => this.emit("open", c), a = (c) => {
      n(c);
    };
    this.webSocketHandlers[r] = {
      message: i,
      close: s,
      open: o,
      error: a
    };
    const l = this.webSocketHandlers[e.identifier];
    Object.keys(l).forEach((c) => {
      e.addEventListener(c, l[c]);
    });
  }
  cleanupWebSocket() {
    if (!this.webSocket)
      return;
    const { identifier: e } = this.webSocket, n = this.webSocketHandlers[e];
    Object.keys(n).forEach((r) => {
      var i;
      (i = this.webSocket) === null || i === void 0 || i.removeEventListener(r, n[r]), delete this.webSocketHandlers[e];
    }), this.webSocket.close(), this.webSocket = null;
  }
  createWebSocketConnection() {
    return new Promise((e, n) => {
      this.webSocket && (this.messageQueue = [], this.cleanupWebSocket()), this.lastMessageReceived = 0, this.identifier += 1;
      const r = new this.configuration.WebSocketPolyfill(this.url);
      r.binaryType = "arraybuffer", r.identifier = this.identifier, this.attachWebSocketListeners(r, n), this.webSocket = r, this.status = bn.Connecting, this.emit("status", { status: bn.Connecting }), this.connectionAttempt = {
        resolve: e,
        reject: n
      };
    });
  }
  onMessage(e) {
    var n;
    this.resolveConnectionAttempt(), this.lastMessageReceived = Jc();
    const i = new zp(e.data).peekVarString();
    (n = this.configuration.providerMap.get(i)) === null || n === void 0 || n.onMessage(e);
  }
  resolveConnectionAttempt() {
    this.connectionAttempt && (this.connectionAttempt.resolve(), this.connectionAttempt = null, this.status = bn.Connected, this.emit("status", { status: bn.Connected }), this.emit("connect"), this.messageQueue.forEach((e) => this.send(e)), this.messageQueue = []);
  }
  stopConnectionAttempt() {
    this.connectionAttempt = null;
  }
  rejectConnectionAttempt() {
    var e;
    (e = this.connectionAttempt) === null || e === void 0 || e.reject(), this.connectionAttempt = null;
  }
  checkConnection() {
    var e;
    this.status === bn.Connected && this.lastMessageReceived && (this.configuration.messageReconnectTimeout >= Jc() - this.lastMessageReceived || (this.closeTries += 1, this.closeTries > 2 ? (this.onClose({
      event: {
        code: 4408,
        reason: "forced"
      }
    }), this.closeTries = 0) : ((e = this.webSocket) === null || e === void 0 || e.close(), this.messageQueue = [])));
  }
  // Ensure that the URL always ends with /
  get serverUrl() {
    for (; this.configuration.url[this.configuration.url.length - 1] === "/"; )
      return this.configuration.url.slice(0, this.configuration.url.length - 1);
    return this.configuration.url;
  }
  get url() {
    const e = Fue(this.configuration.parameters);
    return `${this.serverUrl}${e.length === 0 ? "" : `?${e}`}`;
  }
  disconnect() {
    if (this.shouldConnect = !1, this.webSocket !== null)
      try {
        this.webSocket.close(), this.messageQueue = [];
      } catch {
      }
  }
  send(e) {
    var n;
    ((n = this.webSocket) === null || n === void 0 ? void 0 : n.readyState) === cw.Open ? this.webSocket.send(e) : this.messageQueue.push(e);
  }
  onClose({ event: e }) {
    if (this.closeTries = 0, this.cleanupWebSocket(), this.status === bn.Connected && (this.status = bn.Disconnected, this.emit("status", { status: bn.Disconnected }), this.emit("disconnect", { event: e })), e.code === iM.code && (e.reason === iM.reason ? console.warn("[HocuspocusProvider] An authentication token is required, but you didn’t send one. Try adding a `token` to your HocuspocusProvider configuration. Won’t try again.") : console.warn(`[HocuspocusProvider] Connection closed with status Unauthorized: ${e.reason}`), this.shouldConnect = !1), e.code === tae.code && !this.configuration.quiet) {
      console.warn("[HocuspocusProvider] The provided authentication token isn’t allowed to connect to this server. Will try again.");
      return;
    }
    e.code === eae.code && (console.warn(`[HocuspocusProvider] Connection closed with status MessageTooBig: ${e.reason}`), this.shouldConnect = !1), this.connectionAttempt ? this.rejectConnectionAttempt() : this.shouldConnect && this.connect(), !this.shouldConnect && this.status !== bn.Disconnected && (this.status = bn.Disconnected, this.emit("status", { status: bn.Disconnected }), this.emit("disconnect", { event: e }));
  }
  destroy() {
    this.emit("destroy"), this.intervals.forceSync && clearInterval(this.intervals.forceSync), clearInterval(this.intervals.connectionChecker), this.stopConnectionAttempt(), this.disconnect(), this.removeAllListeners(), this.cleanupWebSocket();
  }
}
const fF = 0, VS = 1, hF = 2, Hue = (t, e) => {
  Sn(t, fF);
  const n = Dle(e);
  hu(t, n);
}, pF = (t, e, n) => {
  Sn(t, VS), hu(t, Mle(e, n));
}, Uue = (t, e, n) => pF(e, n, S0(t)), gF = (t, e, n) => {
  try {
    Cle(e, S0(t), n);
  } catch (r) {
    console.error("Caught error while handling a Yjs update", r);
  }
}, Vue = (t, e) => {
  Sn(t, hF), hu(t, e);
}, Wue = gF, Gue = (t, e, n, r) => {
  const i = $a(t);
  switch (i) {
    case fF:
      Uue(t, e, n);
      break;
    case VS:
      gF(t, n, r);
      break;
    case hF:
      Wue(t, n, r);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return i;
};
class hs {
  constructor() {
    this.encoder = zS();
  }
  get(e) {
    return e.encoder;
  }
  toUint8Array() {
    return HS(this.encoder);
  }
}
class BM {
  constructor(e) {
    this.broadcasted = !1, this.message = e;
  }
  setBroadcasted(e) {
    return this.broadcasted = e, this;
  }
  apply(e, n) {
    const { message: r } = this, i = r.readVarUint(), s = r.length();
    switch (i) {
      case _n.Sync:
        this.applySyncMessage(e, n);
        break;
      case _n.Awareness:
        this.applyAwarenessMessage(e);
        break;
      case _n.Auth:
        this.applyAuthMessage(e);
        break;
      case _n.QueryAwareness:
        this.applyQueryAwarenessMessage(e);
        break;
      case _n.Stateless:
        e.receiveStateless(x0(r.decoder));
        break;
      case _n.SyncStatus:
        this.applySyncStatusMessage(e, vue(r.decoder) === 1);
        break;
      default:
        throw new Error(`Can’t apply message of unknown type: ${i}`);
    }
    r.length() > s + 1 && (this.broadcasted ? e.broadcast(hs, { encoder: r.encoder }) : e.send(hs, { encoder: r.encoder }));
  }
  applySyncMessage(e, n) {
    const { message: r } = this;
    r.writeVarUint(_n.Sync);
    const i = Gue(r.decoder, r.encoder, e.document, e);
    n && i === VS && (e.synced = !0);
  }
  applySyncStatusMessage(e, n) {
    n && e.decrementUnsyncedChanges();
  }
  applyAwarenessMessage(e) {
    if (!e.awareness)
      return;
    const { message: n } = this;
    Bue(e.awareness, n.readVarUint8Array(), e);
  }
  applyAuthMessage(e) {
    const { message: n } = this;
    Qoe(n.decoder, e.permissionDeniedHandler.bind(e), e.authenticatedHandler.bind(e));
  }
  applyQueryAwarenessMessage(e) {
    if (!e.awareness)
      return;
    const { message: n } = this;
    n.writeVarUint(_n.Awareness), n.writeVarUint8Array(kw(e.awareness, Array.from(e.awareness.getStates().keys())));
  }
}
class FM {
  constructor(e, n = {}) {
    this.message = new e(), this.encoder = this.message.get(n);
  }
  create() {
    return HS(this.encoder);
  }
  send(e) {
    e == null || e.send(this.create());
  }
  broadcast(e) {
    Iue(e, this.create());
  }
}
class jue extends hs {
  constructor() {
    super(...arguments), this.type = _n.Auth, this.description = "Authentication";
  }
  get(e) {
    if (typeof e.token > "u")
      throw new Error("The authentication message requires `token` as an argument.");
    return Ii(this.encoder, e.documentName), Sn(this.encoder, this.type), Zoe(this.encoder, e.token), this.encoder;
  }
}
class sp extends hs {
  constructor() {
    super(...arguments), this.type = _n.Awareness, this.description = "Awareness states update";
  }
  get(e) {
    if (typeof e.awareness > "u")
      throw new Error("The awareness message requires awareness as an argument");
    if (typeof e.clients > "u")
      throw new Error("The awareness message requires clients as an argument");
    Ii(this.encoder, e.documentName), Sn(this.encoder, this.type);
    let n;
    return e.states === void 0 ? n = kw(e.awareness, e.clients) : n = kw(e.awareness, e.clients, e.states), hu(this.encoder, n), this.encoder;
  }
}
class que extends hs {
  constructor() {
    super(...arguments), this.type = _n.CLOSE, this.description = "Ask the server to close the connection";
  }
  get(e) {
    return Ii(this.encoder, e.documentName), Sn(this.encoder, this.type), this.encoder;
  }
}
class Kue extends hs {
  constructor() {
    super(...arguments), this.type = _n.QueryAwareness, this.description = "Queries awareness states";
  }
  get(e) {
    return Ii(this.encoder, e.documentName), Sn(this.encoder, this.type), this.encoder;
  }
}
class Yue extends hs {
  constructor() {
    super(...arguments), this.type = _n.Stateless, this.description = "A stateless message";
  }
  get(e) {
    var n;
    return Ii(this.encoder, e.documentName), Sn(this.encoder, this.type), Ii(this.encoder, (n = e.payload) !== null && n !== void 0 ? n : ""), this.encoder;
  }
}
class Jb extends hs {
  constructor() {
    super(...arguments), this.type = _n.Sync, this.description = "First sync step";
  }
  get(e) {
    if (typeof e.document > "u")
      throw new Error("The sync step one message requires document as an argument");
    return Ii(this.encoder, e.documentName), Sn(this.encoder, this.type), Hue(this.encoder, e.document), this.encoder;
  }
}
class Xue extends hs {
  constructor() {
    super(...arguments), this.type = _n.Sync, this.description = "Second sync step";
  }
  get(e) {
    if (typeof e.document > "u")
      throw new Error("The sync step two message requires document as an argument");
    return Ii(this.encoder, e.documentName), Sn(this.encoder, this.type), pF(this.encoder, e.document), this.encoder;
  }
}
class Jue extends hs {
  constructor() {
    super(...arguments), this.type = _n.Sync, this.description = "A document update";
  }
  get(e) {
    return Ii(this.encoder, e.documentName), Sn(this.encoder, this.type), Vue(this.encoder, e.update), this.encoder;
  }
}
class Zue extends Error {
  constructor() {
    super(...arguments), this.code = 1001;
  }
}
class Que extends dF {
  constructor(e) {
    var n, r, i;
    super(), this.configuration = {
      name: "",
      // @ts-ignore
      document: void 0,
      // @ts-ignore
      awareness: void 0,
      token: null,
      parameters: {},
      broadcast: !0,
      forceSyncInterval: !1,
      onAuthenticated: () => null,
      onAuthenticationFailed: () => null,
      onOpen: () => null,
      onConnect: () => null,
      onMessage: () => null,
      onOutgoingMessage: () => null,
      onStatus: () => null,
      onSynced: () => null,
      onDisconnect: () => null,
      onClose: () => null,
      onDestroy: () => null,
      onAwarenessUpdate: () => null,
      onAwarenessChange: () => null,
      onStateless: () => null,
      quiet: !1,
      connect: !0,
      preserveConnection: !0
    }, this.subscribedToBroadcastChannel = !1, this.isSynced = !1, this.unsyncedChanges = 0, this.status = bn.Disconnected, this.isAuthenticated = !1, this.authorizedScope = void 0, this.mux = Pue(), this.intervals = {
      forceSync: null
    }, this.isConnected = !0, this.boundBroadcastChannelSubscriber = this.broadcastChannelSubscriber.bind(this), this.boundPageUnload = this.pageUnload.bind(this), this.boundOnOpen = this.onOpen.bind(this), this.boundOnClose = this.onClose.bind(this), this.boundOnStatus = this.onStatus.bind(this), this.forwardConnect = (s) => this.emit("connect", s), this.forwardOpen = (s) => this.emit("open", s), this.forwardClose = (s) => this.emit("close", s), this.forwardDisconnect = (s) => this.emit("disconnect", s), this.forwardDestroy = (s) => this.emit("destroy", s), this.setConfiguration(e), this.configuration.document = e.document ? e.document : new du(), this.configuration.awareness = e.awareness !== void 0 ? e.awareness : new $ue(this.document), this.on("open", this.configuration.onOpen), this.on("message", this.configuration.onMessage), this.on("outgoingMessage", this.configuration.onOutgoingMessage), this.on("synced", this.configuration.onSynced), this.on("destroy", this.configuration.onDestroy), this.on("awarenessUpdate", this.configuration.onAwarenessUpdate), this.on("awarenessChange", this.configuration.onAwarenessChange), this.on("stateless", this.configuration.onStateless), this.on("authenticated", this.configuration.onAuthenticated), this.on("authenticationFailed", this.configuration.onAuthenticationFailed), this.configuration.websocketProvider.on("connect", this.configuration.onConnect), this.configuration.websocketProvider.on("connect", this.forwardConnect), this.configuration.websocketProvider.on("open", this.boundOnOpen), this.configuration.websocketProvider.on("open", this.forwardOpen), this.configuration.websocketProvider.on("close", this.boundOnClose), this.configuration.websocketProvider.on("close", this.configuration.onClose), this.configuration.websocketProvider.on("close", this.forwardClose), this.configuration.websocketProvider.on("status", this.boundOnStatus), this.configuration.websocketProvider.on("disconnect", this.configuration.onDisconnect), this.configuration.websocketProvider.on("disconnect", this.forwardDisconnect), this.configuration.websocketProvider.on("destroy", this.configuration.onDestroy), this.configuration.websocketProvider.on("destroy", this.forwardDestroy), (n = this.awareness) === null || n === void 0 || n.on("update", () => {
      this.emit("awarenessUpdate", { states: sM(this.awareness.getStates()) });
    }), (r = this.awareness) === null || r === void 0 || r.on("change", () => {
      this.emit("awarenessChange", { states: sM(this.awareness.getStates()) });
    }), this.document.on("update", this.documentUpdateHandler.bind(this)), (i = this.awareness) === null || i === void 0 || i.on("update", this.awarenessUpdateHandler.bind(this)), this.registerEventListeners(), this.configuration.forceSyncInterval && (this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval)), this.configuration.websocketProvider.attach(this);
  }
  onStatus({ status: e }) {
    this.status = e, this.configuration.onStatus({ status: e }), this.emit("status", { status: e });
  }
  setConfiguration(e = {}) {
    if (!e.websocketProvider && e.url) {
      const n = e;
      this.configuration.websocketProvider = new zue({
        url: n.url,
        connect: n.connect,
        parameters: n.parameters
      });
    }
    this.configuration = { ...this.configuration, ...e };
  }
  get document() {
    return this.configuration.document;
  }
  get awareness() {
    return this.configuration.awareness;
  }
  get hasUnsyncedChanges() {
    return this.unsyncedChanges > 0;
  }
  incrementUnsyncedChanges() {
    this.unsyncedChanges += 1, this.emit("unsyncedChanges", this.unsyncedChanges);
  }
  decrementUnsyncedChanges() {
    this.unsyncedChanges -= 1, this.unsyncedChanges === 0 && (this.synced = !0), this.emit("unsyncedChanges", this.unsyncedChanges);
  }
  forceSync() {
    this.send(Jb, { document: this.document, documentName: this.configuration.name });
  }
  pageUnload() {
    this.awareness && Fp(this.awareness, [this.document.clientID], "window unload");
  }
  registerEventListeners() {
    typeof window > "u" || window.addEventListener("unload", this.boundPageUnload);
  }
  sendStateless(e) {
    this.send(Yue, { documentName: this.configuration.name, payload: e });
  }
  documentUpdateHandler(e, n) {
    n !== this && (this.incrementUnsyncedChanges(), this.send(Jue, { update: e, documentName: this.configuration.name }, !0));
  }
  awarenessUpdateHandler({ added: e, updated: n, removed: r }, i) {
    const s = e.concat(n).concat(r);
    this.send(sp, {
      awareness: this.awareness,
      clients: s,
      documentName: this.configuration.name
    }, !0);
  }
  /**
   * Indicates whether a first handshake with the server has been established
   *
   * Note: this does not mean all updates from the client have been persisted to the backend. For this,
   * use `hasUnsyncedChanges`.
   */
  get synced() {
    return this.isSynced;
  }
  set synced(e) {
    this.isSynced !== e && (this.isSynced = e, this.emit("synced", { state: e }), this.emit("sync", { state: e }));
  }
  receiveStateless(e) {
    this.emit("stateless", { payload: e });
  }
  get isAuthenticationRequired() {
    return !!this.configuration.token && !this.isAuthenticated;
  }
  // not needed, but provides backward compatibility with e.g. lexicla/yjs
  async connect() {
    return this.configuration.broadcast && this.subscribeToBroadcastChannel(), this.configuration.websocketProvider.shouldConnect = !0, this.configuration.websocketProvider.attach(this);
  }
  disconnect() {
    this.disconnectBroadcastChannel(), this.configuration.websocketProvider.detach(this), this.isConnected = !1, this.configuration.preserveConnection || this.configuration.websocketProvider.disconnect();
  }
  async onOpen(e) {
    this.isAuthenticated = !1, this.isConnected = !0, this.emit("open", { event: e });
    let n;
    try {
      n = await this.getToken();
    } catch (r) {
      this.permissionDeniedHandler(`Failed to get token: ${r}`);
      return;
    }
    this.isAuthenticationRequired && this.send(jue, {
      token: n,
      documentName: this.configuration.name
    }), this.startSync();
  }
  async getToken() {
    return typeof this.configuration.token == "function" ? await this.configuration.token() : this.configuration.token;
  }
  startSync() {
    this.incrementUnsyncedChanges(), this.send(Jb, { document: this.document, documentName: this.configuration.name }), this.awareness && this.awareness.getLocalState() !== null && this.send(sp, {
      awareness: this.awareness,
      clients: [this.document.clientID],
      documentName: this.configuration.name
    });
  }
  send(e, n, r = !1) {
    if (!this.isConnected)
      return;
    r && this.mux(() => {
      this.broadcast(e, n);
    });
    const i = new FM(e, n);
    this.emit("outgoingMessage", { message: i.message }), i.send(this.configuration.websocketProvider);
  }
  onMessage(e) {
    const n = new zp(e.data), r = n.readVarString();
    n.writeVarString(r), this.emit("message", { event: e, message: new zp(e.data) }), new BM(n).apply(this, !0);
  }
  onClose(e) {
    this.isAuthenticated = !1, this.synced = !1, this.awareness && Fp(this.awareness, Array.from(this.awareness.getStates().keys()).filter((n) => n !== this.document.clientID), this);
  }
  destroy() {
    this.emit("destroy"), this.intervals.forceSync && clearInterval(this.intervals.forceSync), this.awareness && (Fp(this.awareness, [this.document.clientID], "provider destroy"), this.awareness.off("update", this.awarenessUpdateHandler), this.awareness.destroy()), this.document.off("update", this.documentUpdateHandler), this.removeAllListeners(), this.configuration.websocketProvider.off("connect", this.configuration.onConnect), this.configuration.websocketProvider.off("connect", this.forwardConnect), this.configuration.websocketProvider.off("open", this.boundOnOpen), this.configuration.websocketProvider.off("open", this.forwardOpen), this.configuration.websocketProvider.off("close", this.boundOnClose), this.configuration.websocketProvider.off("close", this.configuration.onClose), this.configuration.websocketProvider.off("close", this.forwardClose), this.configuration.websocketProvider.off("status", this.boundOnStatus), this.configuration.websocketProvider.off("disconnect", this.configuration.onDisconnect), this.configuration.websocketProvider.off("disconnect", this.forwardDisconnect), this.configuration.websocketProvider.off("destroy", this.configuration.onDestroy), this.configuration.websocketProvider.off("destroy", this.forwardDestroy), this.send(que, { documentName: this.configuration.name }), this.disconnect(), !(typeof window > "u") && window.removeEventListener("unload", this.boundPageUnload);
  }
  permissionDeniedHandler(e) {
    this.emit("authenticationFailed", { reason: e }), this.isAuthenticated = !1, this.disconnect(), this.status = bn.Disconnected;
  }
  authenticatedHandler(e) {
    this.isAuthenticated = !0, this.authorizedScope = e, this.emit("authenticated");
  }
  get broadcastChannel() {
    return `${this.configuration.name}`;
  }
  broadcastChannelSubscriber(e) {
    this.mux(() => {
      const n = new zp(e), r = n.readVarString();
      n.writeVarString(r), new BM(n).setBroadcasted(!0).apply(this, !1);
    });
  }
  subscribeToBroadcastChannel() {
    this.subscribedToBroadcastChannel || (Rue(this.broadcastChannel, this.boundBroadcastChannelSubscriber), this.subscribedToBroadcastChannel = !0), this.mux(() => {
      this.broadcast(Jb, { document: this.document, documentName: this.configuration.name }), this.broadcast(Xue, { document: this.document, documentName: this.configuration.name }), this.broadcast(Kue, { document: this.document, documentName: this.configuration.name }), this.awareness && this.broadcast(sp, {
        awareness: this.awareness,
        clients: [this.document.clientID],
        document: this.document,
        documentName: this.configuration.name
      });
    });
  }
  disconnectBroadcastChannel() {
    this.awareness && this.send(sp, {
      awareness: this.awareness,
      clients: [this.document.clientID],
      states: /* @__PURE__ */ new Map(),
      documentName: this.configuration.name
    }, !0), this.subscribedToBroadcastChannel && (Due(this.broadcastChannel, this.boundBroadcastChannelSubscriber), this.subscribedToBroadcastChannel = !1);
  }
  broadcast(e, n) {
    this.configuration.broadcast && this.subscribedToBroadcastChannel && new FM(e, n).broadcast(this.broadcastChannel);
  }
  setAwarenessField(e, n) {
    if (!this.awareness)
      throw new Zue(`Cannot set awareness field "${e}" to ${JSON.stringify(n)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);
    this.awareness.setLocalStateField(e, n);
  }
}
crypto.getRandomValues.bind(crypto);
const ede = () => {
  let t = !0;
  return (e, n) => {
    if (t) {
      t = !1;
      try {
        e();
      } finally {
        t = !0;
      }
    } else
      n !== void 0 && n();
  };
}, tde = /[\uD800-\uDBFF]/, nde = /[\uDC00-\uDFFF]/, rde = (t, e) => {
  let n = 0, r = 0;
  for (; n < t.length && n < e.length && t[n] === e[n]; )
    n++;
  for (n > 0 && tde.test(t[n - 1]) && n--; r + n < t.length && r + n < e.length && t[t.length - r - 1] === e[e.length - r - 1]; )
    r++;
  return r > 0 && nde.test(t[t.length - r]) && r--, {
    index: n,
    remove: t.length - n - r,
    insert: e.slice(n, e.length - r)
  };
}, ide = rde, zt = new ft("y-sync"), Hs = new ft("y-undo"), op = new ft("yjs-cursor"), $m = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && /** @type {number} */
e.sv.get(t.id.client) > t.id.clock && !cu(e.ds, t.id), sde = [{ light: "#ecd44433", dark: "#ecd444" }], ode = (t, e, n) => {
  if (!t.has(n)) {
    if (t.size < e.length) {
      const r = il();
      t.forEach((i) => r.add(i)), e = e.filter((i) => !r.has(i));
    }
    t.set(n, Lae(e));
  }
  return (
    /** @type {ColorDef} */
    t.get(n)
  );
}, ade = (t, {
  colors: e = sde,
  colorMapping: n = /* @__PURE__ */ new Map(),
  permanentUserData: r = null,
  onFirstRender: i = () => {
  }
} = {}) => {
  let s = !1, o;
  const a = new ut({
    props: {
      editable: (l) => {
        const c = zt.getState(l);
        return c.snapshot == null && c.prevSnapshot == null;
      }
    },
    key: zt,
    state: {
      /**
       * @returns {any}
       */
      init: (l, c) => ({
        type: t,
        doc: t.doc,
        binding: null,
        snapshot: null,
        prevSnapshot: null,
        isChangeOrigin: !1,
        isUndoRedoOperation: !1,
        addToHistory: !0,
        colors: e,
        colorMapping: n,
        permanentUserData: r
      }),
      apply: (l, c) => {
        const u = l.getMeta(zt);
        if (u !== void 0) {
          c = Object.assign({}, c);
          for (const d in u)
            c[d] = u[d];
        }
        return c.addToHistory = l.getMeta("addToHistory") !== !1, c.isChangeOrigin = u !== void 0 && !!u.isChangeOrigin, c.isUndoRedoOperation = u !== void 0 && !!u.isChangeOrigin && !!u.isUndoRedoOperation, c.binding !== null && u !== void 0 && (u.snapshot != null || u.prevSnapshot != null) && Om(0, () => {
          c.binding == null || c.binding.isDestroyed || (u.restore == null ? c.binding._renderSnapshot(
            u.snapshot,
            u.prevSnapshot,
            c
          ) : (c.binding._renderSnapshot(
            u.snapshot,
            u.snapshot,
            c
          ), delete c.restore, delete c.snapshot, delete c.prevSnapshot, c.binding.mux(() => {
            c.binding._prosemirrorChanged(
              c.binding.prosemirrorView.state.doc
            );
          })));
        }), c;
      }
    },
    view: (l) => {
      const c = new cde(t, l);
      return o != null && o.destroy(), o = Om(0, () => {
        c._forceRerender(), l.dispatch(l.state.tr.setMeta(zt, { binding: c })), i();
      }), {
        update: () => {
          const u = a.getState(l.state);
          if (u.snapshot == null && u.prevSnapshot == null && (s || l.state.doc.content.findDiffStart(
            l.state.doc.type.createAndFill().content
          ) !== null)) {
            if (s = !0, u.addToHistory === !1 && !u.isChangeOrigin) {
              const d = Hs.getState(l.state), f = d && d.undoManager;
              f && f.stopCapturing();
            }
            c.mux(() => {
              u.doc.transact((d) => {
                d.meta.set("addToHistory", u.addToHistory), c._prosemirrorChanged(l.state.doc);
              }, zt);
            });
          }
        },
        destroy: () => {
          o.destroy(), c.destroy();
        }
      };
    }
  });
  return a;
}, lde = (t, e, n) => {
  if (e !== null && e.anchor !== null && e.head !== null) {
    const r = xf(
      n.doc,
      n.type,
      e.anchor,
      n.mapping
    ), i = xf(
      n.doc,
      n.type,
      e.head,
      n.mapping
    );
    r !== null && i !== null && (t = t.setSelection(Te.create(t.doc, r, i)));
  }
}, Cw = (t, e) => ({
  anchor: Fm(
    e.selection.anchor,
    t.type,
    t.mapping
  ),
  head: Fm(
    e.selection.head,
    t.type,
    t.mapping
  )
});
class cde {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {any} prosemirrorView The target binding
   */
  constructor(e, n) {
    this.type = e, this.prosemirrorView = n, this.mux = ede(), this.isDestroyed = !1, this.mapping = /* @__PURE__ */ new Map(), this._observeFunction = this._typeChanged.bind(this), this.doc = e.doc, this.beforeTransactionSelection = null, this.beforeAllTransactions = () => {
      this.beforeTransactionSelection === null && (this.beforeTransactionSelection = Cw(
        this,
        n.state
      ));
    }, this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    }, this.doc.on("beforeAllTransactions", this.beforeAllTransactions), this.doc.on("afterAllTransactions", this.afterAllTransactions), e.observeDeep(this._observeFunction), this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", !1);
  }
  _isLocalCursorInView() {
    return this.prosemirrorView.hasFocus() ? (Jae && this._domSelectionInView === null && (Om(0, () => {
      this._domSelectionInView = null;
    }), this._domSelectionInView = this._isDomSelectionInView()), this._domSelectionInView) : !1;
  }
  _isDomSelectionInView() {
    const e = this.prosemirrorView._root.getSelection(), n = this.prosemirrorView._root.createRange();
    n.setStart(e.anchorNode, e.anchorOffset), n.setEnd(e.focusNode, e.focusOffset), n.getClientRects().length === 0 && n.startContainer && n.collapsed && n.selectNodeContents(n.startContainer);
    const i = n.getBoundingClientRect(), s = ile.documentElement;
    return i.bottom >= 0 && i.right >= 0 && i.left <= (window.innerWidth || s.clientWidth || 0) && i.top <= (window.innerHeight || s.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(e, n) {
    n || (n = AS(CS(), /* @__PURE__ */ new Map())), this.prosemirrorView.dispatch(
      this._tr.setMeta(zt, { snapshot: e, prevSnapshot: n })
    );
  }
  unrenderSnapshot() {
    this.mapping = /* @__PURE__ */ new Map(), this.mux(() => {
      const e = this.type.toArray().map(
        (r) => Hp(
          /** @type {Y.XmlElement} */
          r,
          this.prosemirrorView.state.schema,
          this.mapping
        )
      ).filter((r) => r !== null), n = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Fe(je.from(e), 0, 0)
      );
      n.setMeta(zt, { snapshot: null, prevSnapshot: null }), this.prosemirrorView.dispatch(n);
    });
  }
  _forceRerender() {
    this.mapping = /* @__PURE__ */ new Map(), this.mux(() => {
      const e = this.type.toArray().map(
        (r) => Hp(
          /** @type {Y.XmlElement} */
          r,
          this.prosemirrorView.state.schema,
          this.mapping
        )
      ).filter((r) => r !== null), n = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Fe(je.from(e), 0, 0)
      );
      this.prosemirrorView.dispatch(
        n.setMeta(zt, { isChangeOrigin: !0 })
      );
    });
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(e, n, r) {
    e || (e = Ble(this.doc)), this.mapping = /* @__PURE__ */ new Map(), this.mux(() => {
      this.doc.transact((i) => {
        const s = r.permanentUserData;
        s && s.dss.forEach((c) => {
          Bo(i, c, (u) => {
          });
        });
        const o = (c, u) => {
          const d = c === "added" ? s.getUserByClientId(u.client) : s.getUserByDeletedId(u);
          return {
            user: d,
            type: c,
            color: ode(
              r.colorMapping,
              r.colors,
              d
            )
          };
        }, a = PB(
          this.type,
          new MS(n.ds, e.sv)
        ).map((c) => !c._item.deleted || $m(c._item, e) || $m(c._item, n) ? Hp(
          c,
          this.prosemirrorView.state.schema,
          /* @__PURE__ */ new Map(),
          e,
          n,
          o
        ) : null).filter((c) => c !== null), l = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Fe(je.from(a), 0, 0)
        );
        this.prosemirrorView.dispatch(
          l.setMeta(zt, { isChangeOrigin: !0 })
        );
      }, zt);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(e, n) {
    const r = zt.getState(this.prosemirrorView.state);
    if (e.length === 0 || r.snapshot != null || r.prevSnapshot != null) {
      this.renderSnapshot(r.snapshot, r.prevSnapshot);
      return;
    }
    this.mux(() => {
      const i = (a, l) => this.mapping.delete(l);
      Bo(
        n,
        n.deleteSet,
        (a) => {
          if (a.constructor === kt) {
            const l = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              a.content.type
            );
            l && this.mapping.delete(l);
          }
        }
      ), n.changed.forEach(i), n.changedParentTypes.forEach(i);
      const s = this.type.toArray().map(
        (a) => mF(
          /** @type {Y.XmlElement | Y.XmlHook} */
          a,
          this.prosemirrorView.state.schema,
          this.mapping
        )
      ).filter((a) => a !== null);
      let o = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Fe(je.from(s), 0, 0)
      );
      lde(o, this.beforeTransactionSelection, this), o = o.setMeta(zt, { isChangeOrigin: !0, isUndoRedoOperation: n.origin instanceof MB }), this.beforeTransactionSelection !== null && this._isLocalCursorInView() && o.scrollIntoView(), this.prosemirrorView.dispatch(o);
    });
  }
  _prosemirrorChanged(e) {
    this.doc.transact(() => {
      Ow(this.doc, this.type, e, this.mapping), this.beforeTransactionSelection = Cw(
        this,
        this.prosemirrorView.state
      );
    }, zt);
  }
  destroy() {
    this.isDestroyed = !0, this.type.unobserveDeep(this._observeFunction), this.doc.off("beforeAllTransactions", this.beforeAllTransactions), this.doc.off("afterAllTransactions", this.afterAllTransactions);
  }
}
const mF = (t, e, n, r, i, s) => {
  const o = (
    /** @type {PModel.Node} */
    n.get(t)
  );
  if (o === void 0) {
    if (t instanceof Zn)
      return Hp(
        t,
        e,
        n,
        r,
        i,
        s
      );
    throw Oi();
  }
  return o;
}, Hp = (t, e, n, r, i, s) => {
  const o = [], a = (l) => {
    if (l.constructor === Zn) {
      const c = mF(
        l,
        e,
        n,
        r,
        i,
        s
      );
      c !== null && o.push(c);
    } else {
      const c = ude(
        l,
        e,
        n,
        r,
        i,
        s
      );
      c !== null && c.forEach((u) => {
        u !== null && o.push(u);
      });
    }
  };
  r === void 0 || i === void 0 ? t.toArray().forEach(a) : PB(t, new MS(i.ds, r.sv)).forEach(a);
  try {
    const l = t.getAttributes(r);
    r !== void 0 && ($m(
      /** @type {Y.Item} */
      t._item,
      r
    ) ? $m(
      /** @type {Y.Item} */
      t._item,
      i
    ) || (l.ychange = s ? s(
      "added",
      /** @type {Y.Item} */
      t._item.id
    ) : { type: "added" }) : l.ychange = s ? s(
      "removed",
      /** @type {Y.Item} */
      t._item.id
    ) : { type: "removed" });
    const c = e.node(t.nodeName, l, o);
    return n.set(t, c), c;
  } catch {
    return t.doc.transact((c) => {
      t._item.delete(c);
    }, zt), n.delete(t), null;
  }
}, ude = (t, e, n, r, i, s) => {
  const o = [], a = t.toDelta(r, i, s);
  try {
    for (let l = 0; l < a.length; l++) {
      const c = a[l], u = [];
      for (const d in c.attributes)
        u.push(e.mark(d, c.attributes[d]));
      o.push(e.text(c.insert, u));
    }
  } catch {
    return t.doc.transact((c) => {
      t._item.delete(c);
    }, zt), null;
  }
  return o;
}, dde = (t, e) => {
  const n = new $r(), r = t.map((i) => ({
    // @ts-ignore
    insert: i.text,
    attributes: bF(i.marks)
  }));
  return n.applyDelta(r), e.set(n, t), n;
}, fde = (t, e) => {
  const n = new Zn(t.type.name);
  for (const r in t.attrs) {
    const i = t.attrs[r];
    i !== null && r !== "ychange" && n.setAttribute(r, i);
  }
  return n.insert(
    0,
    k0(t).map(
      (r) => Tw(r, e)
    )
  ), e.set(n, t), n;
}, Tw = (t, e) => t instanceof Array ? dde(t, e) : fde(t, e), zM = (t) => typeof t == "object" && t !== null, WS = (t, e) => {
  const n = Object.keys(t).filter((i) => t[i] !== null);
  let r = n.length === Object.keys(e).filter((i) => e[i] !== null).length;
  for (let i = 0; i < n.length && r; i++) {
    const s = n[i], o = t[s], a = e[s];
    r = s === "ychange" || o === a || zM(o) && zM(a) && WS(o, a);
  }
  return r;
}, k0 = (t) => {
  const e = t.content.content, n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (i.isText) {
      const s = [];
      for (let o = e[r]; r < e.length && o.isText; o = e[++r])
        s.push(o);
      r--, n.push(s);
    } else
      n.push(i);
  }
  return n;
}, vF = (t, e) => {
  const n = t.toDelta();
  return n.length === e.length && n.every(
    (r, i) => r.insert === /** @type {any} */
    e[i].text && lB(r.attributes || {}).length === e[i].marks.length && e[i].marks.every(
      (s) => WS(r.attributes[s.type.name] || {}, s.attrs)
    )
  );
}, Sf = (t, e) => {
  if (t instanceof Zn && !(e instanceof Array) && Mw(t, e)) {
    const n = k0(e);
    return t._length === n.length && WS(t.getAttributes(), e.attrs) && t.toArray().every(
      (r, i) => Sf(r, n[i])
    );
  }
  return t instanceof $r && e instanceof Array && vF(t, e);
}, Bm = (t, e) => t === e || t instanceof Array && e instanceof Array && t.length === e.length && t.every(
  (n, r) => e[r] === n
), HM = (t, e, n) => {
  const r = t.toArray(), i = k0(e), s = i.length, o = r.length, a = Pa(o, s);
  let l = 0, c = 0, u = !1;
  for (; l < a; l++) {
    const d = r[l], f = i[l];
    if (Bm(n.get(d), f))
      u = !0;
    else if (!Sf(d, f))
      break;
  }
  for (; l + c < a; c++) {
    const d = r[o - c - 1], f = i[s - c - 1];
    if (Bm(n.get(d), f))
      u = !0;
    else if (!Sf(d, f))
      break;
  }
  return {
    equalityFactor: l + c,
    foundMappedChild: u
  };
}, hde = (t) => {
  let e = "", n = t._start;
  const r = {};
  for (; n !== null; )
    n.deleted || (n.countable && n.content instanceof Di ? e += n.content.str : n.content instanceof sn && (r[n.content.key] = null)), n = n.right;
  return {
    str: e,
    nAttrs: r
  };
}, pde = (t, e, n) => {
  n.set(t, e);
  const { nAttrs: r, str: i } = hde(t), s = e.map((c) => ({
    insert: (
      /** @type {any} */
      c.text
    ),
    attributes: Object.assign({}, r, bF(c.marks))
  })), { insert: o, remove: a, index: l } = ide(
    i,
    s.map((c) => c.insert).join("")
  );
  t.delete(l, a), t.insert(l, o), t.applyDelta(
    s.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))
  );
}, bF = (t) => {
  const e = {};
  return t.forEach((n) => {
    n.type.name !== "ychange" && (e[n.type.name] = n.attrs);
  }), e;
}, Ow = (t, e, n, r) => {
  if (e instanceof Zn && e.nodeName !== n.type.name)
    throw new Error("node name mismatch!");
  if (r.set(e, n), e instanceof Zn) {
    const d = e.getAttributes(), f = n.attrs;
    for (const h in f)
      f[h] !== null ? d[h] !== f[h] && h !== "ychange" && e.setAttribute(h, f[h]) : e.removeAttribute(h);
    for (const h in d)
      f[h] === void 0 && e.removeAttribute(h);
  }
  const i = k0(n), s = i.length, o = e.toArray(), a = o.length, l = Pa(s, a);
  let c = 0, u = 0;
  for (; c < l; c++) {
    const d = o[c], f = i[c];
    if (!Bm(r.get(d), f))
      if (Sf(d, f))
        r.set(d, f);
      else
        break;
  }
  for (; u + c + 1 < l; u++) {
    const d = o[a - u - 1], f = i[s - u - 1];
    if (!Bm(r.get(d), f))
      if (Sf(d, f))
        r.set(d, f);
      else
        break;
  }
  t.transact(() => {
    for (; a - c - u > 0 && s - c - u > 0; ) {
      const f = o[c], h = i[c], p = o[a - u - 1], g = i[s - u - 1];
      if (f instanceof $r && h instanceof Array)
        vF(f, h) || pde(f, h, r), c += 1;
      else {
        let m = f instanceof Zn && Mw(f, h), v = p instanceof Zn && Mw(p, g);
        if (m && v) {
          const y = HM(
            /** @type {Y.XmlElement} */
            f,
            /** @type {PModel.Node} */
            h,
            r
          ), E = HM(
            /** @type {Y.XmlElement} */
            p,
            /** @type {PModel.Node} */
            g,
            r
          );
          y.foundMappedChild && !E.foundMappedChild ? v = !1 : !y.foundMappedChild && E.foundMappedChild || y.equalityFactor < E.equalityFactor ? m = !1 : v = !1;
        }
        m ? (Ow(
          t,
          /** @type {Y.XmlFragment} */
          f,
          /** @type {PModel.Node} */
          h,
          r
        ), c += 1) : v ? (Ow(
          t,
          /** @type {Y.XmlFragment} */
          p,
          /** @type {PModel.Node} */
          g,
          r
        ), u += 1) : (r.delete(e.get(c)), e.delete(c, 1), e.insert(c, [
          Tw(h, r)
        ]), c += 1);
      }
    }
    const d = a - c - u;
    if (a === 1 && s === 0 && o[0] instanceof $r ? (r.delete(o[0]), o[0].delete(0, o[0].length)) : d > 0 && (e.slice(c, c + d).forEach((f) => r.delete(f)), e.delete(c, d)), c + u < s) {
      const f = [];
      for (let h = c; h < s - u; h++)
        f.push(Tw(i[h], r));
      e.insert(c, f);
    }
  }, zt);
}, Mw = (t, e) => !(e instanceof Array) && t.nodeName === e.type.name;
let Ed = null;
const gde = () => {
  const t = (
    /** @type {Map<EditorView, Map<any, any>>} */
    Ed
  );
  Ed = null, t.forEach((e, n) => {
    const r = n.state.tr, i = zt.getState(n.state);
    i && i.binding && !i.binding.isDestroyed && (e.forEach((s, o) => {
      r.setMeta(o, s);
    }), n.dispatch(r));
  });
}, mde = (t, e, n) => {
  Ed || (Ed = /* @__PURE__ */ new Map(), Om(0, gde)), Ys(Ed, t, ri).set(e, n);
}, Fm = (t, e, n) => {
  if (t === 0)
    return jb(e, 0);
  let r = e._first === null ? null : (
    /** @type {Y.ContentType} */
    e._first.content.type
  );
  for (; r !== null && e !== r; ) {
    if (r instanceof $r) {
      if (r._length >= t)
        return jb(r, t);
      if (t -= r._length, r._item !== null && r._item.next !== null)
        r = /** @type {Y.ContentType} */
        r._item.next.content.type;
      else {
        do
          r = r._item === null ? null : r._item.parent, t--;
        while (r !== e && r !== null && r._item !== null && r._item.next === null);
        r !== null && r !== e && (r = r._item === null ? null : (
          /** @type {Y.ContentType} */
          /** @type Y.Item */
          r._item.next.content.type
        ));
      }
    } else {
      const i = (
        /** @type {any} */
        (n.get(r) || { nodeSize: 0 }).nodeSize
      );
      if (r._first !== null && t < i)
        r = /** @type {Y.ContentType} */
        r._first.content.type, t--;
      else {
        if (t === 1 && r._length === 0 && i > 1)
          return new bf(r._item === null ? null : r._item.id, r._item === null ? mf(r) : null, null);
        if (t -= i, r._item !== null && r._item.next !== null)
          r = /** @type {Y.ContentType} */
          r._item.next.content.type;
        else {
          if (t === 0)
            return r = r._item === null ? r : r._item.parent, new bf(r._item === null ? null : r._item.id, r._item === null ? mf(r) : null, null);
          do
            r = /** @type {Y.Item} */
            r._item.parent, t--;
          while (r !== e && /** @type {Y.Item} */
          r._item.next === null);
          r !== e && (r = /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          /** @type {Y.Item} */
          r._item.next.content.type);
        }
      }
    }
    if (r === null)
      throw di();
    if (t === 0 && r.constructor !== $r && r !== e)
      return vde(r._item.parent, r._item);
  }
  return jb(e, e._length);
}, vde = (t, e) => {
  let n = null, r = null;
  return t._item === null ? r = mf(t) : n = it(t._item.id.client, t._item.id.clock), new bf(n, r, e.id);
}, xf = (t, e, n, r) => {
  const i = $le(n, t);
  if (i === null || i.type !== e && !vf(e, i.type._item))
    return null;
  let s = i.type, o = 0;
  if (s.constructor === $r)
    o = i.index;
  else if (s._item === null || !s._item.deleted) {
    let a = s._first, l = 0;
    for (; l < s._length && l < i.index && a !== null; ) {
      if (!a.deleted) {
        const c = (
          /** @type {Y.ContentType} */
          a.content.type
        );
        l++, c instanceof $r ? o += c._length : o += /** @type {any} */
        r.get(c).nodeSize;
      }
      a = /** @type {Y.Item} */
      a.right;
    }
    o += 1;
  }
  for (; s !== e && s._item !== null; ) {
    const a = s._item.parent;
    if (a._item === null || !a._item.deleted) {
      o += 1;
      let l = (
        /** @type {Y.AbstractType} */
        a._first
      );
      for (; l !== null; ) {
        const c = (
          /** @type {Y.ContentType} */
          l.content.type
        );
        if (c === s)
          break;
        l.deleted || (c instanceof $r ? o += c._length : o += /** @type {any} */
        r.get(c).nodeSize), l = l.right;
      }
    }
    s = /** @type {Y.AbstractType} */
    a;
  }
  return o - 1;
};
function bde(t) {
  const e = t.toArray();
  function n(r) {
    let i;
    if (!r.nodeName)
      i = r.toDelta().map((o) => {
        const a = {
          type: "text",
          text: o.insert
        };
        return o.attributes && (a.marks = Object.keys(o.attributes).map((l) => {
          const c = o.attributes[l], u = {
            type: l
          };
          return Object.keys(c) && (u.attrs = c), u;
        })), a;
      });
    else {
      i = {
        type: r.nodeName
      };
      const s = r.getAttributes();
      Object.keys(s).length && (i.attrs = s);
      const o = r.toArray();
      o.length && (i.content = o.map(n).flat());
    }
    return i;
  }
  return {
    type: "doc",
    content: e.map(n)
  };
}
const yde = (t, e, n) => t !== e, wde = (t) => {
  const e = document.createElement("span");
  e.classList.add("ProseMirror-yjs-cursor"), e.setAttribute("style", `border-color: ${t.color}`);
  const n = document.createElement("div");
  n.setAttribute("style", `background-color: ${t.color}`), n.insertBefore(document.createTextNode(t.name), null);
  const r = document.createTextNode("⁠"), i = document.createTextNode("⁠");
  return e.insertBefore(r, null), e.insertBefore(n, null), e.insertBefore(i, null), e;
}, yF = (t) => ({
  style: `background-color: ${t.color}70`,
  class: "ProseMirror-yjs-selection"
}), _de = /^#[0-9a-fA-F]{6}$/, UM = (t, e, n, r, i) => {
  const s = zt.getState(t), o = s.doc, a = [];
  return s.snapshot != null || s.prevSnapshot != null || s.binding === null ? un.create(t.doc, []) : (e.getStates().forEach((l, c) => {
    if (n(o.clientID, c, l) && l.cursor != null) {
      const u = l.user || {};
      u.color == null ? u.color = "#ffa500" : _de.test(u.color) || console.warn("A user uses an unsupported color format", u), u.name == null && (u.name = `User: ${c}`);
      let d = xf(
        o,
        s.type,
        bd(l.cursor.anchor),
        s.binding.mapping
      ), f = xf(
        o,
        s.type,
        bd(l.cursor.head),
        s.binding.mapping
      );
      if (d !== null && f !== null) {
        const h = qs(t.doc.content.size - 1, 0);
        d = Pa(d, h), f = Pa(f, h), a.push(
          Si.widget(f, () => r(u), {
            key: c + "",
            side: 10
          })
        );
        const p = Pa(d, f), g = qs(d, f);
        a.push(
          Si.inline(p, g, i(u), {
            inclusiveEnd: !0,
            inclusiveStart: !1
          })
        );
      }
    }
  }), un.create(t.doc, a));
}, Ede = (t, {
  awarenessStateFilter: e = yde,
  cursorBuilder: n = wde,
  selectionBuilder: r = yF,
  getSelection: i = (o) => o.selection
} = {}, s = "cursor") => new ut({
  key: op,
  state: {
    init(o, a) {
      return UM(
        a,
        t,
        e,
        n,
        r
      );
    },
    apply(o, a, l, c) {
      const u = zt.getState(c), d = o.getMeta(op);
      return u && u.isChangeOrigin || d && d.awarenessUpdated ? UM(
        c,
        t,
        e,
        n,
        r
      ) : a.map(o.mapping, o.doc);
    }
  },
  props: {
    decorations: (o) => op.getState(o)
  },
  view: (o) => {
    const a = () => {
      o.docView && mde(o, op, { awarenessUpdated: !0 });
    }, l = () => {
      const c = zt.getState(o.state), u = t.getLocalState() || {};
      if (c.binding != null)
        if (o.hasFocus()) {
          const d = i(o.state), f = Fm(
            d.anchor,
            c.type,
            c.binding.mapping
          ), h = Fm(
            d.head,
            c.type,
            c.binding.mapping
          );
          (u.cursor == null || !EM(
            bd(u.cursor.anchor),
            f
          ) || !EM(
            bd(u.cursor.head),
            h
          )) && t.setLocalStateField(s, {
            anchor: f,
            head: h
          });
        } else
          u.cursor != null && xf(
            c.doc,
            c.type,
            bd(u.cursor.anchor),
            c.binding.mapping
          ) !== null && t.setLocalStateField(s, null);
    };
    return t.on("change", a), o.dom.addEventListener("focusin", l), o.dom.addEventListener("focusout", l), {
      update: l,
      destroy: () => {
        o.dom.removeEventListener("focusin", l), o.dom.removeEventListener("focusout", l), t.off("change", a), t.setLocalStateField(s, null);
      }
    };
  }
}), Sde = (t) => {
  const e = Hs.getState(t).undoManager;
  if (e != null)
    return e.undo(), !0;
}, xde = (t) => {
  const e = Hs.getState(t).undoManager;
  if (e != null)
    return e.redo(), !0;
}, kde = /* @__PURE__ */ new Set(["paragraph"]), Cde = (t, e) => !(t instanceof kt) || !(t.content instanceof Bi) || !(t.content.type instanceof ol || t.content.type instanceof Zn && e.has(t.content.type.nodeName)) || t.content.type._length === 0, Tde = ({ protectedNodes: t = kde, trackedOrigins: e = [], undoManager: n = null } = {}) => new ut({
  key: Hs,
  state: {
    init: (r, i) => {
      const s = zt.getState(i), o = n || new MB(s.type, {
        trackedOrigins: new Set([zt].concat(e)),
        deleteFilter: (a) => Cde(a, t),
        captureTransaction: (a) => a.meta.get("addToHistory") !== !1
      });
      return {
        undoManager: o,
        prevSel: null,
        hasUndoOps: o.undoStack.length > 0,
        hasRedoOps: o.redoStack.length > 0
      };
    },
    /**
     * @returns {any}
     */
    apply: (r, i, s, o) => {
      const a = zt.getState(o).binding, l = i.undoManager, c = l.undoStack.length > 0, u = l.redoStack.length > 0;
      return a ? {
        undoManager: l,
        prevSel: Cw(a, s),
        hasUndoOps: c,
        hasRedoOps: u
      } : c !== i.hasUndoOps || u !== i.hasRedoOps ? Object.assign({}, i, {
        hasUndoOps: l.undoStack.length > 0,
        hasRedoOps: l.redoStack.length > 0
      }) : i;
    }
  },
  view: (r) => {
    const i = zt.getState(r.state), s = Hs.getState(r.state).undoManager;
    return s.on("stack-item-added", ({ stackItem: o }) => {
      const a = i.binding;
      a && o.meta.set(a, Hs.getState(r.state).prevSel);
    }), s.on("stack-item-popped", ({ stackItem: o }) => {
      const a = i.binding;
      a && (a.beforeTransactionSelection = o.meta.get(a) || a.beforeTransactionSelection);
    }), {
      destroy: () => {
        s.destroy();
      }
    };
  }
}), Ode = Et.create({
  name: "collaboration",
  priority: 1e3,
  addOptions() {
    return {
      document: null,
      field: "default",
      fragment: null
    };
  },
  addStorage() {
    return {
      isDisabled: !1
    };
  },
  onCreate() {
    this.editor.extensionManager.extensions.find((t) => t.name === "history") && console.warn('[tiptap warn]: "@tiptap/extension-collaboration" comes with its own history support and is not compatible with "@tiptap/extension-history".');
  },
  addCommands() {
    return {
      undo: () => ({ tr: t, state: e, dispatch: n }) => (t.setMeta("preventDispatch", !0), Hs.getState(e).undoManager.undoStack.length === 0 ? !1 : n ? Sde(e) : !0),
      redo: () => ({ tr: t, state: e, dispatch: n }) => (t.setMeta("preventDispatch", !0), Hs.getState(e).undoManager.redoStack.length === 0 ? !1 : n ? xde(e) : !0)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo()
    };
  },
  addProseMirrorPlugins() {
    var t;
    const e = this.options.fragment ? this.options.fragment : this.options.document.getXmlFragment(this.options.field), n = Tde(this.options.yUndoOptions), r = n.spec.view;
    n.spec.view = (o) => {
      const { undoManager: a } = Hs.getState(o.state);
      a.restore && (a.restore(), a.restore = () => {
      });
      const l = r ? r(o) : void 0;
      return {
        destroy: () => {
          const c = a.trackedOrigins.has(a), u = a._observers;
          a.restore = () => {
            c && a.trackedOrigins.add(a), a.doc.on("afterTransaction", a.afterTransactionHandler), a._observers = u;
          }, l != null && l.destroy && l.destroy();
        }
      };
    };
    const i = {
      ...this.options.ySyncOptions,
      onFirstRender: this.options.onFirstRender
    }, s = ade(e, i);
    return this.editor.options.enableContentCheck && ((t = e.doc) === null || t === void 0 || t.on("beforeTransaction", () => {
      try {
        const o = bde(e);
        if (o.content.length === 0)
          return;
        this.editor.schema.nodeFromJSON(o).check();
      } catch (o) {
        return this.editor.emit("contentError", {
          error: o,
          editor: this.editor,
          disableCollaboration: () => {
            var a;
            (a = e.doc) === null || a === void 0 || a.destroy(), this.storage.isDisabled = !0;
          }
        }), !1;
      }
    })), [
      s,
      n,
      // Only add the filterInvalidContent plugin if content checking is enabled
      this.editor.options.enableContentCheck && new ut({
        key: new ft("filterInvalidContent"),
        filterTransaction: () => {
          var o;
          return this.storage.isDisabled && ((o = e.doc) === null || o === void 0 || o.destroy()), !0;
        }
      })
    ].filter(Boolean);
  }
}), VM = (t) => Array.from(t.entries()).map(([e, n]) => ({
  clientId: e,
  ...n.user
})), WM = () => null, Mde = Et.create({
  name: "collaborationCursor",
  priority: 999,
  addOptions() {
    return {
      provider: null,
      user: {
        name: null,
        color: null
      },
      render: (t) => {
        const e = document.createElement("span");
        e.classList.add("collaboration-cursor__caret"), e.setAttribute("style", `border-color: ${t.color}`);
        const n = document.createElement("div");
        return n.classList.add("collaboration-cursor__label"), n.setAttribute("style", `background-color: ${t.color}`), n.insertBefore(document.createTextNode(t.name), null), e.insertBefore(n, null), e;
      },
      selectionRender: yF,
      onUpdate: WM
    };
  },
  onCreate() {
    if (this.options.onUpdate !== WM && console.warn('[tiptap warn]: DEPRECATED: The "onUpdate" option is deprecated. Please use `editor.storage.collaborationCursor.users` instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor'), !this.options.provider)
      throw new Error('The "provider" option is required for the CollaborationCursor extension');
  },
  addStorage() {
    return {
      users: []
    };
  },
  addCommands() {
    return {
      updateUser: (t) => () => (this.options.user = t, this.options.provider.awareness.setLocalStateField("user", this.options.user), !0),
      user: (t) => ({ editor: e }) => (console.warn('[tiptap warn]: DEPRECATED: The "user" command is deprecated. Please use "updateUser" instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor'), e.commands.updateUser(t))
    };
  },
  addProseMirrorPlugins() {
    return [
      Ede(
        (() => (this.options.provider.awareness.setLocalStateField("user", this.options.user), this.storage.users = VM(this.options.provider.awareness.states), this.options.provider.awareness.on("update", () => {
          this.storage.users = VM(this.options.provider.awareness.states);
        }), this.options.provider.awareness))(),
        // @ts-ignore
        {
          cursorBuilder: this.options.render,
          selectionBuilder: this.options.selectionRender
        }
      )
    ];
  }
});
function Ade() {
  const t = "BCDEF".split("");
  let e = "#";
  for (let n = 0; n < 6; n++)
    e += t[Math.floor(Math.random() * t.length)];
  return e;
}
function Nde(t, e) {
  const n = new Que(t);
  return Zc(() => {
    n.disconnect(), n.destroy();
  }), [
    Ode.configure({
      document: n.document
    }),
    Mde.configure({
      provider: n,
      user: e
    })
  ];
}
const oge = /* @__PURE__ */ ae({
  __name: "HocuspocusExt",
  props: {
    options: {
      type: Object,
      required: !0
    },
    user: {
      type: Object,
      required: !1,
      default: () => ({
        // avatar: '',
        // name: '',
        color: Ade()
      })
    }
  },
  setup(t) {
    const e = t;
    return G6("history"), Nde(e.options, e.user).map((n) => {
      nt(n);
    }), (n, r) => null;
  }
}), wF = Et.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new ut({
        key: new ft("focus"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: r } = this.editor, { anchor: i } = e, s = [];
            if (!n || !r)
              return Ht.create(t, []);
            let o = 0;
            this.options.mode === "deepest" && t.descendants((l, c) => {
              if (l.isText)
                return;
              if (!(i >= c && i <= c + l.nodeSize - 1))
                return !1;
              o += 1;
            });
            let a = 0;
            return t.descendants((l, c) => {
              if (l.isText || !(i >= c && i <= c + l.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && o - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              s.push(xn.node(c, c + l.nodeSize, {
                class: this.options.className
              }));
            }), Ht.create(t, s);
          }
        }
      })
    ];
  }
}), Rde = /* @__PURE__ */ ae({
  __name: "Focus",
  props: {
    options: {
      type: Object,
      required: !1
    }
  },
  setup(t) {
    const e = t;
    return nt(wF.configure(e.options)), (n, r) => null;
  }
});
function age(t) {
  return wF.configure(t);
}
const _F = N_(() => ({ isShowToc: X(!1) })), Dde = N_(() => ({ hideBubble: X(!0) })), GS = /* @__PURE__ */ ae({
  __name: "AiExt",
  props: {
    mini: {
      type: Boolean,
      require: !1,
      default: !0
    },
    delPrefix: {
      type: Boolean,
      require: !1,
      default: !0
    }
  },
  setup(t) {
    const e = t, { isShowAiPopover: n } = EF(), { hideBubble: r } = Dde(), i = et();
    async function s() {
      if (n.value = !0, r.value = !r.value, e.delPrefix) {
        const { state: c, dispatch: u } = i.value.view, { from: d } = c.selection;
        u(c.tr.delete(d - 1, d));
      }
      const { from: o, to: a } = i.value.state.selection;
      o !== a && i.value.chain().focus().toggleHighlight({ color: "#b3d4fc" }).run();
      const l = i.value.state.doc.textBetween(
        i.value.state.selection.from,
        i.value.state.selection.to
      );
      console.log(l), i.value.commands.focus();
    }
    return (o, a) => (J(), Ze(ns, {
      icon: C(MG),
      "is-border": !1,
      mini: t.mini,
      class: "!text-left",
      color: "#9333ea",
      content: "Ask AI",
      "content-class": "!px-2.5 !justify-start",
      onClick: s
    }, null, 8, ["icon", "mini"]));
  }
}), EF = N_(() => ({ isShowAiPopover: X(!1) })), Ide = "100%", Pde = ["paragraph", "heading", "list_item", "todo_item"];
function Lde(t, e) {
  const { selection: n, doc: r } = t;
  if (!n || !r || !(n instanceof Te || n instanceof ur))
    return t;
  const { from: i, to: s } = n, o = [], a = e && e !== Ide ? e : null;
  return r.nodesBetween(i, s, (l, c) => {
    const u = l.type;
    return Pde.includes(u.name) ? ((l.attrs.lineHeight || null) !== a && o.push({
      // @ts-ignore
      node: l,
      pos: c,
      // @ts-ignore
      nodeType: u
    }), u.name !== "list_item" && u.name !== "todo_item") : !0;
  }), o.length && o.forEach((l) => {
    const { node: c, pos: u, nodeType: d } = l;
    let { attrs: f } = c;
    f = {
      ...f,
      lineHeight: a
    }, t = t.setNodeMarkup(u, d, f, c.marks);
  }), t;
}
function $de(t) {
  return ({ state: e, dispatch: n }) => {
    const { selection: r } = e;
    let { tr: i } = e;
    return i = i.setSelection(r), i = Lde(i, t), i.docChanged ? (n && n(i), !0) : !1;
  };
}
const Bde = { key: 0 }, Fde = ["onClick"], zde = { class: "flex items-center space-x-2" }, Hde = /* @__PURE__ */ ae({
  __name: "LineHeight",
  setup(t) {
    const e = et();
    nt(Ude());
    function n(o) {
      return parseFloat(o.replace("%", "")) / 100;
    }
    const r = rt(() => {
      const l = e.value.extensionManager.extensions.find(
        (c) => c.name === "lineHeight"
      ).options.lineHeights.map((c) => ({
        label: n(c),
        value: c
      }));
      return l.unshift({
        label: "默认",
        value: "default"
      }), l;
    }), i = X("default");
    function s(o) {
      o === "default" ? e.value.commands.unsetLineHeight() : e.value.commands.setLineHeight(o), i.value = o;
    }
    return (o, a) => C(e) ? (J(), be("div", Bde, [
      W(fi, null, {
        button: Ue(() => [
          W(Jv, {
            title: C(me)("lineHeight")
          }, {
            default: Ue(() => [
              W(C(FG), { class: "w-4 h-4 pr-1" })
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        content: Ue(() => [
          (J(!0), be(Vt, null, $n(r.value, (l, c) => (J(), be("div", {
            key: c,
            class: "flex items-center gap-1.5 cursor-pointer px-2 py-1.5 text-sm rounded-sm langeditor-text langeditor-hover",
            type: "button",
            onClick: (u) => s(l.value)
          }, [
            (J(), Ze(ii(l.icon), {
              size: 14,
              class: "text-sm"
            })),
            se("div", zde, Ut(l.value), 1),
            i.value === l.value ? (J(), Ze(C(Fv), {
              key: 0,
              class: "w-4 h-4"
            })) : He("", !0)
          ], 8, Fde))), 128))
        ]),
        _: 1
      })
    ])) : He("", !0);
  }
});
function Ude() {
  return Et.create({
    name: "lineHeight",
    addOptions() {
      var t;
      return {
        ...(t = this.parent) == null ? void 0 : t.call(this),
        types: ["paragraph", "heading", "list_item", "todo_item"],
        lineHeights: ["100%", "115%", "150%", "200%", "250%", "300%"],
        defaultHeight: "100%"
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            lineHeight: {
              default: null,
              parseHTML: (t) => t.style.lineHeight || this.options.defaultHeight,
              renderHTML: (t) => t.lineHeight === this.options.defaultHeight || !t.lineHeight ? {} : { style: `line-height: ${t.lineHeight}` }
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setLineHeight: (t) => $de(t),
        unsetLineHeight: () => ({ commands: t }) => this.options.types.every((e) => t.resetAttributes(e, "lineHeight"))
      };
    }
  });
}
function Vde(t) {
  var e;
  const { char: n, allowSpaces: r, allowedPrefixes: i, startOfLine: s, $position: o } = t, a = o5(n), l = new RegExp(`\\s${a}$`), c = s ? "^" : "", u = r ? new RegExp(`${c}${a}.*?(?=\\s${a}|$)`, "gm") : new RegExp(`${c}(?:^)?${a}[^\\s${a}]*`, "gm"), d = ((e = o.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && o.nodeBefore.text;
  if (!d)
    return null;
  const f = o.pos - d.length, h = Array.from(d.matchAll(u)).pop();
  if (!h || h.input === void 0 || h.index === void 0)
    return null;
  const p = h.input.slice(Math.max(0, h.index - 1), h.index), g = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(p);
  if (i !== null && !g)
    return null;
  const m = f + h.index;
  let v = m + h[0].length;
  return r && l.test(d.slice(v - 1, v + 1)) && (h[0] += " ", v += 1), m < o.pos && v >= o.pos ? {
    range: {
      from: m,
      to: v
    },
    query: h[0].slice(n.length),
    text: h[0]
  } : null;
}
const Wde = new ft("suggestion");
function Gde({ pluginKey: t = Wde, editor: e, char: n = "@", allowSpaces: r = !1, allowedPrefixes: i = [" "], startOfLine: s = !1, decorationTag: o = "span", decorationClass: a = "suggestion", command: l = () => null, items: c = () => [], render: u = () => ({}), allow: d = () => !0, findSuggestionMatch: f = Vde }) {
  let h;
  const p = u == null ? void 0 : u(), g = new ut({
    key: t,
    view() {
      return {
        update: async (m, v) => {
          var y, E, b, _, w, S, x;
          const k = (y = this.key) === null || y === void 0 ? void 0 : y.getState(v), T = (E = this.key) === null || E === void 0 ? void 0 : E.getState(m.state), I = k.active && T.active && k.range.from !== T.range.from, R = !k.active && T.active, N = k.active && !T.active, $ = !R && !N && k.query !== T.query, B = R || I && $, G = $ || I, M = N || I && $;
          if (!B && !G && !M)
            return;
          const A = M && !B ? k : T, z = m.dom.querySelector(`[data-decoration-id="${A.decorationId}"]`);
          h = {
            editor: e,
            range: A.range,
            query: A.query,
            text: A.text,
            items: [],
            command: (V) => l({
              editor: e,
              range: A.range,
              props: V
            }),
            decorationNode: z,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: z ? () => {
              var V;
              const { decorationId: U } = (V = this.key) === null || V === void 0 ? void 0 : V.getState(e.state), Y = m.dom.querySelector(`[data-decoration-id="${U}"]`);
              return (Y == null ? void 0 : Y.getBoundingClientRect()) || null;
            } : null
          }, B && ((b = p == null ? void 0 : p.onBeforeStart) === null || b === void 0 || b.call(p, h)), G && ((_ = p == null ? void 0 : p.onBeforeUpdate) === null || _ === void 0 || _.call(p, h)), (G || B) && (h.items = await c({
            editor: e,
            query: A.query
          })), M && ((w = p == null ? void 0 : p.onExit) === null || w === void 0 || w.call(p, h)), G && ((S = p == null ? void 0 : p.onUpdate) === null || S === void 0 || S.call(p, h)), B && ((x = p == null ? void 0 : p.onStart) === null || x === void 0 || x.call(p, h));
        },
        destroy: () => {
          var m;
          h && ((m = p == null ? void 0 : p.onExit) === null || m === void 0 || m.call(p, h));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(m, v, y, E) {
        const { isEditable: b } = e, { composing: _ } = e.view, { selection: w } = m, { empty: S, from: x } = w, k = { ...v };
        if (k.composing = _, b && (S || e.view.composing)) {
          (x < v.range.from || x > v.range.to) && !_ && !v.composing && (k.active = !1);
          const T = f({
            char: n,
            allowSpaces: r,
            allowedPrefixes: i,
            startOfLine: s,
            $position: w.$from
          }), I = `id_${Math.floor(Math.random() * 4294967295)}`;
          T && d({
            editor: e,
            state: E,
            range: T.range,
            isActive: v.active
          }) ? (k.active = !0, k.decorationId = v.decorationId ? v.decorationId : I, k.range = T.range, k.query = T.query, k.text = T.text) : k.active = !1;
        } else
          k.active = !1;
        return k.active || (k.decorationId = null, k.range = { from: 0, to: 0 }, k.query = null, k.text = null), k;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(m, v) {
        var y;
        const { active: E, range: b } = g.getState(m.state);
        return E && ((y = p == null ? void 0 : p.onKeyDown) === null || y === void 0 ? void 0 : y.call(p, { view: m, event: v, range: b })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(m) {
        const { active: v, range: y, decorationId: E } = g.getState(m);
        return v ? Ht.create(m.doc, [
          xn.inline(y.from, y.to, {
            nodeName: o,
            class: a,
            "data-decoration-id": E
          })
        ]) : null;
      }
    }
  });
  return g;
}
let Aw, Nw, Rw;
function jde(t) {
  Aw = t;
}
function qde(t) {
  Nw = t;
}
function Kde(t) {
  Rw = t;
}
const Yde = X({});
function SF() {
  return Yde;
}
function Xde(t) {
  return Et.create({
    addProseMirrorPlugins() {
      return [Gde({
        editor: this.editor,
        char: "/",
        allowSpaces: !1,
        startOfLine: !0,
        pluginKey: new ft("slashCommand"),
        allow: ({ state: n, range: r, editor: i }) => {
          var f, h, p;
          const s = n.doc.resolve(r.from), o = s.depth === 1, a = s.parent.type.name === "paragraph", l = ((f = s.parent.textContent) == null ? void 0 : f.charAt(0)) === "/", c = i.isActive("column"), u = (p = s.parent.textContent) == null ? void 0 : p.substring(
            (h = s.parent.textContent) == null ? void 0 : h.indexOf("/")
          ), d = !(u != null && u.endsWith("  "));
          return (o && a && l || c && a && l) && d;
        },
        items: ({ query: n, editor: r }) => Aw ? Aw(n) : [],
        render() {
          return Nw ? Nw() || {} : {};
        }
      })];
    }
  });
}
const jS = (t) => (vA("data-v-7904770f"), t = t(), bA(), t), Jde = { class: "langeditor-slash-command" }, Zde = /* @__PURE__ */ jS(() => /* @__PURE__ */ se("div", { class: "pb-1.5 langeditor-text text-xs px-2" }, "AI", -1)), Qde = /* @__PURE__ */ jS(() => /* @__PURE__ */ se("div", { class: "langeditor-border mt-1 !border-[0.5px]" }, null, -1)), efe = /* @__PURE__ */ jS(() => /* @__PURE__ */ se("div", { class: "py-1.5 langeditor-text text-xs px-2" }, "Basic blocks", -1)), tfe = ["onClick"], nfe = { class: "slash-name" }, rfe = { class: "langeditor-slash-command-value" }, ife = /* @__PURE__ */ ae({
  __name: "DefaultSlashCommandView",
  setup(t) {
    const e = et(), n = SF(), r = X([
      {
        name: "插入链接",
        cmd: "/link",
        icon: Dc,
        action: () => {
          n.value.range && (e.value.chain().focus().deleteRange(n.value.range).run(), e.value.storage.link.openLink());
        }
      },
      {
        name: "插入图片",
        cmd: "/img",
        icon: U_,
        action: () => {
          n.value.range && (e.value.chain().focus().deleteRange(n.value.range).run(), e.value.storage.image.openUploader());
        }
      },
      {
        name: "插入视频",
        cmd: "/video",
        icon: DD,
        action: () => {
          n.value.range && (e.value.chain().focus().deleteRange(n.value.range).run(), e.value.storage.video.openUploader());
        }
      },
      {
        name: "引用",
        cmd: "/b",
        icon: AD,
        action: () => {
          n.value.range && e.value.chain().focus().deleteRange(n.value.range).toggleBlockquote().run();
        }
      },
      {
        name: "标题1",
        cmd: "/h1",
        icon: SD,
        action: () => {
          n.value.range && e.value.chain().focus().deleteRange(n.value.range).toggleHeading({ level: 1 }).run();
        }
      },
      {
        name: "标题2",
        cmd: "/h2",
        icon: xD,
        action: () => {
          n.value.range && e.value.chain().focus().deleteRange(n.value.range).toggleHeading({ level: 2 }).run();
        }
      },
      {
        name: "标题3",
        cmd: "/h3",
        icon: kD,
        action: () => {
          n.value.range && e.value.chain().focus().deleteRange(n.value.range).toggleHeading({ level: 3 }).run();
        }
      },
      {
        name: "列表",
        cmd: "/list",
        icon: TD,
        action: () => {
          n.value.range && e.value.chain().focus().deleteRange(n.value.range).toggleBulletList().run();
        }
      },
      {
        name: "数学公式",
        cmd: "/math",
        icon: ND,
        action: () => {
          n.value.range && (e.value.chain().focus().deleteRange(n.value.range).run(), e.value.storage["hb-math"].openEditor());
        }
      },
      {
        name: "代码",
        cmd: "/code",
        icon: ED,
        action: () => {
          n.value.range && e.value.chain().focus().deleteRange(n.value.range).toggleCode().run();
        }
      },
      {
        name: "代码块",
        cmd: "/codeblock",
        icon: RD,
        action: () => {
          n.value.range && e.value.chain().focus().deleteRange(n.value.range).toggleCodeBlock().run();
        }
      }
    ]), i = rt(() => r.value.filter((a) => a.cmd.startsWith(`/${n.value.query}`))), s = X(-1);
    Bt(
      () => n.value.query,
      () => {
        s.value = -1;
      }
    );
    function o({ event: a }) {
      if (a.key === "Enter") {
        const l = i.value[s.value];
        return l && l.action(), i.value.length === 1 && i.value[0].action(), !0;
      }
      return a.key === "ArrowDown" ? (s.value++, i.value.length === 0 ? (s.value = -1, !0) : (s.value > i.value.length - 1 && (s.value = 0), !0)) : a.key === "ArrowUp" ? (s.value--, i.value.length === 0 ? (s.value = -1, !0) : (s.value < 0 && (s.value = i.value.length - 1), !0)) : !1;
    }
    return Kde(o), (a, l) => Yr((J(), be("div", Jde, [
      Zde,
      W(GS),
      Qde,
      efe,
      (J(!0), be(Vt, null, $n(i.value, (c, u) => (J(), be("div", {
        key: c.cmd,
        class: It([{ active: s.value === u }, "slash-item"]),
        onClick: (d) => c.action()
      }, [
        se("div", nfe, [
          (J(), Ze(ii(c.icon), { class: "w-3 h-3" })),
          se("span", null, Ut(c.name), 1)
        ]),
        se("div", rfe, Ut(c.cmd), 1)
      ], 10, tfe))), 128))
    ], 512)), [
      [ql, i.value.length > 0]
    ]);
  }
});
const sfe = /* @__PURE__ */ wr(ife, [["__scopeId", "data-v-7904770f"]]), ofe = { style: { display: "none" } }, afe = /* @__PURE__ */ ae({
  __name: "SlashCommand",
  setup(t) {
    const e = X();
    let n;
    const r = et();
    nt(Xde());
    const i = X(!1), s = SF();
    jde((c) => (s.value.query = c, [])), qde(() => ({
      onStart: (c) => {
        s.value.range = c.range, s.value.editor = c.editor, setTimeout(() => {
          o(c.clientRect());
        }, 100);
      },
      onUpdate: (c) => {
        s.value.range = c.range, a(c.clientRect());
      },
      onKeyDown: (c) => c.event.key === "Escape" ? (l(), !0) : (s.value.range = c.range, Rw ? Rw(c) : !1),
      onExit: (c) => {
        l();
      }
    }));
    function o(c) {
      if (!e.value)
        return;
      const u = document.createElement("div");
      u.append(e.value), n = Vo("#app", {
        duration: 0,
        getReferenceClientRect: () => c,
        content: u,
        interactive: !0,
        trigger: "manual",
        placement: "bottom-start"
      })[0], n.show(), i.value = !0;
    }
    function a(c) {
      n && n.setProps({
        getReferenceClientRect: () => c
      });
    }
    function l() {
      n && (n.destroy(), s.value.range = void 0, s.value.query = void 0);
    }
    return (c, u) => (J(), be("div", ofe, [
      se("div", {
        ref_key: "root",
        ref: e,
        class: It([i.value ? "langeditor-border" : "", "langeditor-bg max-h-60 w-64 py-1.5 overflow-hidden overflow-y-auto transition-all px-1"])
      }, [
        C(r) && C(r).isEditable ? (J(), Ze(sfe, { key: 0 })) : He("", !0)
      ], 2)
    ]));
  }
});
function GM({ types: t, node: e }) {
  return Array.isArray(t) && t.includes(e.type) || e.type === t;
}
const xF = Et.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: ["paragraph"]
    };
  },
  addProseMirrorPlugins() {
    const t = new ft(this.name), e = Object.entries(this.editor.schema.nodes).map(([, n]) => n).filter((n) => this.options.notAfter.includes(n.name));
    return [
      new ut({
        key: t,
        appendTransaction: (n, r, i) => {
          const { doc: s, tr: o, schema: a } = i, l = t.getState(i), c = s.content.size, u = a.nodes[this.options.node];
          if (l)
            return o.insert(c, u.create());
        },
        state: {
          init: (n, r) => {
            const i = r.tr.doc.lastChild;
            return !GM({ node: i, types: e });
          },
          apply: (n, r) => {
            if (!n.docChanged)
              return r;
            const i = n.doc.lastChild;
            return !GM({ node: i, types: e });
          }
        }
      })
    ];
  }
}), lfe = /* @__PURE__ */ ae({
  __name: "TrailingNode",
  setup(t) {
    return nt(xF), (e, n) => null;
  }
});
function lge() {
  return xF;
}
function cfe(t) {
  const e = t.getBoundingClientRect(), n = t.closest('[role="dialog"]');
  if (n && window.getComputedStyle(n).transform !== "none") {
    const r = n.getBoundingClientRect();
    return {
      top: e.top - r.top,
      left: e.left - r.left,
      width: e.width
    };
  }
  return {
    top: e.top,
    left: e.left,
    width: e.width
  };
}
function jM(t, e) {
  const n = [
    "li",
    "p:not(:first-child)",
    "pre",
    "blockquote",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    ...e.customNodes.map((r) => `[data-type=${r}]`)
  ].join(", ");
  return document.elementsFromPoint(t.x, t.y).find(
    (r) => {
      var i, s;
      return ((s = (i = r.parentElement) == null ? void 0 : i.matches) == null ? void 0 : s.call(i, ".ProseMirror")) || r.matches(n);
    }
  );
}
function ufe(t, e, n) {
  var i;
  const r = t.getBoundingClientRect();
  return (i = e.posAtCoords({
    left: r.left + 50 + n.dragHandleWidth,
    top: r.top + 1
  })) == null ? void 0 : i.inside;
}
function qM(t, e) {
  const n = e.state.doc.resolve(t);
  return n.depth > 1 ? n.before(n.depth) : t;
}
function dfe(t) {
  let e = "";
  function n(a, l) {
    if (l.focus(), !a.dataTransfer)
      return;
    const c = jM(
      {
        x: a.clientX + 50 + t.dragHandleWidth,
        y: a.clientY
      },
      t
    );
    if (!(c instanceof Element))
      return;
    let u = ufe(c, l, t);
    if (u == null || u < 0)
      return;
    u = qM(u, l);
    const { from: d, to: f } = l.state.selection, h = d - f, p = qM(d, l);
    let g = !1;
    const m = l.state.doc.resolve(p);
    if (m.node().type.name === "doc")
      g = !0;
    else {
      const _ = ve.create(l.state.doc, m.before());
      g = !(u + 1 >= _.$from.pos && u <= _.$to.pos);
    }
    let v = l.state.selection;
    if (!g && h !== 0 && !(l.state.selection instanceof ve)) {
      const _ = ve.create(l.state.doc, f - 1);
      v = Te.create(l.state.doc, u, _.$to.pos);
    } else if (v = ve.create(l.state.doc, u), v.node.type.isInline || v.node.type.name === "tableRow") {
      let _ = l.state.doc.resolve(v.from);
      v = ve.create(l.state.doc, _.before());
    }
    l.dispatch(l.state.tr.setSelection(v)), l.state.selection instanceof ve && l.state.selection.node.type.name === "listItem" && (e = c.parentElement.tagName);
    const y = l.state.selection.content(), { dom: E, text: b } = DU(l, y);
    a.dataTransfer.clearData(), a.dataTransfer.setData("text/html", E.innerHTML), a.dataTransfer.setData("text/plain", b), a.dataTransfer.effectAllowed = "copyMove", a.dataTransfer.setDragImage(c, 0, 0), l.dragging = { slice: y, move: a.ctrlKey };
  }
  let r = null;
  function i() {
    r && r.classList.add("hide");
  }
  function s() {
    r && r.classList.remove("hide");
  }
  function o(a) {
    if (a.target instanceof Element) {
      const l = a.relatedTarget;
      if ((l == null ? void 0 : l.classList.contains("tiptap")) || (l == null ? void 0 : l.classList.contains("drag-handle")))
        return;
    }
    i();
  }
  return new ut({
    key: new ft(t.pluginKey),
    view: (a) => {
      var d, f, h, p;
      const l = t.dragHandleSelector ? document.querySelector(t.dragHandleSelector) : null;
      r = l ?? document.createElement("div"), r.draggable = !0, r.dataset.dragHandle = "", r.classList.add("drag-handle");
      function c(g) {
        n(g, a);
      }
      r.addEventListener("dragstart", c);
      function u(g) {
        i();
        let m = window.scrollY;
        g.clientY < t.scrollTreshold ? window.scrollTo({ top: m - 30, behavior: "smooth" }) : window.innerHeight - g.clientY < t.scrollTreshold && window.scrollTo({ top: m + 30, behavior: "smooth" });
      }
      return r.addEventListener("drag", u), i(), l || (f = (d = a == null ? void 0 : a.dom) == null ? void 0 : d.parentElement) == null || f.appendChild(r), (p = (h = a == null ? void 0 : a.dom) == null ? void 0 : h.parentElement) == null || p.addEventListener("mouseout", o), {
        destroy: () => {
          var g, m, v;
          l || (g = r == null ? void 0 : r.remove) == null || g.call(r), r == null || r.removeEventListener("drag", u), r == null || r.removeEventListener("dragstart", c), r = null, (v = (m = a == null ? void 0 : a.dom) == null ? void 0 : m.parentElement) == null || v.removeEventListener("mouseout", o);
        }
      };
    },
    props: {
      handleDOMEvents: {
        mousemove: (a, l) => {
          if (!a.editable)
            return;
          const c = jM(
            {
              x: l.clientX + 50 + t.dragHandleWidth,
              y: l.clientY
            },
            t
          ), u = c == null ? void 0 : c.closest(".not-draggable"), d = t.excludedTags.concat(["ol", "ul"]).join(", ");
          if (!(c instanceof Element) || c.matches(d) || u) {
            i();
            return;
          }
          const f = window.getComputedStyle(c), h = parseInt(f.lineHeight, 10), p = isNaN(h) ? parseInt(f.fontSize) * 1.2 : h, g = parseInt(f.paddingTop, 10), m = cfe(c);
          m.top += (p - 24) / 2, m.top += g, c.matches("ul:not([data-type=taskList]) li, ol li") && (m.left -= t.dragHandleWidth), m.width = t.dragHandleWidth, r && (r.style.left = `${m.left - m.width}px`, r.style.top = `${m.top}px`, s());
        },
        keydown: () => {
          i();
        },
        mousewheel: () => {
          i();
        },
        // dragging class is used for CSS
        dragstart: (a) => {
          a.dom.classList.add("dragging");
        },
        drop: (a, l) => {
          var h;
          a.dom.classList.remove("dragging"), i();
          let c = null;
          const u = a.posAtCoords({
            left: l.clientX,
            top: l.clientY
          });
          if (!u || (a.state.selection instanceof ve && (c = a.state.selection.node), !c))
            return;
          const f = a.state.doc.resolve(u.pos).parent.type.name === "listItem";
          if (a.state.selection instanceof ve && a.state.selection.node.type.name === "listItem" && !f && e == "OL") {
            const p = (h = a.state.schema.nodes.orderedList) == null ? void 0 : h.createAndFill(null, c), g = new De(pe.from(p), 0, 0);
            a.dragging = { slice: g, move: l.ctrlKey };
          }
        },
        dragend: (a) => {
          a.dom.classList.remove("dragging");
        }
      }
    }
  });
}
const ffe = Et.create({
  name: "globalDragHandle",
  addOptions() {
    return {
      dragHandleWidth: 20,
      scrollTreshold: 100,
      excludedTags: [],
      customNodes: []
    };
  },
  addProseMirrorPlugins() {
    return [
      dfe({
        pluginKey: "globalDragHandle",
        dragHandleWidth: this.options.dragHandleWidth,
        scrollTreshold: this.options.scrollTreshold,
        dragHandleSelector: this.options.dragHandleSelector,
        excludedTags: this.options.excludedTags,
        customNodes: this.options.customNodes
      })
    ];
  }
});
function kF(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), s = e.child(r);
    if (i == s) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return n;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        n++;
      return n;
    }
    if (i.content.size || s.content.size) {
      let o = kF(i.content, s.content, n + 1);
      if (o != null)
        return o;
    }
    n += i.nodeSize;
  }
}
function CF(t, e, n, r) {
  for (let i = t.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: n, b: r };
    let o = t.child(--i), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      n -= l, r -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: n, b: r };
    if (o.isText && o.text != a.text) {
      let c = 0, u = Math.min(o.text.length, a.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, r--;
      return { a: n, b: r };
    }
    if (o.content.size || a.content.size) {
      let c = CF(o.content, a.content, n - 1, r - 1);
      if (c)
        return c;
    }
    n -= l, r -= l;
  }
}
class Gt {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, s) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o], c = a + l.nodeSize;
      if (c > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), r, i + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new Gt(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let s = 0, o = 0; o < n; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))), r.push(a), i += a.nodeSize), o = l;
      }
    return new Gt(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? Gt.empty : e == 0 && n == this.content.length ? this : new Gt(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), s = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new Gt(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Gt([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Gt(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return kF(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return CF(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return ap(0, e);
    if (e == this.size)
      return ap(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let s = this.child(r), o = i + s.nodeSize;
      if (o >= e)
        return o == e || n > 0 ? ap(r + 1, o) : ap(r, i);
      i = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Gt.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Gt(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Gt.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s);
    }
    return new Gt(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Gt.empty;
    if (e instanceof Gt)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Gt([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Gt.empty = new Gt([], 0);
const Zb = { index: 0, offset: 0 };
function ap(t, e) {
  return Zb.index = t, Zb.offset = e, Zb;
}
class hfe extends Error {
}
class pn {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = OF(this.content, e + this.openStart, n);
    return r && new pn(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new pn(TF(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return pn.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new pn(Gt.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new pn(e, r, i);
  }
}
pn.empty = new pn(Gt.empty, 0, 0);
function TF(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r), { index: o, offset: a } = t.findIndex(n);
  if (i == e || s.isText) {
    if (a != n && !t.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, s.copy(TF(s.content, e - i - 1, n - i - 1)));
}
function OF(t, e, n, r) {
  let { index: i, offset: s } = t.findIndex(e), o = t.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = OF(o.content, e - s - 1, n);
  return a && t.replaceChild(i, o.copy(a));
}
const MF = 65535, AF = Math.pow(2, 16);
function pfe(t, e) {
  return t + e * AF;
}
function KM(t) {
  return t & MF;
}
function gfe(t) {
  return (t - (t & MF)) / AF;
}
const NF = 1, RF = 2, Up = 4, DF = 8;
class YM {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DF) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (NF | Up)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (RF | Up)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Up) > 0;
  }
}
class Nr {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Nr.empty)
      return Nr.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = KM(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + gfe(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = this.ranges[a + o], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : n : n, h = l + i + (f < 0 ? 0 : u);
        if (r)
          return h;
        let p = e == (n < 0 ? l : d) ? null : pfe(a / 3, e - l), g = e == l ? RF : e == d ? NF : Up;
        return (n < 0 ? e != l : e != d) && (g |= DF), new YM(h, g, p);
      }
      i += u - c;
    }
    return r ? e + i : new YM(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = KM(n), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = l + c;
      if (e <= u && a == i * 3)
        return !0;
      r += this.ranges[a + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), c = this.ranges[i + n], u = this.ranges[i + r];
      e(a, a + c, l, l + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Nr(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Nr.empty : new Nr(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Nr.empty = new Nr([]);
const Qb = /* @__PURE__ */ Object.create(null);
class Un {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Nr.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Qb[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in Qb)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Qb[e] = n, n.prototype.jsonID = e, n;
  }
}
class nn {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new nn(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new nn(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return nn.ok(e.replace(n, r, i));
    } catch (s) {
      if (s instanceof hfe)
        return nn.fail(s.message);
      throw s;
    }
  }
}
function qS(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let s = t.child(i);
    s.content.size && (s = s.copy(qS(s.content, e, s))), s.isInline && (s = e(s, n, i)), r.push(s);
  }
  return Gt.fromArray(r);
}
class va extends Un {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new pn(qS(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), n.openStart, n.openEnd);
    return nn.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new ba(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new va(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof va && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new va(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new va(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Un.jsonID("addMark", va);
class ba extends Un {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new pn(qS(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return nn.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new va(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new ba(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof ba && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ba(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ba(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Un.jsonID("removeMark", ba);
class ya extends Un {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return nn.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return nn.fromReplace(e, this.pos, this.pos + 1, new pn(Gt.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new ya(this.pos, n.marks[i]);
        return new ya(this.pos, this.mark);
      }
    }
    return new kf(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ya(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new ya(n.pos, e.markFromJSON(n.mark));
  }
}
Un.jsonID("addNodeMark", ya);
class kf extends Un {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return nn.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return nn.fromReplace(e, this.pos, this.pos + 1, new pn(Gt.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new ya(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new kf(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new kf(n.pos, e.markFromJSON(n.mark));
  }
}
Un.jsonID("removeNodeMark", kf);
class co extends Un {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && Dw(e, this.from, this.to) ? nn.fail("Structure replace would overwrite content") : nn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Nr([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new co(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new co(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof co) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? pn.empty : new pn(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new co(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? pn.empty : new pn(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new co(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new co(n.from, n.to, pn.fromJSON(e, n.slice), !!n.structure);
  }
}
Un.jsonID("replace", co);
class Sd extends Un {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, s, o, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Dw(e, this.from, this.gapFrom) || Dw(e, this.gapTo, this.to)))
      return nn.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return nn.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? nn.fromReplace(e, this.from, this.to, r) : nn.fail("Content does not fit in gap");
  }
  getMap() {
    return new Nr([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new Sd(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = e.map(this.gapFrom, -1), s = e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || s > r.pos ? null : new Sd(n.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Sd(n.from, n.to, n.gapFrom, n.gapTo, pn.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Un.jsonID("replaceAround", Sd);
function Dw(t, e, n) {
  let r = t.resolve(e), i = n - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function mfe(t, e) {
  let n = t.resolve(e), r = n.index();
  return vfe(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function vfe(t, e) {
  return !!(t && e && !t.isLeaf && t.canAppend(e));
}
class xd extends Un {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return nn.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in n.attrs)
      r[s] = n.attrs[s];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return nn.fromReplace(e, this.pos, this.pos + 1, new pn(Gt.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Nr.empty;
  }
  invert(e) {
    return new xd(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new xd(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new xd(n.pos, n.attr, n.value);
  }
}
Un.jsonID("attr", xd);
class zm extends Un {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      n[i] = e.attrs[i];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return nn.ok(r);
  }
  getMap() {
    return Nr.empty;
  }
  invert(e) {
    return new zm(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new zm(n.attr, n.value);
  }
}
Un.jsonID("docAttr", zm);
let Cf = class extends Error {
};
Cf = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
Cf.prototype = Object.create(Error.prototype);
Cf.prototype.constructor = Cf;
Cf.prototype.name = "TransformError";
function bfe(t, e, n) {
  let r = [];
  for (let o = 0; o < t.mapping.maps.length; o++) {
    let a = t.mapping.maps[o];
    if (a) {
      for (let l = 0; l < r.length; l++)
        r[l] = a.map(r[l]);
      a.forEach((l, c, u, d) => r.push(u, d));
    }
  }
  let i = [];
  for (let o = 0; o < r.length; o += 2) {
    let a = r[o], l = r[o + 1], c = t.doc.resolve(a), u = c.sharedDepth(l), d = c.node(u);
    for (let f = c.indexAfter(u), h = c.after(u + 1); h <= l; ++f) {
      let p = d.maybeChild(f);
      if (!p)
        break;
      if (f && i.indexOf(h) == -1) {
        let g = d.child(f - 1);
        g.type == p.type && n.includes(g.type) && i.push(h);
      }
      h += p.nodeSize;
    }
  }
  let s = !1;
  i.sort((o, a) => o - a);
  for (let o = i.length - 1; o >= 0; o--)
    mfe(t.doc, i[o]) && (e.join(i[o]), s = !0);
  return s;
}
const yfe = Et.create({
  name: "autoJoiner",
  addOptions() {
    return {
      elementsToJoin: []
    };
  },
  addProseMirrorPlugins() {
    const t = new ft(this.name), e = [
      this.editor.schema.nodes.bulletList,
      this.editor.schema.nodes.orderedList
    ];
    return this.options.elementsToJoin.forEach((n) => {
      const r = mn(n, this.editor.schema);
      e.push(r);
    }), [
      new ut({
        key: t,
        appendTransaction(n, r, i) {
          let s = i.tr, o = !1;
          for (const a of n)
            o = bfe(a, s, e) || o;
          if (o)
            return s;
        }
      })
    ];
  }
}), wfe = /* @__PURE__ */ ae({
  __name: "DragHandle",
  setup(t) {
    return nt(
      ffe.configure({
        dragHandleWidth: 20,
        // default
        // The scrollTreshold specifies how close the user must drag an element to the edge of the lower/upper screen for automatic
        // scrolling to take place. For example, scrollTreshold = 100 means that scrolling starts automatically when the user drags an
        // element to a position that is max. 99px away from the edge of the screen
        // You can set this to 0 to prevent auto scrolling caused by this extension
        scrollTreshold: 100
        // default
      })
    ), nt(
      yfe.configure({
        elementsToJoin: ["bulletList", "orderedList"]
        // default
      })
    ), (e, n) => null;
  }
});
function _fe() {
  return Et.create({
    name: "handleCopyPaste",
    addCommands() {
      return {
        copyRange: (t, e) => ({ state: n, dispatch: r }) => {
          this.editor.chain().focus().setNodeSelection(t.from).run();
          const i = jw.fromSchema(this.editor.schema);
          if (e) {
            const s = i.serializeNode(e), o = document.createElement("div");
            return o.append(s), navigator.clipboard.writeText(o.innerHTML), !0;
          }
          return !1;
        }
      };
    },
    addStorage() {
      return {};
    },
    addProseMirrorPlugins() {
      const t = this.editor;
      return [new ut({
        key: new ft("handleCopyPaste"),
        props: {
          handlePaste: (n, r, i) => {
            function s() {
              return t.extensionManager.extensions.find((f) => f.name === "image");
            }
            function o() {
              return t.extensionManager.extensions.find((f) => f.name === "upload-manager");
            }
            const a = r.clipboardData.files, l = s();
            if (o() && l && a && a.length) {
              const f = [];
              for (let h = 0; h < a.length; h++) {
                const p = a.item(h);
                p && p.type.startsWith("image") && f.push({
                  file: p,
                  pos: n.state.selection.from
                });
              }
              return t.commands.upload(f), !0;
            }
            if (r.clipboardData.getData("text/html"))
              return !1;
            const d = r.clipboardData.getData("text");
            return d ? t.commands.insertContent(d) : !1;
          }
        }
      })];
    }
  });
}
const cge = /* @__PURE__ */ ae({
  __name: "CopyPasteExt",
  setup(t) {
    return et(), nt(_fe()), (e, n) => null;
  }
}), Efe = { class: "placeholder-image" }, Sfe = ["src"], xfe = { class: "upload-controller" }, kfe = { class: "upload-percent" }, Cfe = /* @__PURE__ */ ae({
  __name: "UploadingView",
  props: {
    handleUpload: {
      type: Function,
      required: !0
    },
    file: {
      type: Object,
      required: !0
    },
    onSuccess: {
      type: Function,
      required: !0
    },
    destroy: {
      type: Function
    }
  },
  setup(t) {
    const e = X(0), n = X("");
    function r(s) {
      s >= 100 && (s = 100), e.value = s;
    }
    const i = t;
    return Zt(() => {
      n.value = URL.createObjectURL(i.file), i.handleUpload(i.file, r).then((s) => {
        i.onSuccess(s), setTimeout(() => {
          i.destroy && i.destroy();
        });
      });
    }), (s, o) => (J(), be("div", Efe, [
      se("img", {
        src: n.value,
        class: "preview-image"
      }, null, 8, Sfe),
      se("div", xfe, [
        se("div", kfe, Ut(e.value) + "%", 1)
      ])
    ]));
  }
});
const Tfe = /* @__PURE__ */ wr(Cfe, [["__scopeId", "data-v-9a6eb4b9"]]);
function Ofe(t, e, n, r) {
  const i = {}, s = n.state.tr, o = t.file, a = t.pos - 1, l = (u) => {
    var g;
    const { schema: d } = n.state, f = Mfe(n.state, i);
    if (f == null)
      return;
    const h = (g = d.nodes.image) == null ? void 0 : g.create({ src: u });
    if (!h)
      return;
    const p = n.state.tr.replaceWith(f, f, h).setMeta(Hm, { remove: [i] });
    n.dispatch(p);
  }, c = () => {
    const u = new YR(Tfe, {
      props: {
        handleUpload: e.handleUpload,
        onSuccess: l,
        file: o
      },
      editor: r
    });
    return u.updateProps({
      destroy: () => {
        u.destroy();
      }
    }), u;
  };
  s.selection.empty || s.deleteSelection(), s.setMeta(Hm, {
    add: [{ id: i, pos: a, info: t, render: c }]
  }), n.dispatch(s);
}
function Mfe(t, e) {
  var i;
  const r = Hm.getState(t).find(void 0, void 0, (s) => s.id == e);
  return r.length ? (i = r[0]) == null ? void 0 : i.from : null;
}
const Hm = new ft("upload-manager");
function Afe(t) {
  return Et.create({
    name: "upload-manager",
    addCommands() {
      return {
        upload: (e) => ({ view: n }) => (e.forEach((r) => {
          Ofe(r, t, n, this.editor);
        }), !0)
      };
    },
    addProseMirrorPlugins() {
      return [new ut({
        key: Hm,
        props: {
          decorations(n) {
            return this.getState(n);
          }
        },
        state: {
          init() {
            return Ht.empty;
          },
          apply(n, r) {
            r = r.map(n.mapping, n.doc);
            const i = n.getMeta(this);
            return i != null && i.add ? i.add.forEach(({ id: s, pos: o, src: a, render: l, onSuccess: c }) => {
              const u = l(), d = xn.widget(o + 1, u.element, {
                id: s
              });
              r = r.add(n.doc, [d]);
            }) : i != null && i.remove && i.remove.forEach((s) => {
              r = r.remove(r.find(void 0, void 0, (o) => o.id == s));
            }), r;
          }
        }
      })];
    }
  });
}
const uge = /* @__PURE__ */ ae({
  __name: "UploadManagerExt",
  props: {
    handleUpload: {
      type: Function,
      required: !1
    }
  },
  setup(t) {
    return nt(
      Afe({
        handleUpload: t.handleUpload
      })
    ), (n, r) => null;
  }
}), Nfe = { key: 0 }, Rfe = /* @__PURE__ */ ae({
  __name: "OutlineExt",
  setup(t) {
    const e = et(), n = X(!1), { isShowToc: r } = _F();
    function i() {
      n.value = !n.value, r.value = n.value;
    }
    return (s, o) => C(e) ? (J(), be("div", Nfe, [
      Lt(s.$slots, "default", {}, () => [
        W(Ve, {
          action: i,
          icon: C(bG),
          "is-active": () => n.value,
          title: C(me)("outlineTree")
        }, null, 8, ["icon", "is-active", "title"])
      ])
    ])) : He("", !0);
  }
}), Dfe = {
  key: 0,
  class: "flex items-center"
}, Ife = /* @__PURE__ */ ae({
  __name: "ExportFile",
  setup(t) {
    const e = et();
    function n() {
    }
    function r() {
    }
    const i = Me("PdfIcon", [
      [
        "path",
        {
          fill: "none",
          stroke: "currentColor",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": "2",
          d: "M5 17v-5h1.5a1.5 1.5 0 1 1 0 3H5m12 2v-5h2m-2 3h2M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5m6 4v5h1.375A1.627 1.627 0 0 0 14 15.375v-1.75A1.627 1.627 0 0 0 12.375 12z",
          key: "1"
        }
      ]
    ]), s = Me("WordIcon", [
      [
        "path",
        {
          fill: "none",
          stroke: "currentColor",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": "2",
          d: "M10 3v4a1 1 0 0 1-1 1H5m4 4l1 5l2-3.333L14 17l1-5m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1",
          key: "1"
        }
      ]
    ]);
    return (o, a) => C(e) ? (J(), be("div", Dfe, [
      Lt(o.$slots, "default", {}, () => [
        W(Ve, {
          action: n,
          icon: C(i),
          title: C(me)("exportPdf")
        }, null, 8, ["icon", "title"]),
        W(Ve, {
          action: r,
          icon: C(s),
          title: C(me)("exportWord")
        }, null, 8, ["icon", "title"])
      ])
    ])) : He("", !0);
  }
}), Pfe = { class: "flex items-center gap-2 text-nowrap" }, Lfe = ["onClick"], $fe = { class: "flex gap-1.5 items-center justify-start flex-1" }, Bfe = { class: "flex items-center space-x-2" }, Ffe = /* @__PURE__ */ ae({
  __name: "ViewEditingExt",
  emits: ["update"],
  setup(t, { emit: e }) {
    const n = et(), r = e, i = X(0), s = [
      {
        name: "editing",
        icon: EG,
        isEdit: !0,
        command: () => {
          n.value.setEditable(!0, !0), i.value = (/* @__PURE__ */ new Date()).getMilliseconds(), r("update", !0);
        }
      },
      {
        name: "preview",
        icon: Jy,
        isEdit: !1,
        command: () => {
          n.value.setEditable(!1, !0), i.value = (/* @__PURE__ */ new Date()).getMilliseconds(), r("update", !1);
        }
      }
    ];
    return (o, a) => C(n) ? (J(), be("div", { key: i.value }, [
      W(fi, { "content-class": "w-36 px-1" }, {
        button: Ue(() => [
          W(Jv, {
            title: C(me)("preview")
          }, {
            default: Ue(() => [
              se("div", Pfe, [
                (J(), Ze(ii(C(n).isEditable ? s[0].icon : s[1].icon), {
                  size: 14,
                  class: "text-sm"
                })),
                se("span", null, Ut(C(n).isEditable ? C(me)(s[0].name) : C(me)(s[1].name)), 1)
              ])
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        content: Ue(() => [
          (J(), be(Vt, null, $n(s, (l, c) => se("div", {
            key: c,
            class: "flex items-center justify-end rounded gap-1.5 px-2 py-1.5 cursor-pointer text-sm langeditor-text langeditor-hover",
            type: "button",
            onClick: (u) => l.command()
          }, [
            se("div", $fe, [
              (J(), Ze(ii(l.icon), {
                size: 14,
                class: "text-sm"
              })),
              se("div", Bfe, Ut(l.name), 1)
            ]),
            l.isEdit === C(n).isEditable ? (J(), Ze(C(Fv), {
              key: 0,
              class: "w-4 h-4"
            })) : He("", !0)
          ], 8, Lfe)), 64))
        ]),
        _: 1
      })
    ])) : He("", !0);
  }
}), Wl = "4.47.1";
let XM = !1, kd, IF, PF, Iw, LF, $F, BF, FF, zF;
function zfe(t, e = { auto: !1 }) {
  if (XM)
    throw new Error(`you must \`import 'openai/shims/${t.kind}'\` before importing anything else from openai`);
  if (kd)
    throw new Error(`can't \`import 'openai/shims/${t.kind}'\` after \`import 'openai/shims/${kd}'\``);
  XM = e.auto, kd = t.kind, IF = t.fetch, t.Request, t.Response, t.Headers, PF = t.FormData, t.Blob, Iw = t.File, LF = t.ReadableStream, $F = t.getMultipartRequestOptions, BF = t.getDefaultAgent, FF = t.fileFromPath, zF = t.isFsReadStream;
}
class Hfe {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
}
function Ufe({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import … from 'openai'`:\n- `import 'openai/shims/node'` (if you're running on Node)\n- `import 'openai/shims/web'` (otherwise)\n";
  let n, r, i, s;
  try {
    n = fetch, r = Request, i = Response, s = Headers;
  } catch (o) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${o.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: r,
    Response: i,
    Headers: s,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (o, a) => ({
      ...a,
      body: new Hfe(o)
    }),
    getDefaultAgent: (o) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (o) => !1
  };
}
kd || zfe(Ufe(), { auto: !0 });
class vt extends Error {
}
class Nn extends vt {
  constructor(e, n, r, i) {
    super(`${Nn.makeMessage(e, n, r)}`), this.status = e, this.headers = i, this.request_id = i == null ? void 0 : i["x-request-id"];
    const s = n;
    this.error = s, this.code = s == null ? void 0 : s.code, this.param = s == null ? void 0 : s.param, this.type = s == null ? void 0 : s.type;
  }
  static makeMessage(e, n, r) {
    const i = n != null && n.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : r;
    return e && i ? `${e} ${i}` : e ? `${e} status code (no body)` : i || "(no status code or body)";
  }
  static generate(e, n, r, i) {
    if (!e)
      return new C0({ cause: Lw(n) });
    const s = n == null ? void 0 : n.error;
    return e === 400 ? new HF(e, s, r, i) : e === 401 ? new UF(e, s, r, i) : e === 403 ? new VF(e, s, r, i) : e === 404 ? new WF(e, s, r, i) : e === 409 ? new GF(e, s, r, i) : e === 422 ? new jF(e, s, r, i) : e === 429 ? new qF(e, s, r, i) : e >= 500 ? new KF(e, s, r, i) : new Nn(e, s, r, i);
  }
}
class Ir extends Nn {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0), this.status = void 0;
  }
}
class C0 extends Nn {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), this.status = void 0, n && (this.cause = n);
  }
}
class KS extends C0 {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}
class HF extends Nn {
  constructor() {
    super(...arguments), this.status = 400;
  }
}
class UF extends Nn {
  constructor() {
    super(...arguments), this.status = 401;
  }
}
class VF extends Nn {
  constructor() {
    super(...arguments), this.status = 403;
  }
}
class WF extends Nn {
  constructor() {
    super(...arguments), this.status = 404;
  }
}
class GF extends Nn {
  constructor() {
    super(...arguments), this.status = 409;
  }
}
class jF extends Nn {
  constructor() {
    super(...arguments), this.status = 422;
  }
}
class qF extends Nn {
  constructor() {
    super(...arguments), this.status = 429;
  }
}
class KF extends Nn {
}
class Zi {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let r = !1;
    async function* i() {
      if (r)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      r = !0;
      let s = !1;
      try {
        for await (const o of Vfe(e, n))
          if (!s) {
            if (o.data.startsWith("[DONE]")) {
              s = !0;
              continue;
            }
            if (o.event === null) {
              let a;
              try {
                a = JSON.parse(o.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", o.data), console.error("From chunk:", o.raw), l;
              }
              if (a && a.error)
                throw new Nn(void 0, a.error, void 0, void 0);
              yield a;
            } else {
              let a;
              try {
                a = JSON.parse(o.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", o.data), console.error("From chunk:", o.raw), l;
              }
              if (o.event == "error")
                throw new Nn(void 0, a.error, a.message, void 0);
              yield { event: o.event, data: a };
            }
          }
        s = !0;
      } catch (o) {
        if (o instanceof Error && o.name === "AbortError")
          return;
        throw o;
      } finally {
        s || n.abort();
      }
    }
    return new Zi(i, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let r = !1;
    async function* i() {
      const o = new cl(), a = YF(e);
      for await (const l of a)
        for (const c of o.decode(l))
          yield c;
      for (const l of o.flush())
        yield l;
    }
    async function* s() {
      if (r)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      r = !0;
      let o = !1;
      try {
        for await (const a of i())
          o || a && (yield JSON.parse(a));
        o = !0;
      } catch (a) {
        if (a instanceof Error && a.name === "AbortError")
          return;
        throw a;
      } finally {
        o || n.abort();
      }
    }
    return new Zi(s, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], r = this.iterator(), i = (s) => ({
      next: () => {
        if (s.length === 0) {
          const o = r.next();
          e.push(o), n.push(o);
        }
        return s.shift();
      }
    });
    return [
      new Zi(() => i(e), this.controller),
      new Zi(() => i(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const r = new TextEncoder();
    return new LF({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(i) {
        try {
          const { value: s, done: o } = await n.next();
          if (o)
            return i.close();
          const a = r.encode(JSON.stringify(s) + `
`);
          i.enqueue(a);
        } catch (s) {
          i.error(s);
        }
      },
      async cancel() {
        var i;
        await ((i = n.return) == null ? void 0 : i.call(n));
      }
    });
  }
}
async function* Vfe(t, e) {
  if (!t.body)
    throw e.abort(), new vt("Attempted to iterate over a response with no body");
  const n = new jfe(), r = new cl(), i = YF(t.body);
  for await (const s of Wfe(i))
    for (const o of r.decode(s)) {
      const a = n.decode(o);
      a && (yield a);
    }
  for (const s of r.flush()) {
    const o = n.decode(s);
    o && (yield o);
  }
}
async function* Wfe(t) {
  let e = new Uint8Array();
  for await (const n of t) {
    if (n == null)
      continue;
    const r = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? new TextEncoder().encode(n) : n;
    let i = new Uint8Array(e.length + r.length);
    i.set(e), i.set(r, e.length), e = i;
    let s;
    for (; (s = Gfe(e)) !== -1; )
      yield e.slice(0, s), e = e.slice(s);
  }
  e.length > 0 && (yield e);
}
function Gfe(t) {
  for (let r = 0; r < t.length - 2; r++) {
    if (t[r] === 10 && t[r + 1] === 10 || t[r] === 13 && t[r + 1] === 13)
      return r + 2;
    if (t[r] === 13 && t[r + 1] === 10 && r + 3 < t.length && t[r + 2] === 13 && t[r + 3] === 10)
      return r + 4;
  }
  return -1;
}
class jfe {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const s = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], s;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, r, i] = qfe(e, ":");
    return i.startsWith(" ") && (i = i.substring(1)), n === "event" ? this.event = i : n === "data" && this.data.push(i), null;
  }
}
class cl {
  constructor() {
    this.buffer = [], this.trailingCR = !1;
  }
  decode(e) {
    let n = this.decodeText(e);
    if (this.trailingCR && (n = "\r" + n, this.trailingCR = !1), n.endsWith("\r") && (this.trailingCR = !0, n = n.slice(0, -1)), !n)
      return [];
    const r = cl.NEWLINE_CHARS.has(n[n.length - 1] || "");
    let i = n.split(cl.NEWLINE_REGEXP);
    return r && i.pop(), i.length === 1 && !r ? (this.buffer.push(i[0]), []) : (this.buffer.length > 0 && (i = [this.buffer.join("") + i[0], ...i.slice(1)], this.buffer = []), r || (this.buffer = [i.pop() || ""]), i);
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof Buffer < "u") {
      if (e instanceof Buffer)
        return e.toString();
      if (e instanceof Uint8Array)
        return Buffer.from(e).toString();
      throw new vt(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new vt(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new vt("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR)
      return [];
    const e = [this.buffer.join("")];
    return this.buffer = [], this.trailingCR = !1, e;
  }
}
cl.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
cl.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function qfe(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
function YF(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n != null && n.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
const XF = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", JF = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && ZF(t), ZF = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function", Kfe = (t) => JF(t) || XF(t) || zF(t);
async function QF(t, e, n) {
  var i;
  if (t = await t, n ?? (n = JF(t) ? { lastModified: t.lastModified, type: t.type } : {}), XF(t)) {
    const s = await t.blob();
    return e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file"), new Iw([s], e, n);
  }
  const r = await Yfe(t);
  if (e || (e = Jfe(t) ?? "unknown_file"), !n.type) {
    const s = (i = r[0]) == null ? void 0 : i.type;
    typeof s == "string" && (n = { ...n, type: s });
  }
  return new Iw(r, e, n);
}
async function Yfe(t) {
  var n;
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (ZF(t))
    e.push(await t.arrayBuffer());
  else if (Zfe(t))
    for await (const r of t)
      e.push(r);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${(n = t == null ? void 0 : t.constructor) == null ? void 0 : n.name}; props: ${Xfe(t)}`);
  return e;
}
function Xfe(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function Jfe(t) {
  var e;
  return ey(t.name) || ey(t.filename) || // For fs.ReadStream
  ((e = ey(t.path)) == null ? void 0 : e.split(/[\\/]/).pop());
}
const ey = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof Buffer < "u" && t instanceof Buffer)
    return String(t);
}, Zfe = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", JM = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody", Tf = async (t) => {
  const e = await Qfe(t.body);
  return $F(e, t);
}, Qfe = async (t) => {
  const e = new PF();
  return await Promise.all(Object.entries(t || {}).map(([n, r]) => Pw(e, n, r))), e;
}, Pw = async (t, e, n) => {
  if (n !== void 0) {
    if (n == null)
      throw new TypeError(`Received null for "${e}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof n == "string" || typeof n == "number" || typeof n == "boolean")
      t.append(e, String(n));
    else if (Kfe(n)) {
      const r = await QF(n);
      t.append(e, r);
    } else if (Array.isArray(n))
      await Promise.all(n.map((r) => Pw(t, e + "[]", r)));
    else if (typeof n == "object")
      await Promise.all(Object.entries(n).map(([r, i]) => Pw(t, `${e}[${r}]`, i)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${n} instead`);
  }
};
var ehe = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n;
}, the = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t);
}, lp;
async function e3(t) {
  const { response: e } = t;
  if (t.options.stream)
    return pc("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : Zi.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const n = e.headers.get("content-type");
  if ((n == null ? void 0 : n.includes("application/json")) || (n == null ? void 0 : n.includes("application/vnd.api+json"))) {
    const s = await e.json();
    return pc("response", e.status, e.url, e.headers, s), s;
  }
  const i = await e.text();
  return pc("response", e.status, e.url, e.headers, i), i;
}
class T0 extends Promise {
  constructor(e, n = e3) {
    super((r) => {
      r(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new T0(this.responsePromise, async (n) => e(await this.parseResponse(n)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}
class nhe {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: r = 6e5,
    // 10 minutes
    httpAgent: i,
    fetch: s
  }) {
    this.baseURL = e, this.maxRetries = ty("maxRetries", n), this.timeout = ty("timeout", r), this.httpAgent = i, this.fetch = s ?? IF;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...lhe(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${fhe()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, r) {
    return this.request(Promise.resolve(r).then((i) => ({ method: e, path: n, ...i })));
  }
  getAPIList(e, n, r) {
    return this.requestAPIList(n, { method: "get", path: e, ...r });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof Buffer < "u")
        return Buffer.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    }
    return null;
  }
  buildRequest(e) {
    var p;
    const { method: n, path: r, query: i, headers: s = {} } = e, o = JM(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, a = this.calculateContentLength(o), l = this.buildURL(r, i);
    "timeout" in e && ty("timeout", e.timeout);
    const c = e.timeout ?? this.timeout, u = e.httpAgent ?? this.httpAgent ?? BF(l), d = c + 1e3;
    typeof ((p = u == null ? void 0 : u.options) == null ? void 0 : p.timeout) == "number" && d > (u.options.timeout ?? 0) && (u.options.timeout = d), this.idempotencyHeader && n !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), s[this.idempotencyHeader] = e.idempotencyKey);
    const f = this.buildHeaders({ options: e, headers: s, contentLength: a });
    return { req: {
      method: n,
      ...o && { body: o },
      headers: f,
      ...u && { agent: u },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: l, timeout: c };
  }
  buildHeaders({ options: e, headers: n, contentLength: r }) {
    const i = {};
    r && (i["content-length"] = r);
    const s = this.defaultHeaders(e);
    return tA(i, s), tA(i, n), JM(e.body) && kd !== "node" && delete i["content-type"], this.validateHeaders(i, n), i;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: r }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, r, i) {
    return Nn.generate(e, n, r, i);
  }
  request(e, n = null) {
    return new T0(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    var u, d;
    const r = await e;
    n == null && (n = r.maxRetries ?? this.maxRetries), await this.prepareOptions(r);
    const { req: i, url: s, timeout: o } = this.buildRequest(r);
    if (await this.prepareRequest(i, { url: s, options: r }), pc("request", s, r, i.headers), (u = r.signal) != null && u.aborted)
      throw new Ir();
    const a = new AbortController(), l = await this.fetchWithTimeout(s, i, o, a).catch(Lw);
    if (l instanceof Error) {
      if ((d = r.signal) != null && d.aborted)
        throw new Ir();
      if (n)
        return this.retryRequest(r, n);
      throw l.name === "AbortError" ? new KS() : new C0({ cause: l });
    }
    const c = ihe(l.headers);
    if (!l.ok) {
      if (n && this.shouldRetry(l)) {
        const v = `retrying, ${n} attempts remaining`;
        return pc(`response (error; ${v})`, l.status, s, c), this.retryRequest(r, n, c);
      }
      const f = await l.text().catch((v) => Lw(v).message), h = che(f), p = h ? void 0 : f;
      throw pc(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, l.status, s, c, p), this.makeStatusError(l.status, h, p, c);
    }
    return { response: l, options: r, controller: a };
  }
  requestAPIList(e, n) {
    const r = this.makeRequest(n, null);
    return new rhe(this, r, e);
  }
  buildURL(e, n) {
    const r = dhe(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), i = this.defaultQuery();
    return n3(i) || (n = { ...i, ...n }), typeof n == "object" && n && !Array.isArray(n) && (r.search = this.stringifyQuery(n)), r.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, r]) => typeof r < "u").map(([n, r]) => {
      if (typeof r == "string" || typeof r == "number" || typeof r == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(r)}`;
      if (r === null)
        return `${encodeURIComponent(n)}=`;
      throw new vt(`Cannot stringify type ${typeof r}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, r, i) {
    const { signal: s, ...o } = n || {};
    s && s.addEventListener("abort", () => i.abort());
    const a = setTimeout(() => i.abort(), r);
    return this.getRequestClient().fetch.call(void 0, e, { signal: i.signal, ...o }).finally(() => {
      clearTimeout(a);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, r) {
    let i;
    const s = r == null ? void 0 : r["retry-after-ms"];
    if (s) {
      const a = parseFloat(s);
      Number.isNaN(a) || (i = a);
    }
    const o = r == null ? void 0 : r["retry-after"];
    if (o && !i) {
      const a = parseFloat(o);
      Number.isNaN(a) ? i = Date.parse(o) - Date.now() : i = a * 1e3;
    }
    if (!(i && 0 <= i && i < 60 * 1e3)) {
      const a = e.maxRetries ?? this.maxRetries;
      i = this.calculateDefaultRetryTimeoutMillis(n, a);
    }
    return await oh(i), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const s = n - e, o = Math.min(0.5 * Math.pow(2, s), 8), a = 1 - Math.random() * 0.25;
    return o * a * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Wl}`;
  }
}
class t3 {
  constructor(e, n, r, i) {
    lp.set(this, void 0), ehe(this, lp, e, "f"), this.options = i, this.response = n, this.body = r;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;
  }
  async getNextPage() {
    const e = this.nextPageInfo();
    if (!e)
      throw new vt("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    const n = { ...this.options };
    if ("params" in e && typeof n.query == "object")
      n.query = { ...n.query, ...e.params };
    else if ("url" in e) {
      const r = [...Object.entries(n.query || {}), ...e.url.searchParams.entries()];
      for (const [i, s] of r)
        e.url.searchParams.set(i, s);
      n.query = void 0, n.path = e.url.toString();
    }
    return await the(this, lp, "f").requestAPIList(this.constructor, n);
  }
  async *iterPages() {
    let e = this;
    for (yield e; e.hasNextPage(); )
      e = await e.getNextPage(), yield e;
  }
  async *[(lp = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const e of this.iterPages())
      for (const n of e.getPaginatedItems())
        yield n;
  }
}
class rhe extends T0 {
  constructor(e, n, r) {
    super(n, async (i) => new r(e, i.response, await e3(i), i.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
}
const ihe = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const r = n.toString();
    return e[r.toLowerCase()] || e[r];
  }
}), she = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, Ur = (t) => typeof t == "object" && t !== null && !n3(t) && Object.keys(t).every((e) => r3(she, e)), ohe = () => {
  var e;
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Wl,
      "X-Stainless-OS": QM(Deno.build.os),
      "X-Stainless-Arch": ZM(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : ((e = Deno.version) == null ? void 0 : e.deno) ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Wl,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  if (Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Wl,
      "X-Stainless-OS": QM(process.platform),
      "X-Stainless-Arch": ZM(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  const t = ahe();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Wl,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Wl,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function ahe() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const r = n.exec(navigator.userAgent);
    if (r) {
      const i = r[1] || 0, s = r[2] || 0, o = r[3] || 0;
      return { browser: e, version: `${i}.${s}.${o}` };
    }
  }
  return null;
}
const ZM = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", QM = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let eA;
const lhe = () => eA ?? (eA = ohe()), che = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, uhe = new RegExp("^(?:[a-z]+:)?//", "i"), dhe = (t) => uhe.test(t), oh = (t) => new Promise((e) => setTimeout(e, t)), ty = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new vt(`${t} must be an integer`);
  if (e < 0)
    throw new vt(`${t} must be a positive integer`);
  return e;
}, Lw = (t) => t instanceof Error ? t : new Error(t), cp = (t) => {
  var e, n, r, i, s;
  if (typeof process < "u")
    return ((n = (e = process.env) == null ? void 0 : e[t]) == null ? void 0 : n.trim()) ?? void 0;
  if (typeof Deno < "u")
    return (s = (i = (r = Deno.env) == null ? void 0 : r.get) == null ? void 0 : i.call(r, t)) == null ? void 0 : s.trim();
};
function n3(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function r3(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function tA(t, e) {
  for (const n in e) {
    if (!r3(e, n))
      continue;
    const r = n.toLowerCase();
    if (!r)
      continue;
    const i = e[n];
    i === null ? delete t[r] : i !== void 0 && (t[r] = i);
  }
}
function pc(t, ...e) {
  var n;
  typeof process < "u" && ((n = process == null ? void 0 : process.env) == null ? void 0 : n.DEBUG) === "true" && console.log(`OpenAI:DEBUG:${t}`, ...e);
}
const fhe = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), hhe = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
function nA(t) {
  return t != null && typeof t == "object" && !Array.isArray(t);
}
class YS extends t3 {
  constructor(e, n, r, i) {
    super(e, n, r, i), this.data = r.data || [], this.object = r.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
}
class Fi extends t3 {
  constructor(e, n, r, i) {
    super(e, n, r, i), this.data = r.data || [];
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const e = this.nextPageInfo();
    if (!e)
      return null;
    if ("params" in e)
      return e.params;
    const n = Object.fromEntries(e.url.searchParams);
    return Object.keys(n).length ? n : null;
  }
  nextPageInfo() {
    var r;
    const e = this.getPaginatedItems();
    if (!e.length)
      return null;
    const n = (r = e[e.length - 1]) == null ? void 0 : r.id;
    return n ? { params: { after: n } } : null;
  }
}
class Pt {
  constructor(e) {
    this._client = e;
  }
}
let Um = class extends Pt {
  create(e, n) {
    return this._client.post("/chat/completions", { body: e, ...n, stream: e.stream ?? !1 });
  }
};
Um || (Um = {});
let Vm = class extends Pt {
  constructor() {
    super(...arguments), this.completions = new Um(this._client);
  }
};
(function(t) {
  t.Completions = Um;
})(Vm || (Vm = {}));
class Wm extends Pt {
  /**
   * Generates audio from the input text.
   */
  create(e, n) {
    return this._client.post("/audio/speech", { body: e, ...n, __binaryResponse: !0 });
  }
}
Wm || (Wm = {});
class Gm extends Pt {
  /**
   * Transcribes audio into the input language.
   */
  create(e, n) {
    return this._client.post("/audio/transcriptions", Tf({ body: e, ...n }));
  }
}
Gm || (Gm = {});
class jm extends Pt {
  /**
   * Translates audio into English.
   */
  create(e, n) {
    return this._client.post("/audio/translations", Tf({ body: e, ...n }));
  }
}
jm || (jm = {});
class qm extends Pt {
  constructor() {
    super(...arguments), this.transcriptions = new Gm(this._client), this.translations = new jm(this._client), this.speech = new Wm(this._client);
  }
}
(function(t) {
  t.Transcriptions = Gm, t.Translations = jm, t.Speech = Wm;
})(qm || (qm = {}));
class Km extends Pt {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(e, n) {
    return this._client.post("/batches", { body: e, ...n });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(e, n) {
    return this._client.get(`/batches/${e}`, n);
  }
  list(e = {}, n) {
    return Ur(e) ? this.list({}, e) : this._client.getAPIList("/batches", XS, { query: e, ...n });
  }
  /**
   * Cancels an in-progress batch.
   */
  cancel(e, n) {
    return this._client.post(`/batches/${e}/cancel`, n);
  }
}
class XS extends Fi {
}
(function(t) {
  t.BatchesPage = XS;
})(Km || (Km = {}));
class Ym extends Pt {
  /**
   * Create an assistant with a model and instructions.
   */
  create(e, n) {
    return this._client.post("/assistants", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(e, n) {
    return this._client.get(`/assistants/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(e, n, r) {
    return this._client.post(`/assistants/${e}`, {
      body: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  list(e = {}, n) {
    return Ur(e) ? this.list({}, e) : this._client.getAPIList("/assistants", JS, {
      query: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(e, n) {
    return this._client.delete(`/assistants/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
}
class JS extends Fi {
}
(function(t) {
  t.AssistantsPage = JS;
})(Ym || (Ym = {}));
function rA(t) {
  return typeof t.parse == "function";
}
const gc = (t) => (t == null ? void 0 : t.role) === "assistant", i3 = (t) => (t == null ? void 0 : t.role) === "function", s3 = (t) => (t == null ? void 0 : t.role) === "tool";
var pi = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n;
}, dt = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t);
}, Rn, Vp, Wp, $u, Bu, Gp, Fu, Os, zu, jp, qp, Gl, $w, Xm, Bw, Fw, zw, Hw, o3, Uw;
const iA = 10;
class a3 {
  constructor() {
    Rn.add(this), this.controller = new AbortController(), Vp.set(this, void 0), Wp.set(this, () => {
    }), $u.set(this, () => {
    }), Bu.set(this, void 0), Gp.set(this, () => {
    }), Fu.set(this, () => {
    }), Os.set(this, {}), this._chatCompletions = [], this.messages = [], zu.set(this, !1), jp.set(this, !1), qp.set(this, !1), Gl.set(this, !1), Hw.set(this, (e) => {
      if (pi(this, jp, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new Ir()), e instanceof Ir)
        return pi(this, qp, !0, "f"), this._emit("abort", e);
      if (e instanceof vt)
        return this._emit("error", e);
      if (e instanceof Error) {
        const n = new vt(e.message);
        return n.cause = e, this._emit("error", n);
      }
      return this._emit("error", new vt(String(e)));
    }), pi(this, Vp, new Promise((e, n) => {
      pi(this, Wp, e, "f"), pi(this, $u, n, "f");
    }), "f"), pi(this, Bu, new Promise((e, n) => {
      pi(this, Gp, e, "f"), pi(this, Fu, n, "f");
    }), "f"), dt(this, Vp, "f").catch(() => {
    }), dt(this, Bu, "f").catch(() => {
    });
  }
  _run(e) {
    setTimeout(() => {
      e().then(() => {
        this._emitFinal(), this._emit("end");
      }, dt(this, Hw, "f"));
    }, 0);
  }
  _addChatCompletion(e) {
    var r;
    this._chatCompletions.push(e), this._emit("chatCompletion", e);
    const n = (r = e.choices[0]) == null ? void 0 : r.message;
    return n && this._addMessage(n), e;
  }
  _addMessage(e, n = !0) {
    if ("content" in e || (e.content = null), this.messages.push(e), n) {
      if (this._emit("message", e), (i3(e) || s3(e)) && e.content)
        this._emit("functionCallResult", e.content);
      else if (gc(e) && e.function_call)
        this._emit("functionCall", e.function_call);
      else if (gc(e) && e.tool_calls)
        for (const r of e.tool_calls)
          r.type === "function" && this._emit("functionCall", r.function);
    }
  }
  _connected() {
    this.ended || (dt(this, Wp, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return dt(this, zu, "f");
  }
  get errored() {
    return dt(this, jp, "f");
  }
  get aborted() {
    return dt(this, qp, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(e, n) {
    return (dt(this, Os, "f")[e] || (dt(this, Os, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(e, n) {
    const r = dt(this, Os, "f")[e];
    if (!r)
      return this;
    const i = r.findIndex((s) => s.listener === n);
    return i >= 0 && r.splice(i, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(e, n) {
    return (dt(this, Os, "f")[e] || (dt(this, Os, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, r) => {
      pi(this, Gl, !0, "f"), e !== "error" && this.once("error", r), this.once(e, n);
    });
  }
  async done() {
    pi(this, Gl, !0, "f"), await dt(this, Bu, "f");
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    if (!e)
      throw new vt("stream ended without producing a ChatCompletion");
    return e;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), dt(this, Rn, "m", $w).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), dt(this, Rn, "m", Xm).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    return await this.done(), dt(this, Rn, "m", Bw).call(this);
  }
  async finalFunctionCallResult() {
    return await this.done(), dt(this, Rn, "m", Fw).call(this);
  }
  async totalUsage() {
    return await this.done(), dt(this, Rn, "m", zw).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emit(e, ...n) {
    if (dt(this, zu, "f"))
      return;
    e === "end" && (pi(this, zu, !0, "f"), dt(this, Gp, "f").call(this));
    const r = dt(this, Os, "f")[e];
    if (r && (dt(this, Os, "f")[e] = r.filter((i) => !i.once), r.forEach(({ listener: i }) => i(...n))), e === "abort") {
      const i = n[0];
      !dt(this, Gl, "f") && !(r != null && r.length) && Promise.reject(i), dt(this, $u, "f").call(this, i), dt(this, Fu, "f").call(this, i), this._emit("end");
      return;
    }
    if (e === "error") {
      const i = n[0];
      !dt(this, Gl, "f") && !(r != null && r.length) && Promise.reject(i), dt(this, $u, "f").call(this, i), dt(this, Fu, "f").call(this, i), this._emit("end");
    }
  }
  _emitFinal() {
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    e && this._emit("finalChatCompletion", e);
    const n = dt(this, Rn, "m", Xm).call(this);
    n && this._emit("finalMessage", n);
    const r = dt(this, Rn, "m", $w).call(this);
    r && this._emit("finalContent", r);
    const i = dt(this, Rn, "m", Bw).call(this);
    i && this._emit("finalFunctionCall", i);
    const s = dt(this, Rn, "m", Fw).call(this);
    s != null && this._emit("finalFunctionCallResult", s), this._chatCompletions.some((o) => o.usage) && this._emit("totalUsage", dt(this, Rn, "m", zw).call(this));
  }
  async _createChatCompletion(e, n, r) {
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort())), dt(this, Rn, "m", o3).call(this, n);
    const s = await e.create({ ...n, stream: !1 }, { ...r, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion(s);
  }
  async _runChatCompletion(e, n, r) {
    for (const i of n.messages)
      this._addMessage(i, !1);
    return await this._createChatCompletion(e, n, r);
  }
  async _runFunctions(e, n, r) {
    var f;
    const i = "function", { function_call: s = "auto", stream: o, ...a } = n, l = typeof s != "string" && (s == null ? void 0 : s.name), { maxChatCompletions: c = iA } = r || {}, u = {};
    for (const h of n.functions)
      u[h.name || h.function.name] = h;
    const d = n.functions.map((h) => ({
      name: h.name || h.function.name,
      parameters: h.parameters,
      description: h.description
    }));
    for (const h of n.messages)
      this._addMessage(h, !1);
    for (let h = 0; h < c; ++h) {
      const g = (f = (await this._createChatCompletion(e, {
        ...a,
        function_call: s,
        functions: d,
        messages: [...this.messages]
      }, r)).choices[0]) == null ? void 0 : f.message;
      if (!g)
        throw new vt("missing message in ChatCompletion response");
      if (!g.function_call)
        return;
      const { name: m, arguments: v } = g.function_call, y = u[m];
      if (y) {
        if (l && l !== m) {
          const w = `Invalid function_call: ${JSON.stringify(m)}. ${JSON.stringify(l)} requested. Please try again`;
          this._addMessage({ role: i, name: m, content: w });
          continue;
        }
      } else {
        const w = `Invalid function_call: ${JSON.stringify(m)}. Available options are: ${d.map((S) => JSON.stringify(S.name)).join(", ")}. Please try again`;
        this._addMessage({ role: i, name: m, content: w });
        continue;
      }
      let E;
      try {
        E = rA(y) ? await y.parse(v) : v;
      } catch (w) {
        this._addMessage({
          role: i,
          name: m,
          content: w instanceof Error ? w.message : String(w)
        });
        continue;
      }
      const b = await y.function(E, this), _ = dt(this, Rn, "m", Uw).call(this, b);
      if (this._addMessage({ role: i, name: m, content: _ }), l)
        return;
    }
  }
  async _runTools(e, n, r) {
    var f, h;
    const i = "tool", { tool_choice: s = "auto", stream: o, ...a } = n, l = typeof s != "string" && ((f = s == null ? void 0 : s.function) == null ? void 0 : f.name), { maxChatCompletions: c = iA } = r || {}, u = {};
    for (const p of n.tools)
      p.type === "function" && (u[p.function.name || p.function.function.name] = p.function);
    const d = "tools" in n ? n.tools.map((p) => p.type === "function" ? {
      type: "function",
      function: {
        name: p.function.name || p.function.function.name,
        parameters: p.function.parameters,
        description: p.function.description
      }
    } : p) : void 0;
    for (const p of n.messages)
      this._addMessage(p, !1);
    for (let p = 0; p < c; ++p) {
      const m = (h = (await this._createChatCompletion(e, {
        ...a,
        tool_choice: s,
        tools: d,
        messages: [...this.messages]
      }, r)).choices[0]) == null ? void 0 : h.message;
      if (!m)
        throw new vt("missing message in ChatCompletion response");
      if (!m.tool_calls)
        return;
      for (const v of m.tool_calls) {
        if (v.type !== "function")
          continue;
        const y = v.id, { name: E, arguments: b } = v.function, _ = u[E];
        if (_) {
          if (l && l !== E) {
            const k = `Invalid tool_call: ${JSON.stringify(E)}. ${JSON.stringify(l)} requested. Please try again`;
            this._addMessage({ role: i, tool_call_id: y, content: k });
            continue;
          }
        } else {
          const k = `Invalid tool_call: ${JSON.stringify(E)}. Available options are: ${d.map((T) => JSON.stringify(T.function.name)).join(", ")}. Please try again`;
          this._addMessage({ role: i, tool_call_id: y, content: k });
          continue;
        }
        let w;
        try {
          w = rA(_) ? await _.parse(b) : b;
        } catch (k) {
          const T = k instanceof Error ? k.message : String(k);
          this._addMessage({ role: i, tool_call_id: y, content: T });
          continue;
        }
        const S = await _.function(w, this), x = dt(this, Rn, "m", Uw).call(this, S);
        if (this._addMessage({ role: i, tool_call_id: y, content: x }), l)
          return;
      }
    }
  }
}
Vp = /* @__PURE__ */ new WeakMap(), Wp = /* @__PURE__ */ new WeakMap(), $u = /* @__PURE__ */ new WeakMap(), Bu = /* @__PURE__ */ new WeakMap(), Gp = /* @__PURE__ */ new WeakMap(), Fu = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakMap(), zu = /* @__PURE__ */ new WeakMap(), jp = /* @__PURE__ */ new WeakMap(), qp = /* @__PURE__ */ new WeakMap(), Gl = /* @__PURE__ */ new WeakMap(), Hw = /* @__PURE__ */ new WeakMap(), Rn = /* @__PURE__ */ new WeakSet(), $w = function() {
  return dt(this, Rn, "m", Xm).call(this).content ?? null;
}, Xm = function() {
  let e = this.messages.length;
  for (; e-- > 0; ) {
    const n = this.messages[e];
    if (gc(n))
      return { ...n, content: n.content ?? null };
  }
  throw new vt("stream ended without producing a ChatCompletionMessage with role=assistant");
}, Bw = function() {
  var e, n;
  for (let r = this.messages.length - 1; r >= 0; r--) {
    const i = this.messages[r];
    if (gc(i) && (i != null && i.function_call))
      return i.function_call;
    if (gc(i) && ((e = i == null ? void 0 : i.tool_calls) != null && e.length))
      return (n = i.tool_calls.at(-1)) == null ? void 0 : n.function;
  }
}, Fw = function() {
  for (let e = this.messages.length - 1; e >= 0; e--) {
    const n = this.messages[e];
    if (i3(n) && n.content != null || s3(n) && n.content != null && this.messages.some((r) => {
      var i;
      return r.role === "assistant" && ((i = r.tool_calls) == null ? void 0 : i.some((s) => s.type === "function" && s.id === n.tool_call_id));
    }))
      return n.content;
  }
}, zw = function() {
  const e = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: n } of this._chatCompletions)
    n && (e.completion_tokens += n.completion_tokens, e.prompt_tokens += n.prompt_tokens, e.total_tokens += n.total_tokens);
  return e;
}, o3 = function(e) {
  if (e.n != null && e.n > 1)
    throw new vt("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, Uw = function(e) {
  return typeof e == "string" ? e : e === void 0 ? "undefined" : JSON.stringify(e);
};
class Of extends a3 {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(e, n, r) {
    const i = new Of(), s = {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return i._run(() => i._runFunctions(e, n, s)), i;
  }
  static runTools(e, n, r) {
    const i = new Of(), s = {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return i._run(() => i._runTools(e, n, s)), i;
  }
  _addMessage(e) {
    super._addMessage(e), gc(e) && e.content && this._emit("content", e.content);
  }
}
var gi = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t);
}, ny = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n;
}, Vi, no, ry, iy, up, sA;
class Mf extends a3 {
  constructor() {
    super(...arguments), Vi.add(this), no.set(this, void 0);
  }
  get currentChatCompletionSnapshot() {
    return gi(this, no, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const n = new Mf();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  static createChatCompletion(e, n, r) {
    const i = new Mf();
    return i._run(() => i._runChatCompletion(e, { ...n, stream: !0 }, { ...r, headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "stream" } })), i;
  }
  async _createChatCompletion(e, n, r) {
    var o;
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort())), gi(this, Vi, "m", ry).call(this);
    const s = await e.create({ ...n, stream: !0 }, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const a of s)
      gi(this, Vi, "m", iy).call(this, a);
    if ((o = s.controller.signal) != null && o.aborted)
      throw new Ir();
    return this._addChatCompletion(gi(this, Vi, "m", up).call(this));
  }
  async _fromReadableStream(e, n) {
    var o;
    const r = n == null ? void 0 : n.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), gi(this, Vi, "m", ry).call(this), this._connected();
    const i = Zi.fromReadableStream(e, this.controller);
    let s;
    for await (const a of i)
      s && s !== a.id && this._addChatCompletion(gi(this, Vi, "m", up).call(this)), gi(this, Vi, "m", iy).call(this, a), s = a.id;
    if ((o = i.controller.signal) != null && o.aborted)
      throw new Ir();
    return this._addChatCompletion(gi(this, Vi, "m", up).call(this));
  }
  [(no = /* @__PURE__ */ new WeakMap(), Vi = /* @__PURE__ */ new WeakSet(), ry = function() {
    this.ended || ny(this, no, void 0, "f");
  }, iy = function(n) {
    var o, a, l;
    if (this.ended)
      return;
    const r = gi(this, Vi, "m", sA).call(this, n);
    this._emit("chunk", n, r);
    const i = (a = (o = n.choices[0]) == null ? void 0 : o.delta) == null ? void 0 : a.content, s = (l = r.choices[0]) == null ? void 0 : l.message;
    i != null && (s == null ? void 0 : s.role) === "assistant" && (s != null && s.content) && this._emit("content", i, s.content);
  }, up = function() {
    if (this.ended)
      throw new vt("stream has ended, this shouldn't happen");
    const n = gi(this, no, "f");
    if (!n)
      throw new vt("request ended without sending any chunks");
    return ny(this, no, void 0, "f"), phe(n);
  }, sA = function(n) {
    var r, i, s;
    let o = gi(this, no, "f");
    const { choices: a, ...l } = n;
    o ? Object.assign(o, l) : o = ny(this, no, {
      ...l,
      choices: []
    }, "f");
    for (const { delta: c, finish_reason: u, index: d, logprobs: f = null, ...h } of n.choices) {
      let p = o.choices[d];
      if (p || (p = o.choices[d] = { finish_reason: u, index: d, message: {}, logprobs: f, ...h }), f)
        if (!p.logprobs)
          p.logprobs = Object.assign({}, f);
        else {
          const { content: b, ..._ } = f;
          Object.assign(p.logprobs, _), b && ((r = p.logprobs).content ?? (r.content = []), p.logprobs.content.push(...b));
        }
      if (u && (p.finish_reason = u), Object.assign(p, h), !c)
        continue;
      const { content: g, function_call: m, role: v, tool_calls: y, ...E } = c;
      if (Object.assign(p.message, E), g && (p.message.content = (p.message.content || "") + g), v && (p.message.role = v), m && (p.message.function_call ? (m.name && (p.message.function_call.name = m.name), m.arguments && ((i = p.message.function_call).arguments ?? (i.arguments = ""), p.message.function_call.arguments += m.arguments)) : p.message.function_call = m), y) {
        p.message.tool_calls || (p.message.tool_calls = []);
        for (const { index: b, id: _, type: w, function: S, ...x } of y) {
          const k = (s = p.message.tool_calls)[b] ?? (s[b] = {});
          Object.assign(k, x), _ && (k.id = _), w && (k.type = w), S && (k.function ?? (k.function = { arguments: "" })), S != null && S.name && (k.function.name = S.name), S != null && S.arguments && (k.function.arguments += S.arguments);
        }
      }
    }
    return o;
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let r = !1;
    return this.on("chunk", (i) => {
      const s = n.shift();
      s ? s.resolve(i) : e.push(i);
    }), this.on("end", () => {
      r = !0;
      for (const i of n)
        i.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (i) => {
      r = !0;
      for (const s of n)
        s.reject(i);
      n.length = 0;
    }), this.on("error", (i) => {
      r = !0;
      for (const s of n)
        s.reject(i);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((s, o) => n.push({ resolve: s, reject: o })).then((s) => s ? { value: s, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new Zi(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function phe(t) {
  const { id: e, choices: n, created: r, model: i, system_fingerprint: s, ...o } = t;
  return {
    ...o,
    id: e,
    choices: n.map(({ message: a, finish_reason: l, index: c, logprobs: u, ...d }) => {
      if (!l)
        throw new vt(`missing finish_reason for choice ${c}`);
      const { content: f = null, function_call: h, tool_calls: p, ...g } = a, m = a.role;
      if (!m)
        throw new vt(`missing role for choice ${c}`);
      if (h) {
        const { arguments: v, name: y } = h;
        if (v == null)
          throw new vt(`missing function_call.arguments for choice ${c}`);
        if (!y)
          throw new vt(`missing function_call.name for choice ${c}`);
        return {
          ...d,
          message: { content: f, function_call: { arguments: v, name: y }, role: m },
          finish_reason: l,
          index: c,
          logprobs: u
        };
      }
      return p ? {
        ...d,
        index: c,
        finish_reason: l,
        logprobs: u,
        message: {
          ...g,
          role: m,
          content: f,
          tool_calls: p.map((v, y) => {
            const { function: E, type: b, id: _, ...w } = v, { arguments: S, name: x, ...k } = E || {};
            if (_ == null)
              throw new vt(`missing choices[${c}].tool_calls[${y}].id
${dp(t)}`);
            if (b == null)
              throw new vt(`missing choices[${c}].tool_calls[${y}].type
${dp(t)}`);
            if (x == null)
              throw new vt(`missing choices[${c}].tool_calls[${y}].function.name
${dp(t)}`);
            if (S == null)
              throw new vt(`missing choices[${c}].tool_calls[${y}].function.arguments
${dp(t)}`);
            return { ...w, id: _, type: b, function: { ...k, name: x, arguments: S } };
          })
        }
      } : {
        ...d,
        message: { ...g, content: f, role: m },
        finish_reason: l,
        index: c,
        logprobs: u
      };
    }),
    created: r,
    model: i,
    object: "chat.completion",
    ...s ? { system_fingerprint: s } : {}
  };
}
function dp(t) {
  return JSON.stringify(t);
}
class mc extends Mf {
  static fromReadableStream(e) {
    const n = new mc();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(e, n, r) {
    const i = new mc(), s = {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return i._run(() => i._runFunctions(e, n, s)), i;
  }
  static runTools(e, n, r) {
    const i = new mc(), s = {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return i._run(() => i._runTools(e, n, s)), i;
  }
}
let l3 = class extends Pt {
  runFunctions(e, n) {
    return e.stream ? mc.runFunctions(this._client.chat.completions, e, n) : Of.runFunctions(this._client.chat.completions, e, n);
  }
  runTools(e, n) {
    return e.stream ? mc.runTools(this._client.chat.completions, e, n) : Of.runTools(this._client.chat.completions, e, n);
  }
  /**
   * Creates a chat completion stream
   */
  stream(e, n) {
    return Mf.createChatCompletion(this._client.chat.completions, e, n);
  }
};
class Jm extends Pt {
  constructor() {
    super(...arguments), this.completions = new l3(this._client);
  }
}
(function(t) {
  t.Completions = l3;
})(Jm || (Jm = {}));
var mi = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n;
}, Wt = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t);
}, Kp, Yp, Hu, Uu, Xp, Vu, Ms, Wu, Jp, Zp, jl, Vw;
class ghe {
  constructor() {
    this.controller = new AbortController(), Kp.set(this, void 0), Yp.set(this, () => {
    }), Hu.set(this, () => {
    }), Uu.set(this, void 0), Xp.set(this, () => {
    }), Vu.set(this, () => {
    }), Ms.set(this, {}), Wu.set(this, !1), Jp.set(this, !1), Zp.set(this, !1), jl.set(this, !1), Vw.set(this, (e) => {
      if (mi(this, Jp, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new Ir()), e instanceof Ir)
        return mi(this, Zp, !0, "f"), this._emit("abort", e);
      if (e instanceof vt)
        return this._emit("error", e);
      if (e instanceof Error) {
        const n = new vt(e.message);
        return n.cause = e, this._emit("error", n);
      }
      return this._emit("error", new vt(String(e)));
    }), mi(this, Kp, new Promise((e, n) => {
      mi(this, Yp, e, "f"), mi(this, Hu, n, "f");
    }), "f"), mi(this, Uu, new Promise((e, n) => {
      mi(this, Xp, e, "f"), mi(this, Vu, n, "f");
    }), "f"), Wt(this, Kp, "f").catch(() => {
    }), Wt(this, Uu, "f").catch(() => {
    });
  }
  _run(e) {
    setTimeout(() => {
      e().then(() => {
        this._emit("end");
      }, Wt(this, Vw, "f"));
    }, 0);
  }
  _addRun(e) {
    return e;
  }
  _connected() {
    this.ended || (Wt(this, Yp, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return Wt(this, Wu, "f");
  }
  get errored() {
    return Wt(this, Jp, "f");
  }
  get aborted() {
    return Wt(this, Zp, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(e, n) {
    return (Wt(this, Ms, "f")[e] || (Wt(this, Ms, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(e, n) {
    const r = Wt(this, Ms, "f")[e];
    if (!r)
      return this;
    const i = r.findIndex((s) => s.listener === n);
    return i >= 0 && r.splice(i, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(e, n) {
    return (Wt(this, Ms, "f")[e] || (Wt(this, Ms, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, r) => {
      mi(this, jl, !0, "f"), e !== "error" && this.once("error", r), this.once(e, n);
    });
  }
  async done() {
    mi(this, jl, !0, "f"), await Wt(this, Uu, "f");
  }
  _emit(e, ...n) {
    if (Wt(this, Wu, "f"))
      return;
    e === "end" && (mi(this, Wu, !0, "f"), Wt(this, Xp, "f").call(this));
    const r = Wt(this, Ms, "f")[e];
    if (r && (Wt(this, Ms, "f")[e] = r.filter((i) => !i.once), r.forEach(({ listener: i }) => i(...n))), e === "abort") {
      const i = n[0];
      !Wt(this, jl, "f") && !(r != null && r.length) && Promise.reject(i), Wt(this, Hu, "f").call(this, i), Wt(this, Vu, "f").call(this, i), this._emit("end");
      return;
    }
    if (e === "error") {
      const i = n[0];
      !Wt(this, jl, "f") && !(r != null && r.length) && Promise.reject(i), Wt(this, Hu, "f").call(this, i), Wt(this, Vu, "f").call(this, i), this._emit("end");
    }
  }
  async _threadAssistantStream(e, n, r) {
    return await this._createThreadAssistantStream(n, e, r);
  }
  async _runAssistantStream(e, n, r, i) {
    return await this._createAssistantStream(n, e, r, i);
  }
  async _runToolAssistantStream(e, n, r, i, s) {
    return await this._createToolAssistantStream(r, e, n, i, s);
  }
  async _createThreadAssistantStream(e, n, r) {
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
    const s = await e.createAndRun({ ...n, stream: !1 }, { ...r, signal: this.controller.signal });
    return this._connected(), this._addRun(s);
  }
  async _createToolAssistantStream(e, n, r, i, s) {
    const o = s == null ? void 0 : s.signal;
    o && (o.aborted && this.controller.abort(), o.addEventListener("abort", () => this.controller.abort()));
    const a = await e.submitToolOutputs(n, r, { ...i, stream: !1 }, { ...s, signal: this.controller.signal });
    return this._connected(), this._addRun(a);
  }
  async _createAssistantStream(e, n, r, i) {
    const s = i == null ? void 0 : i.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort()));
    const o = await e.create(n, { ...r, stream: !1 }, { ...i, signal: this.controller.signal });
    return this._connected(), this._addRun(o);
  }
}
Kp = /* @__PURE__ */ new WeakMap(), Yp = /* @__PURE__ */ new WeakMap(), Hu = /* @__PURE__ */ new WeakMap(), Uu = /* @__PURE__ */ new WeakMap(), Xp = /* @__PURE__ */ new WeakMap(), Vu = /* @__PURE__ */ new WeakMap(), Ms = /* @__PURE__ */ new WeakMap(), Wu = /* @__PURE__ */ new WeakMap(), Jp = /* @__PURE__ */ new WeakMap(), Zp = /* @__PURE__ */ new WeakMap(), jl = /* @__PURE__ */ new WeakMap(), Vw = /* @__PURE__ */ new WeakMap();
var Ge = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t);
}, xr = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n;
}, Tn, Ww, qi, Qp, vi, wa, nc, da, Zm, kr, eg, tg, Cd, Gu, ju, oA, aA, lA, cA, uA, dA, fA;
class xi extends ghe {
  constructor() {
    super(...arguments), Tn.add(this), Ww.set(this, []), qi.set(this, {}), Qp.set(this, {}), vi.set(this, void 0), wa.set(this, void 0), nc.set(this, void 0), da.set(this, void 0), Zm.set(this, void 0), kr.set(this, void 0), eg.set(this, void 0), tg.set(this, void 0), Cd.set(this, void 0);
  }
  [(Ww = /* @__PURE__ */ new WeakMap(), qi = /* @__PURE__ */ new WeakMap(), Qp = /* @__PURE__ */ new WeakMap(), vi = /* @__PURE__ */ new WeakMap(), wa = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakMap(), da = /* @__PURE__ */ new WeakMap(), Zm = /* @__PURE__ */ new WeakMap(), kr = /* @__PURE__ */ new WeakMap(), eg = /* @__PURE__ */ new WeakMap(), tg = /* @__PURE__ */ new WeakMap(), Cd = /* @__PURE__ */ new WeakMap(), Tn = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const e = [], n = [];
    let r = !1;
    return this.on("event", (i) => {
      const s = n.shift();
      s ? s.resolve(i) : e.push(i);
    }), this.on("end", () => {
      r = !0;
      for (const i of n)
        i.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (i) => {
      r = !0;
      for (const s of n)
        s.reject(i);
      n.length = 0;
    }), this.on("error", (i) => {
      r = !0;
      for (const s of n)
        s.reject(i);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((s, o) => n.push({ resolve: s, reject: o })).then((s) => s ? { value: s, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  static fromReadableStream(e) {
    const n = new xi();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  async _fromReadableStream(e, n) {
    var s;
    const r = n == null ? void 0 : n.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), this._connected();
    const i = Zi.fromReadableStream(e, this.controller);
    for await (const o of i)
      Ge(this, Tn, "m", Gu).call(this, o);
    if ((s = i.controller.signal) != null && s.aborted)
      throw new Ir();
    return this._addRun(Ge(this, Tn, "m", ju).call(this));
  }
  toReadableStream() {
    return new Zi(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(e, n, r, i, s) {
    const o = new xi();
    return o._run(() => o._runToolAssistantStream(e, n, r, i, {
      ...s,
      headers: { ...s == null ? void 0 : s.headers, "X-Stainless-Helper-Method": "stream" }
    })), o;
  }
  async _createToolAssistantStream(e, n, r, i, s) {
    var c;
    const o = s == null ? void 0 : s.signal;
    o && (o.aborted && this.controller.abort(), o.addEventListener("abort", () => this.controller.abort()));
    const a = { ...i, stream: !0 }, l = await e.submitToolOutputs(n, r, a, {
      ...s,
      signal: this.controller.signal
    });
    this._connected();
    for await (const u of l)
      Ge(this, Tn, "m", Gu).call(this, u);
    if ((c = l.controller.signal) != null && c.aborted)
      throw new Ir();
    return this._addRun(Ge(this, Tn, "m", ju).call(this));
  }
  static createThreadAssistantStream(e, n, r) {
    const i = new xi();
    return i._run(() => i._threadAssistantStream(e, n, {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "stream" }
    })), i;
  }
  static createAssistantStream(e, n, r, i) {
    const s = new xi();
    return s._run(() => s._runAssistantStream(e, n, r, {
      ...i,
      headers: { ...i == null ? void 0 : i.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  currentEvent() {
    return Ge(this, eg, "f");
  }
  currentRun() {
    return Ge(this, tg, "f");
  }
  currentMessageSnapshot() {
    return Ge(this, vi, "f");
  }
  currentRunStepSnapshot() {
    return Ge(this, Cd, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values(Ge(this, qi, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values(Ge(this, Qp, "f"));
  }
  async finalRun() {
    if (await this.done(), !Ge(this, wa, "f"))
      throw Error("Final run was not received.");
    return Ge(this, wa, "f");
  }
  async _createThreadAssistantStream(e, n, r) {
    var a;
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
    const s = { ...n, stream: !0 }, o = await e.createAndRun(s, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const l of o)
      Ge(this, Tn, "m", Gu).call(this, l);
    if ((a = o.controller.signal) != null && a.aborted)
      throw new Ir();
    return this._addRun(Ge(this, Tn, "m", ju).call(this));
  }
  async _createAssistantStream(e, n, r, i) {
    var l;
    const s = i == null ? void 0 : i.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort()));
    const o = { ...r, stream: !0 }, a = await e.create(n, o, { ...i, signal: this.controller.signal });
    this._connected();
    for await (const c of a)
      Ge(this, Tn, "m", Gu).call(this, c);
    if ((l = a.controller.signal) != null && l.aborted)
      throw new Ir();
    return this._addRun(Ge(this, Tn, "m", ju).call(this));
  }
  static accumulateDelta(e, n) {
    for (const [r, i] of Object.entries(n)) {
      if (!e.hasOwnProperty(r)) {
        e[r] = i;
        continue;
      }
      let s = e[r];
      if (s == null) {
        e[r] = i;
        continue;
      }
      if (r === "index" || r === "type") {
        e[r] = i;
        continue;
      }
      if (typeof s == "string" && typeof i == "string")
        s += i;
      else if (typeof s == "number" && typeof i == "number")
        s += i;
      else if (nA(s) && nA(i))
        s = this.accumulateDelta(s, i);
      else if (Array.isArray(s) && Array.isArray(i)) {
        if (s.every((o) => typeof o == "string" || typeof o == "number")) {
          s.push(...i);
          continue;
        }
      } else
        throw Error(`Unhandled record type: ${r}, deltaValue: ${i}, accValue: ${s}`);
      e[r] = s;
    }
    return e;
  }
}
Gu = function(e) {
  if (!this.ended)
    switch (xr(this, eg, e, "f"), Ge(this, Tn, "m", lA).call(this, e), e.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        Ge(this, Tn, "m", fA).call(this, e);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        Ge(this, Tn, "m", aA).call(this, e);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        Ge(this, Tn, "m", oA).call(this, e);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, ju = function() {
  if (this.ended)
    throw new vt("stream has ended, this shouldn't happen");
  if (!Ge(this, wa, "f"))
    throw Error("Final run has not been received");
  return Ge(this, wa, "f");
}, oA = function(e) {
  const [n, r] = Ge(this, Tn, "m", uA).call(this, e, Ge(this, vi, "f"));
  xr(this, vi, n, "f"), Ge(this, Qp, "f")[n.id] = n;
  for (const i of r) {
    const s = n.content[i.index];
    (s == null ? void 0 : s.type) == "text" && this._emit("textCreated", s.text);
  }
  switch (e.event) {
    case "thread.message.created":
      this._emit("messageCreated", e.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", e.data.delta, n), e.data.delta.content)
        for (const i of e.data.delta.content) {
          if (i.type == "text" && i.text) {
            let s = i.text, o = n.content[i.index];
            if (o && o.type == "text")
              this._emit("textDelta", s, o.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (i.index != Ge(this, nc, "f")) {
            if (Ge(this, da, "f"))
              switch (Ge(this, da, "f").type) {
                case "text":
                  this._emit("textDone", Ge(this, da, "f").text, Ge(this, vi, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", Ge(this, da, "f").image_file, Ge(this, vi, "f"));
                  break;
              }
            xr(this, nc, i.index, "f");
          }
          xr(this, da, n.content[i.index], "f");
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (Ge(this, nc, "f") !== void 0) {
        const i = e.data.content[Ge(this, nc, "f")];
        if (i)
          switch (i.type) {
            case "image_file":
              this._emit("imageFileDone", i.image_file, Ge(this, vi, "f"));
              break;
            case "text":
              this._emit("textDone", i.text, Ge(this, vi, "f"));
              break;
          }
      }
      Ge(this, vi, "f") && this._emit("messageDone", e.data), xr(this, vi, void 0, "f");
  }
}, aA = function(e) {
  const n = Ge(this, Tn, "m", cA).call(this, e);
  switch (xr(this, Cd, n, "f"), e.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", e.data);
      break;
    case "thread.run.step.delta":
      const r = e.data.delta;
      if (r.step_details && r.step_details.type == "tool_calls" && r.step_details.tool_calls && n.step_details.type == "tool_calls")
        for (const s of r.step_details.tool_calls)
          s.index == Ge(this, Zm, "f") ? this._emit("toolCallDelta", s, n.step_details.tool_calls[s.index]) : (Ge(this, kr, "f") && this._emit("toolCallDone", Ge(this, kr, "f")), xr(this, Zm, s.index, "f"), xr(this, kr, n.step_details.tool_calls[s.index], "f"), Ge(this, kr, "f") && this._emit("toolCallCreated", Ge(this, kr, "f")));
      this._emit("runStepDelta", e.data.delta, n);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      xr(this, Cd, void 0, "f"), e.data.step_details.type == "tool_calls" && Ge(this, kr, "f") && (this._emit("toolCallDone", Ge(this, kr, "f")), xr(this, kr, void 0, "f")), this._emit("runStepDone", e.data, n);
      break;
  }
}, lA = function(e) {
  Ge(this, Ww, "f").push(e), this._emit("event", e);
}, cA = function(e) {
  switch (e.event) {
    case "thread.run.step.created":
      return Ge(this, qi, "f")[e.data.id] = e.data, e.data;
    case "thread.run.step.delta":
      let n = Ge(this, qi, "f")[e.data.id];
      if (!n)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let r = e.data;
      if (r.delta) {
        const i = xi.accumulateDelta(n, r.delta);
        Ge(this, qi, "f")[e.data.id] = i;
      }
      return Ge(this, qi, "f")[e.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      Ge(this, qi, "f")[e.data.id] = e.data;
      break;
  }
  if (Ge(this, qi, "f")[e.data.id])
    return Ge(this, qi, "f")[e.data.id];
  throw new Error("No snapshot available");
}, uA = function(e, n) {
  let r = [];
  switch (e.event) {
    case "thread.message.created":
      return [e.data, r];
    case "thread.message.delta":
      if (!n)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let i = e.data;
      if (i.delta.content)
        for (const s of i.delta.content)
          if (s.index in n.content) {
            let o = n.content[s.index];
            n.content[s.index] = Ge(this, Tn, "m", dA).call(this, s, o);
          } else
            n.content[s.index] = s, r.push(s);
      return [n, r];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (n)
        return [n, r];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, dA = function(e, n) {
  return xi.accumulateDelta(n, e);
}, fA = function(e) {
  switch (xr(this, tg, e.data, "f"), e.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      xr(this, wa, e.data, "f"), Ge(this, kr, "f") && (this._emit("toolCallDone", Ge(this, kr, "f")), xr(this, kr, void 0, "f"));
      break;
  }
};
class Qm extends Pt {
  /**
   * Create a message.
   */
  create(e, n, r) {
    return this._client.post(`/threads/${e}/messages`, {
      body: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(e, n, r) {
    return this._client.get(`/threads/${e}/messages/${n}`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(e, n, r, i) {
    return this._client.post(`/threads/${e}/messages/${n}`, {
      body: r,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v2", ...i == null ? void 0 : i.headers }
    });
  }
  list(e, n = {}, r) {
    return Ur(n) ? this.list(e, {}, n) : this._client.getAPIList(`/threads/${e}/messages`, ZS, {
      query: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Deletes a message.
   */
  del(e, n, r) {
    return this._client.delete(`/threads/${e}/messages/${n}`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
}
class ZS extends Fi {
}
(function(t) {
  t.MessagesPage = ZS;
})(Qm || (Qm = {}));
class ev extends Pt {
  /**
   * Retrieves a run step.
   */
  retrieve(e, n, r, i) {
    return this._client.get(`/threads/${e}/runs/${n}/steps/${r}`, {
      ...i,
      headers: { "OpenAI-Beta": "assistants=v2", ...i == null ? void 0 : i.headers }
    });
  }
  list(e, n, r = {}, i) {
    return Ur(r) ? this.list(e, n, {}, r) : this._client.getAPIList(`/threads/${e}/runs/${n}/steps`, QS, {
      query: r,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v2", ...i == null ? void 0 : i.headers }
    });
  }
}
class QS extends Fi {
}
(function(t) {
  t.RunStepsPage = QS;
})(ev || (ev = {}));
class tv extends Pt {
  constructor() {
    super(...arguments), this.steps = new ev(this._client);
  }
  create(e, n, r) {
    return this._client.post(`/threads/${e}/runs`, {
      body: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers },
      stream: n.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(e, n, r) {
    return this._client.get(`/threads/${e}/runs/${n}`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(e, n, r, i) {
    return this._client.post(`/threads/${e}/runs/${n}`, {
      body: r,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v2", ...i == null ? void 0 : i.headers }
    });
  }
  list(e, n = {}, r) {
    return Ur(n) ? this.list(e, {}, n) : this._client.getAPIList(`/threads/${e}/runs`, ex, {
      query: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(e, n, r) {
    return this._client.post(`/threads/${e}/runs/${n}/cancel`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(e, n, r) {
    const i = await this.create(e, n, r);
    return await this.poll(e, i.id, r);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(e, n, r) {
    return xi.createAssistantStream(e, this._client.beta.threads.runs, n, r);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(e, n, r) {
    const i = { ...r == null ? void 0 : r.headers, "X-Stainless-Poll-Helper": "true" };
    for (r != null && r.pollIntervalMs && (i["X-Stainless-Custom-Poll-Interval"] = r.pollIntervalMs.toString()); ; ) {
      const { data: s, response: o } = await this.retrieve(e, n, {
        ...r,
        headers: { ...r == null ? void 0 : r.headers, ...i }
      }).withResponse();
      switch (s.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let a = 5e3;
          if (r != null && r.pollIntervalMs)
            a = r.pollIntervalMs;
          else {
            const l = o.headers.get("openai-poll-after-ms");
            if (l) {
              const c = parseInt(l);
              isNaN(c) || (a = c);
            }
          }
          await oh(a);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return s;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(e, n, r) {
    return xi.createAssistantStream(e, this._client.beta.threads.runs, n, r);
  }
  submitToolOutputs(e, n, r, i) {
    return this._client.post(`/threads/${e}/runs/${n}/submit_tool_outputs`, {
      body: r,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v2", ...i == null ? void 0 : i.headers },
      stream: r.stream ?? !1
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(e, n, r, i) {
    const s = await this.submitToolOutputs(e, n, r, i);
    return await this.poll(e, s.id, i);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(e, n, r, i) {
    return xi.createToolAssistantStream(e, n, this._client.beta.threads.runs, r, i);
  }
}
class ex extends Fi {
}
(function(t) {
  t.RunsPage = ex, t.Steps = ev, t.RunStepsPage = QS;
})(tv || (tv = {}));
class nv extends Pt {
  constructor() {
    super(...arguments), this.runs = new tv(this._client), this.messages = new Qm(this._client);
  }
  create(e = {}, n) {
    return Ur(e) ? this.create({}, e) : this._client.post("/threads", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(e, n) {
    return this._client.get(`/threads/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(e, n, r) {
    return this._client.post(`/threads/${e}`, {
      body: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(e, n) {
    return this._client.delete(`/threads/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  createAndRun(e, n) {
    return this._client.post("/threads/runs", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers },
      stream: e.stream ?? !1
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(e, n) {
    const r = await this.createAndRun(e, n);
    return await this.runs.poll(r.thread_id, r.id, n);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(e, n) {
    return xi.createThreadAssistantStream(e, this._client.beta.threads, n);
  }
}
(function(t) {
  t.Runs = tv, t.RunsPage = ex, t.Messages = Qm, t.MessagesPage = ZS;
})(nv || (nv = {}));
const mhe = async (t) => {
  const e = await Promise.allSettled(t), n = e.filter((i) => i.status === "rejected");
  if (n.length) {
    for (const i of n)
      console.error(i.reason);
    throw new Error(`${n.length} promise(s) failed - see the above errors`);
  }
  const r = [];
  for (const i of e)
    i.status === "fulfilled" && r.push(i.value);
  return r;
};
let rv = class extends Pt {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(e, n, r) {
    return this._client.post(`/vector_stores/${e}/files`, {
      body: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(e, n, r) {
    return this._client.get(`/vector_stores/${e}/files/${n}`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  list(e, n = {}, r) {
    return Ur(n) ? this.list(e, {}, n) : this._client.getAPIList(`/vector_stores/${e}/files`, O0, {
      query: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(e, n, r) {
    return this._client.delete(`/vector_stores/${e}/files/${n}`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(e, n, r) {
    const i = await this.create(e, n, r);
    return await this.poll(e, i.id, r);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(e, n, r) {
    const i = { ...r == null ? void 0 : r.headers, "X-Stainless-Poll-Helper": "true" };
    for (r != null && r.pollIntervalMs && (i["X-Stainless-Custom-Poll-Interval"] = r.pollIntervalMs.toString()); ; ) {
      const s = await this.retrieve(e, n, {
        ...r,
        headers: i
      }).withResponse(), o = s.data;
      switch (o.status) {
        case "in_progress":
          let a = 5e3;
          if (r != null && r.pollIntervalMs)
            a = r.pollIntervalMs;
          else {
            const l = s.response.headers.get("openai-poll-after-ms");
            if (l) {
              const c = parseInt(l);
              isNaN(c) || (a = c);
            }
          }
          await oh(a);
          break;
        case "failed":
        case "completed":
          return o;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(e, n, r) {
    const i = await this._client.files.create({ file: n, purpose: "assistants" }, r);
    return this.create(e, { file_id: i.id }, r);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(e, n, r) {
    const i = await this.upload(e, n, r);
    return await this.poll(e, i.id, r);
  }
};
class O0 extends Fi {
}
(function(t) {
  t.VectorStoreFilesPage = O0;
})(rv || (rv = {}));
class iv extends Pt {
  /**
   * Create a vector store file batch.
   */
  create(e, n, r) {
    return this._client.post(`/vector_stores/${e}/file_batches`, {
      body: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(e, n, r) {
    return this._client.get(`/vector_stores/${e}/file_batches/${n}`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(e, n, r) {
    return this._client.post(`/vector_stores/${e}/file_batches/${n}/cancel`, {
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(e, n, r) {
    const i = await this.create(e, n);
    return await this.poll(e, i.id, r);
  }
  listFiles(e, n, r = {}, i) {
    return Ur(r) ? this.listFiles(e, n, {}, r) : this._client.getAPIList(`/vector_stores/${e}/file_batches/${n}/files`, O0, { query: r, ...i, headers: { "OpenAI-Beta": "assistants=v2", ...i == null ? void 0 : i.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(e, n, r) {
    const i = { ...r == null ? void 0 : r.headers, "X-Stainless-Poll-Helper": "true" };
    for (r != null && r.pollIntervalMs && (i["X-Stainless-Custom-Poll-Interval"] = r.pollIntervalMs.toString()); ; ) {
      const { data: s, response: o } = await this.retrieve(e, n, {
        ...r,
        headers: i
      }).withResponse();
      switch (s.status) {
        case "in_progress":
          let a = 5e3;
          if (r != null && r.pollIntervalMs)
            a = r.pollIntervalMs;
          else {
            const l = o.headers.get("openai-poll-after-ms");
            if (l) {
              const c = parseInt(l);
              isNaN(c) || (a = c);
            }
          }
          await oh(a);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return s;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(e, { files: n, fileIds: r = [] }, i) {
    if (n === null || n.length == 0)
      throw new Error("No files provided to process.");
    const s = (i == null ? void 0 : i.maxConcurrency) ?? 5, o = Math.min(s, n.length), a = this._client, l = n.values(), c = [...r];
    async function u(f) {
      for (let h of f) {
        const p = await a.files.create({ file: h, purpose: "assistants" }, i);
        c.push(p.id);
      }
    }
    const d = Array(o).fill(l).map(u);
    return await mhe(d), await this.createAndPoll(e, {
      file_ids: c
    });
  }
}
iv || (iv = {});
class sv extends Pt {
  constructor() {
    super(...arguments), this.files = new rv(this._client), this.fileBatches = new iv(this._client);
  }
  /**
   * Create a vector store.
   */
  create(e, n) {
    return this._client.post("/vector_stores", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(e, n) {
    return this._client.get(`/vector_stores/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(e, n, r) {
    return this._client.post(`/vector_stores/${e}`, {
      body: n,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r == null ? void 0 : r.headers }
    });
  }
  list(e = {}, n) {
    return Ur(e) ? this.list({}, e) : this._client.getAPIList("/vector_stores", tx, {
      query: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(e, n) {
    return this._client.delete(`/vector_stores/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n == null ? void 0 : n.headers }
    });
  }
}
class tx extends Fi {
}
(function(t) {
  t.VectorStoresPage = tx, t.Files = rv, t.VectorStoreFilesPage = O0, t.FileBatches = iv;
})(sv || (sv = {}));
class ov extends Pt {
  constructor() {
    super(...arguments), this.vectorStores = new sv(this._client), this.chat = new Jm(this._client), this.assistants = new Ym(this._client), this.threads = new nv(this._client);
  }
}
(function(t) {
  t.VectorStores = sv, t.VectorStoresPage = tx, t.Chat = Jm, t.Assistants = Ym, t.AssistantsPage = JS, t.Threads = nv;
})(ov || (ov = {}));
class av extends Pt {
  create(e, n) {
    return this._client.post("/completions", { body: e, ...n, stream: e.stream ?? !1 });
  }
}
av || (av = {});
class lv extends Pt {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(e, n) {
    return this._client.post("/embeddings", { body: e, ...n });
  }
}
lv || (lv = {});
class cv extends Pt {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files.
   *
   * The Batch API only supports `.jsonl` files up to 100 MB in size.
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(e, n) {
    return this._client.post("/files", Tf({ body: e, ...n }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(e, n) {
    return this._client.get(`/files/${e}`, n);
  }
  list(e = {}, n) {
    return Ur(e) ? this.list({}, e) : this._client.getAPIList("/files", nx, { query: e, ...n });
  }
  /**
   * Delete a file.
   */
  del(e, n) {
    return this._client.delete(`/files/${e}`, n);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(e, n) {
    return this._client.get(`/files/${e}/content`, { ...n, __binaryResponse: !0 });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(e, n) {
    return this._client.get(`/files/${e}/content`, {
      ...n,
      headers: { Accept: "application/json", ...n == null ? void 0 : n.headers }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(e, { pollInterval: n = 5e3, maxWait: r = 30 * 60 * 1e3 } = {}) {
    const i = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), s = Date.now();
    let o = await this.retrieve(e);
    for (; !o.status || !i.has(o.status); )
      if (await oh(n), o = await this.retrieve(e), Date.now() - s > r)
        throw new KS({
          message: `Giving up on waiting for file ${e} to finish processing after ${r} milliseconds.`
        });
    return o;
  }
}
class nx extends YS {
}
(function(t) {
  t.FileObjectsPage = nx;
})(cv || (cv = {}));
class uv extends Pt {
  list(e, n = {}, r) {
    return Ur(n) ? this.list(e, {}, n) : this._client.getAPIList(`/fine_tuning/jobs/${e}/checkpoints`, rx, { query: n, ...r });
  }
}
class rx extends Fi {
}
(function(t) {
  t.FineTuningJobCheckpointsPage = rx;
})(uv || (uv = {}));
class dv extends Pt {
  constructor() {
    super(...arguments), this.checkpoints = new uv(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(e, n) {
    return this._client.post("/fine_tuning/jobs", { body: e, ...n });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(e, n) {
    return this._client.get(`/fine_tuning/jobs/${e}`, n);
  }
  list(e = {}, n) {
    return Ur(e) ? this.list({}, e) : this._client.getAPIList("/fine_tuning/jobs", ix, { query: e, ...n });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(e, n) {
    return this._client.post(`/fine_tuning/jobs/${e}/cancel`, n);
  }
  listEvents(e, n = {}, r) {
    return Ur(n) ? this.listEvents(e, {}, n) : this._client.getAPIList(`/fine_tuning/jobs/${e}/events`, sx, {
      query: n,
      ...r
    });
  }
}
class ix extends Fi {
}
class sx extends Fi {
}
(function(t) {
  t.FineTuningJobsPage = ix, t.FineTuningJobEventsPage = sx, t.Checkpoints = uv, t.FineTuningJobCheckpointsPage = rx;
})(dv || (dv = {}));
class fv extends Pt {
  constructor() {
    super(...arguments), this.jobs = new dv(this._client);
  }
}
(function(t) {
  t.Jobs = dv, t.FineTuningJobsPage = ix, t.FineTuningJobEventsPage = sx;
})(fv || (fv = {}));
class hv extends Pt {
  /**
   * Creates a variation of a given image.
   */
  createVariation(e, n) {
    return this._client.post("/images/variations", Tf({ body: e, ...n }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(e, n) {
    return this._client.post("/images/edits", Tf({ body: e, ...n }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(e, n) {
    return this._client.post("/images/generations", { body: e, ...n });
  }
}
hv || (hv = {});
class pv extends Pt {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(e, n) {
    return this._client.get(`/models/${e}`, n);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(e) {
    return this._client.getAPIList("/models", ox, e);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(e, n) {
    return this._client.delete(`/models/${e}`, n);
  }
}
class ox extends YS {
}
(function(t) {
  t.ModelsPage = ox;
})(pv || (pv = {}));
class gv extends Pt {
  /**
   * Classifies if text is potentially harmful.
   */
  create(e, n) {
    return this._client.post("/moderations", { body: e, ...n });
  }
}
gv || (gv = {});
var c3;
class on extends nhe {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = cp("OPENAI_BASE_URL"), apiKey: n = cp("OPENAI_API_KEY"), organization: r = cp("OPENAI_ORG_ID") ?? null, project: i = cp("OPENAI_PROJECT_ID") ?? null, ...s } = {}) {
    if (n === void 0)
      throw new vt("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    const o = {
      apiKey: n,
      organization: r,
      project: i,
      ...s,
      baseURL: e || "https://api.openai.com/v1"
    };
    if (!o.dangerouslyAllowBrowser && hhe())
      throw new vt(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    super({
      baseURL: o.baseURL,
      timeout: o.timeout ?? 6e5,
      httpAgent: o.httpAgent,
      maxRetries: o.maxRetries,
      fetch: o.fetch
    }), this.completions = new av(this), this.chat = new Vm(this), this.embeddings = new lv(this), this.files = new cv(this), this.images = new hv(this), this.audio = new qm(this), this.moderations = new gv(this), this.models = new pv(this), this.fineTuning = new fv(this), this.beta = new ov(this), this.batches = new Km(this), this._options = o, this.apiKey = n, this.organization = r, this.project = i;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(e) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
c3 = on;
on.OpenAI = c3;
on.OpenAIError = vt;
on.APIError = Nn;
on.APIConnectionError = C0;
on.APIConnectionTimeoutError = KS;
on.APIUserAbortError = Ir;
on.NotFoundError = WF;
on.ConflictError = GF;
on.RateLimitError = qF;
on.BadRequestError = HF;
on.AuthenticationError = UF;
on.InternalServerError = KF;
on.PermissionDeniedError = VF;
on.UnprocessableEntityError = jF;
on.toFile = QF;
on.fileFromPath = FF;
(function(t) {
  t.Page = YS, t.CursorPage = Fi, t.Completions = av, t.Chat = Vm, t.Embeddings = lv, t.Files = cv, t.FileObjectsPage = nx, t.Images = hv, t.Audio = qm, t.Moderations = gv, t.Models = pv, t.ModelsPage = ox, t.FineTuning = fv, t.Beta = ov, t.Batches = Km, t.BatchesPage = XS;
})(on || (on = {}));
const ax = on, vhe = {
  height: "3em",
  viewBox: "0 0 24 24",
  width: "3em",
  xmlns: "http://www.w3.org/2000/svg"
}, bhe = /* @__PURE__ */ se("path", {
  d: "M12 3c4.97 0 9 4.03 9 9",
  fill: "none",
  stroke: "currentColor",
  "stroke-dasharray": "16",
  "stroke-dashoffset": "16",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
}, [
  /* @__PURE__ */ se("animate", {
    attributeName: "stroke-dashoffset",
    dur: "0.2s",
    fill: "freeze",
    values: "16;0"
  }),
  /* @__PURE__ */ se("animateTransform", {
    attributeName: "transform",
    dur: "1.5s",
    repeatCount: "indefinite",
    type: "rotate",
    values: "0 12 12;360 12 12"
  })
], -1), yhe = [
  bhe
], hA = /* @__PURE__ */ ae({
  __name: "LineMdLoadingLoop",
  setup(t) {
    return ae({
      name: "LineMdLoadingLoop"
    }), (e, n) => (J(), be("svg", vhe, yhe));
  }
}), whe = /* @__PURE__ */ ae({
  __name: "AiTextExt",
  props: {
    client: {
      type: ax,
      required: !0
    },
    message: {
      type: String,
      required: !0
    }
  },
  emits: ["updateStatus"],
  setup(t, { emit: e }) {
    const n = e, r = t, i = [
      {
        label: "AI续写",
        key: "xuxie",
        icon: wG
      },
      {
        label: "AI润色",
        key: "runse",
        icon: _G
      },
      {
        label: "AI翻译",
        key: "fanyi",
        icon: fG
      }
    ], s = et();
    let o;
    async function a() {
      var l, c;
      try {
        o = await r.client.chat.completions.create({
          // model: "deepseek-chat",
          model: "dall-e-3",
          messages: [{ role: "user", content: r.message }]
          // stream: true,
        }), s.value.commands.setTextSelection({
          from: s.value.state.selection.to,
          to: s.value.state.selection.to
        }), n("updateStatus", "generating");
        for await (const u of o) {
          const d = ((c = (l = u.choices[0]) == null ? void 0 : l.delta) == null ? void 0 : c.content) || "";
          d.length !== 0 && s.value.commands.insertContent({
            type: "text",
            text: d,
            attrs: { class: "custom" }
          });
        }
      } catch (u) {
        console.error(u);
      } finally {
        n("updateStatus", "completed");
      }
    }
    return (l, c) => (J(), be(Vt, null, $n(i, (u) => se("div", {
      key: u,
      class: "langeditor-hover text-sm flex items-center gap-2 langeditor-text p-2 rounded-md cursor-pointer py-1.5",
      onClick: a
    }, [
      (J(), Ze(ii(u.icon), { class: "w-3 h-3" })),
      se("span", null, Ut(u.label), 1)
    ])), 64));
  }
}), _he = /* @__PURE__ */ se("span", null, "AI文生图", -1), Ehe = /* @__PURE__ */ ae({
  __name: "AiImageExt",
  props: {
    client: {
      type: ax,
      required: !0
    },
    message: {
      type: String,
      required: !0
    }
  },
  emits: ["updateStatus"],
  setup(t, { emit: e }) {
    const n = e, r = t, i = et();
    async function s() {
      try {
        n("updateStatus", "thinking");
        const o = await r.client.images.generate({
          model: "dall-e-3",
          prompt: r.message
        });
        i.value.chain().focus().setImage({
          src: o.data[0].url
        }).run();
      } catch (o) {
        console.error(o);
      } finally {
        n("updateStatus", "completed");
      }
    }
    return (o, a) => (J(), be("div", {
      class: "langeditor-hover text-sm flex items-center gap-2 langeditor-text p-2 rounded-md cursor-pointer py-1.5",
      onClick: s
    }, [
      W(C(U_), { class: "w-3 h-3" }),
      _he
    ]));
  }
}), She = { class: "border-b langeditor-text border-[hsl(var(--border))] flex items-center gap-1" }, xhe = { class: "flex langeditor-text justify-between text-sm items-center p-2 py-1 transition-all" }, khe = { class: "flex items-center gap-2" }, Che = /* @__PURE__ */ se("div", null, "Thinking...", -1), The = { class: "flex gap-2 langeditor-text text-sm justify-between items-center p-2 py-1 transition-all" }, Ohe = { class: "flex items-center gap-2" }, Mhe = /* @__PURE__ */ se("div", null, "Generating...", -1), Ahe = { class: "p-2 py-1.5" }, Nhe = /* @__PURE__ */ ae({
  __name: "AiPopover",
  setup(t) {
    const e = et(), n = X("completed"), r = X(null), i = X(null), { isShowAiPopover: s } = EF(), o = X(!0), a = {
      maxWidth: 600,
      placement: "bottom-start",
      appendTo: () => document.body,
      onShow() {
        document.addEventListener("click", l);
      },
      onHide() {
        document.removeEventListener("click", l);
      }
    }, l = (g) => {
      if (r.value && !r.value.contains(g.target)) {
        if (o.value) {
          o.value = !1;
          return;
        }
        s.value = !1, e.value.chain().focus().unsetHighlight().run(), e.value.chain().focus().unsetColor().run();
      }
    };
    Bt(s, (g) => {
      g && setTimeout(() => {
        i.value.focus();
      }, 100);
    });
    const c = X(""), u = new ax({
      // apiKey: "sk-93698149677f409583a5199f1cb92a8a",
      // baseURL: "https://api.deepseek.com/v1",
      apiKey: "sk-JVoQ2qnmuif8thJZ4J030Qx0IOv82xt2eL7eQKOHq57aOvlD",
      baseURL: "https://all.gpts.vin/v1",
      dangerouslyAllowBrowser: !0
    });
    function d() {
    }
    function f(g) {
      n.value = g;
    }
    function h() {
      c.value = "";
    }
    function p() {
      h();
    }
    return (g, m) => (J(), Ze(C(G8), {
      editor: C(e),
      "should-show": () => C(s),
      "tippy-options": a,
      class: "sm:w-[600px] rounded-xl"
    }, {
      default: Ue(() => [
        se("div", {
          ref_key: "bubbleRef",
          ref: r,
          class: "langeditor-bg rounded-xl langeditor-border w-full gap-2 shadow-md transition-all"
        }, [
          Yr(se("div", She, [
            Yr(se("input", {
              ref_key: "inputRef",
              ref: i,
              "onUpdate:modelValue": m[0] || (m[0] = (v) => c.value = v),
              autofocus: "",
              class: "p-3 pr-1 py-2 text-sm bg-transparent w-full overflow-auto",
              placeholder: "Ask AI anything...",
              onKeydown: mA(d, ["enter"])
            }, null, 544), [
              [vc, c.value]
            ]),
            se("div", {
              class: "p-2 langeditor-hover mr-1 rounded-md transition-all",
              onClick: d
            }, [
              W(C(Ga), { class: "w-4 h-4" })
            ])
          ], 512), [
            [ql, n.value === "completed"]
          ]),
          Yr(se("div", xhe, [
            se("div", khe, [
              W(hA, { class: "w-4 h-4" }),
              Che
            ]),
            se("div", {
              class: "langeditor-hover text-sm langeditor-text p-1.5 rounded-md cursor-pointer py-1",
              onClick: p
            }, [
              W(C(lC))
            ])
          ], 512), [
            [ql, n.value === "thinking"]
          ]),
          Yr(se("div", The, [
            se("div", Ohe, [
              W(hA, { class: "w-4 h-4" }),
              Mhe
            ]),
            se("div", {
              class: "langeditor-hover text-sm langeditor-text p-1.5 rounded-md cursor-pointer py-1",
              onClick: p
            }, [
              W(C(lC))
            ])
          ], 512), [
            [ql, n.value === "generating"]
          ]),
          Yr(se("div", Ahe, [
            W(whe, {
              client: C(u),
              message: c.value,
              onUpdateStatus: f
            }, null, 8, ["client", "message"]),
            W(Ehe, {
              client: C(u),
              message: c.value,
              onUpdateStatus: f
            }, null, 8, ["client", "message"])
          ], 512), [
            [ql, n.value === "completed"]
          ])
        ], 512)
      ]),
      _: 1
    }, 8, ["editor", "should-show"]));
  }
}), Rhe = { class: "flex items-center z-[999] p-2 py-1 border-b border-[hsl(var(--border))] flex-nowrap scroll w-full overflow-x-auto" }, Dhe = /* @__PURE__ */ ae({
  __name: "LangToolbar",
  props: {
    editor: {
      type: Object,
      require: !0
    }
  },
  setup(t) {
    const e = X(!0);
    function n(r) {
      e.value = r;
    }
    return (r, i) => (J(), be("div", Rhe, [
      se("div", {
        class: It([{ "editor-readonly": !e.value }, "flex flex-nowrap w-full scroll overflow-x-auto items-center"])
      }, [
        W(C(GS), {
          "del-prefix": !1,
          mini: !1,
          class: "!w-auto"
        }),
        t.editor ? (J(), Ze(Nhe, { key: 0 })) : He("", !0),
        W(C(Aoe)),
        W(C(Roe)),
        W(C(KX)),
        W(C(Jo)),
        W(C(oI)),
        W(C(jL)),
        W(C(o$)),
        W(C(Z$)),
        W(C(T2)),
        W(C(D2)),
        W(C(Jo)),
        W(C(xre)),
        W(C(xJ)),
        W(C(C9)),
        W(C(sre)),
        W(C(foe)),
        W(C(Jo)),
        W(C(aJ)),
        W(C(X$)),
        W(C(Hde)),
        W(C(Jo)),
        W(C(Ire)),
        W(C(Lre)),
        W(C(Jo)),
        W(C(yre)),
        W(C(sne)),
        W(C(Coe)),
        W(C(ire)),
        W(C(Jo)),
        W(C(lse)),
        W(C(N9)),
        W(C(WY)),
        W(C(b9)),
        W(C(Jo)),
        W(C(XX)),
        W(C(Ife)),
        W(C(QX)),
        W(C(Rfe))
      ], 2),
      W(C(Ffe), {
        class: "flex-1 flex justify-end items-center ml-auto",
        onUpdate: n
      })
    ]));
  }
});
const Ihe = /* @__PURE__ */ wr(Dhe, [["__scopeId", "data-v-63f8bc11"]]), Phe = { class: "flex items-center px-1 py-0.5" }, Lhe = /* @__PURE__ */ ae({
  __name: "TextBubbleMenu",
  setup(t) {
    return (e, n) => (J(), be("div", Phe, [
      W(C(GS), {
        "del-prefix": !1,
        mini: !1,
        class: "w-auto"
      }),
      W(C(oI), { mini: !0 }),
      W(C(jL), { mini: !0 }),
      W(C(o$), { mini: !0 }),
      W(C(Z$), { mini: !0 }),
      W(C(T2), { mini: !0 }),
      W(C(D2), { mini: !0 }),
      W(C(X$), { mini: !0 })
    ]));
  }
}), $he = { class: "flex items-center gap-1" }, Bhe = /* @__PURE__ */ ae({
  __name: "LangBubbleMenu",
  props: {
    bubbleMenu: {
      type: Boolean,
      default: !0
    },
    editor: {
      type: xR,
      default: !0
    }
  },
  setup(t) {
    const e = t, n = X(!1), r = rt(() => {
      var h, p, g, m, v;
      if (!e.editor)
        return;
      const i = e.editor.state.selection, s = ((h = i.node) == null ? void 0 : h.type.name) === "image", o = ((p = i.node) == null ? void 0 : p.type.name) === "video", a = ((g = i.node) == null ? void 0 : g.type.name) === "magic", l = ((m = i.node) == null ? void 0 : m.type.name) === "hb-math", c = i.$anchor.parent.type.name === "codeBlock", u = i instanceof Ti, d = ((v = i.node) == null ? void 0 : v.type.name) === "table" || u, f = i instanceof Te;
      if (s)
        return "image";
      if (o)
        return "video";
      if (d)
        return "table";
      if (a)
        return "magic";
      if (l)
        return "math";
      if (c)
        return "codeBlock";
      if (f)
        return "text";
    });
    return Bt(r, () => {
      r.value === "magic" || r.value === "codeBlock" ? n.value = !0 : n.value = !1;
    }), (i, s) => t.editor && t.editor.isEditable && t.bubbleMenu && r.value ? Yr((J(), Ze(C(U8), {
      key: 0,
      editor: t.editor,
      "tippy-options": { duration: 0, maxWidth: 600, placement: "top-start" },
      "update-delay": 250,
      class: "langeditor-bg langeditor-text langeditor-border"
    }, {
      default: Ue(() => [
        se("div", $he, [
          r.value === "text" ? (J(), Ze(Lhe, { key: 0 })) : He("", !0),
          r.value === "image" ? (J(), Ze(C(lne), { key: 1 })) : He("", !0),
          r.value === "video" ? (J(), Ze(C(Ooe), { key: 2 })) : He("", !0),
          r.value === "table" ? (J(), Ze(C(soe), { key: 3 })) : He("", !0),
          r.value === "math" ? (J(), Ze(C(_re), { key: 4 })) : He("", !0)
        ])
      ]),
      _: 1
    }, 8, ["editor"])), [
      [ql, !n.value]
    ]) : He("", !0);
  }
});
const Fhe = { class: "langeditor-footer langeditor-text" }, zhe = { class: "text-xs" }, Hhe = {
  __name: "LangFooter",
  props: {
    characters: {
      type: Number,
      default: 0,
      require: !0
    }
  },
  setup(t) {
    return (e, n) => (J(), be("div", Fhe, [
      se("div", zhe, Ut(C(me)("wordCount")) + " " + Ut(t.characters), 1)
    ]));
  }
}, Uhe = /* @__PURE__ */ wr(Hhe, [["__scopeId", "data-v-d24c7f42"]]), Vhe = { class: "langeditor-text langeditor-hover mb-2.5" }, Whe = /* @__PURE__ */ ae({
  __name: "TreeItem",
  props: {
    item: {}
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const n = t, r = e, i = () => r("click", n.item.dom);
    return (s, o) => {
      const a = m3("TreeItem", !0);
      return J(), be("ul", {
        class: It([
          "transition-colors cursor-pointer mb-2.5",
          s.item.level === 1 ? "ml-0 font-normal" : "",
          s.item.level === 2 ? "ml-3" : "",
          s.item.level === 3 ? "ml-4" : ""
        ]),
        onClick: i
      }, [
        se("li", Vhe, Ut(s.item.label), 1),
        s.item.children && s.item.children.length ? (J(!0), be(Vt, { key: 0 }, $n(s.item.children, (l, c) => (J(), Ze(a, {
          key: c,
          item: l,
          onClick: (u) => s.$emit("click", l.dom)
        }, null, 8, ["item", "onClick"]))), 128)) : He("", !0)
      ], 2);
    };
  }
});
const Ghe = /* @__PURE__ */ wr(Whe, [["__scopeId", "data-v-9fe01772"]]), jhe = { class: "w-64 transition-all" }, qhe = {
  key: 0,
  class: "text-stone-500 px-4 text-[13px]"
}, Khe = { class: "mb-4 pl-[6px] font-semibold gap-1 text-sm hover:text-stone-800 cursor-pointer" }, Yhe = { class: "pl-2 max-h-[40vh] overflow-hidden overflow-y-auto" }, Xhe = /* @__PURE__ */ ae({
  __name: "TocAnchor",
  setup(t) {
    const e = et();
    X(!1);
    const n = (u) => {
      let d = [], f = 0;
      for (; f < u.length; ) {
        const h = { ...u[f] }, p = [];
        for (f++; f < u.length && u[f].level > h.level; )
          p.push(u[f]), f++;
        if (p.length > 0) {
          const g = n(p);
          g.length > 0 && (h.children = g);
        }
        d.push(h);
      }
      return d;
    }, r = X(null), i = X([]);
    function s() {
      Af(() => {
        let u = e.value.options.element;
        u.classList.contains("editor-body-page") && (u = u.parentElement), r.value = u.parentElement;
      });
    }
    Zt(() => {
      a();
    });
    const o = jy(a, 100);
    function a() {
      if (!e.value)
        return;
      let u = e.value.options.element;
      u.classList.contains("editor-body-page") && (u = u.parentElement);
      const d = [...u.querySelectorAll("h1,h2,h3,h4")], f = [];
      d.forEach((h, p) => {
        f.push({
          label: h.innerText,
          //标题
          level: parseInt(h.nodeName.slice(1), 10),
          //标题大小（1-6）
          key: p + "",
          dom: h,
          children: []
        });
      }), i.value = n(f);
    }
    zf(() => {
      e.value.on("update", o), s();
    }), Zc(() => {
      e.value.off("update", o);
    });
    function l(u) {
      u.scrollIntoView();
    }
    const c = () => {
      e.value.view.dom.scrollIntoView({ behavior: "smooth", block: "start" });
    };
    return (u, d) => (J(), be("div", jhe, [
      i.value.length ? (J(), be("nav", qhe, [
        se("div", Khe, Ut(C(me)("tocHeadTips")), 1),
        se("div", Yhe, [
          (J(!0), be(Vt, null, $n(i.value, (f, h) => (J(), Ze(Ghe, {
            key: h,
            item: f,
            onClick: (p) => l(f.dom)
          }, null, 8, ["item", "onClick"]))), 128))
        ]),
        se("div", {
          class: "mt-4 pl-[6px] flex text-stone-400 items-center gap-1 text-xs hover:text-stone-800 cursor-pointer",
          onClick: c
        }, [
          se("span", null, Ut(C(me)("tocEndTips")), 1)
        ])
      ])) : He("", !0)
    ]));
  }
}), Jhe = /* @__PURE__ */ ae({
  __name: "LangSider",
  props: {
    page: {
      type: Boolean,
      default: !0,
      required: !0
    },
    tocRight: {
      type: Boolean,
      default: !0,
      required: !0
    }
  },
  setup(t) {
    const { isShowToc: e } = _F();
    return Bt(e, () => {
    }), (n, r) => (J(), be("div", {
      class: It([{ "langeditor-side-document": !t.page, right: !t.tocRight }, "py-[3vh] flex h-full max-w-2xl transition-all border-l border-[hsl(var(--border))]"])
    }, [
      C(e) === !0 ? (J(), Ze(Xhe, { key: 0 })) : He("", !0)
    ], 2));
  }
});
const Zhe = /* @__PURE__ */ wr(Jhe, [["__scopeId", "data-v-74e358cb"]]), Qhe = /* @__PURE__ */ ae({
  __name: "LangBaseExtension",
  setup(t) {
    return (e, n) => (J(), be("div", null, [
      W(C(PX)),
      W(C(Cre)),
      W(C(rJ)),
      W(C(hne)),
      W(C(EJ)),
      W(C(BX)),
      W(C(jX)),
      W(C(hoe)),
      W(C(Mre)),
      W(C(T9)),
      W(C(voe)),
      W(C(Rde)),
      W(C(lfe))
    ]));
  }
}), epe = {
  key: 0,
  style: { width: "100%" }
}, tpe = /* @__PURE__ */ ae({
  __name: "LangEditor",
  props: {
    page: {
      type: Boolean,
      default: !0
    },
    toolbar: {
      type: Boolean,
      default: !0
    },
    dark: {
      type: Boolean,
      default: !1
    },
    bubbleMenu: {
      type: Boolean,
      default: !0
    },
    modelValue: {
      type: String,
      default: ""
    },
    to: {
      type: String,
      required: !1,
      default: ""
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    tocRight: {
      type: Boolean,
      default: !0
    },
    language: {
      type: String,
      default: "en-US"
    },
    contentClass: {
      type: String,
      default: "py-[1.2em] px-[2.5em]"
    }
  },
  emits: ["update:modelValue", "change"],
  setup(t, { expose: e, emit: n }) {
    const r = t;
    let i = [];
    const s = mv(), o = X(0), a = X(!1), l = X(null), c = X(null), u = X(!1), d = n;
    cr("useExtension", h), cr("removeExtension", p), cr("editorInstance", s);
    const f = jy(() => {
      var _;
      o.value = ((_ = s.value) == null ? void 0 : _.storage.characterCount.characters()) || 0;
    }, 300);
    function h(_) {
      i.filter((w) => w === _).length || i.push(_);
    }
    function p(_) {
      const w = i.findIndex((S) => S.name === _);
      w > -1 && i.splice(w, 1);
    }
    const g = jy((_) => {
      d("update:modelValue", _.getHTML()), f();
    }, 300);
    function m() {
      const _ = {
        content: r.modelValue,
        editable: !r.readonly,
        extensions: i,
        onUpdate: ({ editor: w }) => {
          g(w);
        },
        onFocus: () => {
          u.value = !0;
        },
        onBlur: () => {
          u.value = !1;
        },
        onSelectionUpdate: ({ editor: w }) => {
        }
      };
      s.value = new V8(_), s.value.storage.fullscreen = a, d("update:modelValue", s.value.getHTML()), d("change", s.value.getHTML()), f();
    }
    Zt(() => {
      m(), document.body.classList.add(r.dark ? "dark" : "light");
    }), Bt(
      () => r.dark,
      (_) => {
        document.body.classList.add(_ ? "dark" : "light");
      }
    ), Bt(
      () => r.readonly,
      (_) => {
        s.value && s.value.setEditable(!_);
      }
    ), Bt(
      () => r.language,
      (_) => {
        g9(_);
      }
    );
    const v = X8((_) => {
      !s.value || s.value.getHTML() === _ || s.value.commands.setContent(_, !1);
    }, 200);
    Bt(() => r.modelValue, v), Bt(a, () => {
      if (a.value === !0) {
        if (r.to) {
          c.value = l.value.parentNode;
          const _ = document.getElementById(r.to);
          _ && _.append(l.value);
        }
      } else
        r.to && c.value.append(l.value);
    }), Zc(() => {
      var _;
      (_ = s.value) == null || _.destroy();
    });
    function y(_) {
      _.keyCode === 9 && _.preventDefault();
    }
    function E() {
      return s.value;
    }
    function b() {
      m();
    }
    return e({
      getInstance: E,
      reload: b
    }), (_, w) => (J(), be("div", {
      ref_key: "editorBox",
      ref: l,
      class: It([{ fullscreen: a.value, dark: r.dark, light: !r.dark }, "langeditor-body"]),
      onKeydown: y
    }, [
      W(C(wfe)),
      W(C(afe)),
      s.value ? (J(), Ze(Bhe, {
        key: 0,
        "bubble-menu": t.bubbleMenu,
        editor: s.value
      }, null, 8, ["bubble-menu", "editor"])) : He("", !0),
      se("div", {
        class: It([{
          fullscreen: a.value,
          focus: u.value && !a.value,
          online: t.page
        }, "langeditor-content"]),
        spellcheck: "false"
      }, [
        W(Qhe),
        t.toolbar ? (J(), be("div", epe, [
          W(Ihe, { editor: s.value }, null, 8, ["editor"])
        ])) : He("", !0),
        se("div", {
          class: It({ "langeditor-head-document": !t.page })
        }, null, 2),
        se("div", {
          class: It([{ "langeditor-page-document": !t.page }, "langeditor-page"])
        }, [
          se("div", {
            class: It([{ "langeditor-core-document": !t.page }, "langeditor-core-page "])
          }, [
            W(C(W8), {
              class: It([[t.contentClass, { dark: r.dark, light: !r.dark }], "langeditor-core markdown-body"]),
              editor: s.value
            }, null, 8, ["class", "editor"])
          ], 2),
          W(Zhe, {
            page: t.page,
            tocRight: t.tocRight
          }, null, 8, ["page", "tocRight"])
        ], 2),
        Lt(_.$slots, "footer", {
          data: { characters: o.value }
        }, () => [
          W(Uhe, { characters: o.value }, null, 8, ["characters"])
        ], !0)
      ], 2)
    ], 34));
  }
});
const u3 = /* @__PURE__ */ wr(tpe, [["__scopeId", "data-v-c2a0cf6f"]]);
function npe(t) {
  t.component("LangEditor", u3), m9(t), t.use(U6);
}
u3.install = npe;
export {
  GS as AiExt,
  b9 as BlockQuoteExt,
  oI as BoldExt,
  C9 as BulletListExt,
  T9 as CharacterCountExt,
  WY as CodeBlockExt,
  N9 as CodeExt,
  T2 as ColorExt,
  cge as CopyPasteExt,
  Jo as DividerExt,
  PX as DocumentExt,
  wfe as DragHandle,
  BX as DropcursorExt,
  Rde as FocusExt,
  KX as FormatClearExt,
  XX as FullscreenExt,
  jX as GapcursorExt,
  rJ as HardBreakExt,
  aJ as HeadingExt,
  D2 as HighlightExt,
  EJ as HistoryExt,
  oge as HocuspocusExt,
  xJ as HorizontalRuleExt,
  lne as ImageBubbleMenu,
  sne as ImageExt,
  hne as IndentExt,
  jL as ItalicExt,
  u3 as LangEditor,
  Ve as LangMenuItem,
  Hde as LineHeightExt,
  ire as LinkExt,
  sre as ListItemExt,
  _re as MathBubbleMenu,
  yre as MathExt,
  xre as OrderedListExt,
  Rfe as OutlineExt,
  Cre as ParagraphExt,
  Mre as PlaceholderExt,
  Roe as RedoExt,
  afe as SlashCommand,
  o$ as StrikeExt,
  Ire as SubscriptExt,
  Lre as SuperscriptExt,
  soe as TableBubbleMenu,
  lse as TableExt,
  foe as TaskListExt,
  X$ as TextAlignExt,
  hoe as TextExt,
  voe as TextStyleExt,
  lfe as TrailingNodeExt,
  Z$ as UnderlineExt,
  Aoe as UndoExt,
  uge as UploadManagerExt,
  Ooe as VideoBubbleMenu,
  Coe as VideoExt,
  Ade as getRandomColor,
  xpe as useBlockquote,
  kpe as useBold,
  Cpe as useBulletList,
  Tpe as useCharacterCount,
  Ope as useCode,
  UY as useCodeBlock,
  Ppe as useColor,
  _fe as useCopyPaste,
  Lpe as useDocument,
  $pe as useDropcursor,
  age as useFocus,
  Bpe as useGapcursor,
  Fpe as useHardBreak,
  zpe as useHeading,
  dJ as useHighlight,
  Hpe as useHistory,
  Nde as useHocuspocus,
  Upe as useHorizontalRule,
  Kte as useImage,
  fne as useIndent,
  Vpe as useItalic,
  Ude as useLineHeight,
  Wne as useLink,
  Wpe as useListItem,
  ore as useMath,
  Gpe as useOrderedList,
  jpe as useParagraph,
  Ore as usePlaceholder,
  qpe as useStrike,
  Kpe as useSubscript,
  Ype as useSuperscript,
  ese as useTable,
  uoe as useTaskItem,
  aoe as useTaskList,
  Zpe as useText,
  Qpe as useTextAlign,
  ege as useTextStyle,
  lge as useTrailingNode,
  tge as useUnderline,
  Eoe as useVideo
};
